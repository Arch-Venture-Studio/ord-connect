(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap";.ord-connect-wallet-button{color:#000;background-color:#fff;font-weight:700;font-size:14px;line-height:20px;border-radius:40px;padding:10px 16px;border:0px;cursor:pointer}.ord-connect-wallet-button:disabled{background-color:#888;cursor:not-allowed}.ord-connect-wallet-button span:before{content:"Connect"}@media screen and (min-width: 768px){.ord-connect-wallet-button{padding:10px 24px}.ord-connect-wallet-button span:before{content:"Connect wallet"}}.ord-connect-wallet-button:enabled:hover{background-color:#f2f2f2}.ord-connect-wallet-button:enabled:active{opacity:.7}.ord-wallet-connected-container{position:relative;display:inline-block}.ord-wallet-connected-button{border-radius:52px;border:1px solid #8c8c8c;background-color:transparent;padding:8px 12px 8px 8px;display:flex;align-items:center;cursor:pointer}.ord-wallet-connected-button .address-container{display:none}@media screen and (min-width: 768px){.ord-wallet-connected-button .address-container{display:block;margin-left:8px}}.ord-wallet-connected-button .address{color:#fff;font-size:14px;font-weight:700;line-height:20px;margin:0}.ord-wallet-connected-button .network-container{display:flex;align-items:center}.ord-wallet-connected-button .status-indicator{width:8px;height:8px;background:#00ad1d;border-radius:999px;margin-right:8px}.ord-wallet-connected-button .network{color:#ffffff80;margin:0;font-size:12px;font-weight:600;line-height:16px}.ord-wallet-connected-button .wallet-profile-icon{width:28px;height:28px;border-radius:999px;background-color:pink;margin-right:8px}.ord-wallet-connected-button .dropdown-button{transition:transform .3s ease;margin-left:16px}.ord-wallet-connected-button .expand-dropdown-button{width:20px;transform:rotate(0)}.ord-wallet-connected-button .close-dropdown-button{transform:rotate(-180deg)}.ord-wallet-connection-dropdown{background:#121212;border-radius:15px;border:.5px solid rgba(255,255,255,.5);width:256px;position:absolute;top:54px;right:0}.ord-wallet-connection-dropdown .dropdown-button{display:flex;align-items:center;background:transparent;border:0px;cursor:pointer;width:100%;justify-content:space-between}.ord-wallet-connection-dropdown .dropdown-button:hover{background:#ffffff1a}.ord-wallet-connection-dropdown .dropdown-button:hover:first-child{border-top-left-radius:15px;border-top-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:hover:last-child{border-bottom-left-radius:15px;border-bottom-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:active{background:#ffffff1a;opacity:.7}.ord-wallet-connection-dropdown .dropdown-button:first-child{padding:26px 16px 18px}.ord-wallet-connection-dropdown .dropdown-button:not(:first-child):not(:last-child){padding:9px 16px}.ord-wallet-connection-dropdown .dropdown-button:last-child{padding:18px 16px 26px}.ord-wallet-connection-dropdown .label{color:#fff;font-size:14px;font-weight:600;flex:1 1 0%;text-align:left}.ord-wallet-connection-dropdown .value{color:#a6a6a6}.ord-wallet-connection-dropdown .change-wallet-label{color:#ffffffb3;font-size:14px;font-weight:700;flex:1 1 0%;text-align:right}.ord-wallet-connection-dropdown .profile-item-container{width:100%;display:flex;flex-direction:column}.ord-wallet-connection-dropdown .profile-item-inner-container{display:flex;justify-content:space-between}.ord-wallet-connection-dropdown .offers{font-size:10px;font-weight:700;line-height:12px;letter-spacing:.08em;color:#fff;padding:4px 12px;border-radius:16px;background:#ffffff1a}.ord-wallet-connection-dropdown .horizontal-separator{margin:6px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal{position:relative;z-index:10}.ord-connect-wallet-modal .backdrop{position:fixed;top:0;right:0;bottom:0;left:0;background:#00000080;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}.ord-connect-wallet-modal .outer-container{position:fixed;top:0;left:0;overflow-y:auto;width:100%;height:100%}.ord-connect-wallet-modal .inner-container{display:flex;align-items:center;justify-content:center;text-align:center;height:100%}.ord-connect-wallet-modal .panel{width:100%;background-color:#121212;overflow:hidden;text-align:left;height:100%}.ord-connect-wallet-modal .panel-title-container{display:flex;justify-content:space-between;padding:32px 24px 0;align-items:center}.ord-connect-wallet-modal .panel-title{color:#fff;font-size:24px;font-style:normal;font-weight:700;line-height:32px;margin:0}.ord-connect-wallet-modal .unsupported-browser-message{color:#fff}.ord-connect-wallet-modal .close-button{display:inline-flex;background:transparent;border:0px;cursor:pointer}.ord-connect-wallet-modal .panel-content-container{margin:32px 24px 0}.ord-connect-wallet-modal .panel-content-inner-container{border-radius:20px;border:1px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .wallet-option-button{display:flex;align-items:center;background:transparent;border:0px;color:#fff;font-size:16px;font-weight:600;line-height:20px;width:100%;cursor:pointer}.ord-connect-wallet-modal .wallet-option-button:disabled .chevron-btn{opacity:.3}.waiting-cursor{cursor:wait!important}.wallet-identifier-container{position:relative;display:inline-block}.wallet-identifier-container img{position:absolute;bottom:4px;right:0;width:12px;border-radius:50%;background-color:#000;object-fit:cover}.ord-connect-wallet-modal .option-wrapper{display:flex;align-items:center;justify-content:space-between;padding:16px 4px;width:100%}.ord-connect-wallet-modal .wallet-option-button{padding:8px 16px}.ord-connect-wallet-modal .wallet-option-button:hover{background:#ffffff1a}.ord-connect-wallet-modal .wallet-option-button:active{background:#ffffff1a;opacity:.7}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-option-button:last-child{padding:8px 16px 16px;border:0px;margin-bottom:0;border-radius:0 0 20px 20px}.ord-connect-wallet-modal .wallet-option-button:only-child{padding:8px 16px;border:0px;margin-bottom:0;border-radius:20px}.ord-connect-wallet-modal .wallet-icon{width:32px;height:32px}.ord-connect-wallet-modal .wallet-option{flex-grow:1;margin-left:12px;text-align:left}.ord-connect-wallet-modal .wallet-option-connected-address{display:flex;padding:4px 8px;align-items:center;margin-left:4px;margin-right:8px;text-align:left;background-color:#00000080;border-radius:20px;-webkit-backdrop-filter:blur(15px);backdrop-filter:blur(15px)}.ord-connect-wallet-modal .wallet-option-connected-address .label{margin-left:4px;font-size:12px;font-weight:400;color:#ffffffb3}.ord-connect-wallet-modal .wallet-option-label{font-size:16px;font-weight:600;line-height:20px;margin:0}.ord-connect-wallet-modal .wallet-option-subtitle{font-size:12px;font-weight:400;line-height:16px;color:#8c8c8c;margin:0}.ord-connect-wallet-modal .horizontal-separator{margin:2px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .error-message{margin:16px 0 0;color:#e54545;font-size:14px;line-height:20px}.ord-connect-wallet-modal .preferred-label{padding:4px 12px;color:#000000b2;background-color:#ffbf18;font-size:12px;line-height:16px;font-weight:400;border-radius:20px;margin-left:4px;margin-right:8px}@media screen and (min-width: 768px){.ord-connect-wallet-modal .outer-container{top:50%;left:50%;transform:translate(-50%,-50%);width:500px;height:auto;border-radius:20px}.ord-connect-wallet-modal .panel{border:1px solid rgba(51,51,51,.5);border-radius:20px}.ord-connect-wallet-modal .panel-title-container{padding:24px 32px 0;border-bottom:0px}.ord-connect-wallet-modal .unsupported-browser-message{font-size:16px;padding-left:24px}.ord-connect-wallet-modal .panel-title{font-size:20px;font-style:normal;font-weight:600;line-height:28px;letter-spacing:.2px}.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .wallet-option{margin-left:16px}}@media screen and (min-width: 1080px){.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .option-wrapper{padding:16px}.ord-connect-wallet-modal .wallet-option-button{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-icon{width:40px;height:40px}.ord-connect-wallet-modal .wallet-option-label{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-connected-address{margin-left:16px;margin-right:16px}.ord-connect-wallet-modal .wallet-option-connected-address .label{font-size:16px}}.ord-connect-font *{font-family:Space Grotesk,sans-serif}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}.ease-in{transition-timing-function:cubic-bezier(.4,0,1,1)}.opacity-0{opacity:0}.opacity-100{opacity:1}.duration-300{transition-duration:.3s}.duration-200{transition-duration:.2s}.scale-95{transform:scale(.95)}.scale-100{transform:scale(1)}')),document.head.appendChild(o)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
import * as C$2 from "react";
import C__default, { useState, useEffect, useCallback, createContext, useMemo, useContext, useLayoutEffect, useRef, forwardRef, Fragment, isValidElement, cloneElement, createElement, useReducer, createRef } from "react";
import { BrowserWalletNotInstalledError, OrditSDKError, BrowserWalletRequestCancelledByUserError, BrowserWalletSigningError, getAddressFormat, getAddressesFromPublicKey, ADDRESS_FORMAT_TO_TYPE, JsonRpcDatasource, PSBTBuilder } from "@ordzaar/ordit-sdk";
import { getAddresses as getAddresses$1, signPsbt as signPsbt$4, signMessage as signMessage$4, LeatherAddressType } from "@ordzaar/ordit-sdk/leather";
import { getAddresses as getAddresses$2, signPsbt as signPsbt$1, signMessage as signMessage$1 } from "@ordzaar/ordit-sdk/magiceden";
import { getAddresses, signPsbt as signPsbt$5, signMessage as signMessage$5 } from "@ordzaar/ordit-sdk/okx";
import { getAddresses as getAddresses$3, signPsbt as signPsbt$2, signMessage as signMessage$2 } from "@ordzaar/ordit-sdk/unisat";
import { createPortal } from "react-dom";
import { signPsbt as signPsbt$3, signMessage as signMessage$3 } from "@ordzaar/ordit-sdk/xverse";
function getDefaultExportFromCjs$1(A) {
  return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
}
var browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(A) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(A, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(A, 0);
  try {
    return cachedSetTimeout(A, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, A, 0);
    } catch {
      return cachedSetTimeout.call(this, A, 0);
    }
  }
}
function runClearTimeout(A) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(A);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(A);
  try {
    return cachedClearTimeout(A);
  } catch {
    try {
      return cachedClearTimeout.call(null, A);
    } catch {
      return cachedClearTimeout.call(this, A);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var A = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var B = queue.length; B; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < B; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, B = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(A);
  }
}
process.nextTick = function(A) {
  var B = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var W = 1; W < arguments.length; W++)
      B[W - 1] = arguments[W];
  queue.push(new Item(A, B)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(A, B) {
  this.fun = A, this.array = B;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(A) {
  return [];
};
process.binding = function(A) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(A) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(A) {
  return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
}
function getAugmentedNamespace(A) {
  if (A.__esModule) return A;
  var B = A.default;
  if (typeof B == "function") {
    var W = function K() {
      return this instanceof K ? Reflect.construct(B, arguments, this.constructor) : B.apply(this, arguments);
    };
    W.prototype = B.prototype;
  } else W = {};
  return Object.defineProperty(W, "__esModule", { value: !0 }), Object.keys(A).forEach(function(K) {
    var J = Object.getOwnPropertyDescriptor(A, K);
    Object.defineProperty(W, K, J.get ? J : {
      enumerable: !0,
      get: function() {
        return A[K];
      }
    });
  }), W;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var A = C__default, B = Symbol.for("react.element"), W = Symbol.for("react.fragment"), K = Object.prototype.hasOwnProperty, J = A.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, L = { key: !0, ref: !0, __self: !0, __source: !0 };
  function re(ie, oe, ke) {
    var ne, pe = {}, rt = null, nt = null;
    ke !== void 0 && (rt = "" + ke), oe.key !== void 0 && (rt = "" + oe.key), oe.ref !== void 0 && (nt = oe.ref);
    for (ne in oe) K.call(oe, ne) && !L.hasOwnProperty(ne) && (pe[ne] = oe[ne]);
    if (ie && ie.defaultProps) for (ne in oe = ie.defaultProps, oe) pe[ne] === void 0 && (pe[ne] = oe[ne]);
    return { $$typeof: B, type: ie, key: rt, ref: nt, props: pe, _owner: J.current };
  }
  return reactJsxRuntime_production_min.Fragment = W, reactJsxRuntime_production_min.jsx = re, reactJsxRuntime_production_min.jsxs = re, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {}, hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var A = C__default, B = Symbol.for("react.element"), W = Symbol.for("react.portal"), K = Symbol.for("react.fragment"), J = Symbol.for("react.strict_mode"), L = Symbol.for("react.profiler"), re = Symbol.for("react.provider"), ie = Symbol.for("react.context"), oe = Symbol.for("react.forward_ref"), ke = Symbol.for("react.suspense"), ne = Symbol.for("react.suspense_list"), pe = Symbol.for("react.memo"), rt = Symbol.for("react.lazy"), nt = Symbol.for("react.offscreen"), ot = Symbol.iterator, ut = "@@iterator";
    function dt(Ft) {
      if (Ft === null || typeof Ft != "object")
        return null;
      var tr = ot && Ft[ot] || Ft[ut];
      return typeof tr == "function" ? tr : null;
    }
    var vt = A.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function pt(Ft) {
      {
        for (var tr = arguments.length, rr = new Array(tr > 1 ? tr - 1 : 0), nr = 1; nr < tr; nr++)
          rr[nr - 1] = arguments[nr];
        mt("error", Ft, rr);
      }
    }
    function mt(Ft, tr, rr) {
      {
        var nr = vt.ReactDebugCurrentFrame, xr = nr.getStackAddendum();
        xr !== "" && (tr += "%s", rr = rr.concat([xr]));
        var br = rr.map(function(dr) {
          return String(dr);
        });
        br.unshift("Warning: " + tr), Function.prototype.apply.call(console[Ft], console, br);
      }
    }
    var gt = !1, Pt = !1, xt = !1, Nt = !1, Et = !1, bt;
    bt = Symbol.for("react.module.reference");
    function Bt(Ft) {
      return !!(typeof Ft == "string" || typeof Ft == "function" || Ft === K || Ft === L || Et || Ft === J || Ft === ke || Ft === ne || Nt || Ft === nt || gt || Pt || xt || typeof Ft == "object" && Ft !== null && (Ft.$$typeof === rt || Ft.$$typeof === pe || Ft.$$typeof === re || Ft.$$typeof === ie || Ft.$$typeof === oe || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Ft.$$typeof === bt || Ft.getModuleId !== void 0));
    }
    function wt(Ft, tr, rr) {
      var nr = Ft.displayName;
      if (nr)
        return nr;
      var xr = tr.displayName || tr.name || "";
      return xr !== "" ? rr + "(" + xr + ")" : rr;
    }
    function st(Ft) {
      return Ft.displayName || "Context";
    }
    function Oe(Ft) {
      if (Ft == null)
        return null;
      if (typeof Ft.tag == "number" && pt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Ft == "function")
        return Ft.displayName || Ft.name || null;
      if (typeof Ft == "string")
        return Ft;
      switch (Ft) {
        case K:
          return "Fragment";
        case W:
          return "Portal";
        case L:
          return "Profiler";
        case J:
          return "StrictMode";
        case ke:
          return "Suspense";
        case ne:
          return "SuspenseList";
      }
      if (typeof Ft == "object")
        switch (Ft.$$typeof) {
          case ie:
            var tr = Ft;
            return st(tr) + ".Consumer";
          case re:
            var rr = Ft;
            return st(rr._context) + ".Provider";
          case oe:
            return wt(Ft, Ft.render, "ForwardRef");
          case pe:
            var nr = Ft.displayName || null;
            return nr !== null ? nr : Oe(Ft.type) || "Memo";
          case rt: {
            var xr = Ft, br = xr._payload, dr = xr._init;
            try {
              return Oe(dr(br));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var V = Object.assign, ce = 0, it, at, ft, lt, ct, ht, Ce;
    function yt() {
    }
    yt.__reactDisabledLog = !0;
    function qt() {
      {
        if (ce === 0) {
          it = console.log, at = console.info, ft = console.warn, lt = console.error, ct = console.group, ht = console.groupCollapsed, Ce = console.groupEnd;
          var Ft = {
            configurable: !0,
            enumerable: !0,
            value: yt,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Ft,
            log: Ft,
            warn: Ft,
            error: Ft,
            group: Ft,
            groupCollapsed: Ft,
            groupEnd: Ft
          });
        }
        ce++;
      }
    }
    function jt() {
      {
        if (ce--, ce === 0) {
          var Ft = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: V({}, Ft, {
              value: it
            }),
            info: V({}, Ft, {
              value: at
            }),
            warn: V({}, Ft, {
              value: ft
            }),
            error: V({}, Ft, {
              value: lt
            }),
            group: V({}, Ft, {
              value: ct
            }),
            groupCollapsed: V({}, Ft, {
              value: ht
            }),
            groupEnd: V({}, Ft, {
              value: Ce
            })
          });
        }
        ce < 0 && pt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var kt = vt.ReactCurrentDispatcher, $t;
    function Mt(Ft, tr, rr) {
      {
        if ($t === void 0)
          try {
            throw Error();
          } catch (xr) {
            var nr = xr.stack.trim().match(/\n( *(at )?)/);
            $t = nr && nr[1] || "";
          }
        return `
` + $t + Ft;
      }
    }
    var Lt = !1, Kt;
    {
      var Tt = typeof WeakMap == "function" ? WeakMap : Map;
      Kt = new Tt();
    }
    function Rt(Ft, tr) {
      if (!Ft || Lt)
        return "";
      {
        var rr = Kt.get(Ft);
        if (rr !== void 0)
          return rr;
      }
      var nr;
      Lt = !0;
      var xr = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var br;
      br = kt.current, kt.current = null, qt();
      try {
        if (tr) {
          var dr = function() {
            throw Error();
          };
          if (Object.defineProperty(dr.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(dr, []);
            } catch (Fr) {
              nr = Fr;
            }
            Reflect.construct(Ft, [], dr);
          } else {
            try {
              dr.call();
            } catch (Fr) {
              nr = Fr;
            }
            Ft.call(dr.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Fr) {
            nr = Fr;
          }
          Ft();
        }
      } catch (Fr) {
        if (Fr && nr && typeof Fr.stack == "string") {
          for (var Rr = Fr.stack.split(`
`), Nr = nr.stack.split(`
`), Or = Rr.length - 1, Cr = Nr.length - 1; Or >= 1 && Cr >= 0 && Rr[Or] !== Nr[Cr]; )
            Cr--;
          for (; Or >= 1 && Cr >= 0; Or--, Cr--)
            if (Rr[Or] !== Nr[Cr]) {
              if (Or !== 1 || Cr !== 1)
                do
                  if (Or--, Cr--, Cr < 0 || Rr[Or] !== Nr[Cr]) {
                    var Lr = `
` + Rr[Or].replace(" at new ", " at ");
                    return Ft.displayName && Lr.includes("<anonymous>") && (Lr = Lr.replace("<anonymous>", Ft.displayName)), typeof Ft == "function" && Kt.set(Ft, Lr), Lr;
                  }
                while (Or >= 1 && Cr >= 0);
              break;
            }
        }
      } finally {
        Lt = !1, kt.current = br, jt(), Error.prepareStackTrace = xr;
      }
      var Dr = Ft ? Ft.displayName || Ft.name : "", Ur = Dr ? Mt(Dr) : "";
      return typeof Ft == "function" && Kt.set(Ft, Ur), Ur;
    }
    function Wt(Ft, tr, rr) {
      return Rt(Ft, !1);
    }
    function Xt(Ft) {
      var tr = Ft.prototype;
      return !!(tr && tr.isReactComponent);
    }
    function Zt(Ft, tr, rr) {
      if (Ft == null)
        return "";
      if (typeof Ft == "function")
        return Rt(Ft, Xt(Ft));
      if (typeof Ft == "string")
        return Mt(Ft);
      switch (Ft) {
        case ke:
          return Mt("Suspense");
        case ne:
          return Mt("SuspenseList");
      }
      if (typeof Ft == "object")
        switch (Ft.$$typeof) {
          case oe:
            return Wt(Ft.render);
          case pe:
            return Zt(Ft.type, tr, rr);
          case rt: {
            var nr = Ft, xr = nr._payload, br = nr._init;
            try {
              return Zt(br(xr), tr, rr);
            } catch {
            }
          }
        }
      return "";
    }
    var ar = Object.prototype.hasOwnProperty, fr = {}, lr = vt.ReactDebugCurrentFrame;
    function Jt(Ft) {
      if (Ft) {
        var tr = Ft._owner, rr = Zt(Ft.type, Ft._source, tr ? tr.type : null);
        lr.setExtraStackFrame(rr);
      } else
        lr.setExtraStackFrame(null);
    }
    function _r(Ft, tr, rr, nr, xr) {
      {
        var br = Function.call.bind(ar);
        for (var dr in Ft)
          if (br(Ft, dr)) {
            var Rr = void 0;
            try {
              if (typeof Ft[dr] != "function") {
                var Nr = Error((nr || "React class") + ": " + rr + " type `" + dr + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Ft[dr] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Nr.name = "Invariant Violation", Nr;
              }
              Rr = Ft[dr](tr, dr, nr, rr, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Or) {
              Rr = Or;
            }
            Rr && !(Rr instanceof Error) && (Jt(xr), pt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", nr || "React class", rr, dr, typeof Rr), Jt(null)), Rr instanceof Error && !(Rr.message in fr) && (fr[Rr.message] = !0, Jt(xr), pt("Failed %s type: %s", rr, Rr.message), Jt(null));
          }
      }
    }
    var sr = Array.isArray;
    function Mr(Ft) {
      return sr(Ft);
    }
    function Sr(Ft) {
      {
        var tr = typeof Symbol == "function" && Symbol.toStringTag, rr = tr && Ft[Symbol.toStringTag] || Ft.constructor.name || "Object";
        return rr;
      }
    }
    function cr(Ft) {
      try {
        return Br(Ft), !1;
      } catch {
        return !0;
      }
    }
    function Br(Ft) {
      return "" + Ft;
    }
    function $r(Ft) {
      if (cr(Ft))
        return pt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Sr(Ft)), Br(Ft);
    }
    var yr = vt.ReactCurrentOwner, kr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Tr, It;
    function St(Ft) {
      if (ar.call(Ft, "ref")) {
        var tr = Object.getOwnPropertyDescriptor(Ft, "ref").get;
        if (tr && tr.isReactWarning)
          return !1;
      }
      return Ft.ref !== void 0;
    }
    function At(Ft) {
      if (ar.call(Ft, "key")) {
        var tr = Object.getOwnPropertyDescriptor(Ft, "key").get;
        if (tr && tr.isReactWarning)
          return !1;
      }
      return Ft.key !== void 0;
    }
    function Ot(Ft, tr) {
      typeof Ft.ref == "string" && yr.current;
    }
    function Gt(Ft, tr) {
      {
        var rr = function() {
          Tr || (Tr = !0, pt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", tr));
        };
        rr.isReactWarning = !0, Object.defineProperty(Ft, "key", {
          get: rr,
          configurable: !0
        });
      }
    }
    function zt(Ft, tr) {
      {
        var rr = function() {
          It || (It = !0, pt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", tr));
        };
        rr.isReactWarning = !0, Object.defineProperty(Ft, "ref", {
          get: rr,
          configurable: !0
        });
      }
    }
    var Vt = function(Ft, tr, rr, nr, xr, br, dr) {
      var Rr = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: B,
        // Built-in properties that belong on the element
        type: Ft,
        key: tr,
        ref: rr,
        props: dr,
        // Record the component responsible for creating this element.
        _owner: br
      };
      return Rr._store = {}, Object.defineProperty(Rr._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Rr, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: nr
      }), Object.defineProperty(Rr, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: xr
      }), Object.freeze && (Object.freeze(Rr.props), Object.freeze(Rr)), Rr;
    };
    function Er(Ft, tr, rr, nr, xr) {
      {
        var br, dr = {}, Rr = null, Nr = null;
        rr !== void 0 && ($r(rr), Rr = "" + rr), At(tr) && ($r(tr.key), Rr = "" + tr.key), St(tr) && (Nr = tr.ref, Ot(tr, xr));
        for (br in tr)
          ar.call(tr, br) && !kr.hasOwnProperty(br) && (dr[br] = tr[br]);
        if (Ft && Ft.defaultProps) {
          var Or = Ft.defaultProps;
          for (br in Or)
            dr[br] === void 0 && (dr[br] = Or[br]);
        }
        if (Rr || Nr) {
          var Cr = typeof Ft == "function" ? Ft.displayName || Ft.name || "Unknown" : Ft;
          Rr && Gt(dr, Cr), Nr && zt(dr, Cr);
        }
        return Vt(Ft, Rr, Nr, xr, nr, yr.current, dr);
      }
    }
    var wr = vt.ReactCurrentOwner, hr = vt.ReactDebugCurrentFrame;
    function Pr(Ft) {
      if (Ft) {
        var tr = Ft._owner, rr = Zt(Ft.type, Ft._source, tr ? tr.type : null);
        hr.setExtraStackFrame(rr);
      } else
        hr.setExtraStackFrame(null);
    }
    var gr;
    gr = !1;
    function vr(Ft) {
      return typeof Ft == "object" && Ft !== null && Ft.$$typeof === B;
    }
    function qr() {
      {
        if (wr.current) {
          var Ft = Oe(wr.current.type);
          if (Ft)
            return `

Check the render method of \`` + Ft + "`.";
        }
        return "";
      }
    }
    function Ir(Ft) {
      return "";
    }
    var Ut = {};
    function Ct(Ft) {
      {
        var tr = qr();
        if (!tr) {
          var rr = typeof Ft == "string" ? Ft : Ft.displayName || Ft.name;
          rr && (tr = `

Check the top-level render call using <` + rr + ">.");
        }
        return tr;
      }
    }
    function Dt(Ft, tr) {
      {
        if (!Ft._store || Ft._store.validated || Ft.key != null)
          return;
        Ft._store.validated = !0;
        var rr = Ct(tr);
        if (Ut[rr])
          return;
        Ut[rr] = !0;
        var nr = "";
        Ft && Ft._owner && Ft._owner !== wr.current && (nr = " It was passed a child from " + Oe(Ft._owner.type) + "."), Pr(Ft), pt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', rr, nr), Pr(null);
      }
    }
    function Ht(Ft, tr) {
      {
        if (typeof Ft != "object")
          return;
        if (Mr(Ft))
          for (var rr = 0; rr < Ft.length; rr++) {
            var nr = Ft[rr];
            vr(nr) && Dt(nr, tr);
          }
        else if (vr(Ft))
          Ft._store && (Ft._store.validated = !0);
        else if (Ft) {
          var xr = dt(Ft);
          if (typeof xr == "function" && xr !== Ft.entries)
            for (var br = xr.call(Ft), dr; !(dr = br.next()).done; )
              vr(dr.value) && Dt(dr.value, tr);
        }
      }
    }
    function Yt(Ft) {
      {
        var tr = Ft.type;
        if (tr == null || typeof tr == "string")
          return;
        var rr;
        if (typeof tr == "function")
          rr = tr.propTypes;
        else if (typeof tr == "object" && (tr.$$typeof === oe || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        tr.$$typeof === pe))
          rr = tr.propTypes;
        else
          return;
        if (rr) {
          var nr = Oe(tr);
          _r(rr, Ft.props, "prop", nr, Ft);
        } else if (tr.PropTypes !== void 0 && !gr) {
          gr = !0;
          var xr = Oe(tr);
          pt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", xr || "Unknown");
        }
        typeof tr.getDefaultProps == "function" && !tr.getDefaultProps.isReactClassApproved && pt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Qt(Ft) {
      {
        for (var tr = Object.keys(Ft.props), rr = 0; rr < tr.length; rr++) {
          var nr = tr[rr];
          if (nr !== "children" && nr !== "key") {
            Pr(Ft), pt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", nr), Pr(null);
            break;
          }
        }
        Ft.ref !== null && (Pr(Ft), pt("Invalid attribute `ref` supplied to `React.Fragment`."), Pr(null));
      }
    }
    var er = {};
    function or(Ft, tr, rr, nr, xr, br) {
      {
        var dr = Bt(Ft);
        if (!dr) {
          var Rr = "";
          (Ft === void 0 || typeof Ft == "object" && Ft !== null && Object.keys(Ft).length === 0) && (Rr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Nr = Ir();
          Nr ? Rr += Nr : Rr += qr();
          var Or;
          Ft === null ? Or = "null" : Mr(Ft) ? Or = "array" : Ft !== void 0 && Ft.$$typeof === B ? (Or = "<" + (Oe(Ft.type) || "Unknown") + " />", Rr = " Did you accidentally export a JSX literal instead of a component?") : Or = typeof Ft, pt("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Or, Rr);
        }
        var Cr = Er(Ft, tr, rr, xr, br);
        if (Cr == null)
          return Cr;
        if (dr) {
          var Lr = tr.children;
          if (Lr !== void 0)
            if (nr)
              if (Mr(Lr)) {
                for (var Dr = 0; Dr < Lr.length; Dr++)
                  Ht(Lr[Dr], Ft);
                Object.freeze && Object.freeze(Lr);
              } else
                pt("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ht(Lr, Ft);
        }
        if (ar.call(tr, "key")) {
          var Ur = Oe(Ft), Fr = Object.keys(tr).filter(function(Wr) {
            return Wr !== "key";
          }), jr = Fr.length > 0 ? "{key: someKey, " + Fr.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!er[Ur + jr]) {
            var Hr = Fr.length > 0 ? "{" + Fr.join(": ..., ") + ": ...}" : "{}";
            pt(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, jr, Ur, Hr, Ur), er[Ur + jr] = !0;
          }
        }
        return Ft === K ? Qt(Cr) : Yt(Cr), Cr;
      }
    }
    function ur(Ft, tr, rr) {
      return or(Ft, tr, rr, !0);
    }
    function ir(Ft, tr, rr) {
      return or(Ft, tr, rr, !1);
    }
    var Ar = ir, pr = ur;
    reactJsxRuntime_development.Fragment = K, reactJsxRuntime_development.jsx = Ar, reactJsxRuntime_development.jsxs = pr;
  }()), reactJsxRuntime_development;
}
process$1.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
function useHasMounted() {
  const [A, B] = useState(!1);
  return useEffect(() => {
    B(!0);
  }, []), A;
}
const KEY_PREFIX = "ord-connect";
function getItemFromLocalStorage(A) {
  typeof window > "u" && console.warn(
    `Attempted to read local storage key ${A} even though environment is not a browser.`
  );
  const B = `${KEY_PREFIX}_${A}`;
  try {
    const W = window.localStorage.getItem(B);
    return W != null ? JSON.parse(W) : null;
  } catch (W) {
    return console.error(`Error retrieving ${B} from localStorage`, W), null;
  }
}
function setItemToLocalStorage(A, B) {
  typeof window > "u" && console.warn(
    `Attempted to set local storage key ${A} even though environment is not a browser.`
  );
  const W = `${KEY_PREFIX}_${A}`;
  try {
    B ? window.localStorage.setItem(W, JSON.stringify(B)) : window.localStorage.removeItem(W);
  } catch (K) {
    console.error(`Error saving ${W} to localStorage`, K);
  }
}
function useLocalStorage(A, B, W = {}) {
  const { initializeWithValue: K = !0 } = W, J = useCallback(() => {
    const oe = getItemFromLocalStorage(A);
    return oe || (setItemToLocalStorage(A, B), B);
  }, [B, A]), [L, re] = useState(() => K ? J() : B), ie = useCallback(
    (oe) => {
      setItemToLocalStorage(A, oe), re(oe);
    },
    [A]
  );
  return useEffect(() => {
    re(J());
  }, [A]), [L, ie];
}
var Network = /* @__PURE__ */ ((A) => (A.MAINNET = "mainnet", A.TESTNET = "testnet", A.SIGNET = "signet", A))(Network || {}), Wallet = /* @__PURE__ */ ((A) => (A.UNISAT = "unisat", A.XVERSE = "xverse", A.MAGICEDEN = "magiceden", A.LEATHER = "leather", A.OKX = "okx", A))(Wallet || {}), Chain = /* @__PURE__ */ ((A) => (A.BITCOIN = "bitcoin", A.FRACTAL_BITCOIN = "fractal-bitcoin", A))(Chain || {});
const EMPTY_BIADDRESS_OBJECT = {
  payments: null,
  ordinals: null
}, OrdConnectContext = createContext(
  void 0
), ADDRESS = "address", WALLET = "wallet", PUBLIC_KEY = "publicKey", FORMAT = "format";
function OrdConnectProvider({
  children: A,
  network: B,
  visibleWallets: W,
  chain: K = "bitcoin",
  ssr: J = !1
}) {
  if (!B)
    throw new Error("Network cannot be empty");
  if (!W || W.length === 0)
    throw new Error("Visible wallets cannot be empty");
  const [L, re] = useState(B), [ie, oe] = useState(W), [ke, ne] = useState(K), [pe, rt] = useLocalStorage(
    ADDRESS,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !J }
  ), [nt, ot] = useLocalStorage(WALLET, null, {
    initializeWithValue: !J
  }), [ut, dt] = useLocalStorage(
    PUBLIC_KEY,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !J }
  ), [vt, pt] = useLocalStorage(
    FORMAT,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !J }
  ), [mt, gt] = useState(!1), Pt = useCallback(() => gt(!0), []), xt = useCallback(() => gt(!1), []), Nt = useCallback(() => {
    rt(EMPTY_BIADDRESS_OBJECT), dt(EMPTY_BIADDRESS_OBJECT), pt(EMPTY_BIADDRESS_OBJECT), ot(null);
  }, [rt, pt, dt, ot]), Et = useMemo(
    () => ({
      address: pe,
      updateAddress: rt,
      publicKey: ut,
      updatePublicKey: dt,
      network: L,
      updateNetwork: (bt) => {
        re(
          nt !== "xverse" && bt === "testnet4" ? "testnet" : nt === "xverse" && bt === "testnet" ? "testnet4" : bt
          /* TESTNET */
        );
      },
      wallet: nt,
      updateWallet: ot,
      isModalOpen: mt,
      openModal: Pt,
      closeModal: xt,
      format: vt,
      updateFormat: pt,
      disconnectWallet: Nt,
      chain: ke,
      updateChain: ne,
      visibleWallets: ie,
      updateVisibleWallets: oe
    }),
    [
      pe,
      rt,
      ut,
      dt,
      L,
      nt,
      mt,
      Pt,
      xt,
      vt,
      pt,
      Nt,
      ke,
      ie,
      ot
    ]
  );
  return useEffect(() => {
    re(B);
  }, [B]), useEffect(() => {
    ke !== K && (Nt(), ne(K));
  }, [K, ke, Nt]), /* @__PURE__ */ jsxRuntimeExports.jsx(OrdConnectContext.Provider, { value: Et, children: A });
}
function useOrdConnect() {
  const A = useContext(OrdConnectContext);
  if (!A)
    throw new Error("useOrdConnect must be used within OrdConnectProvider");
  return A;
}
var build = { exports: {} };
(function(A, B) {
  (function(W, K) {
    A.exports = K(C__default);
  })(commonjsGlobal, function(W) {
    return function(K) {
      var J = {};
      function L(re) {
        if (J[re]) return J[re].exports;
        var ie = J[re] = { i: re, l: !1, exports: {} };
        return K[re].call(ie.exports, ie, ie.exports, L), ie.l = !0, ie.exports;
      }
      return L.m = K, L.c = J, L.d = function(re, ie, oe) {
        L.o(re, ie) || Object.defineProperty(re, ie, { enumerable: !0, get: oe });
      }, L.r = function(re) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(re, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(re, "__esModule", { value: !0 });
      }, L.t = function(re, ie) {
        if (1 & ie && (re = L(re)), 8 & ie || 4 & ie && typeof re == "object" && re && re.__esModule) return re;
        var oe = /* @__PURE__ */ Object.create(null);
        if (L.r(oe), Object.defineProperty(oe, "default", { enumerable: !0, value: re }), 2 & ie && typeof re != "string") for (var ke in re) L.d(oe, ke, (function(ne) {
          return re[ne];
        }).bind(null, ke));
        return oe;
      }, L.n = function(re) {
        var ie = re && re.__esModule ? function() {
          return re.default;
        } : function() {
          return re;
        };
        return L.d(ie, "a", ie), ie;
      }, L.o = function(re, ie) {
        return Object.prototype.hasOwnProperty.call(re, ie);
      }, L.p = "/", L(L.s = 1);
    }([function(K, J) {
      K.exports = W;
    }, function(K, J, L) {
      K.exports = L(2);
    }, function(K, J, L) {
      function re(pt, mt) {
        if (pt == null) return {};
        var gt, Pt, xt = function(Et, bt) {
          if (Et == null) return {};
          var Bt, wt, st = {}, Oe = Object.keys(Et);
          for (wt = 0; wt < Oe.length; wt++) Bt = Oe[wt], bt.indexOf(Bt) >= 0 || (st[Bt] = Et[Bt]);
          return st;
        }(pt, mt);
        if (Object.getOwnPropertySymbols) {
          var Nt = Object.getOwnPropertySymbols(pt);
          for (Pt = 0; Pt < Nt.length; Pt++) gt = Nt[Pt], mt.indexOf(gt) >= 0 || Object.prototype.propertyIsEnumerable.call(pt, gt) && (xt[gt] = pt[gt]);
        }
        return xt;
      }
      L.r(J);
      var ie = L(0), oe = L.n(ie), ke = function(pt) {
        for (var mt = 0, gt = 0; gt < pt.length; gt++)
          mt = (mt << 5) - mt + pt.charCodeAt(gt), mt &= mt;
        return Math.abs(mt);
      }, ne = function(pt, mt) {
        return Math.floor(pt / Math.pow(10, mt) % 10);
      }, pe = function(pt, mt) {
        return !(ne(pt, mt) % 2);
      }, rt = function(pt, mt, gt) {
        var Pt = pt % mt;
        return gt && ne(pt, gt) % 2 === 0 ? -Pt : Pt;
      }, nt = function(pt, mt, gt) {
        return mt[pt % gt];
      }, ot = function(pt) {
        var mt = pt.name, gt = pt.colors, Pt = pt.title, xt = pt.square, Nt = pt.size, Et = re(pt, ["name", "colors", "title", "square", "size"]), bt = function(wt, st) {
          var Oe = ke(wt), V = st && st.length;
          return Array.from({ length: 3 }, function(ce, it) {
            return { color: nt(Oe + it, st, V), translateX: rt(Oe * (it + 1), 8, 1), translateY: rt(Oe * (it + 1), 8, 2), scale: 1.2 + rt(Oe * (it + 1), 4) / 10, rotate: rt(Oe * (it + 1), 360, 1) };
          });
        }(mt, gt), Bt = ie.useId();
        return ie.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Nt, height: Nt }, Et), Pt && ie.createElement("title", null, mt), ie.createElement("mask", { id: Bt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ie.createElement("rect", { width: 80, height: 80, rx: xt ? void 0 : 160, fill: "#FFFFFF" })), ie.createElement("g", { mask: "url(#".concat(Bt, ")") }, ie.createElement("rect", { width: 80, height: 80, fill: bt[0].color }), ie.createElement("path", { filter: "url(#filter_".concat(Bt, ")"), d: "M32.414 59.35L50.376 70.5H72.5v-71H33.728L26.5 13.381l19.057 27.08L32.414 59.35z", fill: bt[1].color, transform: "translate(" + bt[1].translateX + " " + bt[1].translateY + ") rotate(" + bt[1].rotate + " 40 40) scale(" + bt[2].scale + ")" }), ie.createElement("path", { filter: "url(#filter_".concat(Bt, ")"), style: { mixBlendMode: "overlay" }, d: "M22.216 24L0 46.75l14.108 38.129L78 86l-3.081-59.276-22.378 4.005 12.972 20.186-23.35 27.395L22.215 24z", fill: bt[2].color, transform: "translate(" + bt[2].translateX + " " + bt[2].translateY + ") rotate(" + bt[2].rotate + " 40 40) scale(" + bt[2].scale + ")" })), ie.createElement("defs", null, ie.createElement("filter", { id: "filter_".concat(Bt), filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB" }, ie.createElement("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }), ie.createElement("feBlend", { in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), ie.createElement("feGaussianBlur", { stdDeviation: 7, result: "effect1_foregroundBlur" }))));
      }, ut = { pixel: function(pt) {
        var mt = pt.name, gt = pt.colors, Pt = pt.title, xt = pt.square, Nt = pt.size, Et = re(pt, ["name", "colors", "title", "square", "size"]), bt = function(wt, st) {
          var Oe = ke(wt), V = st && st.length;
          return Array.from({ length: 64 }, function(ce, it) {
            return nt(Oe % (it + 1), st, V);
          });
        }(mt, gt), Bt = ie.useId();
        return ie.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Nt, height: Nt }, Et), Pt && ie.createElement("title", null, mt), ie.createElement("mask", { id: Bt, "mask-type": "alpha", maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ie.createElement("rect", { width: 80, height: 80, rx: xt ? void 0 : 160, fill: "#FFFFFF" })), ie.createElement("g", { mask: "url(#".concat(Bt, ")") }, ie.createElement("rect", { width: 10, height: 10, fill: bt[0] }), ie.createElement("rect", { x: 20, width: 10, height: 10, fill: bt[1] }), ie.createElement("rect", { x: 40, width: 10, height: 10, fill: bt[2] }), ie.createElement("rect", { x: 60, width: 10, height: 10, fill: bt[3] }), ie.createElement("rect", { x: 10, width: 10, height: 10, fill: bt[4] }), ie.createElement("rect", { x: 30, width: 10, height: 10, fill: bt[5] }), ie.createElement("rect", { x: 50, width: 10, height: 10, fill: bt[6] }), ie.createElement("rect", { x: 70, width: 10, height: 10, fill: bt[7] }), ie.createElement("rect", { y: 10, width: 10, height: 10, fill: bt[8] }), ie.createElement("rect", { y: 20, width: 10, height: 10, fill: bt[9] }), ie.createElement("rect", { y: 30, width: 10, height: 10, fill: bt[10] }), ie.createElement("rect", { y: 40, width: 10, height: 10, fill: bt[11] }), ie.createElement("rect", { y: 50, width: 10, height: 10, fill: bt[12] }), ie.createElement("rect", { y: 60, width: 10, height: 10, fill: bt[13] }), ie.createElement("rect", { y: 70, width: 10, height: 10, fill: bt[14] }), ie.createElement("rect", { x: 20, y: 10, width: 10, height: 10, fill: bt[15] }), ie.createElement("rect", { x: 20, y: 20, width: 10, height: 10, fill: bt[16] }), ie.createElement("rect", { x: 20, y: 30, width: 10, height: 10, fill: bt[17] }), ie.createElement("rect", { x: 20, y: 40, width: 10, height: 10, fill: bt[18] }), ie.createElement("rect", { x: 20, y: 50, width: 10, height: 10, fill: bt[19] }), ie.createElement("rect", { x: 20, y: 60, width: 10, height: 10, fill: bt[20] }), ie.createElement("rect", { x: 20, y: 70, width: 10, height: 10, fill: bt[21] }), ie.createElement("rect", { x: 40, y: 10, width: 10, height: 10, fill: bt[22] }), ie.createElement("rect", { x: 40, y: 20, width: 10, height: 10, fill: bt[23] }), ie.createElement("rect", { x: 40, y: 30, width: 10, height: 10, fill: bt[24] }), ie.createElement("rect", { x: 40, y: 40, width: 10, height: 10, fill: bt[25] }), ie.createElement("rect", { x: 40, y: 50, width: 10, height: 10, fill: bt[26] }), ie.createElement("rect", { x: 40, y: 60, width: 10, height: 10, fill: bt[27] }), ie.createElement("rect", { x: 40, y: 70, width: 10, height: 10, fill: bt[28] }), ie.createElement("rect", { x: 60, y: 10, width: 10, height: 10, fill: bt[29] }), ie.createElement("rect", { x: 60, y: 20, width: 10, height: 10, fill: bt[30] }), ie.createElement("rect", { x: 60, y: 30, width: 10, height: 10, fill: bt[31] }), ie.createElement("rect", { x: 60, y: 40, width: 10, height: 10, fill: bt[32] }), ie.createElement("rect", { x: 60, y: 50, width: 10, height: 10, fill: bt[33] }), ie.createElement("rect", { x: 60, y: 60, width: 10, height: 10, fill: bt[34] }), ie.createElement("rect", { x: 60, y: 70, width: 10, height: 10, fill: bt[35] }), ie.createElement("rect", { x: 10, y: 10, width: 10, height: 10, fill: bt[36] }), ie.createElement("rect", { x: 10, y: 20, width: 10, height: 10, fill: bt[37] }), ie.createElement("rect", { x: 10, y: 30, width: 10, height: 10, fill: bt[38] }), ie.createElement("rect", { x: 10, y: 40, width: 10, height: 10, fill: bt[39] }), ie.createElement("rect", { x: 10, y: 50, width: 10, height: 10, fill: bt[40] }), ie.createElement("rect", { x: 10, y: 60, width: 10, height: 10, fill: bt[41] }), ie.createElement("rect", { x: 10, y: 70, width: 10, height: 10, fill: bt[42] }), ie.createElement("rect", { x: 30, y: 10, width: 10, height: 10, fill: bt[43] }), ie.createElement("rect", { x: 30, y: 20, width: 10, height: 10, fill: bt[44] }), ie.createElement("rect", { x: 30, y: 30, width: 10, height: 10, fill: bt[45] }), ie.createElement("rect", { x: 30, y: 40, width: 10, height: 10, fill: bt[46] }), ie.createElement("rect", { x: 30, y: 50, width: 10, height: 10, fill: bt[47] }), ie.createElement("rect", { x: 30, y: 60, width: 10, height: 10, fill: bt[48] }), ie.createElement("rect", { x: 30, y: 70, width: 10, height: 10, fill: bt[49] }), ie.createElement("rect", { x: 50, y: 10, width: 10, height: 10, fill: bt[50] }), ie.createElement("rect", { x: 50, y: 20, width: 10, height: 10, fill: bt[51] }), ie.createElement("rect", { x: 50, y: 30, width: 10, height: 10, fill: bt[52] }), ie.createElement("rect", { x: 50, y: 40, width: 10, height: 10, fill: bt[53] }), ie.createElement("rect", { x: 50, y: 50, width: 10, height: 10, fill: bt[54] }), ie.createElement("rect", { x: 50, y: 60, width: 10, height: 10, fill: bt[55] }), ie.createElement("rect", { x: 50, y: 70, width: 10, height: 10, fill: bt[56] }), ie.createElement("rect", { x: 70, y: 10, width: 10, height: 10, fill: bt[57] }), ie.createElement("rect", { x: 70, y: 20, width: 10, height: 10, fill: bt[58] }), ie.createElement("rect", { x: 70, y: 30, width: 10, height: 10, fill: bt[59] }), ie.createElement("rect", { x: 70, y: 40, width: 10, height: 10, fill: bt[60] }), ie.createElement("rect", { x: 70, y: 50, width: 10, height: 10, fill: bt[61] }), ie.createElement("rect", { x: 70, y: 60, width: 10, height: 10, fill: bt[62] }), ie.createElement("rect", { x: 70, y: 70, width: 10, height: 10, fill: bt[63] })));
      }, bauhaus: function(pt) {
        var mt = pt.name, gt = pt.colors, Pt = pt.title, xt = pt.square, Nt = pt.size, Et = re(pt, ["name", "colors", "title", "square", "size"]), bt = function(wt, st) {
          var Oe = ke(wt), V = st && st.length;
          return Array.from({ length: 4 }, function(ce, it) {
            return { color: nt(Oe + it, st, V), translateX: rt(Oe * (it + 1), 40 - (it + 17), 1), translateY: rt(Oe * (it + 1), 40 - (it + 17), 2), rotate: rt(Oe * (it + 1), 360), isSquare: pe(Oe, 2) };
          });
        }(mt, gt), Bt = ie.useId();
        return ie.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Nt, height: Nt }, Et), Pt && ie.createElement("title", null, mt), ie.createElement("mask", { id: Bt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ie.createElement("rect", { width: 80, height: 80, rx: xt ? void 0 : 160, fill: "#FFFFFF" })), ie.createElement("g", { mask: "url(#".concat(Bt, ")") }, ie.createElement("rect", { width: 80, height: 80, fill: bt[0].color }), ie.createElement("rect", { x: 10, y: 30, width: 80, height: bt[1].isSquare ? 80 : 10, fill: bt[1].color, transform: "translate(" + bt[1].translateX + " " + bt[1].translateY + ") rotate(" + bt[1].rotate + " 40 40)" }), ie.createElement("circle", { cx: 40, cy: 40, fill: bt[2].color, r: 16, transform: "translate(" + bt[2].translateX + " " + bt[2].translateY + ")" }), ie.createElement("line", { x1: 0, y1: 40, x2: 80, y2: 40, strokeWidth: 2, stroke: bt[3].color, transform: "translate(" + bt[3].translateX + " " + bt[3].translateY + ") rotate(" + bt[3].rotate + " 40 40)" })));
      }, ring: function(pt) {
        var mt = pt.name, gt = pt.colors, Pt = pt.title, xt = pt.square, Nt = pt.size, Et = re(pt, ["name", "colors", "title", "square", "size"]), bt = function(wt, st) {
          var Oe = ke(st), V = wt && wt.length, ce = Array.from({ length: 5 }, function(at, ft) {
            return nt(Oe + ft, wt, V);
          }), it = [];
          return it[0] = ce[0], it[1] = ce[1], it[2] = ce[1], it[3] = ce[2], it[4] = ce[2], it[5] = ce[3], it[6] = ce[3], it[7] = ce[0], it[8] = ce[4], it;
        }(gt, mt), Bt = oe.a.useId();
        return oe.a.createElement("svg", Object.assign({ viewBox: "0 0 90 90", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Nt, height: Nt }, Et), Pt && oe.a.createElement("title", null, mt), oe.a.createElement("mask", { id: Bt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 90, height: 90 }, oe.a.createElement("rect", { width: 90, height: 90, rx: xt ? void 0 : 180, fill: "#FFFFFF" })), oe.a.createElement("g", { mask: "url(#".concat(Bt, ")") }, oe.a.createElement("path", { d: "M0 0h90v45H0z", fill: bt[0] }), oe.a.createElement("path", { d: "M0 45h90v45H0z", fill: bt[1] }), oe.a.createElement("path", { d: "M83 45a38 38 0 00-76 0h76z", fill: bt[2] }), oe.a.createElement("path", { d: "M83 45a38 38 0 01-76 0h76z", fill: bt[3] }), oe.a.createElement("path", { d: "M77 45a32 32 0 10-64 0h64z", fill: bt[4] }), oe.a.createElement("path", { d: "M77 45a32 32 0 11-64 0h64z", fill: bt[5] }), oe.a.createElement("path", { d: "M71 45a26 26 0 00-52 0h52z", fill: bt[6] }), oe.a.createElement("path", { d: "M71 45a26 26 0 01-52 0h52z", fill: bt[7] }), oe.a.createElement("circle", { cx: 45, cy: 45, r: 23, fill: bt[8] })));
      }, beam: function(pt) {
        var mt = pt.name, gt = pt.colors, Pt = pt.title, xt = pt.square, Nt = pt.size, Et = re(pt, ["name", "colors", "title", "square", "size"]), bt = function(wt, st) {
          var Oe, V = ke(wt), ce = st && st.length, it = nt(V, st, ce), at = rt(V, 10, 1), ft = at < 5 ? at + 4 : at, lt = rt(V, 10, 2), ct = lt < 5 ? lt + 4 : lt;
          return { wrapperColor: it, faceColor: (Oe = it, Oe.slice(0, 1) === "#" && (Oe = Oe.slice(1)), (299 * parseInt(Oe.substr(0, 2), 16) + 587 * parseInt(Oe.substr(2, 2), 16) + 114 * parseInt(Oe.substr(4, 2), 16)) / 1e3 >= 128 ? "#000000" : "#FFFFFF"), backgroundColor: nt(V + 13, st, ce), wrapperTranslateX: ft, wrapperTranslateY: ct, wrapperRotate: rt(V, 360), wrapperScale: 1 + rt(V, 3) / 10, isMouthOpen: pe(V, 2), isCircle: pe(V, 1), eyeSpread: rt(V, 5), mouthSpread: rt(V, 3), faceRotate: rt(V, 10, 3), faceTranslateX: ft > 6 ? ft / 2 : rt(V, 8, 1), faceTranslateY: ct > 6 ? ct / 2 : rt(V, 7, 2) };
        }(mt, gt), Bt = ie.useId();
        return ie.createElement("svg", Object.assign({ viewBox: "0 0 36 36", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Nt, height: Nt }, Et), Pt && ie.createElement("title", null, mt), ie.createElement("mask", { id: Bt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 36, height: 36 }, ie.createElement("rect", { width: 36, height: 36, rx: xt ? void 0 : 72, fill: "#FFFFFF" })), ie.createElement("g", { mask: "url(#".concat(Bt, ")") }, ie.createElement("rect", { width: 36, height: 36, fill: bt.backgroundColor }), ie.createElement("rect", { x: "0", y: "0", width: 36, height: 36, transform: "translate(" + bt.wrapperTranslateX + " " + bt.wrapperTranslateY + ") rotate(" + bt.wrapperRotate + " 18 18) scale(" + bt.wrapperScale + ")", fill: bt.wrapperColor, rx: bt.isCircle ? 36 : 6 }), ie.createElement("g", { transform: "translate(" + bt.faceTranslateX + " " + bt.faceTranslateY + ") rotate(" + bt.faceRotate + " 18 18)" }, bt.isMouthOpen ? ie.createElement("path", { d: "M15 " + (19 + bt.mouthSpread) + "c2 1 4 1 6 0", stroke: bt.faceColor, fill: "none", strokeLinecap: "round" }) : ie.createElement("path", { d: "M13," + (19 + bt.mouthSpread) + " a1,0.75 0 0,0 10,0", fill: bt.faceColor }), ie.createElement("rect", { x: 14 - bt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: bt.faceColor }), ie.createElement("rect", { x: 20 + bt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: bt.faceColor }))));
      }, sunset: function(pt) {
        var mt = pt.name, gt = pt.colors, Pt = pt.title, xt = pt.square, Nt = pt.size, Et = re(pt, ["name", "colors", "title", "square", "size"]), bt = function(st, Oe) {
          var V = ke(st), ce = Oe && Oe.length;
          return Array.from({ length: 4 }, function(it, at) {
            return nt(V + at, Oe, ce);
          });
        }(mt, gt), Bt = mt.replace(/\s/g, ""), wt = ie.useId();
        return ie.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Nt, height: Nt }, Et), Pt && ie.createElement("title", null, mt), ie.createElement("mask", { id: wt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ie.createElement("rect", { width: 80, height: 80, rx: xt ? void 0 : 160, fill: "#FFFFFF" })), ie.createElement("g", { mask: "url(#".concat(wt, ")") }, ie.createElement("path", { fill: "url(#gradient_paint0_linear_" + Bt + ")", d: "M0 0h80v40H0z" }), ie.createElement("path", { fill: "url(#gradient_paint1_linear_" + Bt + ")", d: "M0 40h80v40H0z" })), ie.createElement("defs", null, ie.createElement("linearGradient", { id: "gradient_paint0_linear_" + Bt, x1: 40, y1: 0, x2: 40, y2: 40, gradientUnits: "userSpaceOnUse" }, ie.createElement("stop", { stopColor: bt[0] }), ie.createElement("stop", { offset: 1, stopColor: bt[1] })), ie.createElement("linearGradient", { id: "gradient_paint1_linear_" + Bt, x1: 40, y1: 40, x2: 40, y2: 80, gradientUnits: "userSpaceOnUse" }, ie.createElement("stop", { stopColor: bt[2] }), ie.createElement("stop", { offset: 1, stopColor: bt[3] }))));
      }, marble: ot }, dt = { geometric: "beam", abstract: "bauhaus" }, vt = function(pt) {
        var mt = pt.variant, gt = mt === void 0 ? "marble" : mt, Pt = pt.colors, xt = Pt === void 0 ? ["#92A1C6", "#146A7C", "#F0AB3D", "#C271B4", "#C20D90"] : Pt, Nt = pt.name, Et = Nt === void 0 ? "Clara Barton" : Nt, bt = pt.title, Bt = bt !== void 0 && bt, wt = pt.size, st = pt.square, Oe = st !== void 0 && st, V = re(pt, ["variant", "colors", "name", "title", "size", "square"]), ce = ut[dt[gt] || gt] || ot;
        return oe.a.createElement(ce, Object.assign({ colors: xt, name: Et, title: Bt, size: wt, square: Oe }, V));
      };
      J.default = vt;
    }]);
  });
})(build);
var buildExports = build.exports;
const Avatar = /* @__PURE__ */ getDefaultExportFromCjs(buildExports);
var i$7 = Object.defineProperty, d$5 = (A, B, W) => B in A ? i$7(A, B, { enumerable: !0, configurable: !0, writable: !0, value: W }) : A[B] = W, r$4 = (A, B, W) => (d$5(A, typeof B != "symbol" ? B + "" : B, W), W);
let o$7 = class {
  constructor() {
    r$4(this, "current", this.detect()), r$4(this, "handoffState", "pending"), r$4(this, "currentId", 0);
  }
  set(B) {
    this.current !== B && (this.handoffState = "pending", this.currentId = 0, this.current = B);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$a = new o$7(), l$5 = (A, B) => {
  s$a.isServer ? useEffect(A, B) : useLayoutEffect(A, B);
};
function s$9(A) {
  let B = useRef(A);
  return l$5(() => {
    B.current = A;
  }, [A]), B;
}
let o$6 = function(A) {
  let B = s$9(A);
  return C__default.useCallback((...W) => B.current(...W), [B]);
};
function t$7(A) {
  typeof queueMicrotask == "function" ? queueMicrotask(A) : Promise.resolve().then(A).catch((B) => setTimeout(() => {
    throw B;
  }));
}
function o$5() {
  let A = [], B = { addEventListener(W, K, J, L) {
    return W.addEventListener(K, J, L), B.add(() => W.removeEventListener(K, J, L));
  }, requestAnimationFrame(...W) {
    let K = requestAnimationFrame(...W);
    return B.add(() => cancelAnimationFrame(K));
  }, nextFrame(...W) {
    return B.requestAnimationFrame(() => B.requestAnimationFrame(...W));
  }, setTimeout(...W) {
    let K = setTimeout(...W);
    return B.add(() => clearTimeout(K));
  }, microTask(...W) {
    let K = { current: !0 };
    return t$7(() => {
      K.current && W[0]();
    }), B.add(() => {
      K.current = !1;
    });
  }, style(W, K, J) {
    let L = W.style.getPropertyValue(K);
    return Object.assign(W.style, { [K]: J }), this.add(() => {
      Object.assign(W.style, { [K]: L });
    });
  }, group(W) {
    let K = o$5();
    return W(K), this.add(() => K.dispose());
  }, add(W) {
    return A.push(W), () => {
      let K = A.indexOf(W);
      if (K >= 0) for (let J of A.splice(K, 1)) J();
    };
  }, dispose() {
    for (let W of A.splice(0)) W();
  } };
  return B;
}
function p$3() {
  let [A] = useState(o$5);
  return useEffect(() => () => A.dispose(), [A]), A;
}
function s$8() {
  let A = typeof document > "u";
  return "useSyncExternalStore" in C$2 ? ((B) => B.useSyncExternalStore)(C$2)(() => () => {
  }, () => !1, () => !A) : !1;
}
function l$4() {
  let A = s$8(), [B, W] = C$2.useState(s$a.isHandoffComplete);
  return B && s$a.isHandoffComplete === !1 && W(!1), C$2.useEffect(() => {
    B !== !0 && W(!0);
  }, [B]), C$2.useEffect(() => s$a.handoff(), []), A ? !1 : B;
}
var o$4;
let I$5 = (o$4 = C__default.useId) != null ? o$4 : function() {
  let A = l$4(), [B, W] = C__default.useState(A ? () => s$a.nextId() : null);
  return l$5(() => {
    B === null && W(s$a.nextId());
  }, [B]), B != null ? "" + B : void 0;
};
function u$7(A, B, ...W) {
  if (A in B) {
    let J = B[A];
    return typeof J == "function" ? J(...W) : J;
  }
  let K = new Error(`Tried to handle "${A}" but there is no handler defined. Only defined handlers are: ${Object.keys(B).map((J) => `"${J}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(K, u$7), K;
}
function o$3(A) {
  return s$a.isServer ? null : A instanceof Node ? A.ownerDocument : A != null && A.hasOwnProperty("current") && A.current instanceof Node ? A.current.ownerDocument : document;
}
let c$5 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((A) => `${A}:not([tabindex='-1'])`).join(",");
var M$2 = ((A) => (A[A.First = 1] = "First", A[A.Previous = 2] = "Previous", A[A.Next = 4] = "Next", A[A.Last = 8] = "Last", A[A.WrapAround = 16] = "WrapAround", A[A.NoScroll = 32] = "NoScroll", A))(M$2 || {}), N$2 = ((A) => (A[A.Error = 0] = "Error", A[A.Overflow = 1] = "Overflow", A[A.Success = 2] = "Success", A[A.Underflow = 3] = "Underflow", A))(N$2 || {}), F$3 = ((A) => (A[A.Previous = -1] = "Previous", A[A.Next = 1] = "Next", A))(F$3 || {});
function f$6(A = document.body) {
  return A == null ? [] : Array.from(A.querySelectorAll(c$5)).sort((B, W) => Math.sign((B.tabIndex || Number.MAX_SAFE_INTEGER) - (W.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T$2 = ((A) => (A[A.Strict = 0] = "Strict", A[A.Loose = 1] = "Loose", A))(T$2 || {});
function h$4(A, B = 0) {
  var W;
  return A === ((W = o$3(A)) == null ? void 0 : W.body) ? !1 : u$7(B, { 0() {
    return A.matches(c$5);
  }, 1() {
    let K = A;
    for (; K !== null; ) {
      if (K.matches(c$5)) return !0;
      K = K.parentElement;
    }
    return !1;
  } });
}
function D$3(A) {
  let B = o$3(A);
  o$5().nextFrame(() => {
    B && !h$4(B.activeElement, 0) && y$3(A);
  });
}
var w$2 = ((A) => (A[A.Keyboard = 0] = "Keyboard", A[A.Mouse = 1] = "Mouse", A))(w$2 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (A) => {
  A.metaKey || A.altKey || A.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (A) => {
  A.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : A.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function y$3(A) {
  A == null || A.focus({ preventScroll: !0 });
}
let S$5 = ["textarea", "input"].join(",");
function H(A) {
  var B, W;
  return (W = (B = A == null ? void 0 : A.matches) == null ? void 0 : B.call(A, S$5)) != null ? W : !1;
}
function I$4(A, B = (W) => W) {
  return A.slice().sort((W, K) => {
    let J = B(W), L = B(K);
    if (J === null || L === null) return 0;
    let re = J.compareDocumentPosition(L);
    return re & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : re & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function _$2(A, B) {
  return O$1(f$6(), B, { relativeTo: A });
}
function O$1(A, B, { sorted: W = !0, relativeTo: K = null, skipElements: J = [] } = {}) {
  let L = Array.isArray(A) ? A.length > 0 ? A[0].ownerDocument : document : A.ownerDocument, re = Array.isArray(A) ? W ? I$4(A) : A : f$6(A);
  J.length > 0 && re.length > 1 && (re = re.filter((nt) => !J.includes(nt))), K = K ?? L.activeElement;
  let ie = (() => {
    if (B & 5) return 1;
    if (B & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), oe = (() => {
    if (B & 1) return 0;
    if (B & 2) return Math.max(0, re.indexOf(K)) - 1;
    if (B & 4) return Math.max(0, re.indexOf(K)) + 1;
    if (B & 8) return re.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ke = B & 32 ? { preventScroll: !0 } : {}, ne = 0, pe = re.length, rt;
  do {
    if (ne >= pe || ne + pe <= 0) return 0;
    let nt = oe + ne;
    if (B & 16) nt = (nt + pe) % pe;
    else {
      if (nt < 0) return 3;
      if (nt >= pe) return 1;
    }
    rt = re[nt], rt == null || rt.focus(ke), ne += ie;
  } while (rt !== L.activeElement);
  return B & 6 && H(rt) && rt.select(), 2;
}
function t$6() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$6() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$3() {
  return t$6() || i$6();
}
function d$4(A, B, W) {
  let K = s$9(B);
  useEffect(() => {
    function J(L) {
      K.current(L);
    }
    return document.addEventListener(A, J, W), () => document.removeEventListener(A, J, W);
  }, [A, W]);
}
function s$7(A, B, W) {
  let K = s$9(B);
  useEffect(() => {
    function J(L) {
      K.current(L);
    }
    return window.addEventListener(A, J, W), () => window.removeEventListener(A, J, W);
  }, [A, W]);
}
function y$2(A, B, W = !0) {
  let K = useRef(!1);
  useEffect(() => {
    requestAnimationFrame(() => {
      K.current = W;
    });
  }, [W]);
  function J(re, ie) {
    if (!K.current || re.defaultPrevented) return;
    let oe = ie(re);
    if (oe === null || !oe.getRootNode().contains(oe) || !oe.isConnected) return;
    let ke = function ne(pe) {
      return typeof pe == "function" ? ne(pe()) : Array.isArray(pe) || pe instanceof Set ? pe : [pe];
    }(A);
    for (let ne of ke) {
      if (ne === null) continue;
      let pe = ne instanceof HTMLElement ? ne : ne.current;
      if (pe != null && pe.contains(oe) || re.composed && re.composedPath().includes(pe)) return;
    }
    return !h$4(oe, T$2.Loose) && oe.tabIndex !== -1 && re.preventDefault(), B(re, oe);
  }
  let L = useRef(null);
  d$4("pointerdown", (re) => {
    var ie, oe;
    K.current && (L.current = ((oe = (ie = re.composedPath) == null ? void 0 : ie.call(re)) == null ? void 0 : oe[0]) || re.target);
  }, !0), d$4("mousedown", (re) => {
    var ie, oe;
    K.current && (L.current = ((oe = (ie = re.composedPath) == null ? void 0 : ie.call(re)) == null ? void 0 : oe[0]) || re.target);
  }, !0), d$4("click", (re) => {
    n$3() || L.current && (J(re, () => L.current), L.current = null);
  }, !0), d$4("touchend", (re) => J(re, () => re.target instanceof HTMLElement ? re.target : null), !0), s$7("blur", (re) => J(re, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$2(...A) {
  return useMemo(() => o$3(...A), [...A]);
}
function i$5(A) {
  var B;
  if (A.type) return A.type;
  let W = (B = A.as) != null ? B : "button";
  if (typeof W == "string" && W.toLowerCase() === "button") return "button";
}
function T$1(A, B) {
  let [W, K] = useState(() => i$5(A));
  return l$5(() => {
    K(i$5(A));
  }, [A.type, A.as]), l$5(() => {
    W || B.current && B.current instanceof HTMLButtonElement && !B.current.hasAttribute("type") && K("button");
  }, [W, B]), W;
}
let u$6 = Symbol();
function T(A, B = !0) {
  return Object.assign(A, { [u$6]: B });
}
function y$1(...A) {
  let B = useRef(A);
  useEffect(() => {
    B.current = A;
  }, [A]);
  let W = o$6((K) => {
    for (let J of B.current) J != null && (typeof J == "function" ? J(K) : J.current = K);
  });
  return A.every((K) => K == null || (K == null ? void 0 : K[u$6])) ? void 0 : W;
}
function t$5(A) {
  return [A.screenX, A.screenY];
}
function u$5() {
  let A = useRef([-1, -1]);
  return { wasMoved(B) {
    let W = t$5(B);
    return A.current[0] === W[0] && A.current[1] === W[1] ? !1 : (A.current = W, !0);
  }, update(B) {
    A.current = t$5(B);
  } };
}
function F$2({ container: A, accept: B, walk: W, enabled: K = !0 }) {
  let J = useRef(B), L = useRef(W);
  useEffect(() => {
    J.current = B, L.current = W;
  }, [B, W]), l$5(() => {
    if (!A || !K) return;
    let re = o$3(A);
    if (!re) return;
    let ie = J.current, oe = L.current, ke = Object.assign((pe) => ie(pe), { acceptNode: ie }), ne = re.createTreeWalker(A, NodeFilter.SHOW_ELEMENT, ke, !1);
    for (; ne.nextNode(); ) oe(ne.currentNode);
  }, [A, K, J, L]);
}
function m$2(A, B) {
  let W = useRef([]), K = o$6(A);
  useEffect(() => {
    let J = [...W.current];
    for (let [L, re] of B.entries()) if (W.current[L] !== re) {
      let ie = K(B, J);
      return W.current = B, ie;
    }
  }, [K, ...B]);
}
function t$4(...A) {
  return Array.from(new Set(A.flatMap((B) => typeof B == "string" ? B.split(" ") : []))).filter(Boolean).join(" ");
}
var O = ((A) => (A[A.None = 0] = "None", A[A.RenderStrategy = 1] = "RenderStrategy", A[A.Static = 2] = "Static", A))(O || {}), v$1 = ((A) => (A[A.Unmount = 0] = "Unmount", A[A.Hidden = 1] = "Hidden", A))(v$1 || {});
function C$1({ ourProps: A, theirProps: B, slot: W, defaultTag: K, features: J, visible: L = !0, name: re, mergeRefs: ie }) {
  ie = ie ?? k$1;
  let oe = R(B, A);
  if (L) return m$1(oe, W, K, re, ie);
  let ke = J ?? 0;
  if (ke & 2) {
    let { static: ne = !1, ...pe } = oe;
    if (ne) return m$1(pe, W, K, re, ie);
  }
  if (ke & 1) {
    let { unmount: ne = !0, ...pe } = oe;
    return u$7(ne ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return m$1({ ...pe, hidden: !0, style: { display: "none" } }, W, K, re, ie);
    } });
  }
  return m$1(oe, W, K, re, ie);
}
function m$1(A, B = {}, W, K, J) {
  let { as: L = W, children: re, refName: ie = "ref", ...oe } = F$1(A, ["unmount", "static"]), ke = A.ref !== void 0 ? { [ie]: A.ref } : {}, ne = typeof re == "function" ? re(B) : re;
  "className" in oe && oe.className && typeof oe.className == "function" && (oe.className = oe.className(B));
  let pe = {};
  if (B) {
    let rt = !1, nt = [];
    for (let [ot, ut] of Object.entries(B)) typeof ut == "boolean" && (rt = !0), ut === !0 && nt.push(ot);
    rt && (pe["data-headlessui-state"] = nt.join(" "));
  }
  if (L === Fragment && Object.keys(x$2(oe)).length > 0) {
    if (!isValidElement(ne) || Array.isArray(ne) && ne.length > 1) throw new Error(['Passing props on "Fragment"!', "", `The current component <${K} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(oe).map((ut) => `  - ${ut}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((ut) => `  - ${ut}`).join(`
`)].join(`
`));
    let rt = ne.props, nt = typeof (rt == null ? void 0 : rt.className) == "function" ? (...ut) => t$4(rt == null ? void 0 : rt.className(...ut), oe.className) : t$4(rt == null ? void 0 : rt.className, oe.className), ot = nt ? { className: nt } : {};
    return cloneElement(ne, Object.assign({}, R(ne.props, x$2(F$1(oe, ["ref"]))), pe, ke, { ref: J(ne.ref, ke.ref) }, ot));
  }
  return createElement(L, Object.assign({}, F$1(oe, ["ref"]), L !== Fragment && ke, L !== Fragment && pe), ne);
}
function k$1(...A) {
  return A.every((B) => B == null) ? void 0 : (B) => {
    for (let W of A) W != null && (typeof W == "function" ? W(B) : W.current = B);
  };
}
function R(...A) {
  if (A.length === 0) return {};
  if (A.length === 1) return A[0];
  let B = {}, W = {};
  for (let K of A) for (let J in K) J.startsWith("on") && typeof K[J] == "function" ? (W[J] != null || (W[J] = []), W[J].push(K[J])) : B[J] = K[J];
  if (B.disabled || B["aria-disabled"]) return Object.assign(B, Object.fromEntries(Object.keys(W).map((K) => [K, void 0])));
  for (let K in W) Object.assign(B, { [K](J, ...L) {
    let re = W[K];
    for (let ie of re) {
      if ((J instanceof Event || (J == null ? void 0 : J.nativeEvent) instanceof Event) && J.defaultPrevented) return;
      ie(J, ...L);
    }
  } });
  return B;
}
function U$3(A) {
  var B;
  return Object.assign(forwardRef(A), { displayName: (B = A.displayName) != null ? B : A.name });
}
function x$2(A) {
  let B = Object.assign({}, A);
  for (let W in B) B[W] === void 0 && delete B[W];
  return B;
}
function F$1(A, B = []) {
  let W = Object.assign({}, A);
  for (let K of B) K in W && delete W[K];
  return W;
}
let p$2 = "div";
var s$6 = ((A) => (A[A.None = 1] = "None", A[A.Focusable = 2] = "Focusable", A[A.Hidden = 4] = "Hidden", A))(s$6 || {});
function l$3(A, B) {
  var W;
  let { features: K = 1, ...J } = A, L = { ref: B, "aria-hidden": (K & 2) === 2 ? !0 : (W = J["aria-hidden"]) != null ? W : void 0, hidden: (K & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(K & 4) === 4 && (K & 2) !== 2 && { display: "none" } } };
  return C$1({ ourProps: L, theirProps: J, slot: {}, defaultTag: p$2, name: "Hidden" });
}
let u$4 = U$3(l$3), n$1 = createContext(null);
n$1.displayName = "OpenClosedContext";
var d$3 = ((A) => (A[A.Open = 1] = "Open", A[A.Closed = 2] = "Closed", A[A.Closing = 4] = "Closing", A[A.Opening = 8] = "Opening", A))(d$3 || {});
function u$3() {
  return useContext(n$1);
}
function s$5({ value: A, children: B }) {
  return C__default.createElement(n$1.Provider, { value: A }, B);
}
function t$3(A) {
  function B() {
    document.readyState !== "loading" && (A(), document.removeEventListener("DOMContentLoaded", B));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", B), B());
}
let t$2 = [];
t$3(() => {
  function A(B) {
    B.target instanceof HTMLElement && B.target !== document.body && t$2[0] !== B.target && (t$2.unshift(B.target), t$2 = t$2.filter((W) => W != null && W.isConnected), t$2.splice(10));
  }
  window.addEventListener("click", A, { capture: !0 }), window.addEventListener("mousedown", A, { capture: !0 }), window.addEventListener("focus", A, { capture: !0 }), document.body.addEventListener("click", A, { capture: !0 }), document.body.addEventListener("mousedown", A, { capture: !0 }), document.body.addEventListener("focus", A, { capture: !0 });
});
function r$3(A) {
  let B = A.parentElement, W = null;
  for (; B && !(B instanceof HTMLFieldSetElement); ) B instanceof HTMLLegendElement && (W = B), B = B.parentElement;
  let K = (B == null ? void 0 : B.getAttribute("disabled")) === "";
  return K && i$4(W) ? !1 : K;
}
function i$4(A) {
  if (!A) return !1;
  let B = A.previousElementSibling;
  for (; B !== null; ) {
    if (B instanceof HTMLLegendElement) return !1;
    B = B.previousElementSibling;
  }
  return !0;
}
function u$2(A) {
  throw new Error("Unexpected object: " + A);
}
var c$4 = ((A) => (A[A.First = 0] = "First", A[A.Previous = 1] = "Previous", A[A.Next = 2] = "Next", A[A.Last = 3] = "Last", A[A.Specific = 4] = "Specific", A[A.Nothing = 5] = "Nothing", A))(c$4 || {});
function f$5(A, B) {
  let W = B.resolveItems();
  if (W.length <= 0) return null;
  let K = B.resolveActiveIndex(), J = K ?? -1;
  switch (A.focus) {
    case 0: {
      for (let L = 0; L < W.length; ++L) if (!B.resolveDisabled(W[L], L, W)) return L;
      return K;
    }
    case 1: {
      for (let L = J - 1; L >= 0; --L) if (!B.resolveDisabled(W[L], L, W)) return L;
      return K;
    }
    case 2: {
      for (let L = J + 1; L < W.length; ++L) if (!B.resolveDisabled(W[L], L, W)) return L;
      return K;
    }
    case 3: {
      for (let L = W.length - 1; L >= 0; --L) if (!B.resolveDisabled(W[L], L, W)) return L;
      return K;
    }
    case 4: {
      for (let L = 0; L < W.length; ++L) if (B.resolveId(W[L], L, W) === A.id) return L;
      return K;
    }
    case 5:
      return null;
    default:
      u$2(A);
  }
}
var o$2 = ((A) => (A.Space = " ", A.Enter = "Enter", A.Escape = "Escape", A.Backspace = "Backspace", A.Delete = "Delete", A.ArrowLeft = "ArrowLeft", A.ArrowUp = "ArrowUp", A.ArrowRight = "ArrowRight", A.ArrowDown = "ArrowDown", A.Home = "Home", A.End = "End", A.PageUp = "PageUp", A.PageDown = "PageDown", A.Tab = "Tab", A))(o$2 || {});
function E(A, B, W, K) {
  let J = s$9(W);
  useEffect(() => {
    A = A ?? window;
    function L(re) {
      J.current(re);
    }
    return A.addEventListener(B, L, K), () => A.removeEventListener(B, L, K);
  }, [A, B, K]);
}
function f$4() {
  let A = useRef(!1);
  return l$5(() => (A.current = !0, () => {
    A.current = !1;
  }), []), A;
}
function c$3(A) {
  let B = o$6(A), W = useRef(!1);
  useEffect(() => (W.current = !1, () => {
    W.current = !0, t$7(() => {
      W.current && B();
    });
  }), [B]);
}
var s$4 = ((A) => (A[A.Forwards = 0] = "Forwards", A[A.Backwards = 1] = "Backwards", A))(s$4 || {});
function n() {
  let A = useRef(0);
  return s$7("keydown", (B) => {
    B.key === "Tab" && (A.current = B.shiftKey ? 1 : 0);
  }, !0), A;
}
function P(A) {
  if (!A) return /* @__PURE__ */ new Set();
  if (typeof A == "function") return new Set(A());
  let B = /* @__PURE__ */ new Set();
  for (let W of A.current) W.current instanceof HTMLElement && B.add(W.current);
  return B;
}
let X = "div";
var _$1 = ((A) => (A[A.None = 1] = "None", A[A.InitialFocus = 2] = "InitialFocus", A[A.TabLock = 4] = "TabLock", A[A.FocusLock = 8] = "FocusLock", A[A.RestoreFocus = 16] = "RestoreFocus", A[A.All = 30] = "All", A))(_$1 || {});
function z(A, B) {
  let W = useRef(null), K = y$1(W, B), { initialFocus: J, containers: L, features: re = 30, ...ie } = A;
  l$4() || (re = 1);
  let oe = n$2(W);
  Y({ ownerDocument: oe }, !!(re & 16));
  let ke = Z({ ownerDocument: oe, container: W, initialFocus: J }, !!(re & 2));
  $({ ownerDocument: oe, container: W, containers: L, previousActiveElement: ke }, !!(re & 8));
  let ne = n(), pe = o$6((ut) => {
    let dt = W.current;
    dt && ((vt) => vt())(() => {
      u$7(ne.current, { [s$4.Forwards]: () => {
        O$1(dt, M$2.First, { skipElements: [ut.relatedTarget] });
      }, [s$4.Backwards]: () => {
        O$1(dt, M$2.Last, { skipElements: [ut.relatedTarget] });
      } });
    });
  }), rt = p$3(), nt = useRef(!1), ot = { ref: K, onKeyDown(ut) {
    ut.key == "Tab" && (nt.current = !0, rt.requestAnimationFrame(() => {
      nt.current = !1;
    }));
  }, onBlur(ut) {
    let dt = P(L);
    W.current instanceof HTMLElement && dt.add(W.current);
    let vt = ut.relatedTarget;
    vt instanceof HTMLElement && vt.dataset.headlessuiFocusGuard !== "true" && (S$4(dt, vt) || (nt.current ? O$1(W.current, u$7(ne.current, { [s$4.Forwards]: () => M$2.Next, [s$4.Backwards]: () => M$2.Previous }) | M$2.WrapAround, { relativeTo: ut.target }) : ut.target instanceof HTMLElement && y$3(ut.target)));
  } };
  return C__default.createElement(C__default.Fragment, null, !!(re & 4) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: pe, features: s$6.Focusable }), C$1({ ourProps: ot, theirProps: ie, defaultTag: X, name: "FocusTrap" }), !!(re & 4) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: pe, features: s$6.Focusable }));
}
let D$2 = U$3(z), de$1 = Object.assign(D$2, { features: _$1 });
function Q(A = !0) {
  let B = useRef(t$2.slice());
  return m$2(([W], [K]) => {
    K === !0 && W === !1 && t$7(() => {
      B.current.splice(0);
    }), K === !1 && W === !0 && (B.current = t$2.slice());
  }, [A, t$2, B]), o$6(() => {
    var W;
    return (W = B.current.find((K) => K != null && K.isConnected)) != null ? W : null;
  });
}
function Y({ ownerDocument: A }, B) {
  let W = Q(B);
  m$2(() => {
    B || (A == null ? void 0 : A.activeElement) === (A == null ? void 0 : A.body) && y$3(W());
  }, [B]), c$3(() => {
    B && y$3(W());
  });
}
function Z({ ownerDocument: A, container: B, initialFocus: W }, K) {
  let J = useRef(null), L = f$4();
  return m$2(() => {
    if (!K) return;
    let re = B.current;
    re && t$7(() => {
      if (!L.current) return;
      let ie = A == null ? void 0 : A.activeElement;
      if (W != null && W.current) {
        if ((W == null ? void 0 : W.current) === ie) {
          J.current = ie;
          return;
        }
      } else if (re.contains(ie)) {
        J.current = ie;
        return;
      }
      W != null && W.current ? y$3(W.current) : O$1(re, M$2.First) === N$2.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), J.current = A == null ? void 0 : A.activeElement;
    });
  }, [K]), J;
}
function $({ ownerDocument: A, container: B, containers: W, previousActiveElement: K }, J) {
  let L = f$4();
  E(A == null ? void 0 : A.defaultView, "focus", (re) => {
    if (!J || !L.current) return;
    let ie = P(W);
    B.current instanceof HTMLElement && ie.add(B.current);
    let oe = K.current;
    if (!oe) return;
    let ke = re.target;
    ke && ke instanceof HTMLElement ? S$4(ie, ke) ? (K.current = ke, y$3(ke)) : (re.preventDefault(), re.stopPropagation(), y$3(oe)) : y$3(K.current);
  }, !0);
}
function S$4(A, B) {
  for (let W of A) if (W.contains(B)) return !0;
  return !1;
}
let e = createContext(!1);
function a$5() {
  return useContext(e);
}
function l$2(A) {
  return C__default.createElement(e.Provider, { value: A.force }, A.children);
}
function F(A) {
  let B = a$5(), W = useContext(_), K = n$2(A), [J, L] = useState(() => {
    if (!B && W !== null || s$a.isServer) return null;
    let re = K == null ? void 0 : K.getElementById("headlessui-portal-root");
    if (re) return re;
    if (K === null) return null;
    let ie = K.createElement("div");
    return ie.setAttribute("id", "headlessui-portal-root"), K.body.appendChild(ie);
  });
  return useEffect(() => {
    J !== null && (K != null && K.body.contains(J) || K == null || K.body.appendChild(J));
  }, [J, K]), useEffect(() => {
    B || W !== null && L(W.current);
  }, [W, L, B]), J;
}
let U$2 = Fragment;
function N$1(A, B) {
  let W = A, K = useRef(null), J = y$1(T((ne) => {
    K.current = ne;
  }), B), L = n$2(K), re = F(K), [ie] = useState(() => {
    var ne;
    return s$a.isServer ? null : (ne = L == null ? void 0 : L.createElement("div")) != null ? ne : null;
  }), oe = useContext(f$3), ke = l$4();
  return l$5(() => {
    !re || !ie || re.contains(ie) || (ie.setAttribute("data-headlessui-portal", ""), re.appendChild(ie));
  }, [re, ie]), l$5(() => {
    if (ie && oe) return oe.register(ie);
  }, [oe, ie]), c$3(() => {
    var ne;
    !re || !ie || (ie instanceof Node && re.contains(ie) && re.removeChild(ie), re.childNodes.length <= 0 && ((ne = re.parentElement) == null || ne.removeChild(re)));
  }), ke ? !re || !ie ? null : createPortal(C$1({ ourProps: { ref: J }, theirProps: W, defaultTag: U$2, name: "Portal" }), ie) : null;
}
let S$3 = Fragment, _ = createContext(null);
function j(A, B) {
  let { target: W, ...K } = A, J = { ref: y$1(B) };
  return C__default.createElement(_.Provider, { value: W }, C$1({ ourProps: J, theirProps: K, defaultTag: S$3, name: "Popover.Group" }));
}
let f$3 = createContext(null);
function ee() {
  let A = useContext(f$3), B = useRef([]), W = o$6((L) => (B.current.push(L), A && A.register(L), () => K(L))), K = o$6((L) => {
    let re = B.current.indexOf(L);
    re !== -1 && B.current.splice(re, 1), A && A.unregister(L);
  }), J = useMemo(() => ({ register: W, unregister: K, portals: B }), [W, K, B]);
  return [B, useMemo(() => function({ children: L }) {
    return C__default.createElement(f$3.Provider, { value: J }, L);
  }, [J])];
}
let D$1 = U$3(N$1), I$3 = U$3(j), te = Object.assign(D$1, { Group: I$3 });
function i$3(A, B) {
  return A === B && (A !== 0 || 1 / A === 1 / B) || A !== A && B !== B;
}
const d$2 = typeof Object.is == "function" ? Object.is : i$3, { useState: u$1, useEffect: h$3, useLayoutEffect: f$2, useDebugValue: p$1 } = C$2;
function y(A, B, W) {
  const K = B(), [{ inst: J }, L] = u$1({ inst: { value: K, getSnapshot: B } });
  return f$2(() => {
    J.value = K, J.getSnapshot = B, r$2(J) && L({ inst: J });
  }, [A, K, B]), h$3(() => (r$2(J) && L({ inst: J }), A(() => {
    r$2(J) && L({ inst: J });
  })), [A]), p$1(K), K;
}
function r$2(A) {
  const B = A.getSnapshot, W = A.value;
  try {
    const K = B();
    return !d$2(W, K);
  } catch {
    return !0;
  }
}
function t$1(A, B, W) {
  return B();
}
const r$1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", s$3 = !r$1, c$2 = s$3 ? t$1 : y, a$4 = "useSyncExternalStore" in C$2 ? ((A) => A.useSyncExternalStore)(C$2) : c$2;
function S$2(A) {
  return a$4(A.subscribe, A.getSnapshot, A.getSnapshot);
}
function a$3(A, B) {
  let W = A(), K = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return W;
  }, subscribe(J) {
    return K.add(J), () => K.delete(J);
  }, dispatch(J, ...L) {
    let re = B[J].call(W, ...L);
    re && (W = re, K.forEach((ie) => ie()));
  } };
}
function c$1() {
  let A;
  return { before({ doc: B }) {
    var W;
    let K = B.documentElement;
    A = ((W = B.defaultView) != null ? W : window).innerWidth - K.clientWidth;
  }, after({ doc: B, d: W }) {
    let K = B.documentElement, J = K.clientWidth - K.offsetWidth, L = A - J;
    W.style(K, "paddingRight", `${L}px`);
  } };
}
function d$1() {
  return t$6() ? { before({ doc: A, d: B, meta: W }) {
    function K(J) {
      return W.containers.flatMap((L) => L()).some((L) => L.contains(J));
    }
    B.microTask(() => {
      var J;
      if (window.getComputedStyle(A.documentElement).scrollBehavior !== "auto") {
        let ie = o$5();
        ie.style(A.documentElement, "scrollBehavior", "auto"), B.add(() => B.microTask(() => ie.dispose()));
      }
      let L = (J = window.scrollY) != null ? J : window.pageYOffset, re = null;
      B.addEventListener(A, "click", (ie) => {
        if (ie.target instanceof HTMLElement) try {
          let oe = ie.target.closest("a");
          if (!oe) return;
          let { hash: ke } = new URL(oe.href), ne = A.querySelector(ke);
          ne && !K(ne) && (re = ne);
        } catch {
        }
      }, !0), B.addEventListener(A, "touchstart", (ie) => {
        if (ie.target instanceof HTMLElement) if (K(ie.target)) {
          let oe = ie.target;
          for (; oe.parentElement && K(oe.parentElement); ) oe = oe.parentElement;
          B.style(oe, "overscrollBehavior", "contain");
        } else B.style(ie.target, "touchAction", "none");
      }), B.addEventListener(A, "touchmove", (ie) => {
        if (ie.target instanceof HTMLElement) if (K(ie.target)) {
          let oe = ie.target;
          for (; oe.parentElement && oe.dataset.headlessuiPortal !== "" && !(oe.scrollHeight > oe.clientHeight || oe.scrollWidth > oe.clientWidth); ) oe = oe.parentElement;
          oe.dataset.headlessuiPortal === "" && ie.preventDefault();
        } else ie.preventDefault();
      }, { passive: !1 }), B.add(() => {
        var ie;
        let oe = (ie = window.scrollY) != null ? ie : window.pageYOffset;
        L !== oe && window.scrollTo(0, L), re && re.isConnected && (re.scrollIntoView({ block: "nearest" }), re = null);
      });
    });
  } } : {};
}
function l$1() {
  return { before({ doc: A, d: B }) {
    B.style(A.documentElement, "overflow", "hidden");
  } };
}
function m(A) {
  let B = {};
  for (let W of A) Object.assign(B, W(B));
  return B;
}
let a$2 = a$3(() => /* @__PURE__ */ new Map(), { PUSH(A, B) {
  var W;
  let K = (W = this.get(A)) != null ? W : { doc: A, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return K.count++, K.meta.add(B), this.set(A, K), this;
}, POP(A, B) {
  let W = this.get(A);
  return W && (W.count--, W.meta.delete(B)), this;
}, SCROLL_PREVENT({ doc: A, d: B, meta: W }) {
  let K = { doc: A, d: B, meta: m(W) }, J = [d$1(), c$1(), l$1()];
  J.forEach(({ before: L }) => L == null ? void 0 : L(K)), J.forEach(({ after: L }) => L == null ? void 0 : L(K));
}, SCROLL_ALLOW({ d: A }) {
  A.dispose();
}, TEARDOWN({ doc: A }) {
  this.delete(A);
} });
a$2.subscribe(() => {
  let A = a$2.getSnapshot(), B = /* @__PURE__ */ new Map();
  for (let [W] of A) B.set(W, W.documentElement.style.overflow);
  for (let W of A.values()) {
    let K = B.get(W.doc) === "hidden", J = W.count !== 0;
    (J && !K || !J && K) && a$2.dispatch(W.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", W), W.count === 0 && a$2.dispatch("TEARDOWN", W);
  }
});
function p(A, B, W) {
  let K = S$2(a$2), J = A ? K.get(A) : void 0, L = J ? J.count > 0 : !1;
  return l$5(() => {
    if (!(!A || !B)) return a$2.dispatch("PUSH", A, W), () => a$2.dispatch("POP", A, W);
  }, [B, A]), L;
}
let u = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
function b$3(A, B = !0) {
  l$5(() => {
    var W;
    if (!B) return;
    let K = typeof A == "function" ? A() : A.current;
    if (!K) return;
    function J() {
      var re;
      if (!K) return;
      let ie = (re = t.get(K)) != null ? re : 1;
      if (ie === 1 ? t.delete(K) : t.set(K, ie - 1), ie !== 1) return;
      let oe = u.get(K);
      oe && (oe["aria-hidden"] === null ? K.removeAttribute("aria-hidden") : K.setAttribute("aria-hidden", oe["aria-hidden"]), K.inert = oe.inert, u.delete(K));
    }
    let L = (W = t.get(K)) != null ? W : 0;
    return t.set(K, L + 1), L !== 0 || (u.set(K, { "aria-hidden": K.getAttribute("aria-hidden"), inert: K.inert }), K.setAttribute("aria-hidden", "true"), K.inert = !0), J;
  }, [A, B]);
}
function N({ defaultContainers: A = [], portals: B, mainTreeNodeRef: W } = {}) {
  var K;
  let J = useRef((K = W == null ? void 0 : W.current) != null ? K : null), L = n$2(J), re = o$6(() => {
    var ie, oe, ke;
    let ne = [];
    for (let pe of A) pe !== null && (pe instanceof HTMLElement ? ne.push(pe) : "current" in pe && pe.current instanceof HTMLElement && ne.push(pe.current));
    if (B != null && B.current) for (let pe of B.current) ne.push(pe);
    for (let pe of (ie = L == null ? void 0 : L.querySelectorAll("html > *, body > *")) != null ? ie : []) pe !== document.body && pe !== document.head && pe instanceof HTMLElement && pe.id !== "headlessui-portal-root" && (pe.contains(J.current) || pe.contains((ke = (oe = J.current) == null ? void 0 : oe.getRootNode()) == null ? void 0 : ke.host) || ne.some((rt) => pe.contains(rt)) || ne.push(pe));
    return ne;
  });
  return { resolveContainers: re, contains: o$6((ie) => re().some((oe) => oe.contains(ie))), mainTreeNodeRef: J, MainTreeNode: useMemo(() => function() {
    return W != null ? null : C__default.createElement(u$4, { features: s$6.Hidden, ref: J });
  }, [J, W]) };
}
let a$1 = createContext(() => {
});
a$1.displayName = "StackContext";
var s$2 = ((A) => (A[A.Add = 0] = "Add", A[A.Remove = 1] = "Remove", A))(s$2 || {});
function x$1() {
  return useContext(a$1);
}
function b$2({ children: A, onUpdate: B, type: W, element: K, enabled: J }) {
  let L = x$1(), re = o$6((...ie) => {
    B == null || B(...ie), L(...ie);
  });
  return l$5(() => {
    let ie = J === void 0 || J === !0;
    return ie && re(0, W, K), () => {
      ie && re(1, W, K);
    };
  }, [re, W, K, J]), C__default.createElement(a$1.Provider, { value: re }, A);
}
let d = createContext(null);
function f$1() {
  let A = useContext(d);
  if (A === null) {
    let B = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(B, f$1), B;
  }
  return A;
}
function w$1() {
  let [A, B] = useState([]);
  return [A.length > 0 ? A.join(" ") : void 0, useMemo(() => function(W) {
    let K = o$6((L) => (B((re) => [...re, L]), () => B((re) => {
      let ie = re.slice(), oe = ie.indexOf(L);
      return oe !== -1 && ie.splice(oe, 1), ie;
    }))), J = useMemo(() => ({ register: K, slot: W.slot, name: W.name, props: W.props }), [K, W.slot, W.name, W.props]);
    return C__default.createElement(d.Provider, { value: J }, W.children);
  }, [B])];
}
let I$2 = "p";
function S$1(A, B) {
  let W = I$5(), { id: K = `headlessui-description-${W}`, ...J } = A, L = f$1(), re = y$1(B);
  l$5(() => L.register(K), [K, L.register]);
  let ie = { ref: re, ...L.props, id: K };
  return C$1({ ourProps: ie, theirProps: J, slot: L.slot || {}, defaultTag: I$2, name: L.name || "Description" });
}
let h$2 = U$3(S$1), G = Object.assign(h$2, {});
var Me$1 = ((A) => (A[A.Open = 0] = "Open", A[A.Closed = 1] = "Closed", A))(Me$1 || {}), we = ((A) => (A[A.SetTitleId = 0] = "SetTitleId", A))(we || {});
let He$1 = { 0(A, B) {
  return A.titleId === B.id ? A : { ...A, titleId: B.id };
} }, I$1 = createContext(null);
I$1.displayName = "DialogContext";
function b$1(A) {
  let B = useContext(I$1);
  if (B === null) {
    let W = new Error(`<${A} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(W, b$1), W;
  }
  return B;
}
function Be(A, B, W = () => [document.body]) {
  p(A, B, (K) => {
    var J;
    return { containers: [...(J = K.containers) != null ? J : [], W] };
  });
}
function Ge(A, B) {
  return u$7(B.type, He$1, A, B);
}
let Ne$1 = "div", Ue = O.RenderStrategy | O.Static;
function We(A, B) {
  let W = I$5(), { id: K = `headlessui-dialog-${W}`, open: J, onClose: L, initialFocus: re, role: ie = "dialog", __demoMode: oe = !1, ...ke } = A, [ne, pe] = useState(0), rt = useRef(!1);
  ie = function() {
    return ie === "dialog" || ie === "alertdialog" ? ie : (rt.current || (rt.current = !0, console.warn(`Invalid role [${ie}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let nt = u$3();
  J === void 0 && nt !== null && (J = (nt & d$3.Open) === d$3.Open);
  let ot = useRef(null), ut = y$1(ot, B), dt = n$2(ot), vt = A.hasOwnProperty("open") || nt !== null, pt = A.hasOwnProperty("onClose");
  if (!vt && !pt) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!vt) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!pt) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof J != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${J}`);
  if (typeof L != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${L}`);
  let mt = J ? 0 : 1, [gt, Pt] = useReducer(Ge, { titleId: null, descriptionId: null, panelRef: createRef() }), xt = o$6(() => L(!1)), Nt = o$6((Tt) => Pt({ type: 0, id: Tt })), Et = l$4() ? oe ? !1 : mt === 0 : !1, bt = ne > 1, Bt = useContext(I$1) !== null, [wt, st] = ee(), Oe = { get current() {
    var Tt;
    return (Tt = gt.panelRef.current) != null ? Tt : ot.current;
  } }, { resolveContainers: V, mainTreeNodeRef: ce, MainTreeNode: it } = N({ portals: wt, defaultContainers: [Oe] }), at = bt ? "parent" : "leaf", ft = nt !== null ? (nt & d$3.Closing) === d$3.Closing : !1, lt = Bt || ft ? !1 : Et, ct = useCallback(() => {
    var Tt, Rt;
    return (Rt = Array.from((Tt = dt == null ? void 0 : dt.querySelectorAll("body > *")) != null ? Tt : []).find((Wt) => Wt.id === "headlessui-portal-root" ? !1 : Wt.contains(ce.current) && Wt instanceof HTMLElement)) != null ? Rt : null;
  }, [ce]);
  b$3(ct, lt);
  let ht = bt ? !0 : Et, Ce = useCallback(() => {
    var Tt, Rt;
    return (Rt = Array.from((Tt = dt == null ? void 0 : dt.querySelectorAll("[data-headlessui-portal]")) != null ? Tt : []).find((Wt) => Wt.contains(ce.current) && Wt instanceof HTMLElement)) != null ? Rt : null;
  }, [ce]);
  b$3(Ce, ht), y$2(V, (Tt) => {
    Tt.preventDefault(), xt();
  }, !(!Et || bt));
  let qt = !(bt || mt !== 0);
  E(dt == null ? void 0 : dt.defaultView, "keydown", (Tt) => {
    qt && (Tt.defaultPrevented || Tt.key === o$2.Escape && (Tt.preventDefault(), Tt.stopPropagation(), xt()));
  }), Be(dt, !(ft || mt !== 0 || Bt), V), useEffect(() => {
    if (mt !== 0 || !ot.current) return;
    let Tt = new ResizeObserver((Rt) => {
      for (let Wt of Rt) {
        let Xt = Wt.target.getBoundingClientRect();
        Xt.x === 0 && Xt.y === 0 && Xt.width === 0 && Xt.height === 0 && xt();
      }
    });
    return Tt.observe(ot.current), () => Tt.disconnect();
  }, [mt, ot, xt]);
  let [kt, $t] = w$1(), Mt = useMemo(() => [{ dialogState: mt, close: xt, setTitleId: Nt }, gt], [mt, gt, xt, Nt]), Lt = useMemo(() => ({ open: mt === 0 }), [mt]), Kt = { ref: ut, id: K, role: ie, "aria-modal": mt === 0 ? !0 : void 0, "aria-labelledby": gt.titleId, "aria-describedby": kt };
  return C__default.createElement(b$2, { type: "Dialog", enabled: mt === 0, element: ot, onUpdate: o$6((Tt, Rt) => {
    Rt === "Dialog" && u$7(Tt, { [s$2.Add]: () => pe((Wt) => Wt + 1), [s$2.Remove]: () => pe((Wt) => Wt - 1) });
  }) }, C__default.createElement(l$2, { force: !0 }, C__default.createElement(te, null, C__default.createElement(I$1.Provider, { value: Mt }, C__default.createElement(te.Group, { target: ot }, C__default.createElement(l$2, { force: !1 }, C__default.createElement($t, { slot: Lt, name: "Dialog.Description" }, C__default.createElement(de$1, { initialFocus: re, containers: V, features: Et ? u$7(at, { parent: de$1.features.RestoreFocus, leaf: de$1.features.All & ~de$1.features.FocusLock }) : de$1.features.None }, C__default.createElement(st, null, C$1({ ourProps: Kt, theirProps: ke, slot: Lt, defaultTag: Ne$1, features: Ue, visible: mt === 0, name: "Dialog" }))))))))), C__default.createElement(it, null));
}
let $e = "div";
function Ye(A, B) {
  let W = I$5(), { id: K = `headlessui-dialog-overlay-${W}`, ...J } = A, [{ dialogState: L, close: re }] = b$1("Dialog.Overlay"), ie = y$1(B), oe = o$6((ne) => {
    if (ne.target === ne.currentTarget) {
      if (r$3(ne.currentTarget)) return ne.preventDefault();
      ne.preventDefault(), ne.stopPropagation(), re();
    }
  }), ke = useMemo(() => ({ open: L === 0 }), [L]);
  return C$1({ ourProps: { ref: ie, id: K, "aria-hidden": !0, onClick: oe }, theirProps: J, slot: ke, defaultTag: $e, name: "Dialog.Overlay" });
}
let je = "div";
function Je(A, B) {
  let W = I$5(), { id: K = `headlessui-dialog-backdrop-${W}`, ...J } = A, [{ dialogState: L }, re] = b$1("Dialog.Backdrop"), ie = y$1(B);
  useEffect(() => {
    if (re.panelRef.current === null) throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.");
  }, [re.panelRef]);
  let oe = useMemo(() => ({ open: L === 0 }), [L]);
  return C__default.createElement(l$2, { force: !0 }, C__default.createElement(te, null, C$1({ ourProps: { ref: ie, id: K, "aria-hidden": !0 }, theirProps: J, slot: oe, defaultTag: je, name: "Dialog.Backdrop" })));
}
let Xe = "div";
function Ke(A, B) {
  let W = I$5(), { id: K = `headlessui-dialog-panel-${W}`, ...J } = A, [{ dialogState: L }, re] = b$1("Dialog.Panel"), ie = y$1(B, re.panelRef), oe = useMemo(() => ({ open: L === 0 }), [L]), ke = o$6((ne) => {
    ne.stopPropagation();
  });
  return C$1({ ourProps: { ref: ie, id: K, onClick: ke }, theirProps: J, slot: oe, defaultTag: Xe, name: "Dialog.Panel" });
}
let Ve = "h2";
function qe$2(A, B) {
  let W = I$5(), { id: K = `headlessui-dialog-title-${W}`, ...J } = A, [{ dialogState: L, setTitleId: re }] = b$1("Dialog.Title"), ie = y$1(B);
  useEffect(() => (re(K), () => re(null)), [K, re]);
  let oe = useMemo(() => ({ open: L === 0 }), [L]);
  return C$1({ ourProps: { ref: ie, id: K }, theirProps: J, slot: oe, defaultTag: Ve, name: "Dialog.Title" });
}
let ze = U$3(We), Qe = U$3(Je), Ze = U$3(Ke), et = U$3(Ye), tt = U$3(qe$2), _t = Object.assign(ze, { Backdrop: Qe, Panel: Ze, Overlay: et, Title: tt, Description: G }), a = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$1(A) {
  var B, W;
  let K = (B = A.innerText) != null ? B : "", J = A.cloneNode(!0);
  if (!(J instanceof HTMLElement)) return K;
  let L = !1;
  for (let ie of J.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) ie.remove(), L = !0;
  let re = L ? (W = J.innerText) != null ? W : "" : K;
  return a.test(re) && (re = re.replace(a, "")), re;
}
function g$1(A) {
  let B = A.getAttribute("aria-label");
  if (typeof B == "string") return B.trim();
  let W = A.getAttribute("aria-labelledby");
  if (W) {
    let K = W.split(" ").map((J) => {
      let L = document.getElementById(J);
      if (L) {
        let re = L.getAttribute("aria-label");
        return typeof re == "string" ? re.trim() : o$1(L).trim();
      }
      return null;
    }).filter(Boolean);
    if (K.length > 0) return K.join(", ");
  }
  return o$1(A).trim();
}
function s$1(A) {
  let B = useRef(""), W = useRef("");
  return o$6(() => {
    let K = A.current;
    if (!K) return "";
    let J = K.innerText;
    if (B.current === J) return W.current;
    let L = g$1(K).trim().toLowerCase();
    return B.current = J, W.current = L, L;
  });
}
var me = ((A) => (A[A.Open = 0] = "Open", A[A.Closed = 1] = "Closed", A))(me || {}), de = ((A) => (A[A.Pointer = 0] = "Pointer", A[A.Other = 1] = "Other", A))(de || {}), fe = ((A) => (A[A.OpenMenu = 0] = "OpenMenu", A[A.CloseMenu = 1] = "CloseMenu", A[A.GoToItem = 2] = "GoToItem", A[A.Search = 3] = "Search", A[A.ClearSearch = 4] = "ClearSearch", A[A.RegisterItem = 5] = "RegisterItem", A[A.UnregisterItem = 6] = "UnregisterItem", A))(fe || {});
function w(A, B = (W) => W) {
  let W = A.activeItemIndex !== null ? A.items[A.activeItemIndex] : null, K = I$4(B(A.items.slice()), (L) => L.dataRef.current.domRef.current), J = W ? K.indexOf(W) : null;
  return J === -1 && (J = null), { items: K, activeItemIndex: J };
}
let Te = { 1(A) {
  return A.menuState === 1 ? A : { ...A, activeItemIndex: null, menuState: 1 };
}, 0(A) {
  return A.menuState === 0 ? A : { ...A, __demoMode: !1, menuState: 0 };
}, 2: (A, B) => {
  var W;
  let K = w(A), J = f$5(B, { resolveItems: () => K.items, resolveActiveIndex: () => K.activeItemIndex, resolveId: (L) => L.id, resolveDisabled: (L) => L.dataRef.current.disabled });
  return { ...A, ...K, searchQuery: "", activeItemIndex: J, activationTrigger: (W = B.trigger) != null ? W : 1 };
}, 3: (A, B) => {
  let W = A.searchQuery !== "" ? 0 : 1, K = A.searchQuery + B.value.toLowerCase(), J = (A.activeItemIndex !== null ? A.items.slice(A.activeItemIndex + W).concat(A.items.slice(0, A.activeItemIndex + W)) : A.items).find((re) => {
    var ie;
    return ((ie = re.dataRef.current.textValue) == null ? void 0 : ie.startsWith(K)) && !re.dataRef.current.disabled;
  }), L = J ? A.items.indexOf(J) : -1;
  return L === -1 || L === A.activeItemIndex ? { ...A, searchQuery: K } : { ...A, searchQuery: K, activeItemIndex: L, activationTrigger: 1 };
}, 4(A) {
  return A.searchQuery === "" ? A : { ...A, searchQuery: "", searchActiveItemIndex: null };
}, 5: (A, B) => {
  let W = w(A, (K) => [...K, { id: B.id, dataRef: B.dataRef }]);
  return { ...A, ...W };
}, 6: (A, B) => {
  let W = w(A, (K) => {
    let J = K.findIndex((L) => L.id === B.id);
    return J !== -1 && K.splice(J, 1), K;
  });
  return { ...A, ...W, activationTrigger: 1 };
} }, U$1 = createContext(null);
U$1.displayName = "MenuContext";
function C(A) {
  let B = useContext(U$1);
  if (B === null) {
    let W = new Error(`<${A} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(W, C), W;
  }
  return B;
}
function ye$1(A, B) {
  return u$7(B.type, Te, A, B);
}
let Ie = Fragment;
function Me(A, B) {
  let { __demoMode: W = !1, ...K } = A, J = useReducer(ye$1, { __demoMode: W, menuState: W ? 0 : 1, buttonRef: createRef(), itemsRef: createRef(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: L, itemsRef: re, buttonRef: ie }, oe] = J, ke = y$1(B);
  y$2([ie, re], (nt, ot) => {
    var ut;
    oe({ type: 1 }), h$4(ot, T$2.Loose) || (nt.preventDefault(), (ut = ie.current) == null || ut.focus());
  }, L === 0);
  let ne = o$6(() => {
    oe({ type: 1 });
  }), pe = useMemo(() => ({ open: L === 0, close: ne }), [L, ne]), rt = { ref: ke };
  return C__default.createElement(U$1.Provider, { value: J }, C__default.createElement(s$5, { value: u$7(L, { 0: d$3.Open, 1: d$3.Closed }) }, C$1({ ourProps: rt, theirProps: K, slot: pe, defaultTag: Ie, name: "Menu" })));
}
let ge = "button";
function Re$1(A, B) {
  var W;
  let K = I$5(), { id: J = `headlessui-menu-button-${K}`, ...L } = A, [re, ie] = C("Menu.Button"), oe = y$1(re.buttonRef, B), ke = p$3(), ne = o$6((ut) => {
    switch (ut.key) {
      case o$2.Space:
      case o$2.Enter:
      case o$2.ArrowDown:
        ut.preventDefault(), ut.stopPropagation(), ie({ type: 0 }), ke.nextFrame(() => ie({ type: 2, focus: c$4.First }));
        break;
      case o$2.ArrowUp:
        ut.preventDefault(), ut.stopPropagation(), ie({ type: 0 }), ke.nextFrame(() => ie({ type: 2, focus: c$4.Last }));
        break;
    }
  }), pe = o$6((ut) => {
    switch (ut.key) {
      case o$2.Space:
        ut.preventDefault();
        break;
    }
  }), rt = o$6((ut) => {
    if (r$3(ut.currentTarget)) return ut.preventDefault();
    A.disabled || (re.menuState === 0 ? (ie({ type: 1 }), ke.nextFrame(() => {
      var dt;
      return (dt = re.buttonRef.current) == null ? void 0 : dt.focus({ preventScroll: !0 });
    })) : (ut.preventDefault(), ie({ type: 0 })));
  }), nt = useMemo(() => ({ open: re.menuState === 0 }), [re]), ot = { ref: oe, id: J, type: T$1(A, re.buttonRef), "aria-haspopup": "menu", "aria-controls": (W = re.itemsRef.current) == null ? void 0 : W.id, "aria-expanded": re.menuState === 0, onKeyDown: ne, onKeyUp: pe, onClick: rt };
  return C$1({ ourProps: ot, theirProps: L, slot: nt, defaultTag: ge, name: "Menu.Button" });
}
let Ae = "div", be = O.RenderStrategy | O.Static;
function Ee(A, B) {
  var W, K;
  let J = I$5(), { id: L = `headlessui-menu-items-${J}`, ...re } = A, [ie, oe] = C("Menu.Items"), ke = y$1(ie.itemsRef, B), ne = n$2(ie.itemsRef), pe = p$3(), rt = u$3(), nt = rt !== null ? (rt & d$3.Open) === d$3.Open : ie.menuState === 0;
  useEffect(() => {
    let pt = ie.itemsRef.current;
    pt && ie.menuState === 0 && pt !== (ne == null ? void 0 : ne.activeElement) && pt.focus({ preventScroll: !0 });
  }, [ie.menuState, ie.itemsRef, ne]), F$2({ container: ie.itemsRef.current, enabled: ie.menuState === 0, accept(pt) {
    return pt.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : pt.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(pt) {
    pt.setAttribute("role", "none");
  } });
  let ot = o$6((pt) => {
    var mt, gt;
    switch (pe.dispose(), pt.key) {
      case o$2.Space:
        if (ie.searchQuery !== "") return pt.preventDefault(), pt.stopPropagation(), oe({ type: 3, value: pt.key });
      case o$2.Enter:
        if (pt.preventDefault(), pt.stopPropagation(), oe({ type: 1 }), ie.activeItemIndex !== null) {
          let { dataRef: Pt } = ie.items[ie.activeItemIndex];
          (gt = (mt = Pt.current) == null ? void 0 : mt.domRef.current) == null || gt.click();
        }
        D$3(ie.buttonRef.current);
        break;
      case o$2.ArrowDown:
        return pt.preventDefault(), pt.stopPropagation(), oe({ type: 2, focus: c$4.Next });
      case o$2.ArrowUp:
        return pt.preventDefault(), pt.stopPropagation(), oe({ type: 2, focus: c$4.Previous });
      case o$2.Home:
      case o$2.PageUp:
        return pt.preventDefault(), pt.stopPropagation(), oe({ type: 2, focus: c$4.First });
      case o$2.End:
      case o$2.PageDown:
        return pt.preventDefault(), pt.stopPropagation(), oe({ type: 2, focus: c$4.Last });
      case o$2.Escape:
        pt.preventDefault(), pt.stopPropagation(), oe({ type: 1 }), o$5().nextFrame(() => {
          var Pt;
          return (Pt = ie.buttonRef.current) == null ? void 0 : Pt.focus({ preventScroll: !0 });
        });
        break;
      case o$2.Tab:
        pt.preventDefault(), pt.stopPropagation(), oe({ type: 1 }), o$5().nextFrame(() => {
          _$2(ie.buttonRef.current, pt.shiftKey ? M$2.Previous : M$2.Next);
        });
        break;
      default:
        pt.key.length === 1 && (oe({ type: 3, value: pt.key }), pe.setTimeout(() => oe({ type: 4 }), 350));
        break;
    }
  }), ut = o$6((pt) => {
    switch (pt.key) {
      case o$2.Space:
        pt.preventDefault();
        break;
    }
  }), dt = useMemo(() => ({ open: ie.menuState === 0 }), [ie]), vt = { "aria-activedescendant": ie.activeItemIndex === null || (W = ie.items[ie.activeItemIndex]) == null ? void 0 : W.id, "aria-labelledby": (K = ie.buttonRef.current) == null ? void 0 : K.id, id: L, onKeyDown: ot, onKeyUp: ut, role: "menu", tabIndex: 0, ref: ke };
  return C$1({ ourProps: vt, theirProps: re, slot: dt, defaultTag: Ae, features: be, visible: nt, name: "Menu.Items" });
}
let Se$1 = Fragment;
function xe$1(A, B) {
  let W = I$5(), { id: K = `headlessui-menu-item-${W}`, disabled: J = !1, ...L } = A, [re, ie] = C("Menu.Item"), oe = re.activeItemIndex !== null ? re.items[re.activeItemIndex].id === K : !1, ke = useRef(null), ne = y$1(B, ke);
  l$5(() => {
    if (re.__demoMode || re.menuState !== 0 || !oe || re.activationTrigger === 0) return;
    let Pt = o$5();
    return Pt.requestAnimationFrame(() => {
      var xt, Nt;
      (Nt = (xt = ke.current) == null ? void 0 : xt.scrollIntoView) == null || Nt.call(xt, { block: "nearest" });
    }), Pt.dispose;
  }, [re.__demoMode, ke, oe, re.menuState, re.activationTrigger, re.activeItemIndex]);
  let pe = s$1(ke), rt = useRef({ disabled: J, domRef: ke, get textValue() {
    return pe();
  } });
  l$5(() => {
    rt.current.disabled = J;
  }, [rt, J]), l$5(() => (ie({ type: 5, id: K, dataRef: rt }), () => ie({ type: 6, id: K })), [rt, K]);
  let nt = o$6(() => {
    ie({ type: 1 });
  }), ot = o$6((Pt) => {
    if (J) return Pt.preventDefault();
    ie({ type: 1 }), D$3(re.buttonRef.current);
  }), ut = o$6(() => {
    if (J) return ie({ type: 2, focus: c$4.Nothing });
    ie({ type: 2, focus: c$4.Specific, id: K });
  }), dt = u$5(), vt = o$6((Pt) => dt.update(Pt)), pt = o$6((Pt) => {
    dt.wasMoved(Pt) && (J || oe || ie({ type: 2, focus: c$4.Specific, id: K, trigger: 0 }));
  }), mt = o$6((Pt) => {
    dt.wasMoved(Pt) && (J || oe && ie({ type: 2, focus: c$4.Nothing }));
  }), gt = useMemo(() => ({ active: oe, disabled: J, close: nt }), [oe, J, nt]);
  return C$1({ ourProps: { id: K, ref: ne, role: "menuitem", tabIndex: J === !0 ? void 0 : -1, "aria-disabled": J === !0 ? !0 : void 0, disabled: void 0, onClick: ot, onFocus: ut, onPointerEnter: vt, onMouseEnter: vt, onPointerMove: pt, onMouseMove: pt, onPointerLeave: mt, onMouseLeave: mt }, theirProps: L, slot: gt, defaultTag: Se$1, name: "Menu.Item" });
}
let Pe$1 = U$3(Me), ve = U$3(Re$1), he = U$3(Ee), De$1 = U$3(xe$1), qe$1 = Object.assign(Pe$1, { Button: ve, Items: he, Item: De$1 });
function c(A = 0) {
  let [B, W] = useState(A), K = f$4(), J = useCallback((oe) => {
    K.current && W((ke) => ke | oe);
  }, [B, K]), L = useCallback((oe) => !!(B & oe), [B]), re = useCallback((oe) => {
    K.current && W((ke) => ke & ~oe);
  }, [W, K]), ie = useCallback((oe) => {
    K.current && W((ke) => ke ^ oe);
  }, [W]);
  return { flags: B, addFlag: J, hasFlag: L, removeFlag: re, toggleFlag: ie };
}
function l(A) {
  let B = { called: !1 };
  return (...W) => {
    if (!B.called) return B.called = !0, A(...W);
  };
}
function g(A, ...B) {
  A && B.length > 0 && A.classList.add(...B);
}
function v(A, ...B) {
  A && B.length > 0 && A.classList.remove(...B);
}
function b(A, B) {
  let W = o$5();
  if (!A) return W.dispose;
  let { transitionDuration: K, transitionDelay: J } = getComputedStyle(A), [L, re] = [K, J].map((oe) => {
    let [ke = 0] = oe.split(",").filter(Boolean).map((ne) => ne.includes("ms") ? parseFloat(ne) : parseFloat(ne) * 1e3).sort((ne, pe) => pe - ne);
    return ke;
  }), ie = L + re;
  if (ie !== 0) {
    W.group((ke) => {
      ke.setTimeout(() => {
        B(), ke.dispose();
      }, ie), ke.addEventListener(A, "transitionrun", (ne) => {
        ne.target === ne.currentTarget && ke.dispose();
      });
    });
    let oe = W.addEventListener(A, "transitionend", (ke) => {
      ke.target === ke.currentTarget && (B(), oe());
    });
  } else B();
  return W.add(() => B()), W.dispose;
}
function M$1(A, B, W, K) {
  let J = W ? "enter" : "leave", L = o$5(), re = K !== void 0 ? l(K) : () => {
  };
  J === "enter" && (A.removeAttribute("hidden"), A.style.display = "");
  let ie = u$7(J, { enter: () => B.enter, leave: () => B.leave }), oe = u$7(J, { enter: () => B.enterTo, leave: () => B.leaveTo }), ke = u$7(J, { enter: () => B.enterFrom, leave: () => B.leaveFrom });
  return v(A, ...B.base, ...B.enter, ...B.enterTo, ...B.enterFrom, ...B.leave, ...B.leaveFrom, ...B.leaveTo, ...B.entered), g(A, ...B.base, ...ie, ...ke), L.nextFrame(() => {
    v(A, ...B.base, ...ie, ...ke), g(A, ...B.base, ...ie, ...oe), b(A, () => (v(A, ...B.base, ...ie), g(A, ...B.base, ...B.entered), re()));
  }), L.dispose;
}
function D({ immediate: A, container: B, direction: W, classes: K, onStart: J, onStop: L }) {
  let re = f$4(), ie = p$3(), oe = s$9(W);
  l$5(() => {
    A && (oe.current = "enter");
  }, [A]), l$5(() => {
    let ke = o$5();
    ie.add(ke.dispose);
    let ne = B.current;
    if (ne && oe.current !== "idle" && re.current) return ke.dispose(), J.current(oe.current), ke.add(M$1(ne, K.current, oe.current === "enter", () => {
      ke.dispose(), L.current(oe.current);
    })), ke.dispose;
  }, [W]);
}
function S(A = "") {
  return A.split(/\s+/).filter((B) => B.length > 1);
}
let I = createContext(null);
I.displayName = "TransitionContext";
var Se = ((A) => (A.Visible = "visible", A.Hidden = "hidden", A))(Se || {});
function ye() {
  let A = useContext(I);
  if (A === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return A;
}
function xe() {
  let A = useContext(M);
  if (A === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return A;
}
let M = createContext(null);
M.displayName = "NestingContext";
function U(A) {
  return "children" in A ? U(A.children) : A.current.filter(({ el: B }) => B.current !== null).filter(({ state: B }) => B === "visible").length > 0;
}
function se(A, B) {
  let W = s$9(A), K = useRef([]), J = f$4(), L = p$3(), re = o$6((nt, ot = v$1.Hidden) => {
    let ut = K.current.findIndex(({ el: dt }) => dt === nt);
    ut !== -1 && (u$7(ot, { [v$1.Unmount]() {
      K.current.splice(ut, 1);
    }, [v$1.Hidden]() {
      K.current[ut].state = "hidden";
    } }), L.microTask(() => {
      var dt;
      !U(K) && J.current && ((dt = W.current) == null || dt.call(W));
    }));
  }), ie = o$6((nt) => {
    let ot = K.current.find(({ el: ut }) => ut === nt);
    return ot ? ot.state !== "visible" && (ot.state = "visible") : K.current.push({ el: nt, state: "visible" }), () => re(nt, v$1.Unmount);
  }), oe = useRef([]), ke = useRef(Promise.resolve()), ne = useRef({ enter: [], leave: [], idle: [] }), pe = o$6((nt, ot, ut) => {
    oe.current.splice(0), B && (B.chains.current[ot] = B.chains.current[ot].filter(([dt]) => dt !== nt)), B == null || B.chains.current[ot].push([nt, new Promise((dt) => {
      oe.current.push(dt);
    })]), B == null || B.chains.current[ot].push([nt, new Promise((dt) => {
      Promise.all(ne.current[ot].map(([vt, pt]) => pt)).then(() => dt());
    })]), ot === "enter" ? ke.current = ke.current.then(() => B == null ? void 0 : B.wait.current).then(() => ut(ot)) : ut(ot);
  }), rt = o$6((nt, ot, ut) => {
    Promise.all(ne.current[ot].splice(0).map(([dt, vt]) => vt)).then(() => {
      var dt;
      (dt = oe.current.shift()) == null || dt();
    }).then(() => ut(ot));
  });
  return useMemo(() => ({ children: K, register: ie, unregister: re, onStart: pe, onStop: rt, wait: ke, chains: ne }), [ie, re, K, pe, rt, ne, ke]);
}
function Ne() {
}
let Pe = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function ae(A) {
  var B;
  let W = {};
  for (let K of Pe) W[K] = (B = A[K]) != null ? B : Ne;
  return W;
}
function Re(A) {
  let B = useRef(ae(A));
  return useEffect(() => {
    B.current = ae(A);
  }, [A]), B;
}
let De = "div", le = O.RenderStrategy;
function He(A, B) {
  var W, K;
  let { beforeEnter: J, afterEnter: L, beforeLeave: re, afterLeave: ie, enter: oe, enterFrom: ke, enterTo: ne, entered: pe, leave: rt, leaveFrom: nt, leaveTo: ot, ...ut } = A, dt = useRef(null), vt = y$1(dt, B), pt = (W = ut.unmount) == null || W ? v$1.Unmount : v$1.Hidden, { show: mt, appear: gt, initial: Pt } = ye(), [xt, Nt] = useState(mt ? "visible" : "hidden"), Et = xe(), { register: bt, unregister: Bt } = Et;
  useEffect(() => bt(dt), [bt, dt]), useEffect(() => {
    if (pt === v$1.Hidden && dt.current) {
      if (mt && xt !== "visible") {
        Nt("visible");
        return;
      }
      return u$7(xt, { hidden: () => Bt(dt), visible: () => bt(dt) });
    }
  }, [xt, dt, bt, Bt, mt, pt]);
  let wt = s$9({ base: S(ut.className), enter: S(oe), enterFrom: S(ke), enterTo: S(ne), entered: S(pe), leave: S(rt), leaveFrom: S(nt), leaveTo: S(ot) }), st = Re({ beforeEnter: J, afterEnter: L, beforeLeave: re, afterLeave: ie }), Oe = l$4();
  useEffect(() => {
    if (Oe && xt === "visible" && dt.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [dt, xt, Oe]);
  let V = Pt && !gt, ce = gt && mt && Pt, it = !Oe || V ? "idle" : mt ? "enter" : "leave", at = c(0), ft = o$6((qt) => u$7(qt, { enter: () => {
    at.addFlag(d$3.Opening), st.current.beforeEnter();
  }, leave: () => {
    at.addFlag(d$3.Closing), st.current.beforeLeave();
  }, idle: () => {
  } })), lt = o$6((qt) => u$7(qt, { enter: () => {
    at.removeFlag(d$3.Opening), st.current.afterEnter();
  }, leave: () => {
    at.removeFlag(d$3.Closing), st.current.afterLeave();
  }, idle: () => {
  } })), ct = se(() => {
    Nt("hidden"), Bt(dt);
  }, Et), ht = useRef(!1);
  D({ immediate: ce, container: dt, classes: wt, direction: it, onStart: s$9((qt) => {
    ht.current = !0, ct.onStart(dt, qt, ft);
  }), onStop: s$9((qt) => {
    ht.current = !1, ct.onStop(dt, qt, lt), qt === "leave" && !U(ct) && (Nt("hidden"), Bt(dt));
  }) });
  let Ce = ut, yt = { ref: vt };
  return ce ? Ce = { ...Ce, className: t$4(ut.className, ...wt.current.enter, ...wt.current.enterFrom) } : ht.current && (Ce.className = t$4(ut.className, (K = dt.current) == null ? void 0 : K.className), Ce.className === "" && delete Ce.className), C__default.createElement(M.Provider, { value: ct }, C__default.createElement(s$5, { value: u$7(xt, { visible: d$3.Open, hidden: d$3.Closed }) | at.flags }, C$1({ ourProps: yt, theirProps: Ce, defaultTag: De, features: le, visible: xt === "visible", name: "Transition.Child" })));
}
function Fe(A, B) {
  let { show: W, appear: K = !1, unmount: J = !0, ...L } = A, re = useRef(null), ie = y$1(re, B);
  l$4();
  let oe = u$3();
  if (W === void 0 && oe !== null && (W = (oe & d$3.Open) === d$3.Open), ![!0, !1].includes(W)) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [ke, ne] = useState(W ? "visible" : "hidden"), pe = se(() => {
    ne("hidden");
  }), [rt, nt] = useState(!0), ot = useRef([W]);
  l$5(() => {
    rt !== !1 && ot.current[ot.current.length - 1] !== W && (ot.current.push(W), nt(!1));
  }, [ot, W]);
  let ut = useMemo(() => ({ show: W, appear: K, initial: rt }), [W, K, rt]);
  useEffect(() => {
    if (W) ne("visible");
    else if (!U(pe)) ne("hidden");
    else {
      let mt = re.current;
      if (!mt) return;
      let gt = mt.getBoundingClientRect();
      gt.x === 0 && gt.y === 0 && gt.width === 0 && gt.height === 0 && ne("hidden");
    }
  }, [W, pe]);
  let dt = { unmount: J }, vt = o$6(() => {
    var mt;
    rt && nt(!1), (mt = A.beforeEnter) == null || mt.call(A);
  }), pt = o$6(() => {
    var mt;
    rt && nt(!1), (mt = A.beforeLeave) == null || mt.call(A);
  });
  return C__default.createElement(M.Provider, { value: pe }, C__default.createElement(I.Provider, { value: ut }, C$1({ ourProps: { ...dt, as: Fragment, children: C__default.createElement(ue, { ref: ie, ...dt, ...L, beforeEnter: vt, beforeLeave: pt }) }, theirProps: {}, defaultTag: Fragment, features: le, visible: ke === "visible", name: "Transition" })));
}
function _e(A, B) {
  let W = useContext(I) !== null, K = u$3() !== null;
  return C__default.createElement(C__default.Fragment, null, !W && K ? C__default.createElement(q, { ref: B, ...A }) : C__default.createElement(ue, { ref: B, ...A }));
}
let q = U$3(Fe), ue = U$3(He), Le = U$3(_e), qe = Object.assign(q, { Child: Le, Root: q });
const ChevronDownIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5%207.5L10%2012.5L15%207.5'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LeatherWalletIcon = "data:image/svg+xml,%3csvg%20width='41'%20height='40'%20viewBox='0%200%2041%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20x='0.5'%20width='40'%20height='40'%20rx='20'%20fill='url(%23pattern0)'/%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_21497_326778'%20transform='translate(-0.00625)%20scale(0.0125)'/%3e%3c/pattern%3e%3cimage%20id='image0_21497_326778'%20width='81'%20height='80'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFEAAABQCAYAAABh05mTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAi3SURBVHgB7Z1dbBRVFMfPLJVuE1lGFNOENi5v2sbY8kIbEymJtJiYSIVq9AEKrQm+0A+Q+KBpqz5ppIU3Ywvti4kWktaYQFsTi4nZ8sTyQH3TIa0JD0Km2wQWkB3Pf3Zms/Oxu7Mfszvb7i9Zdjt7Zzfz33PuOffcOxeBSowoisEtRG0KUZAo9pJAQjD+mkTtkYzED1lQH0I4RnTHRxR+lh+SLMtUIgQqMkFWbZ3okEKxffz1h8gqVK6EfSQs8vPsv7K8SEWkKCJqwrURKX2K+uw6kkDKokC+qWII6qqIEC9CsT7+mn4qnMVlCwsqjNyT5UlyCVdE9Ih4ZlwTs+Ai7hADEG+YvCOeGYg5wGLOUIEomIg7RbHpKSmX+GUTlQHcZ04+Q76Ru7IsUZ4URETN+sao/JA4oh/PN/hsoTxA37fFX32VBTxJ5YnI2UJ3jb+aHkYfXaccydkSazlJfkzKbxRPjMseFmJmG1tlLkl7TiJq/R8E9GrwyJXwVhI6s+0nsxZxAwuoI7GQ+7MRMisRN4GAOlKAhGanru0jh6AP3CQCgmCErxWB00ljR9E5KYjU0uahlq+5lqP2bKaGjkTc6q+GgC/TpkNoqvHXrD2MRpfStcrozpxID1GZjELcQRl9QRTb0rVIG1i0QHKTKqQNNGnd2e+vDtHmCCSZEJ+Q4n8QfTRn92ZKd9bcOEgVVGJc1kvl1rburEXjv6mCARZr8Z68tt983NYSnxANUQULmNqws0aLJVasMD121mixxIoVpsfOGg2WWI5W2NrSQu3tb9LBjnaqq6tTj4WWlmj68hWanr5CbmC2RoOIz4titxIv8XueQCBA5779mjra21O2mb58mQZPnyU34Gi9W9YqPYY8kSu8ENDz42NY3M8zV2hPc3Pado0NDRSJROjmzTAVGp7swnBwMf5ao5SuPDT0OR1sP2A41vHW26oAZiDg9I8/JFw3E/iMxlddGbVK9+W13XiRCCyPiQ5RCYBb9p44roqiP0JLN2wFBHBhOwHRD45PXKLV1VXL59fXOxM8S1ApU3+dKv0ITyG+o1DxaW3Zazk2N79g27an54QaSJKB2L0fnVRFBMvLyyz0N1QMfPElMWHVEllRsUhrZCw0cL9lZnVl1XIM1td7otty/L33P0wICAKB7ZY2a2v2Vp0vMDw8qyJWlbDUZeeakXXrRQ/2n7K0HRn5km6z5SV/Vm9Pt6EN3DtV15AviqabKmLMY/XCul1WYVtbjW4MccYvGrOx4aHPLEKPT0ySi8CJg6qIHKL3UYlYXv7Tcqyr613j30cOW8Q5N3Yh8RrvXbv6iyVnhNDIFd2Ec8QmLTorJasZLie5o07XkSPUwxE78XfXYcP7qjjTcXEQbOZYwEabvhUBxy1X1sGqXjXZrvH7h6lExVcI0tq6l+pNltbWto9Tk13xFIiFSmaFz9n54k6a+P47tr4DVF1dbflcjFQWr+e8MiQLlLtqsr1D3F6K7CYB0pafOIEuBOaUx20UEma3oGdkJT+lEgJrXI+ss/W9QfkA4Y4ePW6I2G7jI+GuEI8u3qjcIDDYRdhMQLzR0QtFsz4TkqdE1EFgGRw4lVZMWO+1uQWa59FNicTT8aaIOoP9fTQw0Gc8duYTmmPx3I66WSBVkYdpaHzF8DeEc6vQmgey4wVNpcBcbAiFbpDX4LqiXIXqLKc4VEyQE7Zw9Ubv89C/ra7+Y+jbICByxGTmFhbIi+juLFERJuohzAAHDLOF6UDMc2Pn1T6v3VSkBUuhkgaQVNzSk22st3G1CIEAgUDhBL2wmhydkfsd5Gq39xBGtD5RuEUuggKCUwGBXuFOJuTACmHhK3f+MjxSWX2hYCsM6+6MmZxj5BKDA1YBEWkxDQDq6nbZFhCSmZ//lbzIUz3FwT3DMXIHWILZqlCBGf7iK0OuhzawVnPFRsdJXmhXJXc5n+S4LMenB/6LW6IrtNjMoUxcnLRcHPpBNZFOMb+CAkWHTbBJxlzVBm6Oo3HjOp5VESEnZvXJBSJcWDBjJyzSGUydphIK749z6QuzffU2w0EELks/6vJwkEtf6nruxLzzDlEc5sMFX4eTqsyFC0TyHAhso8bGhqwDAM6/fTtuZanOHzxzNlG8dYMYCc1w54SIbo6hQ3/8nnVlRj2Phco1uqrF3tfzK61lwDp5j5GLWy6dy3qY0dHz6nQohDBPyGcC7XGum3B/mLg1w7QWpwbKtlGBwUVhQmrPnibLUM4MrO80i45VXQABaOLiJXVY2MgFiUznI5CgMLuSpfDZwq78QTQaVRfCG1aFocqtubQr8y1waSyBw1I45IUQBCLhgtE/OqkNotaI2UD9fIAfCTknKjzFqC2yFS7ek2X7pXWAA8wYdg2hCilhETuTtz+wiOjlIq1HSAQUHUs9Mb5wUZiiCrZgRxPrMRs0a0Rlp3IjkBGLFQLbO6oQdThS11CJVop5FSTXekROxpf6BMLuIhJVUGE3Pi+nuBs/pYgYT2O7E6oAJC55Dad6M+0Nkg+iUYnd+jl+6W5l0+OwG++X0+wJkXG2774s97s1HCwPhBEUGdK1cDRl+jTu1hJtMtAPshENZ27nkE2Y9oQ1N864I4njyXv0CfhQvKSND66104mAIOvNhXDvhm+Dby6UKZCYyXoZCTpZzSIl2niEsxUQ5LQWZyMKyUFkKhcBQc5b/2H4U+2vmfXFV04EqawRRpDK8TVFKQfy2j8RQj6MPprihBx9axuVH9iEsjPffWZz2vrPDi0FKpv9FJEDYijnNAKn/6wCw5Xxfq0yHiRvgk3NBwq5/3Ze7mwH9tVCX8m/NMbcXrrdTd3VmOuBH6MmQAWk4JaYjHbfGywTd2MGqQQI8a30p8pus3I7sL8Ei3msSLcEy5ji4B9wpuy3zbdD/18vYmydQkHTI3Vx0fViCWf4ZioxmqhNivpQXvOp2zYLQe2mTdPQUpDwL7cLC6SwtfluYVkgVrUVIsrmyv91DJTKn0hYjQAAAABJRU5ErkJggg=='/%3e%3c/defs%3e%3c/svg%3e", LogoutIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.5%2017.5H4.16667C3.72464%2017.5%203.30072%2017.3244%202.98816%2017.0118C2.67559%2016.6993%202.5%2016.2754%202.5%2015.8333V4.16667C2.5%203.72464%202.67559%203.30072%202.98816%202.98816C3.30072%202.67559%203.72464%202.5%204.16667%202.5H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.333%2014.1667L17.4997%2010L13.333%205.83337'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M17.5%2010H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", MagicEdenWalletIcon = "data:image/svg+xml,%3csvg%20width='25'%20height='24'%20viewBox='0%200%2025%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20x='0.423462'%20width='24'%20height='24'%20rx='12'%20fill='%231C1326'/%3e%3cpath%20d='M15.6787%209.69931L16.5929%2010.7735C16.6976%2010.8942%2016.7904%2010.9934%2016.8279%2011.0499C17.1013%2011.3216%2017.2546%2011.6889%2017.2544%2012.0716C17.2288%2012.523%2016.9345%2012.8305%2016.662%2013.1594L16.0222%2013.9106L15.6885%2014.2998C15.6765%2014.3132%2015.6688%2014.3298%2015.6663%2014.3475C15.6638%2014.3652%2015.6666%2014.3832%2015.6743%2014.3993C15.6821%2014.4155%2015.6945%2014.429%2015.71%2014.4383C15.7255%2014.4476%2015.7434%2014.4522%2015.7616%2014.4515H19.0968C19.6062%2014.4515%2020.248%2014.8797%2020.2105%2015.5297C20.2095%2015.8251%2020.0899%2016.1081%2019.8779%2016.317C19.6659%2016.5259%2019.3788%2016.6437%2019.079%2016.6447H13.856C13.5124%2016.6447%2012.5883%2016.6817%2012.3296%2015.8936C12.2746%2015.7289%2012.2671%2015.5524%2012.3079%2015.3837C12.3831%2015.1343%2012.502%2014.8998%2012.6594%2014.6909C12.922%2014.3017%2013.2064%2013.9125%2013.4868%2013.535C13.8481%2013.0407%2014.2194%2012.5619%2014.5847%2012.0579C14.5977%2012.0415%2014.6047%2012.0213%2014.6047%2012.0005C14.6047%2011.9797%2014.5977%2011.9595%2014.5847%2011.9431L13.2577%2010.3863C13.2491%2010.375%2013.2379%2010.3658%2013.225%2010.3595C13.2122%2010.3532%2013.198%2010.3499%2013.1836%2010.3499C13.1693%2010.3499%2013.1551%2010.3532%2013.1423%2010.3595C13.1295%2010.3658%2013.1182%2010.375%2013.1096%2010.3863C12.7542%2010.8591%2011.1982%2012.9531%2010.8664%2013.3773C10.5346%2013.8016%209.71714%2013.8249%209.26493%2013.3773L7.18959%2011.3243C7.17633%2011.3112%207.1594%2011.3022%207.14103%2011.2986C7.12261%2011.295%207.10348%2011.2968%207.08614%2011.3039C7.06879%2011.311%207.05398%2011.323%207.04358%2011.3384C7.03317%2011.3538%207.02764%2011.3719%207.02768%2011.3904V15.3389C7.03256%2015.6192%206.94837%2015.8938%206.78689%2016.1245C6.6254%2016.3552%206.39473%2016.5303%206.12722%2016.6253C5.95626%2016.6839%205.77359%2016.7014%205.59439%2016.6763C5.41518%2016.6513%205.24465%2016.5843%205.09704%2016.4811C4.94943%2016.3779%204.82898%2016.2414%204.74575%2016.083C4.66252%2015.9246%204.61892%2015.7489%204.61859%2015.5705V8.47138C4.63049%208.21553%204.7239%207.96991%204.88554%207.76938C5.04719%207.56885%205.26884%207.42363%205.51901%207.35435C5.73365%207.298%205.95954%207.29856%206.17386%207.35599C6.38817%207.41341%206.58326%207.52563%206.73936%207.6813L9.93042%2010.83C9.93998%2010.8395%209.95151%2010.8469%209.96431%2010.8516C9.97706%2010.8562%209.9907%2010.8581%2010.0043%2010.857C10.0178%2010.8559%2010.031%2010.8518%2010.0428%2010.8451C10.0546%2010.8385%2010.0648%2010.8293%2010.0726%2010.8183L12.3395%207.72606C12.4442%207.60053%2012.5756%207.49905%2012.7243%207.42883C12.873%207.35856%2013.0355%207.32121%2013.2005%207.31933H19.0968C19.2581%207.31956%2019.4176%207.35378%2019.5644%207.41969C19.7113%207.48555%2019.8422%207.5816%2019.9484%207.70131C20.0546%207.82108%2020.1336%207.9618%2020.1802%208.11405C20.2267%208.2663%2020.2397%208.42661%2020.2184%208.58425C20.1768%208.85767%2020.0361%209.107%2019.8222%209.28592C19.6083%209.46485%2019.3358%209.56127%2019.0553%209.55728H15.7537C15.7371%209.55766%2015.7209%209.56244%2015.7068%209.57111C15.6928%209.57974%2015.6813%209.59197%2015.6736%209.60645C15.666%209.62099%2015.6624%209.63725%2015.6632%209.65356C15.6641%209.66992%2015.6695%209.68572%2015.6787%209.69931Z'%20fill='url(%23paint0_radial_6204_5907)'/%3e%3cdefs%3e%3cradialGradient%20id='paint0_radial_6204_5907'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(4.66396%207.31249)%20rotate(31.8526)%20scale(18.4306%2015.0426)'%3e%3cstop%20stop-color='%237500EB'/%3e%3cstop%20offset='0.48642'%20stop-color='%23E42575'/%3e%3cstop%20offset='0.791667'%20stop-color='%23E42575'/%3e%3cstop%20offset='1'%20stop-color='%23FF6914'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", OKXWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cg%20clip-path='url(%23clip0_6327_5988)'%3e%3crect%20width='24'%20height='24'%20rx='12'%20fill='black'/%3e%3crect%20x='5.37042'%20y='5.10571'%20width='14.1245'%20height='14.3972'%20fill='url(%23pattern0)'/%3e%3c/g%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_6327_5988'%20transform='matrix(0.00331001%200%200%200.00324732%20-0.161%20-0.168981)'/%3e%3c/pattern%3e%3cclipPath%20id='clip0_6327_5988'%3e%3crect%20width='24'%20height='24'%20fill='white'/%3e%3c/clipPath%3e%3cimage%20id='image0_6327_5988'%20width='399'%20height='399'%20xlink:href='data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gKgSUNDX1BST0ZJTEUAAQEAAAKQbGNtcwQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwQVBQTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLWxjbXMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkZXNjAAABCAAAADhjcHJ0AAABQAAAAE53dHB0AAABkAAAABRjaGFkAAABpAAAACxyWFlaAAAB0AAAABRiWFlaAAAB5AAAABRnWFlaAAAB+AAAABRyVFJDAAACDAAAACBnVFJDAAACLAAAACBiVFJDAAACTAAAACBjaHJtAAACbAAAACRtbHVjAAAAAAAAAAEAAAAMZW5VUwAAABwAAAAcAHMAUgBHAEIAIABiAHUAaQBsAHQALQBpAG4AAG1sdWMAAAAAAAAAAQAAAAxlblVTAAAAMgAAABwATgBvACAAYwBvAHAAeQByAGkAZwBoAHQALAAgAHUAcwBlACAAZgByAGUAZQBsAHkAAAAAWFlaIAAAAAAAAPbWAAEAAAAA0y1zZjMyAAAAAAABDEoAAAXj///zKgAAB5sAAP2H///7ov///aMAAAPYAADAlFhZWiAAAAAAAABvlAAAOO4AAAOQWFlaIAAAAAAAACSdAAAPgwAAtr5YWVogAAAAAAAAYqUAALeQAAAY3nBhcmEAAAAAAAMAAAACZmYAAPKnAAANWQAAE9AAAApbcGFyYQAAAAAAAwAAAAJmZgAA8qcAAA1ZAAAT0AAACltwYXJhAAAAAAADAAAAAmZmAADypwAADVkAABPQAAAKW2Nocm0AAAAAAAMAAAAAo9cAAFR7AABMzQAAmZoAACZmAAAPXP/bAEMABQMEBAQDBQQEBAUFBQYHDAgHBwcHDwsLCQwRDxISEQ8RERMWHBcTFBoVEREYIRgaHR0fHx8TFyIkIh4kHB4fHv/bAEMBBQUFBwYHDggIDh4UERQeHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHv/CABEIAY8BjwMBIgACEQEDEQH/xAAbAAEBAQEBAQEBAAAAAAAAAAAACAYHBQECBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf2K5JLV2JEV2JEV2JE+V4IzbnDAAAA2Jnf1XYkRXYkRXYkRXYkD+KxpMPMAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyHXgAAABO/O+hc9AAAG6wu5KTAAAAk2spMPGAAAAAAAAAA3OGHRHOx0RzsdEc7HRPnPB1TauhnPHQxzx0Mc8dDHPMd3TDHLf3zsdEc7HRHOx0RzsbvDfkAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAADYGPboYVuhhW6GFbr4dQ6Hwvdm5YYblhhuWGG5wzEnIm4/RhW6GFboYVuhhWyxoAAAAAAAAAB/fXsiV2AAAATpz7onOwAABuMPuikgAAAJLrSTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAf21zHPqFcJNFZJNFZJNFZJN+Gjwf34AAANljRZiS/0Vkk0Vkk0Vkk0VdJjygAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8QAJRAAAAMIAwEBAQEAAAAAAAAAAAUwAQIDBAYWNTYHFEAVUIAR/9oACAEBAAEFAv7/AIUtMRXelOjpTo6U6OlOjpTo6U6OlOh6Tm3WJOyk0870p0dKdHSnR0p0dKdHSnR0p0RZaZhO+WUhsizcGE5BhIVtLwpc+QpCBCmD9CI45EcNITsAy8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+Qvax2fRr5rG1AhQ7WMqNE7ax458spVBvLwLwOBeBwLwOBeBwLwOBeBwLwOA2rzj/KaJGHbLPJxZ5OLPJxZ5OLPJxZ5OLPJxZ5OKlIHCiC5Vxwx28DgXgcC8DgXgcC8DgXgcC8DgTFVG8aF7+P9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/fK04bzMG1DsWodi1DsWodi1DsWodi1DsNpU6YylTuEUOXWSC6yQXWSC6yQXWSC6yQXWSC6yQVSfwDKVdpY7ay1DsWodi1DsWodi1DsWodi1DsTFNHMCF5ZB1j88jXzrGVAhRDrHqjROXWOHHkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vySb7IU5DfciOIVxGhxj9Cjo0OBUKDWsdYaxHYxp5YM/PQHPrGg+saD6xoPrGg+saD6xoPrGgeNDJ5iThmZOu/WNB9Y0H1jQfWNB9Y0H1jQfWNBGMJ+ND/v8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAwEBPwEcf//EABQRAQAAAAAAAAAAAAAAAAAAAJD/2gAIAQIBAT8BHH//xAA5EAABAQUDCQcCBQUAAAAAAAACAQADBDCTETSyNUBEcnN0g5KxBRITITFQUUFhFDJxkaFCY4CBkP/aAAgBAQAGPwL/AD/tduHpp8iKq10iKatdIimrXSIpq10iKatdIimrXSIpq10iKat3ihX6Js1loQwr5UX0VAVrpEU1a6RFNWukRTVrpEU1a6RFNWukRTVrpEU1bvPHD0B+SBUzZy6L0M0FWF06FAAUsRE+kl4jkEBDFDVE+ZMOD4UIUtKxfsklQMUISSxUX6tFOHf5Hb4hT/S5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw6qtiI9HrKWxfR0NsmHtX1QsMqNJPRYg8S5sLlHoPEHyRTG1W0fkbR+RtH5G0fkbR+RtH5G0fkb1cJw2e9odovnhIp2eS+ZL8tpHO2kc7aRztpHO2kc7aRztpHO2kc7B2j2c+eD4Zpair5p90ZEUnJfdXbaPyNo/I2j8jaPyNo/I2j8jaPyMTvxQd976gNi+wcUpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxe08UpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxewI9CEsEvTvEiNdwqC13CoLXcKgtdwqC13CoLXcKgtdwqC1v4YV4gs97O7RA3dhqqLZ6L8KjXg6ZNeDpk14OmTXg6ZNeDpk14OmTXg6ZNeDpkw9n9ngb3xCS1e7/AAjW/hRT9XgtdwqC13CoLXcKgtdwqC13CoLXcKgtdwqCxPChbRHzXukirmzgS80V4KL+8olRLLXYqsmHtS2xCX+JUaApYiRBonNmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5q5eF6AaEv7shgSEJJaip9ZLzwyQu4CAtnzJhyekgito2r90kqqrYiNFvna2gb4yH9FXNu45jYh0PwD1URspRlcmylGVybKUZXJspRlcmylGVybKUZXJspRlcmsLtGLVF/vFLQQ7QixFPREfE2UoyuTZSjK5NlKMrk2UoyuTZSjK5NlKMrk2UoyuTeG+jol4K/wBJPVVP+AH/xAAoEAABAgUDBAIDAQAAAAAAAAABAPARMFFxwSFAYTFBUKGBsYCR0ZD/2gAIAQEAAT8h/P8A4J2T0nVhOrCdWE6sJ1YTqwnVhEoL6kgA9S9fFxED6TqwnVhOrCdWE6sJ1YTqwuEdA9jbRoBAyhMFC+2bQJIclZQALr9Rk6bVK0JIRH5kwD3GiAPYoPBFlygbVzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwBHCEmmiUMQEiBQ6mSNoEGLxSimxIg7YGgrRYL9/lczbrmbdczbrmbdczbrmbdczbowgDT0I6P2UWbMNLqCRprCC4m2XE2y4m2XE2y4m2XE2y4m2XE2y6tWBFjoS8NOUVDDlH9LmbdczbrmbdczbrmbdczbrmbdQuIIHQvB7I6mJ37q0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPAFnDRj0isCYp1ZTqynVlOrKdWU6sp1ZR5onYf2QiPHWTpA9R2TqwnVhOrCdWE6sJ1YTqwnVhFzcVkIwOgOpMUNaj2ivtOrKdWU6sp1ZTqynVlOrKhN5o6FgYn42wJoOKghKBzI5Hc6j6AkwooGiOhjlDhBpQAtq50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4EeP4sAFRD3GiAPcSYbaa6hB1HuTTmpESAe5IywESSYABR8BqpJG2FRr/ACYFNzKbmU3MpuZTcym5lNzKJes4Ew+5egkAAA9puZTcym5lNzKbmU3MpuZRl1HFb4J/wA//2gAMAwEAAgADAAAAEPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPNPPPPNPPPOPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPHPPPOPPPPPPPPPPPPPPPLDDDDHPPPOLDDDLPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPMMMNOMMMJMMMMPPPPPPPPPPPPPPPPNPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPGPPPPNPPPPPPPPJPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP/xAAUEQEAAAAAAAAAAAAAAAAAAACQ/9oACAEDAQE/EBx//8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAgEBPxAcf//EACYQAQABAwQBBQEBAQEAAAAAAAERACExMFDw8UFAUWFxgZGhgJD/2gAIAQEAAT8Q/wC/7iwi5HtITQrVq1atWrCYGTo91YGmFR4LPuJBNCtWrVq1ashDEGcXFwPTMgkmUNR+NBDFHgkAGjGQMElGBYlk+V0Z5/JGGs5ADHmL2oAINBHwCRqEGyJkowgOspMT9B689m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m532jVRKGE+AMr9aRbEZ5iB/Ef3REhc/ylj/ADSBSf8AhFB/npgQrBGWBKMPeT812GvYa9hr2GvYa9hr2Gpvwi7fIkP6NGdVgHBWMCAAY8AD0GvQa9Br0GvQa9Br0GvQaoA4tpWaDaBQ+Uxag7pCD7WQfwrsNew17DXsNew17DXsNVC+nwRDKqvkhPCUlElbq+vxc7blW4udtyrcXO25VuLnbcq3FztuVbi523Ktxc7blW4udtprQPDZ/YhgPiQnJbQq1atWrVqnZQW6PwSalFaSYDLLyEHLNodGrVq1atWrVYBaqOR+8hLB7EzZWRExA+wcaFWrVq1atUQqIDAlRkHwX0xHUpwCT9KACDROYeHikfmB+aPkbIkEb9njSCi7bBED6D157NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvtGqigkRZmQf4UD4BI1IhZEw6MktLQEshaSx9kTJowshWgFKuJQfbotXweCJVWwBlr5etjM/RPTY2XGH0I86AMGDBgwYMKoQ8D2Ri0qsukbFYO/sAQNAGDBgwYMH/q6K5SP8/8AP/Z'/%3e%3c/defs%3e%3c/svg%3e", UnisatWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.8742%204.5804L18.5392%208.15088C18.8511%208.45416%2019.0047%208.76103%2018.9999%209.07026C18.995%209.3795%2018.8608%209.66136%2018.5984%209.91707C18.3239%2010.1847%2018.0277%2010.3203%2017.7109%2010.3262C17.3941%2010.331%2017.0797%2010.1811%2016.7677%209.87785L13.0193%206.22648C12.5937%205.8114%2012.1825%205.51762%2011.7872%205.34516C11.3917%205.1727%2010.9758%205.14535%2010.5405%205.26428C10.104%205.38203%209.63603%205.68532%209.13422%206.17295C8.44258%206.84733%208.11246%207.48007%208.14634%208.0712C8.18018%208.6623%208.52358%209.27602%209.17534%209.90996L12.954%2013.5922C13.2696%2013.8991%2013.4244%2014.2059%2013.4195%2014.5104C13.4147%2014.8161%2013.2793%2015.098%2013.012%2015.3584C12.746%2015.6177%2012.4522%2015.7533%2012.133%2015.764C11.8137%2015.7747%2011.4957%2015.6261%2011.1813%2015.3192L7.51634%2011.7487C6.92022%2011.1683%206.48975%2010.6188%206.22495%2010.1002C5.96014%209.58168%205.86099%208.99533%205.92991%208.34118C5.99158%207.78099%206.17416%207.23864%206.47887%206.71294C6.78237%206.18723%207.21768%205.64964%207.78237%205.09896C8.45466%204.44362%209.09673%203.94171%209.70858%203.59203C10.3192%203.24236%2010.9105%203.04849%2011.4812%203.00806C12.0532%202.96762%2012.6166%203.07942%2013.1741%203.34346C13.7315%203.6075%2014.2974%204.01902%2014.873%204.5804H14.8742Z'%20fill='url(%23paint0_linear_4212_6487)'/%3e%3cpath%20d='M9.12459%2018.9872L5.46081%2015.4167C5.14884%2015.1122%204.99527%2014.8066%205.00011%2014.4973C5.00495%2014.1881%205.13917%2013.9062%205.40156%2013.6505C5.67604%2013.3829%205.97229%2013.2473%206.28909%2013.2414C6.60589%2013.2366%206.92028%2013.3853%207.23225%2013.6897L10.9795%2017.3411C11.4063%2017.7562%2011.8162%2018.05%2012.2116%2018.2224C12.607%2018.3949%2013.023%2018.421%2013.4595%2018.3033C13.896%2018.1856%2014.3639%2017.8823%2014.8657%2017.3934C15.5574%2016.7191%2015.8875%2016.0863%2015.8537%2015.4952C15.8198%2014.9041%2015.4764%2014.2904%2014.8247%2013.6553L12.8114%2011.7106C12.4958%2011.4038%2012.341%2011.0969%2012.3458%2010.7925C12.3507%2010.4868%2012.4861%2010.2049%2012.7533%209.94445C13.0194%209.68514%2013.3132%209.54957%2013.6324%209.53887C13.9516%209.52816%2014.2696%209.67682%2014.584%209.9837L16.4824%2011.8165C17.0785%2012.3969%2017.509%2012.9464%2017.7738%2013.465C18.0386%2013.9835%2018.1378%2014.5699%2018.0688%2015.224C18.0072%2015.7842%2017.8246%2016.3266%2017.5199%2016.8523C17.2164%2017.378%2016.7811%2017.9156%2016.2164%2018.4663C15.5441%2019.1216%2014.902%2019.6235%2014.2902%2019.9732C13.6783%2020.3229%2013.0871%2020.5179%2012.5151%2020.5583C11.9432%2020.5988%2011.3797%2020.487%2010.8223%2020.2229C10.2648%2019.9589%209.69894%2019.5474%209.12338%2018.986L9.12459%2018.9872Z'%20fill='url(%23paint1_linear_4212_6487)'/%3e%3cpath%20d='M11.4098%209.77448C12.153%209.77448%2012.7556%209.18182%2012.7556%208.4507C12.7556%207.71962%2012.153%207.12695%2011.4098%207.12695C10.6665%207.12695%2010.064%207.71962%2010.064%208.4507C10.064%209.18182%2010.6665%209.77448%2011.4098%209.77448Z'%20fill='url(%23paint2_radial_4212_6487)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_4212_6487'%20x1='17.9364'%20y1='6.66057'%20x2='6.64095'%20y2='11.7639'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23201C1B'/%3e%3cstop%20offset='0.36'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4B852'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_4212_6487'%20x1='6.3763'%20y1='17.0541'%20x2='19.5023'%20y2='13.0825'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231F1D1C'/%3e%3cstop%20offset='0.37'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4FB52'/%3e%3c/linearGradient%3e%3cradialGradient%20id='paint2_radial_4212_6487'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(11.4098%208.45191)%20scale(1.34581%201.32377)'%3e%3cstop%20stop-color='%23F4B852'/%3e%3cstop%20offset='0.33'%20stop-color='%23EA8101'/%3e%3cstop%20offset='0.64'%20stop-color='%2377390D'/%3e%3cstop%20offset='1'%20stop-color='%23211C1D'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", XverseWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M19.4283%2019.185V16.4677C19.4283%2016.36%2019.3855%2016.2572%2019.3092%2016.1809L7.74741%204.61916C7.67106%204.54281%207.56829%204.5%207.46055%204.5H4.74332C4.60917%204.5%204.5%204.60917%204.5%204.74332V7.26787C4.5%207.37562%204.54281%207.47837%204.61916%207.55472L8.76923%2011.7047C8.86412%2011.7997%208.86412%2011.9538%208.76923%2012.0487L4.57136%2016.2465C4.52569%2016.2922%204.5%2016.3543%204.5%2016.4185V19.185C4.5%2019.319%204.60917%2019.4283%204.74332%2019.4283H9.28369C9.41784%2019.4283%209.527%2019.319%209.527%2019.185V17.5552C9.527%2017.491%209.55271%2017.4289%209.59838%2017.3832L11.8504%2015.1312C11.9453%2015.0363%2012.0994%2015.0363%2012.1943%2015.1312L16.3729%2019.3099C16.4492%2019.3862%2016.552%2019.429%2016.6597%2019.429H19.1843C19.3185%2019.429%2019.4276%2019.3198%2019.4276%2019.1857L19.4283%2019.185Z'%20fill='white'/%3e%3cpath%20d='M13.372%208.09816H15.6461C15.781%208.09816%2015.8909%208.20805%2015.8909%208.34292V10.617C15.8909%2010.8353%2016.1549%2010.9445%2016.309%2010.7897L19.4287%207.66505C19.4743%207.61937%2019.5001%207.5573%2019.5001%207.49236V4.75588C19.5001%204.62102%2019.3908%204.51114%2019.2553%204.51114L16.4781%204.50757C16.4132%204.50757%2016.3511%204.53326%2016.3047%204.57892L13.1986%207.68003C13.0445%207.83415%2013.1537%208.09816%2013.3713%208.09816H13.372Z'%20fill='%23EE7A30'/%3e%3c/svg%3e";
function truncateMiddle(A, B = 4, W = 5) {
  if (A.length <= B + W)
    return A;
  const K = A.slice(0, B), J = A.slice(A.length - W);
  return `${K}...${J}`;
}
const WALLET_TO_ICON = {
  [Wallet.MAGICEDEN]: MagicEdenWalletIcon,
  [Wallet.UNISAT]: UnisatWalletIcon,
  [Wallet.XVERSE]: XverseWalletIcon,
  [Wallet.LEATHER]: LeatherWalletIcon,
  [Wallet.OKX]: OKXWalletIcon
}, NETWORK_DISPLAY_NAME = {
  [Network.MAINNET]: "Mainnet",
  [Network.TESTNET]: "Testnet",
  [Network.SIGNET]: "Signet"
};
function PostConnectButton({
  address: A,
  network: B,
  onViewProfile: W,
  onChangeWallet: K,
  onDisconnectWallet: J,
  renderAvatar: L
}) {
  const { wallet: re } = useOrdConnect();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    qe$1,
    {
      as: "section",
      className: "ord-connect-font ord-wallet-connected-container relative inline-block text-left",
      children: ({ open: ie }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Button, { className: "ord-wallet-connected-button", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-identifier-container", children: [
            L ? L(A, "large") : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Avatar,
              {
                size: 28,
                variant: "beam",
                name: A,
                colors: ["#1C2DCB", "#F226B8"]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: WALLET_TO_ICON[re],
                alt: `${re} is connected`
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "address-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "address", children: truncateMiddle(A) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "network-container", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-indicator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "network", children: NETWORK_DISPLAY_NAME[B] ?? B })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: ChevronDownIcon,
              className: `dropdown-button ${ie ? "close-dropdown-button" : "expand-dropdown-button"}`,
              alt: ""
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe,
          {
            as: Fragment,
            enter: "transition ease-out duration-100",
            enterFrom: "transform opacity-0 scale-95",
            enterTo: "transform opacity-100 scale-100",
            leave: "transition ease-in duration-75",
            leaveFrom: "transform opacity-100 scale-100",
            leaveTo: "transform opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Items, { className: "ord-wallet-connection-dropdown", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => W == null ? void 0 : W(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "View profile" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: truncateMiddle(A) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => K == null ? void 0 : K(),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "change-wallet-label", children: "Change wallet" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => J == null ? void 0 : J(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Disconnect wallet" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: LogoutIcon, className: "logout-icon", alt: "" })
                  ]
                }
              )
            ] })
          }
        )
      ] })
    }
  );
}
function PreConnectButton({
  openModal: A,
  disabled: B
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      onClick: A,
      disabled: B,
      "data-testid": "connect-wallet-button",
      className: "ord-connect-font ord-connect-wallet-button",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {})
    }
  );
}
const CloseModalIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M12%2022C17.5228%2022%2022%2017.5228%2022%2012C22%206.47715%2017.5228%202%2012%202C6.47715%202%202%206.47715%202%2012C2%2017.5228%206.47715%2022%2012%2022Z'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M15%209L9%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M9%209L15%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e";
function isMobileUserAgent() {
  return typeof window > "u" ? !1 : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
    window.navigator.userAgent
  );
}
var buffer$1 = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength$1;
base64Js$1.toByteArray = toByteArray$1;
base64Js$1.fromByteArray = fromByteArray$1;
var lookup$1 = [], revLookup$1 = [], Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len$1 = code$1.length; i$2 < len$1; ++i$2)
  lookup$1[i$2] = code$1[i$2], revLookup$1[code$1.charCodeAt(i$2)] = i$2;
revLookup$1[45] = 62;
revLookup$1[95] = 63;
function getLens$1(A) {
  var B = A.length;
  if (B % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var W = A.indexOf("=");
  W === -1 && (W = B);
  var K = W === B ? 0 : 4 - W % 4;
  return [W, K];
}
function byteLength$1(A) {
  var B = getLens$1(A), W = B[0], K = B[1];
  return (W + K) * 3 / 4 - K;
}
function _byteLength$1(A, B, W) {
  return (B + W) * 3 / 4 - W;
}
function toByteArray$1(A) {
  var B, W = getLens$1(A), K = W[0], J = W[1], L = new Arr$1(_byteLength$1(A, K, J)), re = 0, ie = J > 0 ? K - 4 : K, oe;
  for (oe = 0; oe < ie; oe += 4)
    B = revLookup$1[A.charCodeAt(oe)] << 18 | revLookup$1[A.charCodeAt(oe + 1)] << 12 | revLookup$1[A.charCodeAt(oe + 2)] << 6 | revLookup$1[A.charCodeAt(oe + 3)], L[re++] = B >> 16 & 255, L[re++] = B >> 8 & 255, L[re++] = B & 255;
  return J === 2 && (B = revLookup$1[A.charCodeAt(oe)] << 2 | revLookup$1[A.charCodeAt(oe + 1)] >> 4, L[re++] = B & 255), J === 1 && (B = revLookup$1[A.charCodeAt(oe)] << 10 | revLookup$1[A.charCodeAt(oe + 1)] << 4 | revLookup$1[A.charCodeAt(oe + 2)] >> 2, L[re++] = B >> 8 & 255, L[re++] = B & 255), L;
}
function tripletToBase64$1(A) {
  return lookup$1[A >> 18 & 63] + lookup$1[A >> 12 & 63] + lookup$1[A >> 6 & 63] + lookup$1[A & 63];
}
function encodeChunk$1(A, B, W) {
  for (var K, J = [], L = B; L < W; L += 3)
    K = (A[L] << 16 & 16711680) + (A[L + 1] << 8 & 65280) + (A[L + 2] & 255), J.push(tripletToBase64$1(K));
  return J.join("");
}
function fromByteArray$1(A) {
  for (var B, W = A.length, K = W % 3, J = [], L = 16383, re = 0, ie = W - K; re < ie; re += L)
    J.push(encodeChunk$1(A, re, re + L > ie ? ie : re + L));
  return K === 1 ? (B = A[W - 1], J.push(
    lookup$1[B >> 2] + lookup$1[B << 4 & 63] + "=="
  )) : K === 2 && (B = (A[W - 2] << 8) + A[W - 1], J.push(
    lookup$1[B >> 10] + lookup$1[B >> 4 & 63] + lookup$1[B << 2 & 63] + "="
  )), J.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(A, B, W, K, J) {
  var L, re, ie = J * 8 - K - 1, oe = (1 << ie) - 1, ke = oe >> 1, ne = -7, pe = W ? J - 1 : 0, rt = W ? -1 : 1, nt = A[B + pe];
  for (pe += rt, L = nt & (1 << -ne) - 1, nt >>= -ne, ne += ie; ne > 0; L = L * 256 + A[B + pe], pe += rt, ne -= 8)
    ;
  for (re = L & (1 << -ne) - 1, L >>= -ne, ne += K; ne > 0; re = re * 256 + A[B + pe], pe += rt, ne -= 8)
    ;
  if (L === 0)
    L = 1 - ke;
  else {
    if (L === oe)
      return re ? NaN : (nt ? -1 : 1) * (1 / 0);
    re = re + Math.pow(2, K), L = L - ke;
  }
  return (nt ? -1 : 1) * re * Math.pow(2, L - K);
};
ieee754.write = function(A, B, W, K, J, L) {
  var re, ie, oe, ke = L * 8 - J - 1, ne = (1 << ke) - 1, pe = ne >> 1, rt = J === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, nt = K ? 0 : L - 1, ot = K ? 1 : -1, ut = B < 0 || B === 0 && 1 / B < 0 ? 1 : 0;
  for (B = Math.abs(B), isNaN(B) || B === 1 / 0 ? (ie = isNaN(B) ? 1 : 0, re = ne) : (re = Math.floor(Math.log(B) / Math.LN2), B * (oe = Math.pow(2, -re)) < 1 && (re--, oe *= 2), re + pe >= 1 ? B += rt / oe : B += rt * Math.pow(2, 1 - pe), B * oe >= 2 && (re++, oe /= 2), re + pe >= ne ? (ie = 0, re = ne) : re + pe >= 1 ? (ie = (B * oe - 1) * Math.pow(2, J), re = re + pe) : (ie = B * Math.pow(2, pe - 1) * Math.pow(2, J), re = 0)); J >= 8; A[W + nt] = ie & 255, nt += ot, ie /= 256, J -= 8)
    ;
  for (re = re << J | ie, ke += J; ke > 0; A[W + nt] = re & 255, nt += ot, re /= 256, ke -= 8)
    ;
  A[W + nt - ot] |= ut * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(A) {
  const B = base64Js$1, W = ieee754, K = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  A.Buffer = ne, A.SlowBuffer = Pt, A.INSPECT_MAX_BYTES = 50;
  const J = 2147483647;
  A.kMaxLength = J;
  const { Uint8Array: L, ArrayBuffer: re, SharedArrayBuffer: ie } = globalThis;
  ne.TYPED_ARRAY_SUPPORT = oe(), !ne.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function oe() {
    try {
      const It = new L(1), St = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(St, L.prototype), Object.setPrototypeOf(It, St), It.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(ne.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (ne.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(ne.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (ne.isBuffer(this))
        return this.byteOffset;
    }
  });
  function ke(It) {
    if (It > J)
      throw new RangeError('The value "' + It + '" is invalid for option "size"');
    const St = new L(It);
    return Object.setPrototypeOf(St, ne.prototype), St;
  }
  function ne(It, St, At) {
    if (typeof It == "number") {
      if (typeof St == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return ot(It);
    }
    return pe(It, St, At);
  }
  ne.poolSize = 8192;
  function pe(It, St, At) {
    if (typeof It == "string")
      return ut(It, St);
    if (re.isView(It))
      return vt(It);
    if (It == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof It
      );
    if (Br(It, re) || It && Br(It.buffer, re) || typeof ie < "u" && (Br(It, ie) || It && Br(It.buffer, ie)))
      return pt(It, St, At);
    if (typeof It == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Ot = It.valueOf && It.valueOf();
    if (Ot != null && Ot !== It)
      return ne.from(Ot, St, At);
    const Gt = mt(It);
    if (Gt) return Gt;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof It[Symbol.toPrimitive] == "function")
      return ne.from(It[Symbol.toPrimitive]("string"), St, At);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof It
    );
  }
  ne.from = function(It, St, At) {
    return pe(It, St, At);
  }, Object.setPrototypeOf(ne.prototype, L.prototype), Object.setPrototypeOf(ne, L);
  function rt(It) {
    if (typeof It != "number")
      throw new TypeError('"size" argument must be of type number');
    if (It < 0)
      throw new RangeError('The value "' + It + '" is invalid for option "size"');
  }
  function nt(It, St, At) {
    return rt(It), It <= 0 ? ke(It) : St !== void 0 ? typeof At == "string" ? ke(It).fill(St, At) : ke(It).fill(St) : ke(It);
  }
  ne.alloc = function(It, St, At) {
    return nt(It, St, At);
  };
  function ot(It) {
    return rt(It), ke(It < 0 ? 0 : gt(It) | 0);
  }
  ne.allocUnsafe = function(It) {
    return ot(It);
  }, ne.allocUnsafeSlow = function(It) {
    return ot(It);
  };
  function ut(It, St) {
    if ((typeof St != "string" || St === "") && (St = "utf8"), !ne.isEncoding(St))
      throw new TypeError("Unknown encoding: " + St);
    const At = xt(It, St) | 0;
    let Ot = ke(At);
    const Gt = Ot.write(It, St);
    return Gt !== At && (Ot = Ot.slice(0, Gt)), Ot;
  }
  function dt(It) {
    const St = It.length < 0 ? 0 : gt(It.length) | 0, At = ke(St);
    for (let Ot = 0; Ot < St; Ot += 1)
      At[Ot] = It[Ot] & 255;
    return At;
  }
  function vt(It) {
    if (Br(It, L)) {
      const St = new L(It);
      return pt(St.buffer, St.byteOffset, St.byteLength);
    }
    return dt(It);
  }
  function pt(It, St, At) {
    if (St < 0 || It.byteLength < St)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (It.byteLength < St + (At || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Ot;
    return St === void 0 && At === void 0 ? Ot = new L(It) : At === void 0 ? Ot = new L(It, St) : Ot = new L(It, St, At), Object.setPrototypeOf(Ot, ne.prototype), Ot;
  }
  function mt(It) {
    if (ne.isBuffer(It)) {
      const St = gt(It.length) | 0, At = ke(St);
      return At.length === 0 || It.copy(At, 0, 0, St), At;
    }
    if (It.length !== void 0)
      return typeof It.length != "number" || $r(It.length) ? ke(0) : dt(It);
    if (It.type === "Buffer" && Array.isArray(It.data))
      return dt(It.data);
  }
  function gt(It) {
    if (It >= J)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + J.toString(16) + " bytes");
    return It | 0;
  }
  function Pt(It) {
    return +It != It && (It = 0), ne.alloc(+It);
  }
  ne.isBuffer = function(St) {
    return St != null && St._isBuffer === !0 && St !== ne.prototype;
  }, ne.compare = function(St, At) {
    if (Br(St, L) && (St = ne.from(St, St.offset, St.byteLength)), Br(At, L) && (At = ne.from(At, At.offset, At.byteLength)), !ne.isBuffer(St) || !ne.isBuffer(At))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (St === At) return 0;
    let Ot = St.length, Gt = At.length;
    for (let zt = 0, Vt = Math.min(Ot, Gt); zt < Vt; ++zt)
      if (St[zt] !== At[zt]) {
        Ot = St[zt], Gt = At[zt];
        break;
      }
    return Ot < Gt ? -1 : Gt < Ot ? 1 : 0;
  }, ne.isEncoding = function(St) {
    switch (String(St).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, ne.concat = function(St, At) {
    if (!Array.isArray(St))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (St.length === 0)
      return ne.alloc(0);
    let Ot;
    if (At === void 0)
      for (At = 0, Ot = 0; Ot < St.length; ++Ot)
        At += St[Ot].length;
    const Gt = ne.allocUnsafe(At);
    let zt = 0;
    for (Ot = 0; Ot < St.length; ++Ot) {
      let Vt = St[Ot];
      if (Br(Vt, L))
        zt + Vt.length > Gt.length ? (ne.isBuffer(Vt) || (Vt = ne.from(Vt)), Vt.copy(Gt, zt)) : L.prototype.set.call(
          Gt,
          Vt,
          zt
        );
      else if (ne.isBuffer(Vt))
        Vt.copy(Gt, zt);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      zt += Vt.length;
    }
    return Gt;
  };
  function xt(It, St) {
    if (ne.isBuffer(It))
      return It.length;
    if (re.isView(It) || Br(It, re))
      return It.byteLength;
    if (typeof It != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof It
      );
    const At = It.length, Ot = arguments.length > 2 && arguments[2] === !0;
    if (!Ot && At === 0) return 0;
    let Gt = !1;
    for (; ; )
      switch (St) {
        case "ascii":
        case "latin1":
        case "binary":
          return At;
        case "utf8":
        case "utf-8":
          return _r(It).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return At * 2;
        case "hex":
          return At >>> 1;
        case "base64":
          return Sr(It).length;
        default:
          if (Gt)
            return Ot ? -1 : _r(It).length;
          St = ("" + St).toLowerCase(), Gt = !0;
      }
  }
  ne.byteLength = xt;
  function Nt(It, St, At) {
    let Ot = !1;
    if ((St === void 0 || St < 0) && (St = 0), St > this.length || ((At === void 0 || At > this.length) && (At = this.length), At <= 0) || (At >>>= 0, St >>>= 0, At <= St))
      return "";
    for (It || (It = "utf8"); ; )
      switch (It) {
        case "hex":
          return Ce(this, St, At);
        case "utf8":
        case "utf-8":
          return at(this, St, At);
        case "ascii":
          return ct(this, St, At);
        case "latin1":
        case "binary":
          return ht(this, St, At);
        case "base64":
          return it(this, St, At);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return yt(this, St, At);
        default:
          if (Ot) throw new TypeError("Unknown encoding: " + It);
          It = (It + "").toLowerCase(), Ot = !0;
      }
  }
  ne.prototype._isBuffer = !0;
  function Et(It, St, At) {
    const Ot = It[St];
    It[St] = It[At], It[At] = Ot;
  }
  ne.prototype.swap16 = function() {
    const St = this.length;
    if (St % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let At = 0; At < St; At += 2)
      Et(this, At, At + 1);
    return this;
  }, ne.prototype.swap32 = function() {
    const St = this.length;
    if (St % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let At = 0; At < St; At += 4)
      Et(this, At, At + 3), Et(this, At + 1, At + 2);
    return this;
  }, ne.prototype.swap64 = function() {
    const St = this.length;
    if (St % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let At = 0; At < St; At += 8)
      Et(this, At, At + 7), Et(this, At + 1, At + 6), Et(this, At + 2, At + 5), Et(this, At + 3, At + 4);
    return this;
  }, ne.prototype.toString = function() {
    const St = this.length;
    return St === 0 ? "" : arguments.length === 0 ? at(this, 0, St) : Nt.apply(this, arguments);
  }, ne.prototype.toLocaleString = ne.prototype.toString, ne.prototype.equals = function(St) {
    if (!ne.isBuffer(St)) throw new TypeError("Argument must be a Buffer");
    return this === St ? !0 : ne.compare(this, St) === 0;
  }, ne.prototype.inspect = function() {
    let St = "";
    const At = A.INSPECT_MAX_BYTES;
    return St = this.toString("hex", 0, At).replace(/(.{2})/g, "$1 ").trim(), this.length > At && (St += " ... "), "<Buffer " + St + ">";
  }, K && (ne.prototype[K] = ne.prototype.inspect), ne.prototype.compare = function(St, At, Ot, Gt, zt) {
    if (Br(St, L) && (St = ne.from(St, St.offset, St.byteLength)), !ne.isBuffer(St))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof St
      );
    if (At === void 0 && (At = 0), Ot === void 0 && (Ot = St ? St.length : 0), Gt === void 0 && (Gt = 0), zt === void 0 && (zt = this.length), At < 0 || Ot > St.length || Gt < 0 || zt > this.length)
      throw new RangeError("out of range index");
    if (Gt >= zt && At >= Ot)
      return 0;
    if (Gt >= zt)
      return -1;
    if (At >= Ot)
      return 1;
    if (At >>>= 0, Ot >>>= 0, Gt >>>= 0, zt >>>= 0, this === St) return 0;
    let Vt = zt - Gt, Er = Ot - At;
    const wr = Math.min(Vt, Er), hr = this.slice(Gt, zt), Pr = St.slice(At, Ot);
    for (let gr = 0; gr < wr; ++gr)
      if (hr[gr] !== Pr[gr]) {
        Vt = hr[gr], Er = Pr[gr];
        break;
      }
    return Vt < Er ? -1 : Er < Vt ? 1 : 0;
  };
  function bt(It, St, At, Ot, Gt) {
    if (It.length === 0) return -1;
    if (typeof At == "string" ? (Ot = At, At = 0) : At > 2147483647 ? At = 2147483647 : At < -2147483648 && (At = -2147483648), At = +At, $r(At) && (At = Gt ? 0 : It.length - 1), At < 0 && (At = It.length + At), At >= It.length) {
      if (Gt) return -1;
      At = It.length - 1;
    } else if (At < 0)
      if (Gt) At = 0;
      else return -1;
    if (typeof St == "string" && (St = ne.from(St, Ot)), ne.isBuffer(St))
      return St.length === 0 ? -1 : Bt(It, St, At, Ot, Gt);
    if (typeof St == "number")
      return St = St & 255, typeof L.prototype.indexOf == "function" ? Gt ? L.prototype.indexOf.call(It, St, At) : L.prototype.lastIndexOf.call(It, St, At) : Bt(It, [St], At, Ot, Gt);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Bt(It, St, At, Ot, Gt) {
    let zt = 1, Vt = It.length, Er = St.length;
    if (Ot !== void 0 && (Ot = String(Ot).toLowerCase(), Ot === "ucs2" || Ot === "ucs-2" || Ot === "utf16le" || Ot === "utf-16le")) {
      if (It.length < 2 || St.length < 2)
        return -1;
      zt = 2, Vt /= 2, Er /= 2, At /= 2;
    }
    function wr(Pr, gr) {
      return zt === 1 ? Pr[gr] : Pr.readUInt16BE(gr * zt);
    }
    let hr;
    if (Gt) {
      let Pr = -1;
      for (hr = At; hr < Vt; hr++)
        if (wr(It, hr) === wr(St, Pr === -1 ? 0 : hr - Pr)) {
          if (Pr === -1 && (Pr = hr), hr - Pr + 1 === Er) return Pr * zt;
        } else
          Pr !== -1 && (hr -= hr - Pr), Pr = -1;
    } else
      for (At + Er > Vt && (At = Vt - Er), hr = At; hr >= 0; hr--) {
        let Pr = !0;
        for (let gr = 0; gr < Er; gr++)
          if (wr(It, hr + gr) !== wr(St, gr)) {
            Pr = !1;
            break;
          }
        if (Pr) return hr;
      }
    return -1;
  }
  ne.prototype.includes = function(St, At, Ot) {
    return this.indexOf(St, At, Ot) !== -1;
  }, ne.prototype.indexOf = function(St, At, Ot) {
    return bt(this, St, At, Ot, !0);
  }, ne.prototype.lastIndexOf = function(St, At, Ot) {
    return bt(this, St, At, Ot, !1);
  };
  function wt(It, St, At, Ot) {
    At = Number(At) || 0;
    const Gt = It.length - At;
    Ot ? (Ot = Number(Ot), Ot > Gt && (Ot = Gt)) : Ot = Gt;
    const zt = St.length;
    Ot > zt / 2 && (Ot = zt / 2);
    let Vt;
    for (Vt = 0; Vt < Ot; ++Vt) {
      const Er = parseInt(St.substr(Vt * 2, 2), 16);
      if ($r(Er)) return Vt;
      It[At + Vt] = Er;
    }
    return Vt;
  }
  function st(It, St, At, Ot) {
    return cr(_r(St, It.length - At), It, At, Ot);
  }
  function Oe(It, St, At, Ot) {
    return cr(sr(St), It, At, Ot);
  }
  function V(It, St, At, Ot) {
    return cr(Sr(St), It, At, Ot);
  }
  function ce(It, St, At, Ot) {
    return cr(Mr(St, It.length - At), It, At, Ot);
  }
  ne.prototype.write = function(St, At, Ot, Gt) {
    if (At === void 0)
      Gt = "utf8", Ot = this.length, At = 0;
    else if (Ot === void 0 && typeof At == "string")
      Gt = At, Ot = this.length, At = 0;
    else if (isFinite(At))
      At = At >>> 0, isFinite(Ot) ? (Ot = Ot >>> 0, Gt === void 0 && (Gt = "utf8")) : (Gt = Ot, Ot = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const zt = this.length - At;
    if ((Ot === void 0 || Ot > zt) && (Ot = zt), St.length > 0 && (Ot < 0 || At < 0) || At > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Gt || (Gt = "utf8");
    let Vt = !1;
    for (; ; )
      switch (Gt) {
        case "hex":
          return wt(this, St, At, Ot);
        case "utf8":
        case "utf-8":
          return st(this, St, At, Ot);
        case "ascii":
        case "latin1":
        case "binary":
          return Oe(this, St, At, Ot);
        case "base64":
          return V(this, St, At, Ot);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ce(this, St, At, Ot);
        default:
          if (Vt) throw new TypeError("Unknown encoding: " + Gt);
          Gt = ("" + Gt).toLowerCase(), Vt = !0;
      }
  }, ne.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function it(It, St, At) {
    return St === 0 && At === It.length ? B.fromByteArray(It) : B.fromByteArray(It.slice(St, At));
  }
  function at(It, St, At) {
    At = Math.min(It.length, At);
    const Ot = [];
    let Gt = St;
    for (; Gt < At; ) {
      const zt = It[Gt];
      let Vt = null, Er = zt > 239 ? 4 : zt > 223 ? 3 : zt > 191 ? 2 : 1;
      if (Gt + Er <= At) {
        let wr, hr, Pr, gr;
        switch (Er) {
          case 1:
            zt < 128 && (Vt = zt);
            break;
          case 2:
            wr = It[Gt + 1], (wr & 192) === 128 && (gr = (zt & 31) << 6 | wr & 63, gr > 127 && (Vt = gr));
            break;
          case 3:
            wr = It[Gt + 1], hr = It[Gt + 2], (wr & 192) === 128 && (hr & 192) === 128 && (gr = (zt & 15) << 12 | (wr & 63) << 6 | hr & 63, gr > 2047 && (gr < 55296 || gr > 57343) && (Vt = gr));
            break;
          case 4:
            wr = It[Gt + 1], hr = It[Gt + 2], Pr = It[Gt + 3], (wr & 192) === 128 && (hr & 192) === 128 && (Pr & 192) === 128 && (gr = (zt & 15) << 18 | (wr & 63) << 12 | (hr & 63) << 6 | Pr & 63, gr > 65535 && gr < 1114112 && (Vt = gr));
        }
      }
      Vt === null ? (Vt = 65533, Er = 1) : Vt > 65535 && (Vt -= 65536, Ot.push(Vt >>> 10 & 1023 | 55296), Vt = 56320 | Vt & 1023), Ot.push(Vt), Gt += Er;
    }
    return lt(Ot);
  }
  const ft = 4096;
  function lt(It) {
    const St = It.length;
    if (St <= ft)
      return String.fromCharCode.apply(String, It);
    let At = "", Ot = 0;
    for (; Ot < St; )
      At += String.fromCharCode.apply(
        String,
        It.slice(Ot, Ot += ft)
      );
    return At;
  }
  function ct(It, St, At) {
    let Ot = "";
    At = Math.min(It.length, At);
    for (let Gt = St; Gt < At; ++Gt)
      Ot += String.fromCharCode(It[Gt] & 127);
    return Ot;
  }
  function ht(It, St, At) {
    let Ot = "";
    At = Math.min(It.length, At);
    for (let Gt = St; Gt < At; ++Gt)
      Ot += String.fromCharCode(It[Gt]);
    return Ot;
  }
  function Ce(It, St, At) {
    const Ot = It.length;
    (!St || St < 0) && (St = 0), (!At || At < 0 || At > Ot) && (At = Ot);
    let Gt = "";
    for (let zt = St; zt < At; ++zt)
      Gt += yr[It[zt]];
    return Gt;
  }
  function yt(It, St, At) {
    const Ot = It.slice(St, At);
    let Gt = "";
    for (let zt = 0; zt < Ot.length - 1; zt += 2)
      Gt += String.fromCharCode(Ot[zt] + Ot[zt + 1] * 256);
    return Gt;
  }
  ne.prototype.slice = function(St, At) {
    const Ot = this.length;
    St = ~~St, At = At === void 0 ? Ot : ~~At, St < 0 ? (St += Ot, St < 0 && (St = 0)) : St > Ot && (St = Ot), At < 0 ? (At += Ot, At < 0 && (At = 0)) : At > Ot && (At = Ot), At < St && (At = St);
    const Gt = this.subarray(St, At);
    return Object.setPrototypeOf(Gt, ne.prototype), Gt;
  };
  function qt(It, St, At) {
    if (It % 1 !== 0 || It < 0) throw new RangeError("offset is not uint");
    if (It + St > At) throw new RangeError("Trying to access beyond buffer length");
  }
  ne.prototype.readUintLE = ne.prototype.readUIntLE = function(St, At, Ot) {
    St = St >>> 0, At = At >>> 0, Ot || qt(St, At, this.length);
    let Gt = this[St], zt = 1, Vt = 0;
    for (; ++Vt < At && (zt *= 256); )
      Gt += this[St + Vt] * zt;
    return Gt;
  }, ne.prototype.readUintBE = ne.prototype.readUIntBE = function(St, At, Ot) {
    St = St >>> 0, At = At >>> 0, Ot || qt(St, At, this.length);
    let Gt = this[St + --At], zt = 1;
    for (; At > 0 && (zt *= 256); )
      Gt += this[St + --At] * zt;
    return Gt;
  }, ne.prototype.readUint8 = ne.prototype.readUInt8 = function(St, At) {
    return St = St >>> 0, At || qt(St, 1, this.length), this[St];
  }, ne.prototype.readUint16LE = ne.prototype.readUInt16LE = function(St, At) {
    return St = St >>> 0, At || qt(St, 2, this.length), this[St] | this[St + 1] << 8;
  }, ne.prototype.readUint16BE = ne.prototype.readUInt16BE = function(St, At) {
    return St = St >>> 0, At || qt(St, 2, this.length), this[St] << 8 | this[St + 1];
  }, ne.prototype.readUint32LE = ne.prototype.readUInt32LE = function(St, At) {
    return St = St >>> 0, At || qt(St, 4, this.length), (this[St] | this[St + 1] << 8 | this[St + 2] << 16) + this[St + 3] * 16777216;
  }, ne.prototype.readUint32BE = ne.prototype.readUInt32BE = function(St, At) {
    return St = St >>> 0, At || qt(St, 4, this.length), this[St] * 16777216 + (this[St + 1] << 16 | this[St + 2] << 8 | this[St + 3]);
  }, ne.prototype.readBigUInt64LE = kr(function(St) {
    St = St >>> 0, ar(St, "offset");
    const At = this[St], Ot = this[St + 7];
    (At === void 0 || Ot === void 0) && fr(St, this.length - 8);
    const Gt = At + this[++St] * 2 ** 8 + this[++St] * 2 ** 16 + this[++St] * 2 ** 24, zt = this[++St] + this[++St] * 2 ** 8 + this[++St] * 2 ** 16 + Ot * 2 ** 24;
    return BigInt(Gt) + (BigInt(zt) << BigInt(32));
  }), ne.prototype.readBigUInt64BE = kr(function(St) {
    St = St >>> 0, ar(St, "offset");
    const At = this[St], Ot = this[St + 7];
    (At === void 0 || Ot === void 0) && fr(St, this.length - 8);
    const Gt = At * 2 ** 24 + this[++St] * 2 ** 16 + this[++St] * 2 ** 8 + this[++St], zt = this[++St] * 2 ** 24 + this[++St] * 2 ** 16 + this[++St] * 2 ** 8 + Ot;
    return (BigInt(Gt) << BigInt(32)) + BigInt(zt);
  }), ne.prototype.readIntLE = function(St, At, Ot) {
    St = St >>> 0, At = At >>> 0, Ot || qt(St, At, this.length);
    let Gt = this[St], zt = 1, Vt = 0;
    for (; ++Vt < At && (zt *= 256); )
      Gt += this[St + Vt] * zt;
    return zt *= 128, Gt >= zt && (Gt -= Math.pow(2, 8 * At)), Gt;
  }, ne.prototype.readIntBE = function(St, At, Ot) {
    St = St >>> 0, At = At >>> 0, Ot || qt(St, At, this.length);
    let Gt = At, zt = 1, Vt = this[St + --Gt];
    for (; Gt > 0 && (zt *= 256); )
      Vt += this[St + --Gt] * zt;
    return zt *= 128, Vt >= zt && (Vt -= Math.pow(2, 8 * At)), Vt;
  }, ne.prototype.readInt8 = function(St, At) {
    return St = St >>> 0, At || qt(St, 1, this.length), this[St] & 128 ? (255 - this[St] + 1) * -1 : this[St];
  }, ne.prototype.readInt16LE = function(St, At) {
    St = St >>> 0, At || qt(St, 2, this.length);
    const Ot = this[St] | this[St + 1] << 8;
    return Ot & 32768 ? Ot | 4294901760 : Ot;
  }, ne.prototype.readInt16BE = function(St, At) {
    St = St >>> 0, At || qt(St, 2, this.length);
    const Ot = this[St + 1] | this[St] << 8;
    return Ot & 32768 ? Ot | 4294901760 : Ot;
  }, ne.prototype.readInt32LE = function(St, At) {
    return St = St >>> 0, At || qt(St, 4, this.length), this[St] | this[St + 1] << 8 | this[St + 2] << 16 | this[St + 3] << 24;
  }, ne.prototype.readInt32BE = function(St, At) {
    return St = St >>> 0, At || qt(St, 4, this.length), this[St] << 24 | this[St + 1] << 16 | this[St + 2] << 8 | this[St + 3];
  }, ne.prototype.readBigInt64LE = kr(function(St) {
    St = St >>> 0, ar(St, "offset");
    const At = this[St], Ot = this[St + 7];
    (At === void 0 || Ot === void 0) && fr(St, this.length - 8);
    const Gt = this[St + 4] + this[St + 5] * 2 ** 8 + this[St + 6] * 2 ** 16 + (Ot << 24);
    return (BigInt(Gt) << BigInt(32)) + BigInt(At + this[++St] * 2 ** 8 + this[++St] * 2 ** 16 + this[++St] * 2 ** 24);
  }), ne.prototype.readBigInt64BE = kr(function(St) {
    St = St >>> 0, ar(St, "offset");
    const At = this[St], Ot = this[St + 7];
    (At === void 0 || Ot === void 0) && fr(St, this.length - 8);
    const Gt = (At << 24) + // Overflow
    this[++St] * 2 ** 16 + this[++St] * 2 ** 8 + this[++St];
    return (BigInt(Gt) << BigInt(32)) + BigInt(this[++St] * 2 ** 24 + this[++St] * 2 ** 16 + this[++St] * 2 ** 8 + Ot);
  }), ne.prototype.readFloatLE = function(St, At) {
    return St = St >>> 0, At || qt(St, 4, this.length), W.read(this, St, !0, 23, 4);
  }, ne.prototype.readFloatBE = function(St, At) {
    return St = St >>> 0, At || qt(St, 4, this.length), W.read(this, St, !1, 23, 4);
  }, ne.prototype.readDoubleLE = function(St, At) {
    return St = St >>> 0, At || qt(St, 8, this.length), W.read(this, St, !0, 52, 8);
  }, ne.prototype.readDoubleBE = function(St, At) {
    return St = St >>> 0, At || qt(St, 8, this.length), W.read(this, St, !1, 52, 8);
  };
  function jt(It, St, At, Ot, Gt, zt) {
    if (!ne.isBuffer(It)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (St > Gt || St < zt) throw new RangeError('"value" argument is out of bounds');
    if (At + Ot > It.length) throw new RangeError("Index out of range");
  }
  ne.prototype.writeUintLE = ne.prototype.writeUIntLE = function(St, At, Ot, Gt) {
    if (St = +St, At = At >>> 0, Ot = Ot >>> 0, !Gt) {
      const Er = Math.pow(2, 8 * Ot) - 1;
      jt(this, St, At, Ot, Er, 0);
    }
    let zt = 1, Vt = 0;
    for (this[At] = St & 255; ++Vt < Ot && (zt *= 256); )
      this[At + Vt] = St / zt & 255;
    return At + Ot;
  }, ne.prototype.writeUintBE = ne.prototype.writeUIntBE = function(St, At, Ot, Gt) {
    if (St = +St, At = At >>> 0, Ot = Ot >>> 0, !Gt) {
      const Er = Math.pow(2, 8 * Ot) - 1;
      jt(this, St, At, Ot, Er, 0);
    }
    let zt = Ot - 1, Vt = 1;
    for (this[At + zt] = St & 255; --zt >= 0 && (Vt *= 256); )
      this[At + zt] = St / Vt & 255;
    return At + Ot;
  }, ne.prototype.writeUint8 = ne.prototype.writeUInt8 = function(St, At, Ot) {
    return St = +St, At = At >>> 0, Ot || jt(this, St, At, 1, 255, 0), this[At] = St & 255, At + 1;
  }, ne.prototype.writeUint16LE = ne.prototype.writeUInt16LE = function(St, At, Ot) {
    return St = +St, At = At >>> 0, Ot || jt(this, St, At, 2, 65535, 0), this[At] = St & 255, this[At + 1] = St >>> 8, At + 2;
  }, ne.prototype.writeUint16BE = ne.prototype.writeUInt16BE = function(St, At, Ot) {
    return St = +St, At = At >>> 0, Ot || jt(this, St, At, 2, 65535, 0), this[At] = St >>> 8, this[At + 1] = St & 255, At + 2;
  }, ne.prototype.writeUint32LE = ne.prototype.writeUInt32LE = function(St, At, Ot) {
    return St = +St, At = At >>> 0, Ot || jt(this, St, At, 4, 4294967295, 0), this[At + 3] = St >>> 24, this[At + 2] = St >>> 16, this[At + 1] = St >>> 8, this[At] = St & 255, At + 4;
  }, ne.prototype.writeUint32BE = ne.prototype.writeUInt32BE = function(St, At, Ot) {
    return St = +St, At = At >>> 0, Ot || jt(this, St, At, 4, 4294967295, 0), this[At] = St >>> 24, this[At + 1] = St >>> 16, this[At + 2] = St >>> 8, this[At + 3] = St & 255, At + 4;
  };
  function kt(It, St, At, Ot, Gt) {
    Zt(St, Ot, Gt, It, At, 7);
    let zt = Number(St & BigInt(4294967295));
    It[At++] = zt, zt = zt >> 8, It[At++] = zt, zt = zt >> 8, It[At++] = zt, zt = zt >> 8, It[At++] = zt;
    let Vt = Number(St >> BigInt(32) & BigInt(4294967295));
    return It[At++] = Vt, Vt = Vt >> 8, It[At++] = Vt, Vt = Vt >> 8, It[At++] = Vt, Vt = Vt >> 8, It[At++] = Vt, At;
  }
  function $t(It, St, At, Ot, Gt) {
    Zt(St, Ot, Gt, It, At, 7);
    let zt = Number(St & BigInt(4294967295));
    It[At + 7] = zt, zt = zt >> 8, It[At + 6] = zt, zt = zt >> 8, It[At + 5] = zt, zt = zt >> 8, It[At + 4] = zt;
    let Vt = Number(St >> BigInt(32) & BigInt(4294967295));
    return It[At + 3] = Vt, Vt = Vt >> 8, It[At + 2] = Vt, Vt = Vt >> 8, It[At + 1] = Vt, Vt = Vt >> 8, It[At] = Vt, At + 8;
  }
  ne.prototype.writeBigUInt64LE = kr(function(St, At = 0) {
    return kt(this, St, At, BigInt(0), BigInt("0xffffffffffffffff"));
  }), ne.prototype.writeBigUInt64BE = kr(function(St, At = 0) {
    return $t(this, St, At, BigInt(0), BigInt("0xffffffffffffffff"));
  }), ne.prototype.writeIntLE = function(St, At, Ot, Gt) {
    if (St = +St, At = At >>> 0, !Gt) {
      const wr = Math.pow(2, 8 * Ot - 1);
      jt(this, St, At, Ot, wr - 1, -wr);
    }
    let zt = 0, Vt = 1, Er = 0;
    for (this[At] = St & 255; ++zt < Ot && (Vt *= 256); )
      St < 0 && Er === 0 && this[At + zt - 1] !== 0 && (Er = 1), this[At + zt] = (St / Vt >> 0) - Er & 255;
    return At + Ot;
  }, ne.prototype.writeIntBE = function(St, At, Ot, Gt) {
    if (St = +St, At = At >>> 0, !Gt) {
      const wr = Math.pow(2, 8 * Ot - 1);
      jt(this, St, At, Ot, wr - 1, -wr);
    }
    let zt = Ot - 1, Vt = 1, Er = 0;
    for (this[At + zt] = St & 255; --zt >= 0 && (Vt *= 256); )
      St < 0 && Er === 0 && this[At + zt + 1] !== 0 && (Er = 1), this[At + zt] = (St / Vt >> 0) - Er & 255;
    return At + Ot;
  }, ne.prototype.writeInt8 = function(St, At, Ot) {
    return St = +St, At = At >>> 0, Ot || jt(this, St, At, 1, 127, -128), St < 0 && (St = 255 + St + 1), this[At] = St & 255, At + 1;
  }, ne.prototype.writeInt16LE = function(St, At, Ot) {
    return St = +St, At = At >>> 0, Ot || jt(this, St, At, 2, 32767, -32768), this[At] = St & 255, this[At + 1] = St >>> 8, At + 2;
  }, ne.prototype.writeInt16BE = function(St, At, Ot) {
    return St = +St, At = At >>> 0, Ot || jt(this, St, At, 2, 32767, -32768), this[At] = St >>> 8, this[At + 1] = St & 255, At + 2;
  }, ne.prototype.writeInt32LE = function(St, At, Ot) {
    return St = +St, At = At >>> 0, Ot || jt(this, St, At, 4, 2147483647, -2147483648), this[At] = St & 255, this[At + 1] = St >>> 8, this[At + 2] = St >>> 16, this[At + 3] = St >>> 24, At + 4;
  }, ne.prototype.writeInt32BE = function(St, At, Ot) {
    return St = +St, At = At >>> 0, Ot || jt(this, St, At, 4, 2147483647, -2147483648), St < 0 && (St = 4294967295 + St + 1), this[At] = St >>> 24, this[At + 1] = St >>> 16, this[At + 2] = St >>> 8, this[At + 3] = St & 255, At + 4;
  }, ne.prototype.writeBigInt64LE = kr(function(St, At = 0) {
    return kt(this, St, At, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), ne.prototype.writeBigInt64BE = kr(function(St, At = 0) {
    return $t(this, St, At, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Mt(It, St, At, Ot, Gt, zt) {
    if (At + Ot > It.length) throw new RangeError("Index out of range");
    if (At < 0) throw new RangeError("Index out of range");
  }
  function Lt(It, St, At, Ot, Gt) {
    return St = +St, At = At >>> 0, Gt || Mt(It, St, At, 4), W.write(It, St, At, Ot, 23, 4), At + 4;
  }
  ne.prototype.writeFloatLE = function(St, At, Ot) {
    return Lt(this, St, At, !0, Ot);
  }, ne.prototype.writeFloatBE = function(St, At, Ot) {
    return Lt(this, St, At, !1, Ot);
  };
  function Kt(It, St, At, Ot, Gt) {
    return St = +St, At = At >>> 0, Gt || Mt(It, St, At, 8), W.write(It, St, At, Ot, 52, 8), At + 8;
  }
  ne.prototype.writeDoubleLE = function(St, At, Ot) {
    return Kt(this, St, At, !0, Ot);
  }, ne.prototype.writeDoubleBE = function(St, At, Ot) {
    return Kt(this, St, At, !1, Ot);
  }, ne.prototype.copy = function(St, At, Ot, Gt) {
    if (!ne.isBuffer(St)) throw new TypeError("argument should be a Buffer");
    if (Ot || (Ot = 0), !Gt && Gt !== 0 && (Gt = this.length), At >= St.length && (At = St.length), At || (At = 0), Gt > 0 && Gt < Ot && (Gt = Ot), Gt === Ot || St.length === 0 || this.length === 0) return 0;
    if (At < 0)
      throw new RangeError("targetStart out of bounds");
    if (Ot < 0 || Ot >= this.length) throw new RangeError("Index out of range");
    if (Gt < 0) throw new RangeError("sourceEnd out of bounds");
    Gt > this.length && (Gt = this.length), St.length - At < Gt - Ot && (Gt = St.length - At + Ot);
    const zt = Gt - Ot;
    return this === St && typeof L.prototype.copyWithin == "function" ? this.copyWithin(At, Ot, Gt) : L.prototype.set.call(
      St,
      this.subarray(Ot, Gt),
      At
    ), zt;
  }, ne.prototype.fill = function(St, At, Ot, Gt) {
    if (typeof St == "string") {
      if (typeof At == "string" ? (Gt = At, At = 0, Ot = this.length) : typeof Ot == "string" && (Gt = Ot, Ot = this.length), Gt !== void 0 && typeof Gt != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Gt == "string" && !ne.isEncoding(Gt))
        throw new TypeError("Unknown encoding: " + Gt);
      if (St.length === 1) {
        const Vt = St.charCodeAt(0);
        (Gt === "utf8" && Vt < 128 || Gt === "latin1") && (St = Vt);
      }
    } else typeof St == "number" ? St = St & 255 : typeof St == "boolean" && (St = Number(St));
    if (At < 0 || this.length < At || this.length < Ot)
      throw new RangeError("Out of range index");
    if (Ot <= At)
      return this;
    At = At >>> 0, Ot = Ot === void 0 ? this.length : Ot >>> 0, St || (St = 0);
    let zt;
    if (typeof St == "number")
      for (zt = At; zt < Ot; ++zt)
        this[zt] = St;
    else {
      const Vt = ne.isBuffer(St) ? St : ne.from(St, Gt), Er = Vt.length;
      if (Er === 0)
        throw new TypeError('The value "' + St + '" is invalid for argument "value"');
      for (zt = 0; zt < Ot - At; ++zt)
        this[zt + At] = Vt[zt % Er];
    }
    return this;
  };
  const Tt = {};
  function Rt(It, St, At) {
    Tt[It] = class extends At {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: St.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${It}]`, this.stack, delete this.name;
      }
      get code() {
        return It;
      }
      set code(Gt) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Gt,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${It}]: ${this.message}`;
      }
    };
  }
  Rt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(It) {
      return It ? `${It} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Rt(
    "ERR_INVALID_ARG_TYPE",
    function(It, St) {
      return `The "${It}" argument must be of type number. Received type ${typeof St}`;
    },
    TypeError
  ), Rt(
    "ERR_OUT_OF_RANGE",
    function(It, St, At) {
      let Ot = `The value of "${It}" is out of range.`, Gt = At;
      return Number.isInteger(At) && Math.abs(At) > 2 ** 32 ? Gt = Wt(String(At)) : typeof At == "bigint" && (Gt = String(At), (At > BigInt(2) ** BigInt(32) || At < -(BigInt(2) ** BigInt(32))) && (Gt = Wt(Gt)), Gt += "n"), Ot += ` It must be ${St}. Received ${Gt}`, Ot;
    },
    RangeError
  );
  function Wt(It) {
    let St = "", At = It.length;
    const Ot = It[0] === "-" ? 1 : 0;
    for (; At >= Ot + 4; At -= 3)
      St = `_${It.slice(At - 3, At)}${St}`;
    return `${It.slice(0, At)}${St}`;
  }
  function Xt(It, St, At) {
    ar(St, "offset"), (It[St] === void 0 || It[St + At] === void 0) && fr(St, It.length - (At + 1));
  }
  function Zt(It, St, At, Ot, Gt, zt) {
    if (It > At || It < St) {
      const Vt = typeof St == "bigint" ? "n" : "";
      let Er;
      throw St === 0 || St === BigInt(0) ? Er = `>= 0${Vt} and < 2${Vt} ** ${(zt + 1) * 8}${Vt}` : Er = `>= -(2${Vt} ** ${(zt + 1) * 8 - 1}${Vt}) and < 2 ** ${(zt + 1) * 8 - 1}${Vt}`, new Tt.ERR_OUT_OF_RANGE("value", Er, It);
    }
    Xt(Ot, Gt, zt);
  }
  function ar(It, St) {
    if (typeof It != "number")
      throw new Tt.ERR_INVALID_ARG_TYPE(St, "number", It);
  }
  function fr(It, St, At) {
    throw Math.floor(It) !== It ? (ar(It, At), new Tt.ERR_OUT_OF_RANGE("offset", "an integer", It)) : St < 0 ? new Tt.ERR_BUFFER_OUT_OF_BOUNDS() : new Tt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${St}`,
      It
    );
  }
  const lr = /[^+/0-9A-Za-z-_]/g;
  function Jt(It) {
    if (It = It.split("=")[0], It = It.trim().replace(lr, ""), It.length < 2) return "";
    for (; It.length % 4 !== 0; )
      It = It + "=";
    return It;
  }
  function _r(It, St) {
    St = St || 1 / 0;
    let At;
    const Ot = It.length;
    let Gt = null;
    const zt = [];
    for (let Vt = 0; Vt < Ot; ++Vt) {
      if (At = It.charCodeAt(Vt), At > 55295 && At < 57344) {
        if (!Gt) {
          if (At > 56319) {
            (St -= 3) > -1 && zt.push(239, 191, 189);
            continue;
          } else if (Vt + 1 === Ot) {
            (St -= 3) > -1 && zt.push(239, 191, 189);
            continue;
          }
          Gt = At;
          continue;
        }
        if (At < 56320) {
          (St -= 3) > -1 && zt.push(239, 191, 189), Gt = At;
          continue;
        }
        At = (Gt - 55296 << 10 | At - 56320) + 65536;
      } else Gt && (St -= 3) > -1 && zt.push(239, 191, 189);
      if (Gt = null, At < 128) {
        if ((St -= 1) < 0) break;
        zt.push(At);
      } else if (At < 2048) {
        if ((St -= 2) < 0) break;
        zt.push(
          At >> 6 | 192,
          At & 63 | 128
        );
      } else if (At < 65536) {
        if ((St -= 3) < 0) break;
        zt.push(
          At >> 12 | 224,
          At >> 6 & 63 | 128,
          At & 63 | 128
        );
      } else if (At < 1114112) {
        if ((St -= 4) < 0) break;
        zt.push(
          At >> 18 | 240,
          At >> 12 & 63 | 128,
          At >> 6 & 63 | 128,
          At & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return zt;
  }
  function sr(It) {
    const St = [];
    for (let At = 0; At < It.length; ++At)
      St.push(It.charCodeAt(At) & 255);
    return St;
  }
  function Mr(It, St) {
    let At, Ot, Gt;
    const zt = [];
    for (let Vt = 0; Vt < It.length && !((St -= 2) < 0); ++Vt)
      At = It.charCodeAt(Vt), Ot = At >> 8, Gt = At % 256, zt.push(Gt), zt.push(Ot);
    return zt;
  }
  function Sr(It) {
    return B.toByteArray(Jt(It));
  }
  function cr(It, St, At, Ot) {
    let Gt;
    for (Gt = 0; Gt < Ot && !(Gt + At >= St.length || Gt >= It.length); ++Gt)
      St[Gt + At] = It[Gt];
    return Gt;
  }
  function Br(It, St) {
    return It instanceof St || It != null && It.constructor != null && It.constructor.name != null && It.constructor.name === St.name;
  }
  function $r(It) {
    return It !== It;
  }
  const yr = function() {
    const It = "0123456789abcdef", St = new Array(256);
    for (let At = 0; At < 16; ++At) {
      const Ot = At * 16;
      for (let Gt = 0; Gt < 16; ++Gt)
        St[Ot + Gt] = It[At] + It[Gt];
    }
    return St;
  }();
  function kr(It) {
    return typeof BigInt > "u" ? Tr : It;
  }
  function Tr() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$1 = buffer$1.Buffer, Blob = buffer$1.Blob, BlobOptions = buffer$1.BlobOptions, Buffer$1$1 = buffer$1.Buffer, File = buffer$1.File, FileOptions = buffer$1.FileOptions, INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES, SlowBuffer = buffer$1.SlowBuffer, TranscodeEncoding = buffer$1.TranscodeEncoding, atob = buffer$1.atob, btoa = buffer$1.btoa, constants$1 = buffer$1.constants, isAscii = buffer$1.isAscii, isUtf8 = buffer$1.isUtf8, kMaxLength = buffer$1.kMaxLength, kStringMaxLength = buffer$1.kStringMaxLength, resolveObjectURL = buffer$1.resolveObjectURL, transcode = buffer$1.transcode, dist$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob,
  btoa,
  constants: constants$1,
  default: Buffer$1,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var store2;
function getGlobalMessage(A) {
  return store2 == null ? void 0 : store2.get(A);
}
var store3;
function getSchemaMessage(A) {
  return store3 == null ? void 0 : store3.get(A);
}
var store4;
function getSpecificMessage(A, B) {
  var W;
  return (W = store4 == null ? void 0 : store4.get(A)) == null ? void 0 : W.get(B);
}
function _stringify(A) {
  var W, K;
  const B = typeof A;
  return B === "string" ? `"${A}"` : B === "number" || B === "bigint" || B === "boolean" ? `${A}` : B === "object" || B === "function" ? (A && ((K = (W = Object.getPrototypeOf(A)) == null ? void 0 : W.constructor) == null ? void 0 : K.name)) ?? "null" : B;
}
function _addIssue(A, B, W, K, J) {
  const L = J && "input" in J ? J.input : W.value, re = (J == null ? void 0 : J.expected) ?? A.expects ?? null, ie = (J == null ? void 0 : J.received) ?? _stringify(L), oe = {
    kind: A.kind,
    type: A.type,
    input: L,
    expected: re,
    received: ie,
    message: `Invalid ${B}: ${re ? `Expected ${re} but r` : "R"}eceived ${ie}`,
    requirement: A.requirement,
    path: J == null ? void 0 : J.path,
    issues: J == null ? void 0 : J.issues,
    lang: K.lang,
    abortEarly: K.abortEarly,
    abortPipeEarly: K.abortPipeEarly
  }, ke = A.kind === "schema", ne = (J == null ? void 0 : J.message) ?? A.message ?? getSpecificMessage(A.reference, oe.lang) ?? (ke ? getSchemaMessage(oe.lang) : null) ?? K.message ?? getGlobalMessage(oe.lang);
  ne && (oe.message = typeof ne == "function" ? (
    // @ts-expect-error
    ne(oe)
  ) : ne), ke && (W.typed = !1), W.issues ? W.issues.push(oe) : W.issues = [oe];
}
function _isValidObjectKey(A, B) {
  return Object.hasOwn(A, B) && B !== "__proto__" && B !== "prototype" && B !== "constructor";
}
function _joinExpects(A, B) {
  const W = [...new Set(A)];
  return W.length > 1 ? `(${W.join(` ${B} `)})` : W[0] ?? "never";
}
function check$e(A, B) {
  return {
    kind: "validation",
    type: "check",
    reference: check$e,
    async: !1,
    expects: null,
    requirement: A,
    message: B,
    _run(W, K) {
      return W.typed && !this.requirement(W.value) && _addIssue(this, "input", W, K), W;
    }
  };
}
function maxLength(A, B) {
  return {
    kind: "validation",
    type: "max_length",
    reference: maxLength,
    async: !1,
    expects: `<=${A}`,
    requirement: A,
    message: B,
    _run(W, K) {
      return W.typed && W.value.length > this.requirement && _addIssue(this, "length", W, K, {
        received: `${W.value.length}`
      }), W;
    }
  };
}
function minLength(A, B) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: !1,
    expects: `>=${A}`,
    requirement: A,
    message: B,
    _run(W, K) {
      return W.typed && W.value.length < this.requirement && _addIssue(this, "length", W, K, {
        received: `${W.value.length}`
      }), W;
    }
  };
}
function getDefault(A, B, W) {
  return typeof A.default == "function" ? (
    // @ts-expect-error
    A.default(B, W)
  ) : (
    // @ts-expect-error
    A.default
  );
}
function array(A, B) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: !1,
    item: A,
    message: B,
    _run(W, K) {
      var L;
      const J = W.value;
      if (Array.isArray(J)) {
        W.typed = !0, W.value = [];
        for (let re = 0; re < J.length; re++) {
          const ie = J[re], oe = this.item._run({ typed: !1, value: ie }, K);
          if (oe.issues) {
            const ke = {
              type: "array",
              origin: "value",
              input: J,
              key: re,
              value: ie
            };
            for (const ne of oe.issues)
              ne.path ? ne.path.unshift(ke) : ne.path = [ke], (L = W.issues) == null || L.push(ne);
            if (W.issues || (W.issues = oe.issues), K.abortEarly) {
              W.typed = !1;
              break;
            }
          }
          oe.typed || (W.typed = !1), W.value.push(oe.value);
        }
      } else
        _addIssue(this, "type", W, K);
      return W;
    }
  };
}
function boolean(A) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message: A,
    _run(B, W) {
      return typeof B.value == "boolean" ? B.typed = !0 : _addIssue(this, "type", B, W), B;
    }
  };
}
function enum_(A, B) {
  const W = Object.entries(A).filter(([K]) => isNaN(+K)).map(([, K]) => K);
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: _joinExpects(W.map(_stringify), "|"),
    async: !1,
    enum: A,
    options: W,
    message: B,
    _run(K, J) {
      return this.options.includes(K.value) ? K.typed = !0 : _addIssue(this, "type", K, J), K;
    }
  };
}
function literal(A, B) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(A),
    async: !1,
    literal: A,
    message: B,
    _run(W, K) {
      return W.value === this.literal ? W.typed = !0 : _addIssue(this, "type", W, K), W;
    }
  };
}
function looseObject(A, B) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: !1,
    entries: A,
    message: B,
    _run(W, K) {
      var L;
      const J = W.value;
      if (J && typeof J == "object") {
        W.typed = !0, W.value = {};
        for (const re in this.entries) {
          const ie = J[re], oe = this.entries[re]._run(
            { typed: !1, value: ie },
            K
          );
          if (oe.issues) {
            const ke = {
              type: "object",
              origin: "value",
              input: J,
              key: re,
              value: ie
            };
            for (const ne of oe.issues)
              ne.path ? ne.path.unshift(ke) : ne.path = [ke], (L = W.issues) == null || L.push(ne);
            if (W.issues || (W.issues = oe.issues), K.abortEarly) {
              W.typed = !1;
              break;
            }
          }
          oe.typed || (W.typed = !1), (oe.value !== void 0 || re in J) && (W.value[re] = oe.value);
        }
        if (!W.issues || !K.abortEarly)
          for (const re in J)
            _isValidObjectKey(J, re) && !(re in this.entries) && (W.value[re] = J[re]);
      } else
        _addIssue(this, "type", W, K);
      return W;
    }
  };
}
function nonOptional(A, B) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: !1,
    wrapped: A,
    message: B,
    _run(W, K) {
      return W.value === void 0 ? (_addIssue(this, "type", W, K), W) : this.wrapped._run(W, K);
    }
  };
}
function null_(A) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: !1,
    message: A,
    _run(B, W) {
      return B.value === null ? B.typed = !0 : _addIssue(this, "type", B, W), B;
    }
  };
}
function nullish(A, ...B) {
  const W = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `(${A.expects} | null | undefined)`,
    async: !1,
    wrapped: A,
    _run(K, J) {
      return (K.value === null || K.value === void 0) && ("default" in this && (K.value = getDefault(
        this,
        K,
        J
      )), K.value === null || K.value === void 0) ? (K.typed = !0, K) : this.wrapped._run(K, J);
    }
  };
  return 0 in B && (W.default = B[0]), W;
}
function number(A) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: !1,
    message: A,
    _run(B, W) {
      return typeof B.value == "number" && !isNaN(B.value) ? B.typed = !0 : _addIssue(this, "type", B, W), B;
    }
  };
}
function object(A, B) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries: A,
    message: B,
    _run(W, K) {
      var L;
      const J = W.value;
      if (J && typeof J == "object") {
        W.typed = !0, W.value = {};
        for (const re in this.entries) {
          const ie = J[re], oe = this.entries[re]._run(
            { typed: !1, value: ie },
            K
          );
          if (oe.issues) {
            const ke = {
              type: "object",
              origin: "value",
              input: J,
              key: re,
              value: ie
            };
            for (const ne of oe.issues)
              ne.path ? ne.path.unshift(ke) : ne.path = [ke], (L = W.issues) == null || L.push(ne);
            if (W.issues || (W.issues = oe.issues), K.abortEarly) {
              W.typed = !1;
              break;
            }
          }
          oe.typed || (W.typed = !1), (oe.value !== void 0 || re in J) && (W.value[re] = oe.value);
        }
      } else
        _addIssue(this, "type", W, K);
      return W;
    }
  };
}
function optional(A, ...B) {
  const W = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${A.expects} | undefined)`,
    async: !1,
    wrapped: A,
    _run(K, J) {
      return K.value === void 0 && ("default" in this && (K.value = getDefault(
        this,
        K,
        J
      )), K.value === void 0) ? (K.typed = !0, K) : this.wrapped._run(K, J);
    }
  };
  return 0 in B && (W.default = B[0]), W;
}
function picklist(A, B) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: _joinExpects(A.map(_stringify), "|"),
    async: !1,
    options: A,
    message: B,
    _run(W, K) {
      return this.options.includes(W.value) ? W.typed = !0 : _addIssue(this, "type", W, K), W;
    }
  };
}
function record(A, B, W) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: !1,
    key: A,
    value: B,
    message: W,
    _run(K, J) {
      var re, ie;
      const L = K.value;
      if (L && typeof L == "object") {
        K.typed = !0, K.value = {};
        for (const oe in L)
          if (_isValidObjectKey(L, oe)) {
            const ke = L[oe], ne = this.key._run(
              { typed: !1, value: oe },
              J
            );
            if (ne.issues) {
              const rt = {
                type: "object",
                origin: "key",
                input: L,
                key: oe,
                value: ke
              };
              for (const nt of ne.issues)
                nt.path = [rt], (re = K.issues) == null || re.push(nt);
              if (K.issues || (K.issues = ne.issues), J.abortEarly) {
                K.typed = !1;
                break;
              }
            }
            const pe = this.value._run(
              { typed: !1, value: ke },
              J
            );
            if (pe.issues) {
              const rt = {
                type: "object",
                origin: "value",
                input: L,
                key: oe,
                value: ke
              };
              for (const nt of pe.issues)
                nt.path ? nt.path.unshift(rt) : nt.path = [rt], (ie = K.issues) == null || ie.push(nt);
              if (K.issues || (K.issues = pe.issues), J.abortEarly) {
                K.typed = !1;
                break;
              }
            }
            (!ne.typed || !pe.typed) && (K.typed = !1), ne.typed && (K.value[ne.value] = pe.value);
          }
      } else
        _addIssue(this, "type", K, J);
      return K;
    }
  };
}
function string(A) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message: A,
    _run(B, W) {
      return typeof B.value == "string" ? B.typed = !0 : _addIssue(this, "type", B, W), B;
    }
  };
}
function _subIssues(A) {
  let B;
  if (A)
    for (const W of A)
      B ? B.push(...W.issues) : B = W.issues;
  return B;
}
function union(A, B) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: _joinExpects(
      A.map((W) => W.expects),
      "|"
    ),
    async: !1,
    options: A,
    message: B,
    _run(W, K) {
      let J, L, re;
      for (const ie of this.options) {
        const oe = ie._run(
          { typed: !1, value: W.value },
          K
        );
        if (oe.typed)
          if (oe.issues)
            L ? L.push(oe) : L = [oe];
          else {
            J = oe;
            break;
          }
        else
          re ? re.push(oe) : re = [oe];
      }
      if (J)
        return J;
      if (L) {
        if (L.length === 1)
          return L[0];
        _addIssue(this, "type", W, K, {
          issues: _subIssues(L)
        }), W.typed = !0;
      } else {
        if ((re == null ? void 0 : re.length) === 1)
          return re[0];
        _addIssue(this, "type", W, K, {
          issues: _subIssues(re)
        });
      }
      return W;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(A) {
      return A.typed = !0, A;
    }
  };
}
function variant(A, B, W) {
  return {
    kind: "schema",
    type: "variant",
    reference: variant,
    expects: "Object",
    async: !1,
    key: A,
    options: B,
    message: W,
    _run(K, J) {
      const L = K.value;
      if (L && typeof L == "object") {
        let re, ie = 0, oe = this.key, ke = [];
        const ne = (pe, rt) => {
          for (const nt of pe.options) {
            if (nt.type === "variant")
              ne(nt, new Set(rt).add(nt.key));
            else {
              let ot = !0, ut = 0;
              for (const dt of rt) {
                if (nt.entries[dt]._run(
                  // @ts-expect-error
                  { typed: !1, value: L[dt] },
                  J
                ).issues) {
                  ot = !1, oe !== dt && (ie < ut || ie === ut && dt in L && !(oe in L)) && (ie = ut, oe = dt, ke = []), oe === dt && ke.push(
                    nt.entries[dt].expects
                  );
                  break;
                }
                ut++;
              }
              if (ot) {
                const dt = nt._run(
                  { typed: !1, value: L },
                  J
                );
                (!re || !re.typed && dt.typed) && (re = dt);
              }
            }
            if (re && !re.issues)
              break;
          }
        };
        if (ne(this, /* @__PURE__ */ new Set([this.key])), re)
          return re;
        _addIssue(this, "type", K, J, {
          // @ts-expect-error
          input: L[oe],
          expected: _joinExpects(ke, "|"),
          path: [
            {
              type: "object",
              origin: "value",
              input: L,
              key: oe,
              // @ts-expect-error
              value: L[oe]
            }
          ]
        });
      } else
        _addIssue(this, "type", K, J);
      return K;
    }
  };
}
function omit(A, B) {
  const W = {
    ...A.entries
  };
  for (const K of B)
    delete W[K];
  return { ...A, entries: W };
}
function pipe(...A) {
  return {
    ...A[0],
    pipe: A,
    _run(B, W) {
      for (const K of A)
        if (K.kind !== "metadata") {
          if (B.issues && (K.kind === "schema" || K.kind === "transformation")) {
            B.typed = !1;
            break;
          }
          (!B.issues || !W.abortEarly && !W.abortPipeEarly) && (B = K._run(B, W));
        }
      return B;
    }
  };
}
function unwrap(A) {
  return A.wrapped;
}
var lib$1 = {}, signer = {}, base64Url = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(A) {
  var B = A.length;
  if (B % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var W = A.indexOf("=");
  W === -1 && (W = B);
  var K = W === B ? 0 : 4 - W % 4;
  return [W, K];
}
function byteLength(A) {
  var B = getLens(A), W = B[0], K = B[1];
  return (W + K) * 3 / 4 - K;
}
function _byteLength(A, B, W) {
  return (B + W) * 3 / 4 - W;
}
function toByteArray(A) {
  var B, W = getLens(A), K = W[0], J = W[1], L = new Arr(_byteLength(A, K, J)), re = 0, ie = J > 0 ? K - 4 : K, oe;
  for (oe = 0; oe < ie; oe += 4)
    B = revLookup[A.charCodeAt(oe)] << 18 | revLookup[A.charCodeAt(oe + 1)] << 12 | revLookup[A.charCodeAt(oe + 2)] << 6 | revLookup[A.charCodeAt(oe + 3)], L[re++] = B >> 16 & 255, L[re++] = B >> 8 & 255, L[re++] = B & 255;
  return J === 2 && (B = revLookup[A.charCodeAt(oe)] << 2 | revLookup[A.charCodeAt(oe + 1)] >> 4, L[re++] = B & 255), J === 1 && (B = revLookup[A.charCodeAt(oe)] << 10 | revLookup[A.charCodeAt(oe + 1)] << 4 | revLookup[A.charCodeAt(oe + 2)] >> 2, L[re++] = B >> 8 & 255, L[re++] = B & 255), L;
}
function tripletToBase64(A) {
  return lookup[A >> 18 & 63] + lookup[A >> 12 & 63] + lookup[A >> 6 & 63] + lookup[A & 63];
}
function encodeChunk(A, B, W) {
  for (var K, J = [], L = B; L < W; L += 3)
    K = (A[L] << 16 & 16711680) + (A[L + 1] << 8 & 65280) + (A[L + 2] & 255), J.push(tripletToBase64(K));
  return J.join("");
}
function fromByteArray(A) {
  for (var B, W = A.length, K = W % 3, J = [], L = 16383, re = 0, ie = W - K; re < ie; re += L)
    J.push(encodeChunk(A, re, re + L > ie ? ie : re + L));
  return K === 1 ? (B = A[W - 1], J.push(
    lookup[B >> 2] + lookup[B << 4 & 63] + "=="
  )) : K === 2 && (B = (A[W - 2] << 8) + A[W - 1], J.push(
    lookup[B >> 10] + lookup[B >> 4 & 63] + lookup[B << 2 & 63] + "="
  )), J.join("");
}
Object.defineProperty(base64Url, "__esModule", { value: !0 });
base64Url.decode = base64Url.encode = base64Url.unescape = base64Url.escape = base64Url.pad = void 0;
const base64_js_1$1 = base64Js;
function pad(A) {
  return `${A}${"=".repeat(4 - (A.length % 4 || 4))}`;
}
base64Url.pad = pad;
function escape(A) {
  return A.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
base64Url.escape = escape;
function unescape(A) {
  return pad(A).replace(/-/g, "+").replace(/_/g, "/");
}
base64Url.unescape = unescape;
function encode$j(A) {
  return escape((0, base64_js_1$1.fromByteArray)(new TextEncoder().encode(A)));
}
base64Url.encode = encode$j;
function decode$j(A) {
  return new TextDecoder().decode((0, base64_js_1$1.toByteArray)(pad(unescape(A))));
}
base64Url.decode = decode$j;
var cryptoClients = {}, secp256k1$1 = {}, hmac$1 = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.anumber = anumber;
_assert.abytes = abytes;
_assert.ahash = ahash;
_assert.aexists = aexists;
_assert.aoutput = aoutput;
function anumber(A) {
  if (!Number.isSafeInteger(A) || A < 0)
    throw new Error("positive integer expected, got " + A);
}
function isBytes(A) {
  return A instanceof Uint8Array || ArrayBuffer.isView(A) && A.constructor.name === "Uint8Array";
}
function abytes(A, ...B) {
  if (!isBytes(A))
    throw new Error("Uint8Array expected");
  if (B.length > 0 && !B.includes(A.length))
    throw new Error("Uint8Array expected of length " + B + ", got length=" + A.length);
}
function ahash(A) {
  if (typeof A != "function" || typeof A.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber(A.outputLen), anumber(A.blockLen);
}
function aexists(A, B = !0) {
  if (A.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (B && A.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(A, B) {
  abytes(A);
  const W = B.outputLen;
  if (A.length < W)
    throw new Error("digestInto() expects output buffer of length at least " + W);
}
var utils$5 = {}, crypto$2 = {};
Object.defineProperty(crypto$2, "__esModule", { value: !0 });
crypto$2.crypto = void 0;
crypto$2.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(A) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(A, "__esModule", { value: !0 }), A.Hash = A.nextTick = A.byteSwapIfBE = A.isLE = void 0, A.isBytes = K, A.u8 = J, A.u32 = L, A.createView = re, A.rotr = ie, A.rotl = oe, A.byteSwap = ke, A.byteSwap32 = ne, A.bytesToHex = rt, A.hexToBytes = ut, A.asyncLoop = vt, A.utf8ToBytes = pt, A.toBytes = mt, A.concatBytes = gt, A.checkOpts = xt, A.wrapConstructor = Nt, A.wrapConstructorWithOpts = Et, A.wrapXOFConstructorWithOpts = bt, A.randomBytes = Bt;
  const B = crypto$2, W = _assert;
  function K(wt) {
    return wt instanceof Uint8Array || ArrayBuffer.isView(wt) && wt.constructor.name === "Uint8Array";
  }
  function J(wt) {
    return new Uint8Array(wt.buffer, wt.byteOffset, wt.byteLength);
  }
  function L(wt) {
    return new Uint32Array(wt.buffer, wt.byteOffset, Math.floor(wt.byteLength / 4));
  }
  function re(wt) {
    return new DataView(wt.buffer, wt.byteOffset, wt.byteLength);
  }
  function ie(wt, st) {
    return wt << 32 - st | wt >>> st;
  }
  function oe(wt, st) {
    return wt << st | wt >>> 32 - st >>> 0;
  }
  A.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  function ke(wt) {
    return wt << 24 & 4278190080 | wt << 8 & 16711680 | wt >>> 8 & 65280 | wt >>> 24 & 255;
  }
  A.byteSwapIfBE = A.isLE ? (wt) => wt : (wt) => ke(wt);
  function ne(wt) {
    for (let st = 0; st < wt.length; st++)
      wt[st] = ke(wt[st]);
  }
  const pe = /* @__PURE__ */ Array.from({ length: 256 }, (wt, st) => st.toString(16).padStart(2, "0"));
  function rt(wt) {
    (0, W.abytes)(wt);
    let st = "";
    for (let Oe = 0; Oe < wt.length; Oe++)
      st += pe[wt[Oe]];
    return st;
  }
  const nt = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function ot(wt) {
    if (wt >= nt._0 && wt <= nt._9)
      return wt - nt._0;
    if (wt >= nt.A && wt <= nt.F)
      return wt - (nt.A - 10);
    if (wt >= nt.a && wt <= nt.f)
      return wt - (nt.a - 10);
  }
  function ut(wt) {
    if (typeof wt != "string")
      throw new Error("hex string expected, got " + typeof wt);
    const st = wt.length, Oe = st / 2;
    if (st % 2)
      throw new Error("hex string expected, got unpadded hex of length " + st);
    const V = new Uint8Array(Oe);
    for (let ce = 0, it = 0; ce < Oe; ce++, it += 2) {
      const at = ot(wt.charCodeAt(it)), ft = ot(wt.charCodeAt(it + 1));
      if (at === void 0 || ft === void 0) {
        const lt = wt[it] + wt[it + 1];
        throw new Error('hex string expected, got non-hex character "' + lt + '" at index ' + it);
      }
      V[ce] = at * 16 + ft;
    }
    return V;
  }
  const dt = async () => {
  };
  A.nextTick = dt;
  async function vt(wt, st, Oe) {
    let V = Date.now();
    for (let ce = 0; ce < wt; ce++) {
      Oe(ce);
      const it = Date.now() - V;
      it >= 0 && it < st || (await (0, A.nextTick)(), V += it);
    }
  }
  function pt(wt) {
    if (typeof wt != "string")
      throw new Error("utf8ToBytes expected string, got " + typeof wt);
    return new Uint8Array(new TextEncoder().encode(wt));
  }
  function mt(wt) {
    return typeof wt == "string" && (wt = pt(wt)), (0, W.abytes)(wt), wt;
  }
  function gt(...wt) {
    let st = 0;
    for (let V = 0; V < wt.length; V++) {
      const ce = wt[V];
      (0, W.abytes)(ce), st += ce.length;
    }
    const Oe = new Uint8Array(st);
    for (let V = 0, ce = 0; V < wt.length; V++) {
      const it = wt[V];
      Oe.set(it, ce), ce += it.length;
    }
    return Oe;
  }
  class Pt {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  A.Hash = Pt;
  function xt(wt, st) {
    if (st !== void 0 && {}.toString.call(st) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(wt, st);
  }
  function Nt(wt) {
    const st = (V) => wt().update(mt(V)).digest(), Oe = wt();
    return st.outputLen = Oe.outputLen, st.blockLen = Oe.blockLen, st.create = () => wt(), st;
  }
  function Et(wt) {
    const st = (V, ce) => wt(ce).update(mt(V)).digest(), Oe = wt({});
    return st.outputLen = Oe.outputLen, st.blockLen = Oe.blockLen, st.create = (V) => wt(V), st;
  }
  function bt(wt) {
    const st = (V, ce) => wt(ce).update(mt(V)).digest(), Oe = wt({});
    return st.outputLen = Oe.outputLen, st.blockLen = Oe.blockLen, st.create = (V) => wt(V), st;
  }
  function Bt(wt = 32) {
    if (B.crypto && typeof B.crypto.getRandomValues == "function")
      return B.crypto.getRandomValues(new Uint8Array(wt));
    if (B.crypto && typeof B.crypto.randomBytes == "function")
      return B.crypto.randomBytes(wt);
    throw new Error("crypto.getRandomValues must be defined");
  }
})(utils$5);
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.hmac = A.HMAC = void 0;
  const B = _assert, W = utils$5;
  class K extends W.Hash {
    constructor(re, ie) {
      super(), this.finished = !1, this.destroyed = !1, (0, B.ahash)(re);
      const oe = (0, W.toBytes)(ie);
      if (this.iHash = re.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const ke = this.blockLen, ne = new Uint8Array(ke);
      ne.set(oe.length > ke ? re.create().update(oe).digest() : oe);
      for (let pe = 0; pe < ne.length; pe++)
        ne[pe] ^= 54;
      this.iHash.update(ne), this.oHash = re.create();
      for (let pe = 0; pe < ne.length; pe++)
        ne[pe] ^= 106;
      this.oHash.update(ne), ne.fill(0);
    }
    update(re) {
      return (0, B.aexists)(this), this.iHash.update(re), this;
    }
    digestInto(re) {
      (0, B.aexists)(this), (0, B.abytes)(re, this.outputLen), this.finished = !0, this.iHash.digestInto(re), this.oHash.update(re), this.oHash.digestInto(re), this.destroy();
    }
    digest() {
      const re = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(re), re;
    }
    _cloneInto(re) {
      re || (re = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: ie, iHash: oe, finished: ke, destroyed: ne, blockLen: pe, outputLen: rt } = this;
      return re = re, re.finished = ke, re.destroyed = ne, re.blockLen = pe, re.outputLen = rt, re.oHash = ie._cloneInto(re.oHash), re.iHash = oe._cloneInto(re.iHash), re;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  A.HMAC = K;
  const J = (L, re, ie) => new K(L, re).update(ie).digest();
  A.hmac = J, A.hmac.create = (L, re) => new K(L, re);
})(hmac$1);
var sha256$4 = {}, _md = {};
Object.defineProperty(_md, "__esModule", { value: !0 });
_md.HashMD = void 0;
_md.setBigUint64 = setBigUint64;
_md.Chi = Chi;
_md.Maj = Maj;
const _assert_js_1 = _assert, utils_js_1$3 = utils$5;
function setBigUint64(A, B, W, K) {
  if (typeof A.setBigUint64 == "function")
    return A.setBigUint64(B, W, K);
  const J = BigInt(32), L = BigInt(4294967295), re = Number(W >> J & L), ie = Number(W & L), oe = K ? 4 : 0, ke = K ? 0 : 4;
  A.setUint32(B + oe, re, K), A.setUint32(B + ke, ie, K);
}
function Chi(A, B, W) {
  return A & B ^ ~A & W;
}
function Maj(A, B, W) {
  return A & B ^ A & W ^ B & W;
}
class HashMD extends utils_js_1$3.Hash {
  constructor(B, W, K, J) {
    super(), this.blockLen = B, this.outputLen = W, this.padOffset = K, this.isLE = J, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(B), this.view = (0, utils_js_1$3.createView)(this.buffer);
  }
  update(B) {
    (0, _assert_js_1.aexists)(this);
    const { view: W, buffer: K, blockLen: J } = this;
    B = (0, utils_js_1$3.toBytes)(B);
    const L = B.length;
    for (let re = 0; re < L; ) {
      const ie = Math.min(J - this.pos, L - re);
      if (ie === J) {
        const oe = (0, utils_js_1$3.createView)(B);
        for (; J <= L - re; re += J)
          this.process(oe, re);
        continue;
      }
      K.set(B.subarray(re, re + ie), this.pos), this.pos += ie, re += ie, this.pos === J && (this.process(W, 0), this.pos = 0);
    }
    return this.length += B.length, this.roundClean(), this;
  }
  digestInto(B) {
    (0, _assert_js_1.aexists)(this), (0, _assert_js_1.aoutput)(B, this), this.finished = !0;
    const { buffer: W, view: K, blockLen: J, isLE: L } = this;
    let { pos: re } = this;
    W[re++] = 128, this.buffer.subarray(re).fill(0), this.padOffset > J - re && (this.process(K, 0), re = 0);
    for (let pe = re; pe < J; pe++)
      W[pe] = 0;
    setBigUint64(K, J - 8, BigInt(this.length * 8), L), this.process(K, 0);
    const ie = (0, utils_js_1$3.createView)(B), oe = this.outputLen;
    if (oe % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const ke = oe / 4, ne = this.get();
    if (ke > ne.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let pe = 0; pe < ke; pe++)
      ie.setUint32(4 * pe, ne[pe], L);
  }
  digest() {
    const { buffer: B, outputLen: W } = this;
    this.digestInto(B);
    const K = B.slice(0, W);
    return this.destroy(), K;
  }
  _cloneInto(B) {
    B || (B = new this.constructor()), B.set(...this.get());
    const { blockLen: W, buffer: K, length: J, finished: L, destroyed: re, pos: ie } = this;
    return B.length = J, B.pos = ie, B.finished = L, B.destroyed = re, J % W && B.buffer.set(K), B;
  }
}
_md.HashMD = HashMD;
Object.defineProperty(sha256$4, "__esModule", { value: !0 });
sha256$4.sha224 = sha256$4.sha256 = sha256$4.SHA256 = void 0;
const _md_js_1$2 = _md, utils_js_1$2 = utils$5, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_js_1$2.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: B, B: W, C: K, D: J, E: L, F: re, G: ie, H: oe } = this;
    return [B, W, K, J, L, re, ie, oe];
  }
  // prettier-ignore
  set(B, W, K, J, L, re, ie, oe) {
    this.A = B | 0, this.B = W | 0, this.C = K | 0, this.D = J | 0, this.E = L | 0, this.F = re | 0, this.G = ie | 0, this.H = oe | 0;
  }
  process(B, W) {
    for (let pe = 0; pe < 16; pe++, W += 4)
      SHA256_W[pe] = B.getUint32(W, !1);
    for (let pe = 16; pe < 64; pe++) {
      const rt = SHA256_W[pe - 15], nt = SHA256_W[pe - 2], ot = (0, utils_js_1$2.rotr)(rt, 7) ^ (0, utils_js_1$2.rotr)(rt, 18) ^ rt >>> 3, ut = (0, utils_js_1$2.rotr)(nt, 17) ^ (0, utils_js_1$2.rotr)(nt, 19) ^ nt >>> 10;
      SHA256_W[pe] = ut + SHA256_W[pe - 7] + ot + SHA256_W[pe - 16] | 0;
    }
    let { A: K, B: J, C: L, D: re, E: ie, F: oe, G: ke, H: ne } = this;
    for (let pe = 0; pe < 64; pe++) {
      const rt = (0, utils_js_1$2.rotr)(ie, 6) ^ (0, utils_js_1$2.rotr)(ie, 11) ^ (0, utils_js_1$2.rotr)(ie, 25), nt = ne + rt + (0, _md_js_1$2.Chi)(ie, oe, ke) + SHA256_K[pe] + SHA256_W[pe] | 0, ut = ((0, utils_js_1$2.rotr)(K, 2) ^ (0, utils_js_1$2.rotr)(K, 13) ^ (0, utils_js_1$2.rotr)(K, 22)) + (0, _md_js_1$2.Maj)(K, J, L) | 0;
      ne = ke, ke = oe, oe = ie, ie = re + nt | 0, re = L, L = J, J = K, K = nt + ut | 0;
    }
    K = K + this.A | 0, J = J + this.B | 0, L = L + this.C | 0, re = re + this.D | 0, ie = ie + this.E | 0, oe = oe + this.F | 0, ke = ke + this.G | 0, ne = ne + this.H | 0, this.set(K, J, L, re, ie, oe, ke, ne);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha256$4.SHA256 = SHA256;
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
sha256$4.sha256 = (0, utils_js_1$2.wrapConstructor)(() => new SHA256());
sha256$4.sha224 = (0, utils_js_1$2.wrapConstructor)(() => new SHA224());
var lib = {}, cryptoBrowserify = {}, browser$b = { exports: {} }, safeBuffer$1 = { exports: {} };
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(dist$1);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(A, B) {
  var W = require$$0$1, K = W.Buffer;
  function J(re, ie) {
    for (var oe in re)
      ie[oe] = re[oe];
  }
  K.from && K.alloc && K.allocUnsafe && K.allocUnsafeSlow ? A.exports = W : (J(W, B), B.Buffer = L);
  function L(re, ie, oe) {
    return K(re, ie, oe);
  }
  L.prototype = Object.create(K.prototype), J(K, L), L.from = function(re, ie, oe) {
    if (typeof re == "number")
      throw new TypeError("Argument must not be a number");
    return K(re, ie, oe);
  }, L.alloc = function(re, ie, oe) {
    if (typeof re != "number")
      throw new TypeError("Argument must be a number");
    var ke = K(re);
    return ie !== void 0 ? typeof oe == "string" ? ke.fill(ie, oe) : ke.fill(ie) : ke.fill(0), ke;
  }, L.allocUnsafe = function(re) {
    if (typeof re != "number")
      throw new TypeError("Argument must be a number");
    return K(re);
  }, L.allocUnsafeSlow = function(re) {
    if (typeof re != "number")
      throw new TypeError("Argument must be a number");
    return W.SlowBuffer(re);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$b.exports;
  hasRequiredBrowser$b = 1;
  var A = 65536, B = 4294967295;
  function W() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var K = safeBufferExports.Buffer, J = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  J && J.getRandomValues ? browser$b.exports = L : browser$b.exports = W;
  function L(re, ie) {
    if (re > B) throw new RangeError("requested too many random bytes");
    var oe = K.allocUnsafe(re);
    if (re > 0)
      if (re > A)
        for (var ke = 0; ke < re; ke += A)
          J.getRandomValues(oe.slice(ke, ke + A));
      else
        J.getRandomValues(oe);
    return typeof ie == "function" ? process$1.nextTick(function() {
      ie(null, oe);
    }) : oe;
  }
  return browser$b.exports;
}
var inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(B, W) {
    W && (B.super_ = W, B.prototype = Object.create(W.prototype, {
      constructor: {
        value: B,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(B, W) {
    if (W) {
      B.super_ = W;
      var K = function() {
      };
      K.prototype = W.prototype, B.prototype = new K(), B.prototype.constructor = B;
    }
  }), inherits_browser.exports;
}
var readableBrowser$1 = { exports: {} }, events = { exports: {} }, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var A = typeof Reflect == "object" ? Reflect : null, B = A && typeof A.apply == "function" ? A.apply : function(Pt, xt, Nt) {
    return Function.prototype.apply.call(Pt, xt, Nt);
  }, W;
  A && typeof A.ownKeys == "function" ? W = A.ownKeys : Object.getOwnPropertySymbols ? W = function(Pt) {
    return Object.getOwnPropertyNames(Pt).concat(Object.getOwnPropertySymbols(Pt));
  } : W = function(Pt) {
    return Object.getOwnPropertyNames(Pt);
  };
  function K(gt) {
    console && console.warn && console.warn(gt);
  }
  var J = Number.isNaN || function(Pt) {
    return Pt !== Pt;
  };
  function L() {
    L.init.call(this);
  }
  events.exports = L, events.exports.once = vt, L.EventEmitter = L, L.prototype._events = void 0, L.prototype._eventsCount = 0, L.prototype._maxListeners = void 0;
  var re = 10;
  function ie(gt) {
    if (typeof gt != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof gt);
  }
  Object.defineProperty(L, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return re;
    },
    set: function(gt) {
      if (typeof gt != "number" || gt < 0 || J(gt))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + gt + ".");
      re = gt;
    }
  }), L.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, L.prototype.setMaxListeners = function(Pt) {
    if (typeof Pt != "number" || Pt < 0 || J(Pt))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + Pt + ".");
    return this._maxListeners = Pt, this;
  };
  function oe(gt) {
    return gt._maxListeners === void 0 ? L.defaultMaxListeners : gt._maxListeners;
  }
  L.prototype.getMaxListeners = function() {
    return oe(this);
  }, L.prototype.emit = function(Pt) {
    for (var xt = [], Nt = 1; Nt < arguments.length; Nt++) xt.push(arguments[Nt]);
    var Et = Pt === "error", bt = this._events;
    if (bt !== void 0)
      Et = Et && bt.error === void 0;
    else if (!Et)
      return !1;
    if (Et) {
      var Bt;
      if (xt.length > 0 && (Bt = xt[0]), Bt instanceof Error)
        throw Bt;
      var wt = new Error("Unhandled error." + (Bt ? " (" + Bt.message + ")" : ""));
      throw wt.context = Bt, wt;
    }
    var st = bt[Pt];
    if (st === void 0)
      return !1;
    if (typeof st == "function")
      B(st, this, xt);
    else
      for (var Oe = st.length, V = ot(st, Oe), Nt = 0; Nt < Oe; ++Nt)
        B(V[Nt], this, xt);
    return !0;
  };
  function ke(gt, Pt, xt, Nt) {
    var Et, bt, Bt;
    if (ie(xt), bt = gt._events, bt === void 0 ? (bt = gt._events = /* @__PURE__ */ Object.create(null), gt._eventsCount = 0) : (bt.newListener !== void 0 && (gt.emit(
      "newListener",
      Pt,
      xt.listener ? xt.listener : xt
    ), bt = gt._events), Bt = bt[Pt]), Bt === void 0)
      Bt = bt[Pt] = xt, ++gt._eventsCount;
    else if (typeof Bt == "function" ? Bt = bt[Pt] = Nt ? [xt, Bt] : [Bt, xt] : Nt ? Bt.unshift(xt) : Bt.push(xt), Et = oe(gt), Et > 0 && Bt.length > Et && !Bt.warned) {
      Bt.warned = !0;
      var wt = new Error("Possible EventEmitter memory leak detected. " + Bt.length + " " + String(Pt) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      wt.name = "MaxListenersExceededWarning", wt.emitter = gt, wt.type = Pt, wt.count = Bt.length, K(wt);
    }
    return gt;
  }
  L.prototype.addListener = function(Pt, xt) {
    return ke(this, Pt, xt, !1);
  }, L.prototype.on = L.prototype.addListener, L.prototype.prependListener = function(Pt, xt) {
    return ke(this, Pt, xt, !0);
  };
  function ne() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function pe(gt, Pt, xt) {
    var Nt = { fired: !1, wrapFn: void 0, target: gt, type: Pt, listener: xt }, Et = ne.bind(Nt);
    return Et.listener = xt, Nt.wrapFn = Et, Et;
  }
  L.prototype.once = function(Pt, xt) {
    return ie(xt), this.on(Pt, pe(this, Pt, xt)), this;
  }, L.prototype.prependOnceListener = function(Pt, xt) {
    return ie(xt), this.prependListener(Pt, pe(this, Pt, xt)), this;
  }, L.prototype.removeListener = function(Pt, xt) {
    var Nt, Et, bt, Bt, wt;
    if (ie(xt), Et = this._events, Et === void 0)
      return this;
    if (Nt = Et[Pt], Nt === void 0)
      return this;
    if (Nt === xt || Nt.listener === xt)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete Et[Pt], Et.removeListener && this.emit("removeListener", Pt, Nt.listener || xt));
    else if (typeof Nt != "function") {
      for (bt = -1, Bt = Nt.length - 1; Bt >= 0; Bt--)
        if (Nt[Bt] === xt || Nt[Bt].listener === xt) {
          wt = Nt[Bt].listener, bt = Bt;
          break;
        }
      if (bt < 0)
        return this;
      bt === 0 ? Nt.shift() : ut(Nt, bt), Nt.length === 1 && (Et[Pt] = Nt[0]), Et.removeListener !== void 0 && this.emit("removeListener", Pt, wt || xt);
    }
    return this;
  }, L.prototype.off = L.prototype.removeListener, L.prototype.removeAllListeners = function(Pt) {
    var xt, Nt, Et;
    if (Nt = this._events, Nt === void 0)
      return this;
    if (Nt.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Nt[Pt] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Nt[Pt]), this;
    if (arguments.length === 0) {
      var bt = Object.keys(Nt), Bt;
      for (Et = 0; Et < bt.length; ++Et)
        Bt = bt[Et], Bt !== "removeListener" && this.removeAllListeners(Bt);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (xt = Nt[Pt], typeof xt == "function")
      this.removeListener(Pt, xt);
    else if (xt !== void 0)
      for (Et = xt.length - 1; Et >= 0; Et--)
        this.removeListener(Pt, xt[Et]);
    return this;
  };
  function rt(gt, Pt, xt) {
    var Nt = gt._events;
    if (Nt === void 0)
      return [];
    var Et = Nt[Pt];
    return Et === void 0 ? [] : typeof Et == "function" ? xt ? [Et.listener || Et] : [Et] : xt ? dt(Et) : ot(Et, Et.length);
  }
  L.prototype.listeners = function(Pt) {
    return rt(this, Pt, !0);
  }, L.prototype.rawListeners = function(Pt) {
    return rt(this, Pt, !1);
  }, L.listenerCount = function(gt, Pt) {
    return typeof gt.listenerCount == "function" ? gt.listenerCount(Pt) : nt.call(gt, Pt);
  }, L.prototype.listenerCount = nt;
  function nt(gt) {
    var Pt = this._events;
    if (Pt !== void 0) {
      var xt = Pt[gt];
      if (typeof xt == "function")
        return 1;
      if (xt !== void 0)
        return xt.length;
    }
    return 0;
  }
  L.prototype.eventNames = function() {
    return this._eventsCount > 0 ? W(this._events) : [];
  };
  function ot(gt, Pt) {
    for (var xt = new Array(Pt), Nt = 0; Nt < Pt; ++Nt)
      xt[Nt] = gt[Nt];
    return xt;
  }
  function ut(gt, Pt) {
    for (; Pt + 1 < gt.length; Pt++)
      gt[Pt] = gt[Pt + 1];
    gt.pop();
  }
  function dt(gt) {
    for (var Pt = new Array(gt.length), xt = 0; xt < Pt.length; ++xt)
      Pt[xt] = gt[xt].listener || gt[xt];
    return Pt;
  }
  function vt(gt, Pt) {
    return new Promise(function(xt, Nt) {
      function Et(Bt) {
        gt.removeListener(Pt, bt), Nt(Bt);
      }
      function bt() {
        typeof gt.removeListener == "function" && gt.removeListener("error", Et), xt([].slice.call(arguments));
      }
      mt(gt, Pt, bt, { once: !0 }), Pt !== "error" && pt(gt, Et, { once: !0 });
    });
  }
  function pt(gt, Pt, xt) {
    typeof gt.on == "function" && mt(gt, "error", Pt, xt);
  }
  function mt(gt, Pt, xt, Nt) {
    if (typeof gt.on == "function")
      Nt.once ? gt.once(Pt, xt) : gt.on(Pt, xt);
    else if (typeof gt.addEventListener == "function")
      gt.addEventListener(Pt, function Et(bt) {
        Nt.once && gt.removeEventListener(Pt, Et), xt(bt);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof gt);
  }
  return events.exports;
}
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = requireEvents().EventEmitter), streamBrowser$1;
}
var util$1 = {}, types$5 = {}, shams$1, hasRequiredShams$1;
function requireShams$1() {
  return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var B = {}, W = Symbol("test"), K = Object(W);
    if (typeof W == "string" || Object.prototype.toString.call(W) !== "[object Symbol]" || Object.prototype.toString.call(K) !== "[object Symbol]")
      return !1;
    var J = 42;
    B[W] = J;
    for (var L in B)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(B).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(B).length !== 0)
      return !1;
    var re = Object.getOwnPropertySymbols(B);
    if (re.length !== 1 || re[0] !== W || !Object.prototype.propertyIsEnumerable.call(B, W))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var ie = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(B, W)
      );
      if (ie.value !== J || ie.enumerable !== !0)
        return !1;
    }
    return !0;
  }), shams$1;
}
var shams, hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var A = requireShams$1();
  return shams = function() {
    return A() && !!Symbol.toStringTag;
  }, shams;
}
var esObjectAtoms, hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  return hasRequiredEsObjectAtoms || (hasRequiredEsObjectAtoms = 1, esObjectAtoms = Object), esObjectAtoms;
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
  return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors;
}
var _eval, hasRequired_eval;
function require_eval() {
  return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval;
}
var range$3, hasRequiredRange;
function requireRange() {
  return hasRequiredRange || (hasRequiredRange = 1, range$3 = RangeError), range$3;
}
var ref, hasRequiredRef;
function requireRef() {
  return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref;
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
  return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax;
}
var type, hasRequiredType;
function requireType() {
  return hasRequiredType || (hasRequiredType = 1, type = TypeError), type;
}
var uri, hasRequiredUri;
function requireUri() {
  return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri;
}
var abs, hasRequiredAbs;
function requireAbs() {
  return hasRequiredAbs || (hasRequiredAbs = 1, abs = Math.abs), abs;
}
var floor, hasRequiredFloor;
function requireFloor() {
  return hasRequiredFloor || (hasRequiredFloor = 1, floor = Math.floor), floor;
}
var max, hasRequiredMax;
function requireMax() {
  return hasRequiredMax || (hasRequiredMax = 1, max = Math.max), max;
}
var min, hasRequiredMin;
function requireMin() {
  return hasRequiredMin || (hasRequiredMin = 1, min = Math.min), min;
}
var pow, hasRequiredPow;
function requirePow() {
  return hasRequiredPow || (hasRequiredPow = 1, pow = Math.pow), pow;
}
var round, hasRequiredRound;
function requireRound() {
  return hasRequiredRound || (hasRequiredRound = 1, round = Math.round), round;
}
var _isNaN, hasRequired_isNaN;
function require_isNaN() {
  return hasRequired_isNaN || (hasRequired_isNaN = 1, _isNaN = Number.isNaN || function(B) {
    return B !== B;
  }), _isNaN;
}
var sign$1, hasRequiredSign$1;
function requireSign$1() {
  if (hasRequiredSign$1) return sign$1;
  hasRequiredSign$1 = 1;
  var A = require_isNaN();
  return sign$1 = function(W) {
    return A(W) || W === 0 ? W : W < 0 ? -1 : 1;
  }, sign$1;
}
var gOPD, hasRequiredGOPD;
function requireGOPD() {
  return hasRequiredGOPD || (hasRequiredGOPD = 1, gOPD = Object.getOwnPropertyDescriptor), gOPD;
}
var gopd, hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var A = requireGOPD();
  if (A)
    try {
      A([], "length");
    } catch {
      A = null;
    }
  return gopd = A, gopd;
}
var esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var A = Object.defineProperty || !1;
  if (A)
    try {
      A({}, "a", { value: 1 });
    } catch {
      A = !1;
    }
  return esDefineProperty = A, esDefineProperty;
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var A = typeof Symbol < "u" && Symbol, B = requireShams$1();
  return hasSymbols = function() {
    return typeof A != "function" || typeof Symbol != "function" || typeof A("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : B();
  }, hasSymbols;
}
var Reflect_getPrototypeOf, hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  return hasRequiredReflect_getPrototypeOf || (hasRequiredReflect_getPrototypeOf = 1, Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Reflect_getPrototypeOf;
}
var Object_getPrototypeOf, hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var A = requireEsObjectAtoms();
  return Object_getPrototypeOf = A.getPrototypeOf || null, Object_getPrototypeOf;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var A = "Function.prototype.bind called on incompatible ", B = Object.prototype.toString, W = Math.max, K = "[object Function]", J = function(oe, ke) {
    for (var ne = [], pe = 0; pe < oe.length; pe += 1)
      ne[pe] = oe[pe];
    for (var rt = 0; rt < ke.length; rt += 1)
      ne[rt + oe.length] = ke[rt];
    return ne;
  }, L = function(oe, ke) {
    for (var ne = [], pe = ke, rt = 0; pe < oe.length; pe += 1, rt += 1)
      ne[rt] = oe[pe];
    return ne;
  }, re = function(ie, oe) {
    for (var ke = "", ne = 0; ne < ie.length; ne += 1)
      ke += ie[ne], ne + 1 < ie.length && (ke += oe);
    return ke;
  };
  return implementation = function(oe) {
    var ke = this;
    if (typeof ke != "function" || B.apply(ke) !== K)
      throw new TypeError(A + ke);
    for (var ne = L(arguments, 1), pe, rt = function() {
      if (this instanceof pe) {
        var vt = ke.apply(
          this,
          J(ne, arguments)
        );
        return Object(vt) === vt ? vt : this;
      }
      return ke.apply(
        oe,
        J(ne, arguments)
      );
    }, nt = W(0, ke.length - ne.length), ot = [], ut = 0; ut < nt; ut++)
      ot[ut] = "$" + ut;
    if (pe = Function("binder", "return function (" + re(ot, ",") + "){ return binder.apply(this,arguments); }")(rt), ke.prototype) {
      var dt = function() {
      };
      dt.prototype = ke.prototype, pe.prototype = new dt(), dt.prototype = null;
    }
    return pe;
  }, implementation;
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var A = requireImplementation();
  return functionBind = Function.prototype.bind || A, functionBind;
}
var functionCall, hasRequiredFunctionCall;
function requireFunctionCall() {
  return hasRequiredFunctionCall || (hasRequiredFunctionCall = 1, functionCall = Function.prototype.call), functionCall;
}
var functionApply, hasRequiredFunctionApply;
function requireFunctionApply() {
  return hasRequiredFunctionApply || (hasRequiredFunctionApply = 1, functionApply = Function.prototype.apply), functionApply;
}
var reflectApply, hasRequiredReflectApply;
function requireReflectApply() {
  return hasRequiredReflectApply || (hasRequiredReflectApply = 1, reflectApply = typeof Reflect < "u" && Reflect && Reflect.apply), reflectApply;
}
var actualApply, hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var A = requireFunctionBind(), B = requireFunctionApply(), W = requireFunctionCall(), K = requireReflectApply();
  return actualApply = K || A.call(W, B), actualApply;
}
var callBindApplyHelpers, hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var A = requireFunctionBind(), B = requireType(), W = requireFunctionCall(), K = requireActualApply();
  return callBindApplyHelpers = function(L) {
    if (L.length < 1 || typeof L[0] != "function")
      throw new B("a function is required");
    return K(A, W, L);
  }, callBindApplyHelpers;
}
var get, hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var A = requireCallBindApplyHelpers(), B = requireGopd(), W;
  try {
    W = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (re) {
    if (!re || typeof re != "object" || !("code" in re) || re.code !== "ERR_PROTO_ACCESS")
      throw re;
  }
  var K = !!W && B && B(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), J = Object, L = J.getPrototypeOf;
  return get = K && typeof K.get == "function" ? A([K.get]) : typeof L == "function" ? (
    /** @type {import('./get')} */
    function(ie) {
      return L(ie == null ? ie : J(ie));
    }
  ) : !1, get;
}
var getProto, hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var A = requireReflect_getPrototypeOf(), B = requireObject_getPrototypeOf(), W = requireGet();
  return getProto = A ? function(J) {
    return A(J);
  } : B ? function(J) {
    if (!J || typeof J != "object" && typeof J != "function")
      throw new TypeError("getProto: not an object");
    return B(J);
  } : W ? function(J) {
    return W(J);
  } : null, getProto;
}
var hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var A = Function.prototype.call, B = Object.prototype.hasOwnProperty, W = requireFunctionBind();
  return hasown = W.call(A, B), hasown;
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var A, B = requireEsObjectAtoms(), W = requireEsErrors(), K = require_eval(), J = requireRange(), L = requireRef(), re = requireSyntax(), ie = requireType(), oe = requireUri(), ke = requireAbs(), ne = requireFloor(), pe = requireMax(), rt = requireMin(), nt = requirePow(), ot = requireRound(), ut = requireSign$1(), dt = Function, vt = function(Lt) {
    try {
      return dt('"use strict"; return (' + Lt + ").constructor;")();
    } catch {
    }
  }, pt = requireGopd(), mt = requireEsDefineProperty(), gt = function() {
    throw new ie();
  }, Pt = pt ? function() {
    try {
      return arguments.callee, gt;
    } catch {
      try {
        return pt(arguments, "callee").get;
      } catch {
        return gt;
      }
    }
  }() : gt, xt = requireHasSymbols()(), Nt = requireGetProto(), Et = requireObject_getPrototypeOf(), bt = requireReflect_getPrototypeOf(), Bt = requireFunctionApply(), wt = requireFunctionCall(), st = {}, Oe = typeof Uint8Array > "u" || !Nt ? A : Nt(Uint8Array), V = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? A : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? A : ArrayBuffer,
    "%ArrayIteratorPrototype%": xt && Nt ? Nt([][Symbol.iterator]()) : A,
    "%AsyncFromSyncIteratorPrototype%": A,
    "%AsyncFunction%": st,
    "%AsyncGenerator%": st,
    "%AsyncGeneratorFunction%": st,
    "%AsyncIteratorPrototype%": st,
    "%Atomics%": typeof Atomics > "u" ? A : Atomics,
    "%BigInt%": typeof BigInt > "u" ? A : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? A : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? A : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? A : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": W,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": K,
    "%Float16Array%": typeof Float16Array > "u" ? A : Float16Array,
    "%Float32Array%": typeof Float32Array > "u" ? A : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? A : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? A : FinalizationRegistry,
    "%Function%": dt,
    "%GeneratorFunction%": st,
    "%Int8Array%": typeof Int8Array > "u" ? A : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? A : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? A : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": xt && Nt ? Nt(Nt([][Symbol.iterator]())) : A,
    "%JSON%": typeof JSON == "object" ? JSON : A,
    "%Map%": typeof Map > "u" ? A : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !xt || !Nt ? A : Nt((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": B,
    "%Object.getOwnPropertyDescriptor%": pt,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? A : Promise,
    "%Proxy%": typeof Proxy > "u" ? A : Proxy,
    "%RangeError%": J,
    "%ReferenceError%": L,
    "%Reflect%": typeof Reflect > "u" ? A : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? A : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !xt || !Nt ? A : Nt((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? A : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": xt && Nt ? Nt(""[Symbol.iterator]()) : A,
    "%Symbol%": xt ? Symbol : A,
    "%SyntaxError%": re,
    "%ThrowTypeError%": Pt,
    "%TypedArray%": Oe,
    "%TypeError%": ie,
    "%Uint8Array%": typeof Uint8Array > "u" ? A : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? A : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? A : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? A : Uint32Array,
    "%URIError%": oe,
    "%WeakMap%": typeof WeakMap > "u" ? A : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? A : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? A : WeakSet,
    "%Function.prototype.call%": wt,
    "%Function.prototype.apply%": Bt,
    "%Object.defineProperty%": mt,
    "%Object.getPrototypeOf%": Et,
    "%Math.abs%": ke,
    "%Math.floor%": ne,
    "%Math.max%": pe,
    "%Math.min%": rt,
    "%Math.pow%": nt,
    "%Math.round%": ot,
    "%Math.sign%": ut,
    "%Reflect.getPrototypeOf%": bt
  };
  if (Nt)
    try {
      null.error;
    } catch (Lt) {
      var ce = Nt(Nt(Lt));
      V["%Error.prototype%"] = ce;
    }
  var it = function Lt(Kt) {
    var Tt;
    if (Kt === "%AsyncFunction%")
      Tt = vt("async function () {}");
    else if (Kt === "%GeneratorFunction%")
      Tt = vt("function* () {}");
    else if (Kt === "%AsyncGeneratorFunction%")
      Tt = vt("async function* () {}");
    else if (Kt === "%AsyncGenerator%") {
      var Rt = Lt("%AsyncGeneratorFunction%");
      Rt && (Tt = Rt.prototype);
    } else if (Kt === "%AsyncIteratorPrototype%") {
      var Wt = Lt("%AsyncGenerator%");
      Wt && Nt && (Tt = Nt(Wt.prototype));
    }
    return V[Kt] = Tt, Tt;
  }, at = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, ft = requireFunctionBind(), lt = requireHasown(), ct = ft.call(wt, Array.prototype.concat), ht = ft.call(Bt, Array.prototype.splice), Ce = ft.call(wt, String.prototype.replace), yt = ft.call(wt, String.prototype.slice), qt = ft.call(wt, RegExp.prototype.exec), jt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, kt = /\\(\\)?/g, $t = function(Kt) {
    var Tt = yt(Kt, 0, 1), Rt = yt(Kt, -1);
    if (Tt === "%" && Rt !== "%")
      throw new re("invalid intrinsic syntax, expected closing `%`");
    if (Rt === "%" && Tt !== "%")
      throw new re("invalid intrinsic syntax, expected opening `%`");
    var Wt = [];
    return Ce(Kt, jt, function(Xt, Zt, ar, fr) {
      Wt[Wt.length] = ar ? Ce(fr, kt, "$1") : Zt || Xt;
    }), Wt;
  }, Mt = function(Kt, Tt) {
    var Rt = Kt, Wt;
    if (lt(at, Rt) && (Wt = at[Rt], Rt = "%" + Wt[0] + "%"), lt(V, Rt)) {
      var Xt = V[Rt];
      if (Xt === st && (Xt = it(Rt)), typeof Xt > "u" && !Tt)
        throw new ie("intrinsic " + Kt + " exists, but is not available. Please file an issue!");
      return {
        alias: Wt,
        name: Rt,
        value: Xt
      };
    }
    throw new re("intrinsic " + Kt + " does not exist!");
  };
  return getIntrinsic = function(Kt, Tt) {
    if (typeof Kt != "string" || Kt.length === 0)
      throw new ie("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof Tt != "boolean")
      throw new ie('"allowMissing" argument must be a boolean');
    if (qt(/^%?[^%]*%?$/, Kt) === null)
      throw new re("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var Rt = $t(Kt), Wt = Rt.length > 0 ? Rt[0] : "", Xt = Mt("%" + Wt + "%", Tt), Zt = Xt.name, ar = Xt.value, fr = !1, lr = Xt.alias;
    lr && (Wt = lr[0], ht(Rt, ct([0, 1], lr)));
    for (var Jt = 1, _r = !0; Jt < Rt.length; Jt += 1) {
      var sr = Rt[Jt], Mr = yt(sr, 0, 1), Sr = yt(sr, -1);
      if ((Mr === '"' || Mr === "'" || Mr === "`" || Sr === '"' || Sr === "'" || Sr === "`") && Mr !== Sr)
        throw new re("property names with quotes must have matching quotes");
      if ((sr === "constructor" || !_r) && (fr = !0), Wt += "." + sr, Zt = "%" + Wt + "%", lt(V, Zt))
        ar = V[Zt];
      else if (ar != null) {
        if (!(sr in ar)) {
          if (!Tt)
            throw new ie("base intrinsic for " + Kt + " exists, but the property is not available.");
          return;
        }
        if (pt && Jt + 1 >= Rt.length) {
          var cr = pt(ar, sr);
          _r = !!cr, _r && "get" in cr && !("originalValue" in cr.get) ? ar = cr.get : ar = ar[sr];
        } else
          _r = lt(ar, sr), ar = ar[sr];
        _r && !fr && (V[Zt] = ar);
      }
    }
    return ar;
  }, getIntrinsic;
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var A = requireGetIntrinsic(), B = requireCallBindApplyHelpers(), W = B([A("%String.prototype.indexOf%")]);
  return callBound = function(J, L) {
    var re = (
      /** @type {Parameters<typeof callBindBasic>[0][0]} */
      A(J, !!L)
    );
    return typeof re == "function" && W(J, ".prototype.") > -1 ? B([re]) : re;
  }, callBound;
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var A = requireShams()(), B = requireCallBound(), W = B("Object.prototype.toString"), K = function(ie) {
    return A && ie && typeof ie == "object" && Symbol.toStringTag in ie ? !1 : W(ie) === "[object Arguments]";
  }, J = function(ie) {
    return K(ie) ? !0 : ie !== null && typeof ie == "object" && "length" in ie && typeof ie.length == "number" && ie.length >= 0 && W(ie) !== "[object Array]" && "callee" in ie && W(ie.callee) === "[object Function]";
  }, L = function() {
    return K(arguments);
  }();
  return K.isLegacyArguments = J, isArguments = L ? K : J, isArguments;
}
var isRegex, hasRequiredIsRegex;
function requireIsRegex() {
  if (hasRequiredIsRegex) return isRegex;
  hasRequiredIsRegex = 1;
  var A = requireCallBound(), B = requireShams()(), W = requireHasown(), K = requireGopd(), J;
  if (B) {
    var L = A("RegExp.prototype.exec"), re = {}, ie = function() {
      throw re;
    }, oe = {
      toString: ie,
      valueOf: ie
    };
    typeof Symbol.toPrimitive == "symbol" && (oe[Symbol.toPrimitive] = ie), J = function(rt) {
      if (!rt || typeof rt != "object")
        return !1;
      var nt = (
        /** @type {NonNullable<typeof gOPD>} */
        K(
          /** @type {{ lastIndex?: unknown }} */
          rt,
          "lastIndex"
        )
      ), ot = nt && W(nt, "value");
      if (!ot)
        return !1;
      try {
        L(
          rt,
          /** @type {string} */
          /** @type {unknown} */
          oe
        );
      } catch (ut) {
        return ut === re;
      }
    };
  } else {
    var ke = A("Object.prototype.toString"), ne = "[object RegExp]";
    J = function(rt) {
      return !rt || typeof rt != "object" && typeof rt != "function" ? !1 : ke(rt) === ne;
    };
  }
  return isRegex = J, isRegex;
}
var safeRegexTest, hasRequiredSafeRegexTest;
function requireSafeRegexTest() {
  if (hasRequiredSafeRegexTest) return safeRegexTest;
  hasRequiredSafeRegexTest = 1;
  var A = requireCallBound(), B = requireIsRegex(), W = A("RegExp.prototype.exec"), K = requireType();
  return safeRegexTest = function(L) {
    if (!B(L))
      throw new K("`regex` must be a RegExp");
    return function(ie) {
      return W(L, ie) !== null;
    };
  }, safeRegexTest;
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var A = requireCallBound(), B = requireSafeRegexTest(), W = B(/^\s*(?:function)?\*/), K = requireShams()(), J = requireGetProto(), L = A("Object.prototype.toString"), re = A("Function.prototype.toString"), ie = function() {
    if (!K)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, oe;
  return isGeneratorFunction = function(ne) {
    if (typeof ne != "function")
      return !1;
    if (W(re(ne)))
      return !0;
    if (!K) {
      var pe = L(ne);
      return pe === "[object GeneratorFunction]";
    }
    if (!J)
      return !1;
    if (typeof oe > "u") {
      var rt = ie();
      oe = rt ? (
        /** @type {GeneratorFunctionConstructor} */
        J(rt)
      ) : !1;
    }
    return J(ne) === oe;
  }, isGeneratorFunction;
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var A = Function.prototype.toString, B = typeof Reflect == "object" && Reflect !== null && Reflect.apply, W, K;
  if (typeof B == "function" && typeof Object.defineProperty == "function")
    try {
      W = Object.defineProperty({}, "length", {
        get: function() {
          throw K;
        }
      }), K = {}, B(function() {
        throw 42;
      }, null, W);
    } catch (pt) {
      pt !== K && (B = null);
    }
  else
    B = null;
  var J = /^\s*class\b/, L = function(mt) {
    try {
      var gt = A.call(mt);
      return J.test(gt);
    } catch {
      return !1;
    }
  }, re = function(mt) {
    try {
      return L(mt) ? !1 : (A.call(mt), !0);
    } catch {
      return !1;
    }
  }, ie = Object.prototype.toString, oe = "[object Object]", ke = "[object Function]", ne = "[object GeneratorFunction]", pe = "[object HTMLAllCollection]", rt = "[object HTML document.all class]", nt = "[object HTMLCollection]", ot = typeof Symbol == "function" && !!Symbol.toStringTag, ut = !(0 in [,]), dt = function() {
    return !1;
  };
  if (typeof document == "object") {
    var vt = document.all;
    ie.call(vt) === ie.call(document.all) && (dt = function(mt) {
      if ((ut || !mt) && (typeof mt > "u" || typeof mt == "object"))
        try {
          var gt = ie.call(mt);
          return (gt === pe || gt === rt || gt === nt || gt === oe) && mt("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = B ? function(mt) {
    if (dt(mt))
      return !0;
    if (!mt || typeof mt != "function" && typeof mt != "object")
      return !1;
    try {
      B(mt, null, W);
    } catch (gt) {
      if (gt !== K)
        return !1;
    }
    return !L(mt) && re(mt);
  } : function(mt) {
    if (dt(mt))
      return !0;
    if (!mt || typeof mt != "function" && typeof mt != "object")
      return !1;
    if (ot)
      return re(mt);
    if (L(mt))
      return !1;
    var gt = ie.call(mt);
    return gt !== ke && gt !== ne && !/^\[object HTML/.test(gt) ? !1 : re(mt);
  }, isCallable;
}
var forEach, hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach;
  hasRequiredForEach = 1;
  var A = requireIsCallable(), B = Object.prototype.toString, W = Object.prototype.hasOwnProperty, K = function(oe, ke, ne) {
    for (var pe = 0, rt = oe.length; pe < rt; pe++)
      W.call(oe, pe) && (ne == null ? ke(oe[pe], pe, oe) : ke.call(ne, oe[pe], pe, oe));
  }, J = function(oe, ke, ne) {
    for (var pe = 0, rt = oe.length; pe < rt; pe++)
      ne == null ? ke(oe.charAt(pe), pe, oe) : ke.call(ne, oe.charAt(pe), pe, oe);
  }, L = function(oe, ke, ne) {
    for (var pe in oe)
      W.call(oe, pe) && (ne == null ? ke(oe[pe], pe, oe) : ke.call(ne, oe[pe], pe, oe));
  };
  function re(ie) {
    return B.call(ie) === "[object Array]";
  }
  return forEach = function(oe, ke, ne) {
    if (!A(ke))
      throw new TypeError("iterator must be a function");
    var pe;
    arguments.length >= 3 && (pe = ne), re(oe) ? K(oe, ke, pe) : typeof oe == "string" ? J(oe, ke, pe) : L(oe, ke, pe);
  }, forEach;
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), possibleTypedArrayNames;
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var A = requirePossibleTypedArrayNames(), B = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var K = [], J = 0; J < A.length; J++)
      typeof B[A[J]] == "function" && (K[K.length] = A[J]);
    return K;
  }, availableTypedArrays;
}
var callBind = { exports: {} }, defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var A = requireEsDefineProperty(), B = requireSyntax(), W = requireType(), K = requireGopd();
  return defineDataProperty = function(L, re, ie) {
    if (!L || typeof L != "object" && typeof L != "function")
      throw new W("`obj` must be an object or a function`");
    if (typeof re != "string" && typeof re != "symbol")
      throw new W("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new W("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new W("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new W("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new W("`loose`, if provided, must be a boolean");
    var oe = arguments.length > 3 ? arguments[3] : null, ke = arguments.length > 4 ? arguments[4] : null, ne = arguments.length > 5 ? arguments[5] : null, pe = arguments.length > 6 ? arguments[6] : !1, rt = !!K && K(L, re);
    if (A)
      A(L, re, {
        configurable: ne === null && rt ? rt.configurable : !ne,
        enumerable: oe === null && rt ? rt.enumerable : !oe,
        value: ie,
        writable: ke === null && rt ? rt.writable : !ke
      });
    else if (pe || !oe && !ke && !ne)
      L[re] = ie;
    else
      throw new B("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, defineDataProperty;
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var A = requireEsDefineProperty(), B = function() {
    return !!A;
  };
  return B.hasArrayLengthDefineBug = function() {
    if (!A)
      return null;
    try {
      return A([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, hasPropertyDescriptors_1 = B, hasPropertyDescriptors_1;
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var A = requireGetIntrinsic(), B = requireDefineDataProperty(), W = requireHasPropertyDescriptors()(), K = requireGopd(), J = requireType(), L = A("%Math.floor%");
  return setFunctionLength = function(ie, oe) {
    if (typeof ie != "function")
      throw new J("`fn` is not a function");
    if (typeof oe != "number" || oe < 0 || oe > 4294967295 || L(oe) !== oe)
      throw new J("`length` must be a positive 32-bit integer");
    var ke = arguments.length > 2 && !!arguments[2], ne = !0, pe = !0;
    if ("length" in ie && K) {
      var rt = K(ie, "length");
      rt && !rt.configurable && (ne = !1), rt && !rt.writable && (pe = !1);
    }
    return (ne || pe || !ke) && (W ? B(
      /** @type {Parameters<define>[0]} */
      ie,
      "length",
      oe,
      !0,
      !0
    ) : B(
      /** @type {Parameters<define>[0]} */
      ie,
      "length",
      oe
    )), ie;
  }, setFunctionLength;
}
var applyBind, hasRequiredApplyBind;
function requireApplyBind() {
  if (hasRequiredApplyBind) return applyBind;
  hasRequiredApplyBind = 1;
  var A = requireFunctionBind(), B = requireFunctionApply(), W = requireActualApply();
  return applyBind = function() {
    return W(A, B, arguments);
  }, applyBind;
}
var hasRequiredCallBind;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(A) {
    var B = requireSetFunctionLength(), W = requireEsDefineProperty(), K = requireCallBindApplyHelpers(), J = requireApplyBind();
    A.exports = function(re) {
      var ie = K(arguments), oe = re.length - (arguments.length - 1);
      return B(
        ie,
        1 + (oe > 0 ? oe : 0),
        !0
      );
    }, W ? W(A.exports, "apply", { value: J }) : A.exports.apply = J;
  }(callBind)), callBind.exports;
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var A = requireForEach(), B = requireAvailableTypedArrays(), W = requireCallBind(), K = requireCallBound(), J = requireGopd(), L = K("Object.prototype.toString"), re = requireShams()(), ie = typeof globalThis > "u" ? commonjsGlobal : globalThis, oe = B(), ke = K("String.prototype.slice"), ne = Object.getPrototypeOf, pe = K("Array.prototype.indexOf", !0) || function(dt, vt) {
    for (var pt = 0; pt < dt.length; pt += 1)
      if (dt[pt] === vt)
        return pt;
    return -1;
  }, rt = { __proto__: null };
  re && J && ne ? A(oe, function(ut) {
    var dt = new ie[ut]();
    if (Symbol.toStringTag in dt) {
      var vt = ne(dt), pt = J(vt, Symbol.toStringTag);
      if (!pt) {
        var mt = ne(vt);
        pt = J(mt, Symbol.toStringTag);
      }
      rt["$" + ut] = W(pt.get);
    }
  }) : A(oe, function(ut) {
    var dt = new ie[ut](), vt = dt.slice || dt.set;
    vt && (rt["$" + ut] = W(vt));
  });
  var nt = function(dt) {
    var vt = !1;
    return A(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      rt,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(pt, mt) {
        if (!vt)
          try {
            "$" + pt(dt) === mt && (vt = ke(mt, 1));
          } catch {
          }
      }
    ), vt;
  }, ot = function(dt) {
    var vt = !1;
    return A(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      rt,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(pt, mt) {
        if (!vt)
          try {
            pt(dt), vt = ke(mt, 1);
          } catch {
          }
      }
    ), vt;
  };
  return whichTypedArray = function(dt) {
    if (!dt || typeof dt != "object")
      return !1;
    if (!re) {
      var vt = ke(L(dt), 8, -1);
      return pe(oe, vt) > -1 ? vt : vt !== "Object" ? !1 : ot(dt);
    }
    return J ? nt(dt) : null;
  }, whichTypedArray;
}
var isTypedArray, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var A = requireWhichTypedArray();
  return isTypedArray = function(W) {
    return !!A(W);
  }, isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(A) {
    var B = requireIsArguments(), W = requireIsGeneratorFunction(), K = requireWhichTypedArray(), J = requireIsTypedArray();
    function L(Jt) {
      return Jt.call.bind(Jt);
    }
    var re = typeof BigInt < "u", ie = typeof Symbol < "u", oe = L(Object.prototype.toString), ke = L(Number.prototype.valueOf), ne = L(String.prototype.valueOf), pe = L(Boolean.prototype.valueOf);
    if (re)
      var rt = L(BigInt.prototype.valueOf);
    if (ie)
      var nt = L(Symbol.prototype.valueOf);
    function ot(Jt, _r) {
      if (typeof Jt != "object")
        return !1;
      try {
        return _r(Jt), !0;
      } catch {
        return !1;
      }
    }
    A.isArgumentsObject = B, A.isGeneratorFunction = W, A.isTypedArray = J;
    function ut(Jt) {
      return typeof Promise < "u" && Jt instanceof Promise || Jt !== null && typeof Jt == "object" && typeof Jt.then == "function" && typeof Jt.catch == "function";
    }
    A.isPromise = ut;
    function dt(Jt) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Jt) : J(Jt) || yt(Jt);
    }
    A.isArrayBufferView = dt;
    function vt(Jt) {
      return K(Jt) === "Uint8Array";
    }
    A.isUint8Array = vt;
    function pt(Jt) {
      return K(Jt) === "Uint8ClampedArray";
    }
    A.isUint8ClampedArray = pt;
    function mt(Jt) {
      return K(Jt) === "Uint16Array";
    }
    A.isUint16Array = mt;
    function gt(Jt) {
      return K(Jt) === "Uint32Array";
    }
    A.isUint32Array = gt;
    function Pt(Jt) {
      return K(Jt) === "Int8Array";
    }
    A.isInt8Array = Pt;
    function xt(Jt) {
      return K(Jt) === "Int16Array";
    }
    A.isInt16Array = xt;
    function Nt(Jt) {
      return K(Jt) === "Int32Array";
    }
    A.isInt32Array = Nt;
    function Et(Jt) {
      return K(Jt) === "Float32Array";
    }
    A.isFloat32Array = Et;
    function bt(Jt) {
      return K(Jt) === "Float64Array";
    }
    A.isFloat64Array = bt;
    function Bt(Jt) {
      return K(Jt) === "BigInt64Array";
    }
    A.isBigInt64Array = Bt;
    function wt(Jt) {
      return K(Jt) === "BigUint64Array";
    }
    A.isBigUint64Array = wt;
    function st(Jt) {
      return oe(Jt) === "[object Map]";
    }
    st.working = typeof Map < "u" && st(/* @__PURE__ */ new Map());
    function Oe(Jt) {
      return typeof Map > "u" ? !1 : st.working ? st(Jt) : Jt instanceof Map;
    }
    A.isMap = Oe;
    function V(Jt) {
      return oe(Jt) === "[object Set]";
    }
    V.working = typeof Set < "u" && V(/* @__PURE__ */ new Set());
    function ce(Jt) {
      return typeof Set > "u" ? !1 : V.working ? V(Jt) : Jt instanceof Set;
    }
    A.isSet = ce;
    function it(Jt) {
      return oe(Jt) === "[object WeakMap]";
    }
    it.working = typeof WeakMap < "u" && it(/* @__PURE__ */ new WeakMap());
    function at(Jt) {
      return typeof WeakMap > "u" ? !1 : it.working ? it(Jt) : Jt instanceof WeakMap;
    }
    A.isWeakMap = at;
    function ft(Jt) {
      return oe(Jt) === "[object WeakSet]";
    }
    ft.working = typeof WeakSet < "u" && ft(/* @__PURE__ */ new WeakSet());
    function lt(Jt) {
      return ft(Jt);
    }
    A.isWeakSet = lt;
    function ct(Jt) {
      return oe(Jt) === "[object ArrayBuffer]";
    }
    ct.working = typeof ArrayBuffer < "u" && ct(new ArrayBuffer());
    function ht(Jt) {
      return typeof ArrayBuffer > "u" ? !1 : ct.working ? ct(Jt) : Jt instanceof ArrayBuffer;
    }
    A.isArrayBuffer = ht;
    function Ce(Jt) {
      return oe(Jt) === "[object DataView]";
    }
    Ce.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Ce(new DataView(new ArrayBuffer(1), 0, 1));
    function yt(Jt) {
      return typeof DataView > "u" ? !1 : Ce.working ? Ce(Jt) : Jt instanceof DataView;
    }
    A.isDataView = yt;
    var qt = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function jt(Jt) {
      return oe(Jt) === "[object SharedArrayBuffer]";
    }
    function kt(Jt) {
      return typeof qt > "u" ? !1 : (typeof jt.working > "u" && (jt.working = jt(new qt())), jt.working ? jt(Jt) : Jt instanceof qt);
    }
    A.isSharedArrayBuffer = kt;
    function $t(Jt) {
      return oe(Jt) === "[object AsyncFunction]";
    }
    A.isAsyncFunction = $t;
    function Mt(Jt) {
      return oe(Jt) === "[object Map Iterator]";
    }
    A.isMapIterator = Mt;
    function Lt(Jt) {
      return oe(Jt) === "[object Set Iterator]";
    }
    A.isSetIterator = Lt;
    function Kt(Jt) {
      return oe(Jt) === "[object Generator]";
    }
    A.isGeneratorObject = Kt;
    function Tt(Jt) {
      return oe(Jt) === "[object WebAssembly.Module]";
    }
    A.isWebAssemblyCompiledModule = Tt;
    function Rt(Jt) {
      return ot(Jt, ke);
    }
    A.isNumberObject = Rt;
    function Wt(Jt) {
      return ot(Jt, ne);
    }
    A.isStringObject = Wt;
    function Xt(Jt) {
      return ot(Jt, pe);
    }
    A.isBooleanObject = Xt;
    function Zt(Jt) {
      return re && ot(Jt, rt);
    }
    A.isBigIntObject = Zt;
    function ar(Jt) {
      return ie && ot(Jt, nt);
    }
    A.isSymbolObject = ar;
    function fr(Jt) {
      return Rt(Jt) || Wt(Jt) || Xt(Jt) || Zt(Jt) || ar(Jt);
    }
    A.isBoxedPrimitive = fr;
    function lr(Jt) {
      return typeof Uint8Array < "u" && (ht(Jt) || kt(Jt));
    }
    A.isAnyArrayBuffer = lr, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Jt) {
      Object.defineProperty(A, Jt, {
        enumerable: !1,
        value: function() {
          throw new Error(Jt + " is not supported in userland");
        }
      });
    });
  }(types$5)), types$5;
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(B) {
    return B && typeof B == "object" && typeof B.copy == "function" && typeof B.fill == "function" && typeof B.readUInt8 == "function";
  }), isBufferBrowser;
}
var hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(A) {
    var B = Object.getOwnPropertyDescriptors || function(yt) {
      for (var qt = Object.keys(yt), jt = {}, kt = 0; kt < qt.length; kt++)
        jt[qt[kt]] = Object.getOwnPropertyDescriptor(yt, qt[kt]);
      return jt;
    }, W = /%[sdj%]/g;
    A.format = function(Ce) {
      if (!Pt(Ce)) {
        for (var yt = [], qt = 0; qt < arguments.length; qt++)
          yt.push(re(arguments[qt]));
        return yt.join(" ");
      }
      for (var qt = 1, jt = arguments, kt = jt.length, $t = String(Ce).replace(W, function(Lt) {
        if (Lt === "%%") return "%";
        if (qt >= kt) return Lt;
        switch (Lt) {
          case "%s":
            return String(jt[qt++]);
          case "%d":
            return Number(jt[qt++]);
          case "%j":
            try {
              return JSON.stringify(jt[qt++]);
            } catch {
              return "[Circular]";
            }
          default:
            return Lt;
        }
      }), Mt = jt[qt]; qt < kt; Mt = jt[++qt])
        pt(Mt) || !bt(Mt) ? $t += " " + Mt : $t += " " + re(Mt);
      return $t;
    }, A.deprecate = function(Ce, yt) {
      if (typeof process$1 < "u" && process$1.noDeprecation === !0)
        return Ce;
      if (typeof process$1 > "u")
        return function() {
          return A.deprecate(Ce, yt).apply(this, arguments);
        };
      var qt = !1;
      function jt() {
        if (!qt) {
          if (process$1.throwDeprecation)
            throw new Error(yt);
          process$1.traceDeprecation ? console.trace(yt) : console.error(yt), qt = !0;
        }
        return Ce.apply(this, arguments);
      }
      return jt;
    };
    var K = {}, J = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var L = process$1.env.NODE_DEBUG;
      L = L.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), J = new RegExp("^" + L + "$", "i");
    }
    A.debuglog = function(Ce) {
      if (Ce = Ce.toUpperCase(), !K[Ce])
        if (J.test(Ce)) {
          var yt = process$1.pid;
          K[Ce] = function() {
            var qt = A.format.apply(A, arguments);
            console.error("%s %d: %s", Ce, yt, qt);
          };
        } else
          K[Ce] = function() {
          };
      return K[Ce];
    };
    function re(Ce, yt) {
      var qt = {
        seen: [],
        stylize: oe
      };
      return arguments.length >= 3 && (qt.depth = arguments[2]), arguments.length >= 4 && (qt.colors = arguments[3]), vt(yt) ? qt.showHidden = yt : yt && A._extend(qt, yt), Nt(qt.showHidden) && (qt.showHidden = !1), Nt(qt.depth) && (qt.depth = 2), Nt(qt.colors) && (qt.colors = !1), Nt(qt.customInspect) && (qt.customInspect = !0), qt.colors && (qt.stylize = ie), ne(qt, Ce, qt.depth);
    }
    A.inspect = re, re.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, re.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function ie(Ce, yt) {
      var qt = re.styles[yt];
      return qt ? "\x1B[" + re.colors[qt][0] + "m" + Ce + "\x1B[" + re.colors[qt][1] + "m" : Ce;
    }
    function oe(Ce, yt) {
      return Ce;
    }
    function ke(Ce) {
      var yt = {};
      return Ce.forEach(function(qt, jt) {
        yt[qt] = !0;
      }), yt;
    }
    function ne(Ce, yt, qt) {
      if (Ce.customInspect && yt && st(yt.inspect) && // Filter out the util module, it's inspect function is special
      yt.inspect !== A.inspect && // Also filter out any prototype objects using the circular check.
      !(yt.constructor && yt.constructor.prototype === yt)) {
        var jt = yt.inspect(qt, Ce);
        return Pt(jt) || (jt = ne(Ce, jt, qt)), jt;
      }
      var kt = pe(Ce, yt);
      if (kt)
        return kt;
      var $t = Object.keys(yt), Mt = ke($t);
      if (Ce.showHidden && ($t = Object.getOwnPropertyNames(yt)), wt(yt) && ($t.indexOf("message") >= 0 || $t.indexOf("description") >= 0))
        return rt(yt);
      if ($t.length === 0) {
        if (st(yt)) {
          var Lt = yt.name ? ": " + yt.name : "";
          return Ce.stylize("[Function" + Lt + "]", "special");
        }
        if (Et(yt))
          return Ce.stylize(RegExp.prototype.toString.call(yt), "regexp");
        if (Bt(yt))
          return Ce.stylize(Date.prototype.toString.call(yt), "date");
        if (wt(yt))
          return rt(yt);
      }
      var Kt = "", Tt = !1, Rt = ["{", "}"];
      if (dt(yt) && (Tt = !0, Rt = ["[", "]"]), st(yt)) {
        var Wt = yt.name ? ": " + yt.name : "";
        Kt = " [Function" + Wt + "]";
      }
      if (Et(yt) && (Kt = " " + RegExp.prototype.toString.call(yt)), Bt(yt) && (Kt = " " + Date.prototype.toUTCString.call(yt)), wt(yt) && (Kt = " " + rt(yt)), $t.length === 0 && (!Tt || yt.length == 0))
        return Rt[0] + Kt + Rt[1];
      if (qt < 0)
        return Et(yt) ? Ce.stylize(RegExp.prototype.toString.call(yt), "regexp") : Ce.stylize("[Object]", "special");
      Ce.seen.push(yt);
      var Xt;
      return Tt ? Xt = nt(Ce, yt, qt, Mt, $t) : Xt = $t.map(function(Zt) {
        return ot(Ce, yt, qt, Mt, Zt, Tt);
      }), Ce.seen.pop(), ut(Xt, Kt, Rt);
    }
    function pe(Ce, yt) {
      if (Nt(yt))
        return Ce.stylize("undefined", "undefined");
      if (Pt(yt)) {
        var qt = "'" + JSON.stringify(yt).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return Ce.stylize(qt, "string");
      }
      if (gt(yt))
        return Ce.stylize("" + yt, "number");
      if (vt(yt))
        return Ce.stylize("" + yt, "boolean");
      if (pt(yt))
        return Ce.stylize("null", "null");
    }
    function rt(Ce) {
      return "[" + Error.prototype.toString.call(Ce) + "]";
    }
    function nt(Ce, yt, qt, jt, kt) {
      for (var $t = [], Mt = 0, Lt = yt.length; Mt < Lt; ++Mt)
        ft(yt, String(Mt)) ? $t.push(ot(
          Ce,
          yt,
          qt,
          jt,
          String(Mt),
          !0
        )) : $t.push("");
      return kt.forEach(function(Kt) {
        Kt.match(/^\d+$/) || $t.push(ot(
          Ce,
          yt,
          qt,
          jt,
          Kt,
          !0
        ));
      }), $t;
    }
    function ot(Ce, yt, qt, jt, kt, $t) {
      var Mt, Lt, Kt;
      if (Kt = Object.getOwnPropertyDescriptor(yt, kt) || { value: yt[kt] }, Kt.get ? Kt.set ? Lt = Ce.stylize("[Getter/Setter]", "special") : Lt = Ce.stylize("[Getter]", "special") : Kt.set && (Lt = Ce.stylize("[Setter]", "special")), ft(jt, kt) || (Mt = "[" + kt + "]"), Lt || (Ce.seen.indexOf(Kt.value) < 0 ? (pt(qt) ? Lt = ne(Ce, Kt.value, null) : Lt = ne(Ce, Kt.value, qt - 1), Lt.indexOf(`
`) > -1 && ($t ? Lt = Lt.split(`
`).map(function(Tt) {
        return "  " + Tt;
      }).join(`
`).slice(2) : Lt = `
` + Lt.split(`
`).map(function(Tt) {
        return "   " + Tt;
      }).join(`
`))) : Lt = Ce.stylize("[Circular]", "special")), Nt(Mt)) {
        if ($t && kt.match(/^\d+$/))
          return Lt;
        Mt = JSON.stringify("" + kt), Mt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Mt = Mt.slice(1, -1), Mt = Ce.stylize(Mt, "name")) : (Mt = Mt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Mt = Ce.stylize(Mt, "string"));
      }
      return Mt + ": " + Lt;
    }
    function ut(Ce, yt, qt) {
      var jt = Ce.reduce(function(kt, $t) {
        return $t.indexOf(`
`) >= 0, kt + $t.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return jt > 60 ? qt[0] + (yt === "" ? "" : yt + `
 `) + " " + Ce.join(`,
  `) + " " + qt[1] : qt[0] + yt + " " + Ce.join(", ") + " " + qt[1];
    }
    A.types = requireTypes();
    function dt(Ce) {
      return Array.isArray(Ce);
    }
    A.isArray = dt;
    function vt(Ce) {
      return typeof Ce == "boolean";
    }
    A.isBoolean = vt;
    function pt(Ce) {
      return Ce === null;
    }
    A.isNull = pt;
    function mt(Ce) {
      return Ce == null;
    }
    A.isNullOrUndefined = mt;
    function gt(Ce) {
      return typeof Ce == "number";
    }
    A.isNumber = gt;
    function Pt(Ce) {
      return typeof Ce == "string";
    }
    A.isString = Pt;
    function xt(Ce) {
      return typeof Ce == "symbol";
    }
    A.isSymbol = xt;
    function Nt(Ce) {
      return Ce === void 0;
    }
    A.isUndefined = Nt;
    function Et(Ce) {
      return bt(Ce) && V(Ce) === "[object RegExp]";
    }
    A.isRegExp = Et, A.types.isRegExp = Et;
    function bt(Ce) {
      return typeof Ce == "object" && Ce !== null;
    }
    A.isObject = bt;
    function Bt(Ce) {
      return bt(Ce) && V(Ce) === "[object Date]";
    }
    A.isDate = Bt, A.types.isDate = Bt;
    function wt(Ce) {
      return bt(Ce) && (V(Ce) === "[object Error]" || Ce instanceof Error);
    }
    A.isError = wt, A.types.isNativeError = wt;
    function st(Ce) {
      return typeof Ce == "function";
    }
    A.isFunction = st;
    function Oe(Ce) {
      return Ce === null || typeof Ce == "boolean" || typeof Ce == "number" || typeof Ce == "string" || typeof Ce == "symbol" || // ES6 symbol
      typeof Ce > "u";
    }
    A.isPrimitive = Oe, A.isBuffer = requireIsBufferBrowser();
    function V(Ce) {
      return Object.prototype.toString.call(Ce);
    }
    function ce(Ce) {
      return Ce < 10 ? "0" + Ce.toString(10) : Ce.toString(10);
    }
    var it = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function at() {
      var Ce = /* @__PURE__ */ new Date(), yt = [
        ce(Ce.getHours()),
        ce(Ce.getMinutes()),
        ce(Ce.getSeconds())
      ].join(":");
      return [Ce.getDate(), it[Ce.getMonth()], yt].join(" ");
    }
    A.log = function() {
      console.log("%s - %s", at(), A.format.apply(A, arguments));
    }, A.inherits = requireInherits_browser(), A._extend = function(Ce, yt) {
      if (!yt || !bt(yt)) return Ce;
      for (var qt = Object.keys(yt), jt = qt.length; jt--; )
        Ce[qt[jt]] = yt[qt[jt]];
      return Ce;
    };
    function ft(Ce, yt) {
      return Object.prototype.hasOwnProperty.call(Ce, yt);
    }
    var lt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    A.promisify = function(yt) {
      if (typeof yt != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (lt && yt[lt]) {
        var qt = yt[lt];
        if (typeof qt != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(qt, lt, {
          value: qt,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), qt;
      }
      function qt() {
        for (var jt, kt, $t = new Promise(function(Kt, Tt) {
          jt = Kt, kt = Tt;
        }), Mt = [], Lt = 0; Lt < arguments.length; Lt++)
          Mt.push(arguments[Lt]);
        Mt.push(function(Kt, Tt) {
          Kt ? kt(Kt) : jt(Tt);
        });
        try {
          yt.apply(this, Mt);
        } catch (Kt) {
          kt(Kt);
        }
        return $t;
      }
      return Object.setPrototypeOf(qt, Object.getPrototypeOf(yt)), lt && Object.defineProperty(qt, lt, {
        value: qt,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        qt,
        B(yt)
      );
    }, A.promisify.custom = lt;
    function ct(Ce, yt) {
      if (!Ce) {
        var qt = new Error("Promise was rejected with a falsy value");
        qt.reason = Ce, Ce = qt;
      }
      return yt(Ce);
    }
    function ht(Ce) {
      if (typeof Ce != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function yt() {
        for (var qt = [], jt = 0; jt < arguments.length; jt++)
          qt.push(arguments[jt]);
        var kt = qt.pop();
        if (typeof kt != "function")
          throw new TypeError("The last argument must be of type Function");
        var $t = this, Mt = function() {
          return kt.apply($t, arguments);
        };
        Ce.apply(this, qt).then(
          function(Lt) {
            process$1.nextTick(Mt.bind(null, null, Lt));
          },
          function(Lt) {
            process$1.nextTick(ct.bind(null, Lt, Mt));
          }
        );
      }
      return Object.setPrototypeOf(yt, Object.getPrototypeOf(Ce)), Object.defineProperties(
        yt,
        B(Ce)
      ), yt;
    }
    A.callbackify = ht;
  }(util$1)), util$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function A(ot, ut) {
    var dt = Object.keys(ot);
    if (Object.getOwnPropertySymbols) {
      var vt = Object.getOwnPropertySymbols(ot);
      ut && (vt = vt.filter(function(pt) {
        return Object.getOwnPropertyDescriptor(ot, pt).enumerable;
      })), dt.push.apply(dt, vt);
    }
    return dt;
  }
  function B(ot) {
    for (var ut = 1; ut < arguments.length; ut++) {
      var dt = arguments[ut] != null ? arguments[ut] : {};
      ut % 2 ? A(Object(dt), !0).forEach(function(vt) {
        W(ot, vt, dt[vt]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ot, Object.getOwnPropertyDescriptors(dt)) : A(Object(dt)).forEach(function(vt) {
        Object.defineProperty(ot, vt, Object.getOwnPropertyDescriptor(dt, vt));
      });
    }
    return ot;
  }
  function W(ot, ut, dt) {
    return ut = re(ut), ut in ot ? Object.defineProperty(ot, ut, { value: dt, enumerable: !0, configurable: !0, writable: !0 }) : ot[ut] = dt, ot;
  }
  function K(ot, ut) {
    if (!(ot instanceof ut))
      throw new TypeError("Cannot call a class as a function");
  }
  function J(ot, ut) {
    for (var dt = 0; dt < ut.length; dt++) {
      var vt = ut[dt];
      vt.enumerable = vt.enumerable || !1, vt.configurable = !0, "value" in vt && (vt.writable = !0), Object.defineProperty(ot, re(vt.key), vt);
    }
  }
  function L(ot, ut, dt) {
    return ut && J(ot.prototype, ut), Object.defineProperty(ot, "prototype", { writable: !1 }), ot;
  }
  function re(ot) {
    var ut = ie(ot, "string");
    return typeof ut == "symbol" ? ut : String(ut);
  }
  function ie(ot, ut) {
    if (typeof ot != "object" || ot === null) return ot;
    var dt = ot[Symbol.toPrimitive];
    if (dt !== void 0) {
      var vt = dt.call(ot, ut);
      if (typeof vt != "object") return vt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(ot);
  }
  var oe = require$$0$1, ke = oe.Buffer, ne = requireUtil$1(), pe = ne.inspect, rt = pe && pe.custom || "inspect";
  function nt(ot, ut, dt) {
    ke.prototype.copy.call(ot, ut, dt);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function ot() {
      K(this, ot), this.head = null, this.tail = null, this.length = 0;
    }
    return L(ot, [{
      key: "push",
      value: function(dt) {
        var vt = {
          data: dt,
          next: null
        };
        this.length > 0 ? this.tail.next = vt : this.head = vt, this.tail = vt, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(dt) {
        var vt = {
          data: dt,
          next: this.head
        };
        this.length === 0 && (this.tail = vt), this.head = vt, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var dt = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, dt;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(dt) {
        if (this.length === 0) return "";
        for (var vt = this.head, pt = "" + vt.data; vt = vt.next; ) pt += dt + vt.data;
        return pt;
      }
    }, {
      key: "concat",
      value: function(dt) {
        if (this.length === 0) return ke.alloc(0);
        for (var vt = ke.allocUnsafe(dt >>> 0), pt = this.head, mt = 0; pt; )
          nt(pt.data, vt, mt), mt += pt.data.length, pt = pt.next;
        return vt;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(dt, vt) {
        var pt;
        return dt < this.head.data.length ? (pt = this.head.data.slice(0, dt), this.head.data = this.head.data.slice(dt)) : dt === this.head.data.length ? pt = this.shift() : pt = vt ? this._getString(dt) : this._getBuffer(dt), pt;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(dt) {
        var vt = this.head, pt = 1, mt = vt.data;
        for (dt -= mt.length; vt = vt.next; ) {
          var gt = vt.data, Pt = dt > gt.length ? gt.length : dt;
          if (Pt === gt.length ? mt += gt : mt += gt.slice(0, dt), dt -= Pt, dt === 0) {
            Pt === gt.length ? (++pt, vt.next ? this.head = vt.next : this.head = this.tail = null) : (this.head = vt, vt.data = gt.slice(Pt));
            break;
          }
          ++pt;
        }
        return this.length -= pt, mt;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(dt) {
        var vt = ke.allocUnsafe(dt), pt = this.head, mt = 1;
        for (pt.data.copy(vt), dt -= pt.data.length; pt = pt.next; ) {
          var gt = pt.data, Pt = dt > gt.length ? gt.length : dt;
          if (gt.copy(vt, vt.length - dt, 0, Pt), dt -= Pt, dt === 0) {
            Pt === gt.length ? (++mt, pt.next ? this.head = pt.next : this.head = this.tail = null) : (this.head = pt, pt.data = gt.slice(Pt));
            break;
          }
          ++mt;
        }
        return this.length -= mt, vt;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: rt,
      value: function(dt, vt) {
        return pe(this, B(B({}, vt), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), ot;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  function A(re, ie) {
    var oe = this, ke = this._readableState && this._readableState.destroyed, ne = this._writableState && this._writableState.destroyed;
    return ke || ne ? (ie ? ie(re) : re && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(J, this, re)) : process$1.nextTick(J, this, re)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(re || null, function(pe) {
      !ie && pe ? oe._writableState ? oe._writableState.errorEmitted ? process$1.nextTick(W, oe) : (oe._writableState.errorEmitted = !0, process$1.nextTick(B, oe, pe)) : process$1.nextTick(B, oe, pe) : ie ? (process$1.nextTick(W, oe), ie(pe)) : process$1.nextTick(W, oe);
    }), this);
  }
  function B(re, ie) {
    J(re, ie), W(re);
  }
  function W(re) {
    re._writableState && !re._writableState.emitClose || re._readableState && !re._readableState.emitClose || re.emit("close");
  }
  function K() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function J(re, ie) {
    re.emit("error", ie);
  }
  function L(re, ie) {
    var oe = re._readableState, ke = re._writableState;
    oe && oe.autoDestroy || ke && ke.autoDestroy ? re.destroy(ie) : re.emit("error", ie);
  }
  return destroy_1$1 = {
    destroy: A,
    undestroy: K,
    errorOrDestroy: L
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function A(ie, oe) {
    ie.prototype = Object.create(oe.prototype), ie.prototype.constructor = ie, ie.__proto__ = oe;
  }
  var B = {};
  function W(ie, oe, ke) {
    ke || (ke = Error);
    function ne(rt, nt, ot) {
      return typeof oe == "string" ? oe : oe(rt, nt, ot);
    }
    var pe = /* @__PURE__ */ function(rt) {
      A(nt, rt);
      function nt(ot, ut, dt) {
        return rt.call(this, ne(ot, ut, dt)) || this;
      }
      return nt;
    }(ke);
    pe.prototype.name = ke.name, pe.prototype.code = ie, B[ie] = pe;
  }
  function K(ie, oe) {
    if (Array.isArray(ie)) {
      var ke = ie.length;
      return ie = ie.map(function(ne) {
        return String(ne);
      }), ke > 2 ? "one of ".concat(oe, " ").concat(ie.slice(0, ke - 1).join(", "), ", or ") + ie[ke - 1] : ke === 2 ? "one of ".concat(oe, " ").concat(ie[0], " or ").concat(ie[1]) : "of ".concat(oe, " ").concat(ie[0]);
    } else
      return "of ".concat(oe, " ").concat(String(ie));
  }
  function J(ie, oe, ke) {
    return ie.substr(0, oe.length) === oe;
  }
  function L(ie, oe, ke) {
    return (ke === void 0 || ke > ie.length) && (ke = ie.length), ie.substring(ke - oe.length, ke) === oe;
  }
  function re(ie, oe, ke) {
    return typeof ke != "number" && (ke = 0), ke + oe.length > ie.length ? !1 : ie.indexOf(oe, ke) !== -1;
  }
  return W("ERR_INVALID_OPT_VALUE", function(ie, oe) {
    return 'The value "' + oe + '" is invalid for option "' + ie + '"';
  }, TypeError), W("ERR_INVALID_ARG_TYPE", function(ie, oe, ke) {
    var ne;
    typeof oe == "string" && J(oe, "not ") ? (ne = "must not be", oe = oe.replace(/^not /, "")) : ne = "must be";
    var pe;
    if (L(ie, " argument"))
      pe = "The ".concat(ie, " ").concat(ne, " ").concat(K(oe, "type"));
    else {
      var rt = re(ie, ".") ? "property" : "argument";
      pe = 'The "'.concat(ie, '" ').concat(rt, " ").concat(ne, " ").concat(K(oe, "type"));
    }
    return pe += ". Received type ".concat(typeof ke), pe;
  }, TypeError), W("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), W("ERR_METHOD_NOT_IMPLEMENTED", function(ie) {
    return "The " + ie + " method is not implemented";
  }), W("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), W("ERR_STREAM_DESTROYED", function(ie) {
    return "Cannot call " + ie + " after a stream was destroyed";
  }), W("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), W("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), W("ERR_STREAM_WRITE_AFTER_END", "write after end"), W("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), W("ERR_UNKNOWN_ENCODING", function(ie) {
    return "Unknown encoding: " + ie;
  }, TypeError), W("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = B, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var A = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function B(K, J, L) {
    return K.highWaterMark != null ? K.highWaterMark : J ? K[L] : null;
  }
  function W(K, J, L, re) {
    var ie = B(J, re, L);
    if (ie != null) {
      if (!(isFinite(ie) && Math.floor(ie) === ie) || ie < 0) {
        var oe = re ? L : "highWaterMark";
        throw new A(oe, ie);
      }
      return Math.floor(ie);
    }
    return K.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: W
  }, state;
}
var browser$a, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$a;
  hasRequiredBrowser$a = 1, browser$a = A;
  function A(W, K) {
    if (B("noDeprecation"))
      return W;
    var J = !1;
    function L() {
      if (!J) {
        if (B("throwDeprecation"))
          throw new Error(K);
        B("traceDeprecation") ? console.trace(K) : console.warn(K), J = !0;
      }
      return W.apply(this, arguments);
    }
    return L;
  }
  function B(W) {
    try {
      if (!commonjsGlobal.localStorage) return !1;
    } catch {
      return !1;
    }
    var K = commonjsGlobal.localStorage[W];
    return K == null ? !1 : String(K).toLowerCase() === "true";
  }
  return browser$a;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Et;
  function A(kt) {
    var $t = this;
    this.next = null, this.entry = null, this.finish = function() {
      jt($t, kt);
    };
  }
  var B;
  Et.WritableState = xt;
  var W = {
    deprecate: requireBrowser$a()
  }, K = requireStreamBrowser$1(), J = require$$0$1.Buffer, L = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function re(kt) {
    return J.from(kt);
  }
  function ie(kt) {
    return J.isBuffer(kt) || kt instanceof L;
  }
  var oe = requireDestroy$1(), ke = requireState(), ne = ke.getHighWaterMark, pe = requireErrorsBrowser().codes, rt = pe.ERR_INVALID_ARG_TYPE, nt = pe.ERR_METHOD_NOT_IMPLEMENTED, ot = pe.ERR_MULTIPLE_CALLBACK, ut = pe.ERR_STREAM_CANNOT_PIPE, dt = pe.ERR_STREAM_DESTROYED, vt = pe.ERR_STREAM_NULL_VALUES, pt = pe.ERR_STREAM_WRITE_AFTER_END, mt = pe.ERR_UNKNOWN_ENCODING, gt = oe.errorOrDestroy;
  requireInherits_browser()(Et, K);
  function Pt() {
  }
  function xt(kt, $t, Mt) {
    B = B || require_stream_duplex$1(), kt = kt || {}, typeof Mt != "boolean" && (Mt = $t instanceof B), this.objectMode = !!kt.objectMode, Mt && (this.objectMode = this.objectMode || !!kt.writableObjectMode), this.highWaterMark = ne(this, kt, "writableHighWaterMark", Mt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Lt = kt.decodeStrings === !1;
    this.decodeStrings = !Lt, this.defaultEncoding = kt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Kt) {
      it($t, Kt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = kt.emitClose !== !1, this.autoDestroy = !!kt.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new A(this);
  }
  xt.prototype.getBuffer = function() {
    for (var $t = this.bufferedRequest, Mt = []; $t; )
      Mt.push($t), $t = $t.next;
    return Mt;
  }, function() {
    try {
      Object.defineProperty(xt.prototype, "buffer", {
        get: W.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Nt;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Nt = Function.prototype[Symbol.hasInstance], Object.defineProperty(Et, Symbol.hasInstance, {
    value: function($t) {
      return Nt.call(this, $t) ? !0 : this !== Et ? !1 : $t && $t._writableState instanceof xt;
    }
  })) : Nt = function($t) {
    return $t instanceof this;
  };
  function Et(kt) {
    B = B || require_stream_duplex$1();
    var $t = this instanceof B;
    if (!$t && !Nt.call(Et, this)) return new Et(kt);
    this._writableState = new xt(kt, this, $t), this.writable = !0, kt && (typeof kt.write == "function" && (this._write = kt.write), typeof kt.writev == "function" && (this._writev = kt.writev), typeof kt.destroy == "function" && (this._destroy = kt.destroy), typeof kt.final == "function" && (this._final = kt.final)), K.call(this);
  }
  Et.prototype.pipe = function() {
    gt(this, new ut());
  };
  function bt(kt, $t) {
    var Mt = new pt();
    gt(kt, Mt), process$1.nextTick($t, Mt);
  }
  function Bt(kt, $t, Mt, Lt) {
    var Kt;
    return Mt === null ? Kt = new vt() : typeof Mt != "string" && !$t.objectMode && (Kt = new rt("chunk", ["string", "Buffer"], Mt)), Kt ? (gt(kt, Kt), process$1.nextTick(Lt, Kt), !1) : !0;
  }
  Et.prototype.write = function(kt, $t, Mt) {
    var Lt = this._writableState, Kt = !1, Tt = !Lt.objectMode && ie(kt);
    return Tt && !J.isBuffer(kt) && (kt = re(kt)), typeof $t == "function" && (Mt = $t, $t = null), Tt ? $t = "buffer" : $t || ($t = Lt.defaultEncoding), typeof Mt != "function" && (Mt = Pt), Lt.ending ? bt(this, Mt) : (Tt || Bt(this, Lt, kt, Mt)) && (Lt.pendingcb++, Kt = st(this, Lt, Tt, kt, $t, Mt)), Kt;
  }, Et.prototype.cork = function() {
    this._writableState.corked++;
  }, Et.prototype.uncork = function() {
    var kt = this._writableState;
    kt.corked && (kt.corked--, !kt.writing && !kt.corked && !kt.bufferProcessing && kt.bufferedRequest && lt(this, kt));
  }, Et.prototype.setDefaultEncoding = function($t) {
    if (typeof $t == "string" && ($t = $t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf(($t + "").toLowerCase()) > -1)) throw new mt($t);
    return this._writableState.defaultEncoding = $t, this;
  }, Object.defineProperty(Et.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function wt(kt, $t, Mt) {
    return !kt.objectMode && kt.decodeStrings !== !1 && typeof $t == "string" && ($t = J.from($t, Mt)), $t;
  }
  Object.defineProperty(Et.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function st(kt, $t, Mt, Lt, Kt, Tt) {
    if (!Mt) {
      var Rt = wt($t, Lt, Kt);
      Lt !== Rt && (Mt = !0, Kt = "buffer", Lt = Rt);
    }
    var Wt = $t.objectMode ? 1 : Lt.length;
    $t.length += Wt;
    var Xt = $t.length < $t.highWaterMark;
    if (Xt || ($t.needDrain = !0), $t.writing || $t.corked) {
      var Zt = $t.lastBufferedRequest;
      $t.lastBufferedRequest = {
        chunk: Lt,
        encoding: Kt,
        isBuf: Mt,
        callback: Tt,
        next: null
      }, Zt ? Zt.next = $t.lastBufferedRequest : $t.bufferedRequest = $t.lastBufferedRequest, $t.bufferedRequestCount += 1;
    } else
      Oe(kt, $t, !1, Wt, Lt, Kt, Tt);
    return Xt;
  }
  function Oe(kt, $t, Mt, Lt, Kt, Tt, Rt) {
    $t.writelen = Lt, $t.writecb = Rt, $t.writing = !0, $t.sync = !0, $t.destroyed ? $t.onwrite(new dt("write")) : Mt ? kt._writev(Kt, $t.onwrite) : kt._write(Kt, Tt, $t.onwrite), $t.sync = !1;
  }
  function V(kt, $t, Mt, Lt, Kt) {
    --$t.pendingcb, Mt ? (process$1.nextTick(Kt, Lt), process$1.nextTick(yt, kt, $t), kt._writableState.errorEmitted = !0, gt(kt, Lt)) : (Kt(Lt), kt._writableState.errorEmitted = !0, gt(kt, Lt), yt(kt, $t));
  }
  function ce(kt) {
    kt.writing = !1, kt.writecb = null, kt.length -= kt.writelen, kt.writelen = 0;
  }
  function it(kt, $t) {
    var Mt = kt._writableState, Lt = Mt.sync, Kt = Mt.writecb;
    if (typeof Kt != "function") throw new ot();
    if (ce(Mt), $t) V(kt, Mt, Lt, $t, Kt);
    else {
      var Tt = ct(Mt) || kt.destroyed;
      !Tt && !Mt.corked && !Mt.bufferProcessing && Mt.bufferedRequest && lt(kt, Mt), Lt ? process$1.nextTick(at, kt, Mt, Tt, Kt) : at(kt, Mt, Tt, Kt);
    }
  }
  function at(kt, $t, Mt, Lt) {
    Mt || ft(kt, $t), $t.pendingcb--, Lt(), yt(kt, $t);
  }
  function ft(kt, $t) {
    $t.length === 0 && $t.needDrain && ($t.needDrain = !1, kt.emit("drain"));
  }
  function lt(kt, $t) {
    $t.bufferProcessing = !0;
    var Mt = $t.bufferedRequest;
    if (kt._writev && Mt && Mt.next) {
      var Lt = $t.bufferedRequestCount, Kt = new Array(Lt), Tt = $t.corkedRequestsFree;
      Tt.entry = Mt;
      for (var Rt = 0, Wt = !0; Mt; )
        Kt[Rt] = Mt, Mt.isBuf || (Wt = !1), Mt = Mt.next, Rt += 1;
      Kt.allBuffers = Wt, Oe(kt, $t, !0, $t.length, Kt, "", Tt.finish), $t.pendingcb++, $t.lastBufferedRequest = null, Tt.next ? ($t.corkedRequestsFree = Tt.next, Tt.next = null) : $t.corkedRequestsFree = new A($t), $t.bufferedRequestCount = 0;
    } else {
      for (; Mt; ) {
        var Xt = Mt.chunk, Zt = Mt.encoding, ar = Mt.callback, fr = $t.objectMode ? 1 : Xt.length;
        if (Oe(kt, $t, !1, fr, Xt, Zt, ar), Mt = Mt.next, $t.bufferedRequestCount--, $t.writing)
          break;
      }
      Mt === null && ($t.lastBufferedRequest = null);
    }
    $t.bufferedRequest = Mt, $t.bufferProcessing = !1;
  }
  Et.prototype._write = function(kt, $t, Mt) {
    Mt(new nt("_write()"));
  }, Et.prototype._writev = null, Et.prototype.end = function(kt, $t, Mt) {
    var Lt = this._writableState;
    return typeof kt == "function" ? (Mt = kt, kt = null, $t = null) : typeof $t == "function" && (Mt = $t, $t = null), kt != null && this.write(kt, $t), Lt.corked && (Lt.corked = 1, this.uncork()), Lt.ending || qt(this, Lt, Mt), this;
  }, Object.defineProperty(Et.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ct(kt) {
    return kt.ending && kt.length === 0 && kt.bufferedRequest === null && !kt.finished && !kt.writing;
  }
  function ht(kt, $t) {
    kt._final(function(Mt) {
      $t.pendingcb--, Mt && gt(kt, Mt), $t.prefinished = !0, kt.emit("prefinish"), yt(kt, $t);
    });
  }
  function Ce(kt, $t) {
    !$t.prefinished && !$t.finalCalled && (typeof kt._final == "function" && !$t.destroyed ? ($t.pendingcb++, $t.finalCalled = !0, process$1.nextTick(ht, kt, $t)) : ($t.prefinished = !0, kt.emit("prefinish")));
  }
  function yt(kt, $t) {
    var Mt = ct($t);
    if (Mt && (Ce(kt, $t), $t.pendingcb === 0 && ($t.finished = !0, kt.emit("finish"), $t.autoDestroy))) {
      var Lt = kt._readableState;
      (!Lt || Lt.autoDestroy && Lt.endEmitted) && kt.destroy();
    }
    return Mt;
  }
  function qt(kt, $t, Mt) {
    $t.ending = !0, yt(kt, $t), Mt && ($t.finished ? process$1.nextTick(Mt) : kt.once("finish", Mt)), $t.ended = !0, kt.writable = !1;
  }
  function jt(kt, $t, Mt) {
    var Lt = kt.entry;
    for (kt.entry = null; Lt; ) {
      var Kt = Lt.callback;
      $t.pendingcb--, Kt(Mt), Lt = Lt.next;
    }
    $t.corkedRequestsFree.next = kt;
  }
  return Object.defineProperty(Et.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function($t) {
      this._writableState && (this._writableState.destroyed = $t);
    }
  }), Et.prototype.destroy = oe.destroy, Et.prototype._undestroy = oe.undestroy, Et.prototype._destroy = function(kt, $t) {
    $t(kt);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var A = Object.keys || function(ke) {
    var ne = [];
    for (var pe in ke) ne.push(pe);
    return ne;
  };
  _stream_duplex$1 = re;
  var B = require_stream_readable$1(), W = require_stream_writable$1();
  requireInherits_browser()(re, B);
  for (var K = A(W.prototype), J = 0; J < K.length; J++) {
    var L = K[J];
    re.prototype[L] || (re.prototype[L] = W.prototype[L]);
  }
  function re(ke) {
    if (!(this instanceof re)) return new re(ke);
    B.call(this, ke), W.call(this, ke), this.allowHalfOpen = !0, ke && (ke.readable === !1 && (this.readable = !1), ke.writable === !1 && (this.writable = !1), ke.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", ie)));
  }
  Object.defineProperty(re.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(re.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(re.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ie() {
    this._writableState.ended || process$1.nextTick(oe, this);
  }
  function oe(ke) {
    ke.end();
  }
  return Object.defineProperty(re.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(ne) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = ne, this._writableState.destroyed = ne);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var A = safeBufferExports.Buffer, B = A.isEncoding || function(vt) {
    switch (vt = "" + vt, vt && vt.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function W(vt) {
    if (!vt) return "utf8";
    for (var pt; ; )
      switch (vt) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return vt;
        default:
          if (pt) return;
          vt = ("" + vt).toLowerCase(), pt = !0;
      }
  }
  function K(vt) {
    var pt = W(vt);
    if (typeof pt != "string" && (A.isEncoding === B || !B(vt))) throw new Error("Unknown encoding: " + vt);
    return pt || vt;
  }
  string_decoder.StringDecoder = J;
  function J(vt) {
    this.encoding = K(vt);
    var pt;
    switch (this.encoding) {
      case "utf16le":
        this.text = pe, this.end = rt, pt = 4;
        break;
      case "utf8":
        this.fillLast = oe, pt = 4;
        break;
      case "base64":
        this.text = nt, this.end = ot, pt = 3;
        break;
      default:
        this.write = ut, this.end = dt;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = A.allocUnsafe(pt);
  }
  J.prototype.write = function(vt) {
    if (vt.length === 0) return "";
    var pt, mt;
    if (this.lastNeed) {
      if (pt = this.fillLast(vt), pt === void 0) return "";
      mt = this.lastNeed, this.lastNeed = 0;
    } else
      mt = 0;
    return mt < vt.length ? pt ? pt + this.text(vt, mt) : this.text(vt, mt) : pt || "";
  }, J.prototype.end = ne, J.prototype.text = ke, J.prototype.fillLast = function(vt) {
    if (this.lastNeed <= vt.length)
      return vt.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    vt.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, vt.length), this.lastNeed -= vt.length;
  };
  function L(vt) {
    return vt <= 127 ? 0 : vt >> 5 === 6 ? 2 : vt >> 4 === 14 ? 3 : vt >> 3 === 30 ? 4 : vt >> 6 === 2 ? -1 : -2;
  }
  function re(vt, pt, mt) {
    var gt = pt.length - 1;
    if (gt < mt) return 0;
    var Pt = L(pt[gt]);
    return Pt >= 0 ? (Pt > 0 && (vt.lastNeed = Pt - 1), Pt) : --gt < mt || Pt === -2 ? 0 : (Pt = L(pt[gt]), Pt >= 0 ? (Pt > 0 && (vt.lastNeed = Pt - 2), Pt) : --gt < mt || Pt === -2 ? 0 : (Pt = L(pt[gt]), Pt >= 0 ? (Pt > 0 && (Pt === 2 ? Pt = 0 : vt.lastNeed = Pt - 3), Pt) : 0));
  }
  function ie(vt, pt, mt) {
    if ((pt[0] & 192) !== 128)
      return vt.lastNeed = 0, "";
    if (vt.lastNeed > 1 && pt.length > 1) {
      if ((pt[1] & 192) !== 128)
        return vt.lastNeed = 1, "";
      if (vt.lastNeed > 2 && pt.length > 2 && (pt[2] & 192) !== 128)
        return vt.lastNeed = 2, "";
    }
  }
  function oe(vt) {
    var pt = this.lastTotal - this.lastNeed, mt = ie(this, vt);
    if (mt !== void 0) return mt;
    if (this.lastNeed <= vt.length)
      return vt.copy(this.lastChar, pt, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    vt.copy(this.lastChar, pt, 0, vt.length), this.lastNeed -= vt.length;
  }
  function ke(vt, pt) {
    var mt = re(this, vt, pt);
    if (!this.lastNeed) return vt.toString("utf8", pt);
    this.lastTotal = mt;
    var gt = vt.length - (mt - this.lastNeed);
    return vt.copy(this.lastChar, 0, gt), vt.toString("utf8", pt, gt);
  }
  function ne(vt) {
    var pt = vt && vt.length ? this.write(vt) : "";
    return this.lastNeed ? pt + "" : pt;
  }
  function pe(vt, pt) {
    if ((vt.length - pt) % 2 === 0) {
      var mt = vt.toString("utf16le", pt);
      if (mt) {
        var gt = mt.charCodeAt(mt.length - 1);
        if (gt >= 55296 && gt <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = vt[vt.length - 2], this.lastChar[1] = vt[vt.length - 1], mt.slice(0, -1);
      }
      return mt;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = vt[vt.length - 1], vt.toString("utf16le", pt, vt.length - 1);
  }
  function rt(vt) {
    var pt = vt && vt.length ? this.write(vt) : "";
    if (this.lastNeed) {
      var mt = this.lastTotal - this.lastNeed;
      return pt + this.lastChar.toString("utf16le", 0, mt);
    }
    return pt;
  }
  function nt(vt, pt) {
    var mt = (vt.length - pt) % 3;
    return mt === 0 ? vt.toString("base64", pt) : (this.lastNeed = 3 - mt, this.lastTotal = 3, mt === 1 ? this.lastChar[0] = vt[vt.length - 1] : (this.lastChar[0] = vt[vt.length - 2], this.lastChar[1] = vt[vt.length - 1]), vt.toString("base64", pt, vt.length - mt));
  }
  function ot(vt) {
    var pt = vt && vt.length ? this.write(vt) : "";
    return this.lastNeed ? pt + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : pt;
  }
  function ut(vt) {
    return vt.toString(this.encoding);
  }
  function dt(vt) {
    return vt && vt.length ? this.write(vt) : "";
  }
  return string_decoder;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var A = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function B(L) {
    var re = !1;
    return function() {
      if (!re) {
        re = !0;
        for (var ie = arguments.length, oe = new Array(ie), ke = 0; ke < ie; ke++)
          oe[ke] = arguments[ke];
        L.apply(this, oe);
      }
    };
  }
  function W() {
  }
  function K(L) {
    return L.setHeader && typeof L.abort == "function";
  }
  function J(L, re, ie) {
    if (typeof re == "function") return J(L, null, re);
    re || (re = {}), ie = B(ie || W);
    var oe = re.readable || re.readable !== !1 && L.readable, ke = re.writable || re.writable !== !1 && L.writable, ne = function() {
      L.writable || rt();
    }, pe = L._writableState && L._writableState.finished, rt = function() {
      ke = !1, pe = !0, oe || ie.call(L);
    }, nt = L._readableState && L._readableState.endEmitted, ot = function() {
      oe = !1, nt = !0, ke || ie.call(L);
    }, ut = function(mt) {
      ie.call(L, mt);
    }, dt = function() {
      var mt;
      if (oe && !nt)
        return (!L._readableState || !L._readableState.ended) && (mt = new A()), ie.call(L, mt);
      if (ke && !pe)
        return (!L._writableState || !L._writableState.ended) && (mt = new A()), ie.call(L, mt);
    }, vt = function() {
      L.req.on("finish", rt);
    };
    return K(L) ? (L.on("complete", rt), L.on("abort", dt), L.req ? vt() : L.on("request", vt)) : ke && !L._writableState && (L.on("end", ne), L.on("close", ne)), L.on("end", ot), L.on("finish", rt), re.error !== !1 && L.on("error", ut), L.on("close", dt), function() {
      L.removeListener("complete", rt), L.removeListener("abort", dt), L.removeListener("request", vt), L.req && L.req.removeListener("finish", rt), L.removeListener("end", ne), L.removeListener("close", ne), L.removeListener("finish", rt), L.removeListener("end", ot), L.removeListener("error", ut), L.removeListener("close", dt);
    };
  }
  return endOfStream = J, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var A;
  function B(mt, gt, Pt) {
    return gt = W(gt), gt in mt ? Object.defineProperty(mt, gt, { value: Pt, enumerable: !0, configurable: !0, writable: !0 }) : mt[gt] = Pt, mt;
  }
  function W(mt) {
    var gt = K(mt, "string");
    return typeof gt == "symbol" ? gt : String(gt);
  }
  function K(mt, gt) {
    if (typeof mt != "object" || mt === null) return mt;
    var Pt = mt[Symbol.toPrimitive];
    if (Pt !== void 0) {
      var xt = Pt.call(mt, gt);
      if (typeof xt != "object") return xt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (gt === "string" ? String : Number)(mt);
  }
  var J = requireEndOfStream(), L = Symbol("lastResolve"), re = Symbol("lastReject"), ie = Symbol("error"), oe = Symbol("ended"), ke = Symbol("lastPromise"), ne = Symbol("handlePromise"), pe = Symbol("stream");
  function rt(mt, gt) {
    return {
      value: mt,
      done: gt
    };
  }
  function nt(mt) {
    var gt = mt[L];
    if (gt !== null) {
      var Pt = mt[pe].read();
      Pt !== null && (mt[ke] = null, mt[L] = null, mt[re] = null, gt(rt(Pt, !1)));
    }
  }
  function ot(mt) {
    process$1.nextTick(nt, mt);
  }
  function ut(mt, gt) {
    return function(Pt, xt) {
      mt.then(function() {
        if (gt[oe]) {
          Pt(rt(void 0, !0));
          return;
        }
        gt[ne](Pt, xt);
      }, xt);
    };
  }
  var dt = Object.getPrototypeOf(function() {
  }), vt = Object.setPrototypeOf((A = {
    get stream() {
      return this[pe];
    },
    next: function() {
      var gt = this, Pt = this[ie];
      if (Pt !== null)
        return Promise.reject(Pt);
      if (this[oe])
        return Promise.resolve(rt(void 0, !0));
      if (this[pe].destroyed)
        return new Promise(function(bt, Bt) {
          process$1.nextTick(function() {
            gt[ie] ? Bt(gt[ie]) : bt(rt(void 0, !0));
          });
        });
      var xt = this[ke], Nt;
      if (xt)
        Nt = new Promise(ut(xt, this));
      else {
        var Et = this[pe].read();
        if (Et !== null)
          return Promise.resolve(rt(Et, !1));
        Nt = new Promise(this[ne]);
      }
      return this[ke] = Nt, Nt;
    }
  }, B(A, Symbol.asyncIterator, function() {
    return this;
  }), B(A, "return", function() {
    var gt = this;
    return new Promise(function(Pt, xt) {
      gt[pe].destroy(null, function(Nt) {
        if (Nt) {
          xt(Nt);
          return;
        }
        Pt(rt(void 0, !0));
      });
    });
  }), A), dt), pt = function(gt) {
    var Pt, xt = Object.create(vt, (Pt = {}, B(Pt, pe, {
      value: gt,
      writable: !0
    }), B(Pt, L, {
      value: null,
      writable: !0
    }), B(Pt, re, {
      value: null,
      writable: !0
    }), B(Pt, ie, {
      value: null,
      writable: !0
    }), B(Pt, oe, {
      value: gt._readableState.endEmitted,
      writable: !0
    }), B(Pt, ne, {
      value: function(Et, bt) {
        var Bt = xt[pe].read();
        Bt ? (xt[ke] = null, xt[L] = null, xt[re] = null, Et(rt(Bt, !1))) : (xt[L] = Et, xt[re] = bt);
      },
      writable: !0
    }), Pt));
    return xt[ke] = null, J(gt, function(Nt) {
      if (Nt && Nt.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Et = xt[re];
        Et !== null && (xt[ke] = null, xt[L] = null, xt[re] = null, Et(Nt)), xt[ie] = Nt;
        return;
      }
      var bt = xt[L];
      bt !== null && (xt[ke] = null, xt[L] = null, xt[re] = null, bt(rt(void 0, !0))), xt[oe] = !0;
    }), gt.on("readable", ot.bind(null, xt)), xt;
  };
  return async_iterator = pt, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = bt;
  var A;
  bt.ReadableState = Et, requireEvents().EventEmitter;
  var B = function(Rt, Wt) {
    return Rt.listeners(Wt).length;
  }, W = requireStreamBrowser$1(), K = require$$0$1.Buffer, J = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function L(Tt) {
    return K.from(Tt);
  }
  function re(Tt) {
    return K.isBuffer(Tt) || Tt instanceof J;
  }
  var ie = requireUtil$1(), oe;
  ie && ie.debuglog ? oe = ie.debuglog("stream") : oe = function() {
  };
  var ke = requireBuffer_list(), ne = requireDestroy$1(), pe = requireState(), rt = pe.getHighWaterMark, nt = requireErrorsBrowser().codes, ot = nt.ERR_INVALID_ARG_TYPE, ut = nt.ERR_STREAM_PUSH_AFTER_EOF, dt = nt.ERR_METHOD_NOT_IMPLEMENTED, vt = nt.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, pt, mt, gt;
  requireInherits_browser()(bt, W);
  var Pt = ne.errorOrDestroy, xt = ["error", "close", "destroy", "pause", "resume"];
  function Nt(Tt, Rt, Wt) {
    if (typeof Tt.prependListener == "function") return Tt.prependListener(Rt, Wt);
    !Tt._events || !Tt._events[Rt] ? Tt.on(Rt, Wt) : Array.isArray(Tt._events[Rt]) ? Tt._events[Rt].unshift(Wt) : Tt._events[Rt] = [Wt, Tt._events[Rt]];
  }
  function Et(Tt, Rt, Wt) {
    A = A || require_stream_duplex$1(), Tt = Tt || {}, typeof Wt != "boolean" && (Wt = Rt instanceof A), this.objectMode = !!Tt.objectMode, Wt && (this.objectMode = this.objectMode || !!Tt.readableObjectMode), this.highWaterMark = rt(this, Tt, "readableHighWaterMark", Wt), this.buffer = new ke(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Tt.emitClose !== !1, this.autoDestroy = !!Tt.autoDestroy, this.destroyed = !1, this.defaultEncoding = Tt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Tt.encoding && (pt || (pt = requireString_decoder().StringDecoder), this.decoder = new pt(Tt.encoding), this.encoding = Tt.encoding);
  }
  function bt(Tt) {
    if (A = A || require_stream_duplex$1(), !(this instanceof bt)) return new bt(Tt);
    var Rt = this instanceof A;
    this._readableState = new Et(Tt, this, Rt), this.readable = !0, Tt && (typeof Tt.read == "function" && (this._read = Tt.read), typeof Tt.destroy == "function" && (this._destroy = Tt.destroy)), W.call(this);
  }
  Object.defineProperty(bt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Rt) {
      this._readableState && (this._readableState.destroyed = Rt);
    }
  }), bt.prototype.destroy = ne.destroy, bt.prototype._undestroy = ne.undestroy, bt.prototype._destroy = function(Tt, Rt) {
    Rt(Tt);
  }, bt.prototype.push = function(Tt, Rt) {
    var Wt = this._readableState, Xt;
    return Wt.objectMode ? Xt = !0 : typeof Tt == "string" && (Rt = Rt || Wt.defaultEncoding, Rt !== Wt.encoding && (Tt = K.from(Tt, Rt), Rt = ""), Xt = !0), Bt(this, Tt, Rt, !1, Xt);
  }, bt.prototype.unshift = function(Tt) {
    return Bt(this, Tt, null, !0, !1);
  };
  function Bt(Tt, Rt, Wt, Xt, Zt) {
    oe("readableAddChunk", Rt);
    var ar = Tt._readableState;
    if (Rt === null)
      ar.reading = !1, it(Tt, ar);
    else {
      var fr;
      if (Zt || (fr = st(ar, Rt)), fr)
        Pt(Tt, fr);
      else if (ar.objectMode || Rt && Rt.length > 0)
        if (typeof Rt != "string" && !ar.objectMode && Object.getPrototypeOf(Rt) !== K.prototype && (Rt = L(Rt)), Xt)
          ar.endEmitted ? Pt(Tt, new vt()) : wt(Tt, ar, Rt, !0);
        else if (ar.ended)
          Pt(Tt, new ut());
        else {
          if (ar.destroyed)
            return !1;
          ar.reading = !1, ar.decoder && !Wt ? (Rt = ar.decoder.write(Rt), ar.objectMode || Rt.length !== 0 ? wt(Tt, ar, Rt, !1) : lt(Tt, ar)) : wt(Tt, ar, Rt, !1);
        }
      else Xt || (ar.reading = !1, lt(Tt, ar));
    }
    return !ar.ended && (ar.length < ar.highWaterMark || ar.length === 0);
  }
  function wt(Tt, Rt, Wt, Xt) {
    Rt.flowing && Rt.length === 0 && !Rt.sync ? (Rt.awaitDrain = 0, Tt.emit("data", Wt)) : (Rt.length += Rt.objectMode ? 1 : Wt.length, Xt ? Rt.buffer.unshift(Wt) : Rt.buffer.push(Wt), Rt.needReadable && at(Tt)), lt(Tt, Rt);
  }
  function st(Tt, Rt) {
    var Wt;
    return !re(Rt) && typeof Rt != "string" && Rt !== void 0 && !Tt.objectMode && (Wt = new ot("chunk", ["string", "Buffer", "Uint8Array"], Rt)), Wt;
  }
  bt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, bt.prototype.setEncoding = function(Tt) {
    pt || (pt = requireString_decoder().StringDecoder);
    var Rt = new pt(Tt);
    this._readableState.decoder = Rt, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Wt = this._readableState.buffer.head, Xt = ""; Wt !== null; )
      Xt += Rt.write(Wt.data), Wt = Wt.next;
    return this._readableState.buffer.clear(), Xt !== "" && this._readableState.buffer.push(Xt), this._readableState.length = Xt.length, this;
  };
  var Oe = 1073741824;
  function V(Tt) {
    return Tt >= Oe ? Tt = Oe : (Tt--, Tt |= Tt >>> 1, Tt |= Tt >>> 2, Tt |= Tt >>> 4, Tt |= Tt >>> 8, Tt |= Tt >>> 16, Tt++), Tt;
  }
  function ce(Tt, Rt) {
    return Tt <= 0 || Rt.length === 0 && Rt.ended ? 0 : Rt.objectMode ? 1 : Tt !== Tt ? Rt.flowing && Rt.length ? Rt.buffer.head.data.length : Rt.length : (Tt > Rt.highWaterMark && (Rt.highWaterMark = V(Tt)), Tt <= Rt.length ? Tt : Rt.ended ? Rt.length : (Rt.needReadable = !0, 0));
  }
  bt.prototype.read = function(Tt) {
    oe("read", Tt), Tt = parseInt(Tt, 10);
    var Rt = this._readableState, Wt = Tt;
    if (Tt !== 0 && (Rt.emittedReadable = !1), Tt === 0 && Rt.needReadable && ((Rt.highWaterMark !== 0 ? Rt.length >= Rt.highWaterMark : Rt.length > 0) || Rt.ended))
      return oe("read: emitReadable", Rt.length, Rt.ended), Rt.length === 0 && Rt.ended ? Mt(this) : at(this), null;
    if (Tt = ce(Tt, Rt), Tt === 0 && Rt.ended)
      return Rt.length === 0 && Mt(this), null;
    var Xt = Rt.needReadable;
    oe("need readable", Xt), (Rt.length === 0 || Rt.length - Tt < Rt.highWaterMark) && (Xt = !0, oe("length less than watermark", Xt)), Rt.ended || Rt.reading ? (Xt = !1, oe("reading or ended", Xt)) : Xt && (oe("do read"), Rt.reading = !0, Rt.sync = !0, Rt.length === 0 && (Rt.needReadable = !0), this._read(Rt.highWaterMark), Rt.sync = !1, Rt.reading || (Tt = ce(Wt, Rt)));
    var Zt;
    return Tt > 0 ? Zt = $t(Tt, Rt) : Zt = null, Zt === null ? (Rt.needReadable = Rt.length <= Rt.highWaterMark, Tt = 0) : (Rt.length -= Tt, Rt.awaitDrain = 0), Rt.length === 0 && (Rt.ended || (Rt.needReadable = !0), Wt !== Tt && Rt.ended && Mt(this)), Zt !== null && this.emit("data", Zt), Zt;
  };
  function it(Tt, Rt) {
    if (oe("onEofChunk"), !Rt.ended) {
      if (Rt.decoder) {
        var Wt = Rt.decoder.end();
        Wt && Wt.length && (Rt.buffer.push(Wt), Rt.length += Rt.objectMode ? 1 : Wt.length);
      }
      Rt.ended = !0, Rt.sync ? at(Tt) : (Rt.needReadable = !1, Rt.emittedReadable || (Rt.emittedReadable = !0, ft(Tt)));
    }
  }
  function at(Tt) {
    var Rt = Tt._readableState;
    oe("emitReadable", Rt.needReadable, Rt.emittedReadable), Rt.needReadable = !1, Rt.emittedReadable || (oe("emitReadable", Rt.flowing), Rt.emittedReadable = !0, process$1.nextTick(ft, Tt));
  }
  function ft(Tt) {
    var Rt = Tt._readableState;
    oe("emitReadable_", Rt.destroyed, Rt.length, Rt.ended), !Rt.destroyed && (Rt.length || Rt.ended) && (Tt.emit("readable"), Rt.emittedReadable = !1), Rt.needReadable = !Rt.flowing && !Rt.ended && Rt.length <= Rt.highWaterMark, kt(Tt);
  }
  function lt(Tt, Rt) {
    Rt.readingMore || (Rt.readingMore = !0, process$1.nextTick(ct, Tt, Rt));
  }
  function ct(Tt, Rt) {
    for (; !Rt.reading && !Rt.ended && (Rt.length < Rt.highWaterMark || Rt.flowing && Rt.length === 0); ) {
      var Wt = Rt.length;
      if (oe("maybeReadMore read 0"), Tt.read(0), Wt === Rt.length)
        break;
    }
    Rt.readingMore = !1;
  }
  bt.prototype._read = function(Tt) {
    Pt(this, new dt("_read()"));
  }, bt.prototype.pipe = function(Tt, Rt) {
    var Wt = this, Xt = this._readableState;
    switch (Xt.pipesCount) {
      case 0:
        Xt.pipes = Tt;
        break;
      case 1:
        Xt.pipes = [Xt.pipes, Tt];
        break;
      default:
        Xt.pipes.push(Tt);
        break;
    }
    Xt.pipesCount += 1, oe("pipe count=%d opts=%j", Xt.pipesCount, Rt);
    var Zt = (!Rt || Rt.end !== !1) && Tt !== process$1.stdout && Tt !== process$1.stderr, ar = Zt ? lr : $r;
    Xt.endEmitted ? process$1.nextTick(ar) : Wt.once("end", ar), Tt.on("unpipe", fr);
    function fr(yr, kr) {
      oe("onunpipe"), yr === Wt && kr && kr.hasUnpiped === !1 && (kr.hasUnpiped = !0, sr());
    }
    function lr() {
      oe("onend"), Tt.end();
    }
    var Jt = ht(Wt);
    Tt.on("drain", Jt);
    var _r = !1;
    function sr() {
      oe("cleanup"), Tt.removeListener("close", cr), Tt.removeListener("finish", Br), Tt.removeListener("drain", Jt), Tt.removeListener("error", Sr), Tt.removeListener("unpipe", fr), Wt.removeListener("end", lr), Wt.removeListener("end", $r), Wt.removeListener("data", Mr), _r = !0, Xt.awaitDrain && (!Tt._writableState || Tt._writableState.needDrain) && Jt();
    }
    Wt.on("data", Mr);
    function Mr(yr) {
      oe("ondata");
      var kr = Tt.write(yr);
      oe("dest.write", kr), kr === !1 && ((Xt.pipesCount === 1 && Xt.pipes === Tt || Xt.pipesCount > 1 && Kt(Xt.pipes, Tt) !== -1) && !_r && (oe("false write response, pause", Xt.awaitDrain), Xt.awaitDrain++), Wt.pause());
    }
    function Sr(yr) {
      oe("onerror", yr), $r(), Tt.removeListener("error", Sr), B(Tt, "error") === 0 && Pt(Tt, yr);
    }
    Nt(Tt, "error", Sr);
    function cr() {
      Tt.removeListener("finish", Br), $r();
    }
    Tt.once("close", cr);
    function Br() {
      oe("onfinish"), Tt.removeListener("close", cr), $r();
    }
    Tt.once("finish", Br);
    function $r() {
      oe("unpipe"), Wt.unpipe(Tt);
    }
    return Tt.emit("pipe", Wt), Xt.flowing || (oe("pipe resume"), Wt.resume()), Tt;
  };
  function ht(Tt) {
    return function() {
      var Wt = Tt._readableState;
      oe("pipeOnDrain", Wt.awaitDrain), Wt.awaitDrain && Wt.awaitDrain--, Wt.awaitDrain === 0 && B(Tt, "data") && (Wt.flowing = !0, kt(Tt));
    };
  }
  bt.prototype.unpipe = function(Tt) {
    var Rt = this._readableState, Wt = {
      hasUnpiped: !1
    };
    if (Rt.pipesCount === 0) return this;
    if (Rt.pipesCount === 1)
      return Tt && Tt !== Rt.pipes ? this : (Tt || (Tt = Rt.pipes), Rt.pipes = null, Rt.pipesCount = 0, Rt.flowing = !1, Tt && Tt.emit("unpipe", this, Wt), this);
    if (!Tt) {
      var Xt = Rt.pipes, Zt = Rt.pipesCount;
      Rt.pipes = null, Rt.pipesCount = 0, Rt.flowing = !1;
      for (var ar = 0; ar < Zt; ar++) Xt[ar].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var fr = Kt(Rt.pipes, Tt);
    return fr === -1 ? this : (Rt.pipes.splice(fr, 1), Rt.pipesCount -= 1, Rt.pipesCount === 1 && (Rt.pipes = Rt.pipes[0]), Tt.emit("unpipe", this, Wt), this);
  }, bt.prototype.on = function(Tt, Rt) {
    var Wt = W.prototype.on.call(this, Tt, Rt), Xt = this._readableState;
    return Tt === "data" ? (Xt.readableListening = this.listenerCount("readable") > 0, Xt.flowing !== !1 && this.resume()) : Tt === "readable" && !Xt.endEmitted && !Xt.readableListening && (Xt.readableListening = Xt.needReadable = !0, Xt.flowing = !1, Xt.emittedReadable = !1, oe("on readable", Xt.length, Xt.reading), Xt.length ? at(this) : Xt.reading || process$1.nextTick(yt, this)), Wt;
  }, bt.prototype.addListener = bt.prototype.on, bt.prototype.removeListener = function(Tt, Rt) {
    var Wt = W.prototype.removeListener.call(this, Tt, Rt);
    return Tt === "readable" && process$1.nextTick(Ce, this), Wt;
  }, bt.prototype.removeAllListeners = function(Tt) {
    var Rt = W.prototype.removeAllListeners.apply(this, arguments);
    return (Tt === "readable" || Tt === void 0) && process$1.nextTick(Ce, this), Rt;
  };
  function Ce(Tt) {
    var Rt = Tt._readableState;
    Rt.readableListening = Tt.listenerCount("readable") > 0, Rt.resumeScheduled && !Rt.paused ? Rt.flowing = !0 : Tt.listenerCount("data") > 0 && Tt.resume();
  }
  function yt(Tt) {
    oe("readable nexttick read 0"), Tt.read(0);
  }
  bt.prototype.resume = function() {
    var Tt = this._readableState;
    return Tt.flowing || (oe("resume"), Tt.flowing = !Tt.readableListening, qt(this, Tt)), Tt.paused = !1, this;
  };
  function qt(Tt, Rt) {
    Rt.resumeScheduled || (Rt.resumeScheduled = !0, process$1.nextTick(jt, Tt, Rt));
  }
  function jt(Tt, Rt) {
    oe("resume", Rt.reading), Rt.reading || Tt.read(0), Rt.resumeScheduled = !1, Tt.emit("resume"), kt(Tt), Rt.flowing && !Rt.reading && Tt.read(0);
  }
  bt.prototype.pause = function() {
    return oe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (oe("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function kt(Tt) {
    var Rt = Tt._readableState;
    for (oe("flow", Rt.flowing); Rt.flowing && Tt.read() !== null; ) ;
  }
  bt.prototype.wrap = function(Tt) {
    var Rt = this, Wt = this._readableState, Xt = !1;
    Tt.on("end", function() {
      if (oe("wrapped end"), Wt.decoder && !Wt.ended) {
        var fr = Wt.decoder.end();
        fr && fr.length && Rt.push(fr);
      }
      Rt.push(null);
    }), Tt.on("data", function(fr) {
      if (oe("wrapped data"), Wt.decoder && (fr = Wt.decoder.write(fr)), !(Wt.objectMode && fr == null) && !(!Wt.objectMode && (!fr || !fr.length))) {
        var lr = Rt.push(fr);
        lr || (Xt = !0, Tt.pause());
      }
    });
    for (var Zt in Tt)
      this[Zt] === void 0 && typeof Tt[Zt] == "function" && (this[Zt] = /* @__PURE__ */ function(lr) {
        return function() {
          return Tt[lr].apply(Tt, arguments);
        };
      }(Zt));
    for (var ar = 0; ar < xt.length; ar++)
      Tt.on(xt[ar], this.emit.bind(this, xt[ar]));
    return this._read = function(fr) {
      oe("wrapped _read", fr), Xt && (Xt = !1, Tt.resume());
    }, this;
  }, typeof Symbol == "function" && (bt.prototype[Symbol.asyncIterator] = function() {
    return mt === void 0 && (mt = requireAsync_iterator()), mt(this);
  }), Object.defineProperty(bt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(bt.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(bt.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Rt) {
      this._readableState && (this._readableState.flowing = Rt);
    }
  }), bt._fromList = $t, Object.defineProperty(bt.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function $t(Tt, Rt) {
    if (Rt.length === 0) return null;
    var Wt;
    return Rt.objectMode ? Wt = Rt.buffer.shift() : !Tt || Tt >= Rt.length ? (Rt.decoder ? Wt = Rt.buffer.join("") : Rt.buffer.length === 1 ? Wt = Rt.buffer.first() : Wt = Rt.buffer.concat(Rt.length), Rt.buffer.clear()) : Wt = Rt.buffer.consume(Tt, Rt.decoder), Wt;
  }
  function Mt(Tt) {
    var Rt = Tt._readableState;
    oe("endReadable", Rt.endEmitted), Rt.endEmitted || (Rt.ended = !0, process$1.nextTick(Lt, Rt, Tt));
  }
  function Lt(Tt, Rt) {
    if (oe("endReadableNT", Tt.endEmitted, Tt.length), !Tt.endEmitted && Tt.length === 0 && (Tt.endEmitted = !0, Rt.readable = !1, Rt.emit("end"), Tt.autoDestroy)) {
      var Wt = Rt._writableState;
      (!Wt || Wt.autoDestroy && Wt.finished) && Rt.destroy();
    }
  }
  typeof Symbol == "function" && (bt.from = function(Tt, Rt) {
    return gt === void 0 && (gt = requireFromBrowser()), gt(bt, Tt, Rt);
  });
  function Kt(Tt, Rt) {
    for (var Wt = 0, Xt = Tt.length; Wt < Xt; Wt++)
      if (Tt[Wt] === Rt) return Wt;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = ie;
  var A = requireErrorsBrowser().codes, B = A.ERR_METHOD_NOT_IMPLEMENTED, W = A.ERR_MULTIPLE_CALLBACK, K = A.ERR_TRANSFORM_ALREADY_TRANSFORMING, J = A.ERR_TRANSFORM_WITH_LENGTH_0, L = require_stream_duplex$1();
  requireInherits_browser()(ie, L);
  function re(ne, pe) {
    var rt = this._transformState;
    rt.transforming = !1;
    var nt = rt.writecb;
    if (nt === null)
      return this.emit("error", new W());
    rt.writechunk = null, rt.writecb = null, pe != null && this.push(pe), nt(ne);
    var ot = this._readableState;
    ot.reading = !1, (ot.needReadable || ot.length < ot.highWaterMark) && this._read(ot.highWaterMark);
  }
  function ie(ne) {
    if (!(this instanceof ie)) return new ie(ne);
    L.call(this, ne), this._transformState = {
      afterTransform: re.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, ne && (typeof ne.transform == "function" && (this._transform = ne.transform), typeof ne.flush == "function" && (this._flush = ne.flush)), this.on("prefinish", oe);
  }
  function oe() {
    var ne = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(pe, rt) {
      ke(ne, pe, rt);
    }) : ke(this, null, null);
  }
  ie.prototype.push = function(ne, pe) {
    return this._transformState.needTransform = !1, L.prototype.push.call(this, ne, pe);
  }, ie.prototype._transform = function(ne, pe, rt) {
    rt(new B("_transform()"));
  }, ie.prototype._write = function(ne, pe, rt) {
    var nt = this._transformState;
    if (nt.writecb = rt, nt.writechunk = ne, nt.writeencoding = pe, !nt.transforming) {
      var ot = this._readableState;
      (nt.needTransform || ot.needReadable || ot.length < ot.highWaterMark) && this._read(ot.highWaterMark);
    }
  }, ie.prototype._read = function(ne) {
    var pe = this._transformState;
    pe.writechunk !== null && !pe.transforming ? (pe.transforming = !0, this._transform(pe.writechunk, pe.writeencoding, pe.afterTransform)) : pe.needTransform = !0;
  }, ie.prototype._destroy = function(ne, pe) {
    L.prototype._destroy.call(this, ne, function(rt) {
      pe(rt);
    });
  };
  function ke(ne, pe, rt) {
    if (pe) return ne.emit("error", pe);
    if (rt != null && ne.push(rt), ne._writableState.length) throw new J();
    if (ne._transformState.transforming) throw new K();
    return ne.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = B;
  var A = require_stream_transform$1();
  requireInherits_browser()(B, A);
  function B(W) {
    if (!(this instanceof B)) return new B(W);
    A.call(this, W);
  }
  return B.prototype._transform = function(W, K, J) {
    J(null, W);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var A;
  function B(rt) {
    var nt = !1;
    return function() {
      nt || (nt = !0, rt.apply(void 0, arguments));
    };
  }
  var W = requireErrorsBrowser().codes, K = W.ERR_MISSING_ARGS, J = W.ERR_STREAM_DESTROYED;
  function L(rt) {
    if (rt) throw rt;
  }
  function re(rt) {
    return rt.setHeader && typeof rt.abort == "function";
  }
  function ie(rt, nt, ot, ut) {
    ut = B(ut);
    var dt = !1;
    rt.on("close", function() {
      dt = !0;
    }), A === void 0 && (A = requireEndOfStream()), A(rt, {
      readable: nt,
      writable: ot
    }, function(pt) {
      if (pt) return ut(pt);
      dt = !0, ut();
    });
    var vt = !1;
    return function(pt) {
      if (!dt && !vt) {
        if (vt = !0, re(rt)) return rt.abort();
        if (typeof rt.destroy == "function") return rt.destroy();
        ut(pt || new J("pipe"));
      }
    };
  }
  function oe(rt) {
    rt();
  }
  function ke(rt, nt) {
    return rt.pipe(nt);
  }
  function ne(rt) {
    return !rt.length || typeof rt[rt.length - 1] != "function" ? L : rt.pop();
  }
  function pe() {
    for (var rt = arguments.length, nt = new Array(rt), ot = 0; ot < rt; ot++)
      nt[ot] = arguments[ot];
    var ut = ne(nt);
    if (Array.isArray(nt[0]) && (nt = nt[0]), nt.length < 2)
      throw new K("streams");
    var dt, vt = nt.map(function(pt, mt) {
      var gt = mt < nt.length - 1, Pt = mt > 0;
      return ie(pt, gt, Pt, function(xt) {
        dt || (dt = xt), xt && vt.forEach(oe), !gt && (vt.forEach(oe), ut(dt));
      });
    });
    return nt.reduce(ke);
  }
  return pipeline_1 = pe, pipeline_1;
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
  return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1, function(A, B) {
    B = A.exports = require_stream_readable$1(), B.Stream = B, B.Readable = B, B.Writable = require_stream_writable$1(), B.Duplex = require_stream_duplex$1(), B.Transform = require_stream_transform$1(), B.PassThrough = require_stream_passthrough$1(), B.finished = requireEndOfStream(), B.pipeline = requirePipeline();
  }(readableBrowser$1, readableBrowser$1.exports)), readableBrowser$1.exports;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var A = safeBufferExports.Buffer, B = requireReadableBrowser$1().Transform, W = requireInherits_browser();
  function K(L, re) {
    if (!A.isBuffer(L) && typeof L != "string")
      throw new TypeError(re + " must be a string or a buffer");
  }
  function J(L) {
    B.call(this), this._block = A.allocUnsafe(L), this._blockSize = L, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return W(J, B), J.prototype._transform = function(L, re, ie) {
    var oe = null;
    try {
      this.update(L, re);
    } catch (ke) {
      oe = ke;
    }
    ie(oe);
  }, J.prototype._flush = function(L) {
    var re = null;
    try {
      this.push(this.digest());
    } catch (ie) {
      re = ie;
    }
    L(re);
  }, J.prototype.update = function(L, re) {
    if (K(L, "Data"), this._finalized) throw new Error("Digest already called");
    A.isBuffer(L) || (L = A.from(L, re));
    for (var ie = this._block, oe = 0; this._blockOffset + L.length - oe >= this._blockSize; ) {
      for (var ke = this._blockOffset; ke < this._blockSize; ) ie[ke++] = L[oe++];
      this._update(), this._blockOffset = 0;
    }
    for (; oe < L.length; ) ie[this._blockOffset++] = L[oe++];
    for (var ne = 0, pe = L.length * 8; pe > 0; ++ne)
      this._length[ne] += pe, pe = this._length[ne] / 4294967296 | 0, pe > 0 && (this._length[ne] -= 4294967296 * pe);
    return this;
  }, J.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, J.prototype.digest = function(L) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0;
    var re = this._digest();
    L !== void 0 && (re = re.toString(L)), this._block.fill(0), this._blockOffset = 0;
    for (var ie = 0; ie < 4; ++ie) this._length[ie] = 0;
    return re;
  }, J.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = J, hashBase;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var A = requireInherits_browser(), B = requireHashBase(), W = safeBufferExports.Buffer, K = new Array(16);
  function J() {
    B.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  A(J, B), J.prototype._update = function() {
    for (var ne = K, pe = 0; pe < 16; ++pe) ne[pe] = this._block.readInt32LE(pe * 4);
    var rt = this._a, nt = this._b, ot = this._c, ut = this._d;
    rt = re(rt, nt, ot, ut, ne[0], 3614090360, 7), ut = re(ut, rt, nt, ot, ne[1], 3905402710, 12), ot = re(ot, ut, rt, nt, ne[2], 606105819, 17), nt = re(nt, ot, ut, rt, ne[3], 3250441966, 22), rt = re(rt, nt, ot, ut, ne[4], 4118548399, 7), ut = re(ut, rt, nt, ot, ne[5], 1200080426, 12), ot = re(ot, ut, rt, nt, ne[6], 2821735955, 17), nt = re(nt, ot, ut, rt, ne[7], 4249261313, 22), rt = re(rt, nt, ot, ut, ne[8], 1770035416, 7), ut = re(ut, rt, nt, ot, ne[9], 2336552879, 12), ot = re(ot, ut, rt, nt, ne[10], 4294925233, 17), nt = re(nt, ot, ut, rt, ne[11], 2304563134, 22), rt = re(rt, nt, ot, ut, ne[12], 1804603682, 7), ut = re(ut, rt, nt, ot, ne[13], 4254626195, 12), ot = re(ot, ut, rt, nt, ne[14], 2792965006, 17), nt = re(nt, ot, ut, rt, ne[15], 1236535329, 22), rt = ie(rt, nt, ot, ut, ne[1], 4129170786, 5), ut = ie(ut, rt, nt, ot, ne[6], 3225465664, 9), ot = ie(ot, ut, rt, nt, ne[11], 643717713, 14), nt = ie(nt, ot, ut, rt, ne[0], 3921069994, 20), rt = ie(rt, nt, ot, ut, ne[5], 3593408605, 5), ut = ie(ut, rt, nt, ot, ne[10], 38016083, 9), ot = ie(ot, ut, rt, nt, ne[15], 3634488961, 14), nt = ie(nt, ot, ut, rt, ne[4], 3889429448, 20), rt = ie(rt, nt, ot, ut, ne[9], 568446438, 5), ut = ie(ut, rt, nt, ot, ne[14], 3275163606, 9), ot = ie(ot, ut, rt, nt, ne[3], 4107603335, 14), nt = ie(nt, ot, ut, rt, ne[8], 1163531501, 20), rt = ie(rt, nt, ot, ut, ne[13], 2850285829, 5), ut = ie(ut, rt, nt, ot, ne[2], 4243563512, 9), ot = ie(ot, ut, rt, nt, ne[7], 1735328473, 14), nt = ie(nt, ot, ut, rt, ne[12], 2368359562, 20), rt = oe(rt, nt, ot, ut, ne[5], 4294588738, 4), ut = oe(ut, rt, nt, ot, ne[8], 2272392833, 11), ot = oe(ot, ut, rt, nt, ne[11], 1839030562, 16), nt = oe(nt, ot, ut, rt, ne[14], 4259657740, 23), rt = oe(rt, nt, ot, ut, ne[1], 2763975236, 4), ut = oe(ut, rt, nt, ot, ne[4], 1272893353, 11), ot = oe(ot, ut, rt, nt, ne[7], 4139469664, 16), nt = oe(nt, ot, ut, rt, ne[10], 3200236656, 23), rt = oe(rt, nt, ot, ut, ne[13], 681279174, 4), ut = oe(ut, rt, nt, ot, ne[0], 3936430074, 11), ot = oe(ot, ut, rt, nt, ne[3], 3572445317, 16), nt = oe(nt, ot, ut, rt, ne[6], 76029189, 23), rt = oe(rt, nt, ot, ut, ne[9], 3654602809, 4), ut = oe(ut, rt, nt, ot, ne[12], 3873151461, 11), ot = oe(ot, ut, rt, nt, ne[15], 530742520, 16), nt = oe(nt, ot, ut, rt, ne[2], 3299628645, 23), rt = ke(rt, nt, ot, ut, ne[0], 4096336452, 6), ut = ke(ut, rt, nt, ot, ne[7], 1126891415, 10), ot = ke(ot, ut, rt, nt, ne[14], 2878612391, 15), nt = ke(nt, ot, ut, rt, ne[5], 4237533241, 21), rt = ke(rt, nt, ot, ut, ne[12], 1700485571, 6), ut = ke(ut, rt, nt, ot, ne[3], 2399980690, 10), ot = ke(ot, ut, rt, nt, ne[10], 4293915773, 15), nt = ke(nt, ot, ut, rt, ne[1], 2240044497, 21), rt = ke(rt, nt, ot, ut, ne[8], 1873313359, 6), ut = ke(ut, rt, nt, ot, ne[15], 4264355552, 10), ot = ke(ot, ut, rt, nt, ne[6], 2734768916, 15), nt = ke(nt, ot, ut, rt, ne[13], 1309151649, 21), rt = ke(rt, nt, ot, ut, ne[4], 4149444226, 6), ut = ke(ut, rt, nt, ot, ne[11], 3174756917, 10), ot = ke(ot, ut, rt, nt, ne[2], 718787259, 15), nt = ke(nt, ot, ut, rt, ne[9], 3951481745, 21), this._a = this._a + rt | 0, this._b = this._b + nt | 0, this._c = this._c + ot | 0, this._d = this._d + ut | 0;
  }, J.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var ne = W.allocUnsafe(16);
    return ne.writeInt32LE(this._a, 0), ne.writeInt32LE(this._b, 4), ne.writeInt32LE(this._c, 8), ne.writeInt32LE(this._d, 12), ne;
  };
  function L(ne, pe) {
    return ne << pe | ne >>> 32 - pe;
  }
  function re(ne, pe, rt, nt, ot, ut, dt) {
    return L(ne + (pe & rt | ~pe & nt) + ot + ut | 0, dt) + pe | 0;
  }
  function ie(ne, pe, rt, nt, ot, ut, dt) {
    return L(ne + (pe & nt | rt & ~nt) + ot + ut | 0, dt) + pe | 0;
  }
  function oe(ne, pe, rt, nt, ot, ut, dt) {
    return L(ne + (pe ^ rt ^ nt) + ot + ut | 0, dt) + pe | 0;
  }
  function ke(ne, pe, rt, nt, ot, ut, dt) {
    return L(ne + (rt ^ (pe | ~nt)) + ot + ut | 0, dt) + pe | 0;
  }
  return md5_js = J, md5_js;
}
var ripemd160$1, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160$1;
  hasRequiredRipemd160 = 1;
  var A = require$$0$1.Buffer, B = requireInherits_browser(), W = requireHashBase(), K = new Array(16), J = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], L = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], re = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], ie = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], oe = [0, 1518500249, 1859775393, 2400959708, 2840853838], ke = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function ne() {
    W.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  B(ne, W), ne.prototype._update = function() {
    for (var vt = K, pt = 0; pt < 16; ++pt) vt[pt] = this._block.readInt32LE(pt * 4);
    for (var mt = this._a | 0, gt = this._b | 0, Pt = this._c | 0, xt = this._d | 0, Nt = this._e | 0, Et = this._a | 0, bt = this._b | 0, Bt = this._c | 0, wt = this._d | 0, st = this._e | 0, Oe = 0; Oe < 80; Oe += 1) {
      var V, ce;
      Oe < 16 ? (V = rt(mt, gt, Pt, xt, Nt, vt[J[Oe]], oe[0], re[Oe]), ce = dt(Et, bt, Bt, wt, st, vt[L[Oe]], ke[0], ie[Oe])) : Oe < 32 ? (V = nt(mt, gt, Pt, xt, Nt, vt[J[Oe]], oe[1], re[Oe]), ce = ut(Et, bt, Bt, wt, st, vt[L[Oe]], ke[1], ie[Oe])) : Oe < 48 ? (V = ot(mt, gt, Pt, xt, Nt, vt[J[Oe]], oe[2], re[Oe]), ce = ot(Et, bt, Bt, wt, st, vt[L[Oe]], ke[2], ie[Oe])) : Oe < 64 ? (V = ut(mt, gt, Pt, xt, Nt, vt[J[Oe]], oe[3], re[Oe]), ce = nt(Et, bt, Bt, wt, st, vt[L[Oe]], ke[3], ie[Oe])) : (V = dt(mt, gt, Pt, xt, Nt, vt[J[Oe]], oe[4], re[Oe]), ce = rt(Et, bt, Bt, wt, st, vt[L[Oe]], ke[4], ie[Oe])), mt = Nt, Nt = xt, xt = pe(Pt, 10), Pt = gt, gt = V, Et = st, st = wt, wt = pe(Bt, 10), Bt = bt, bt = ce;
    }
    var it = this._b + Pt + wt | 0;
    this._b = this._c + xt + st | 0, this._c = this._d + Nt + Et | 0, this._d = this._e + mt + bt | 0, this._e = this._a + gt + Bt | 0, this._a = it;
  }, ne.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var vt = A.alloc ? A.alloc(20) : new A(20);
    return vt.writeInt32LE(this._a, 0), vt.writeInt32LE(this._b, 4), vt.writeInt32LE(this._c, 8), vt.writeInt32LE(this._d, 12), vt.writeInt32LE(this._e, 16), vt;
  };
  function pe(vt, pt) {
    return vt << pt | vt >>> 32 - pt;
  }
  function rt(vt, pt, mt, gt, Pt, xt, Nt, Et) {
    return pe(vt + (pt ^ mt ^ gt) + xt + Nt | 0, Et) + Pt | 0;
  }
  function nt(vt, pt, mt, gt, Pt, xt, Nt, Et) {
    return pe(vt + (pt & mt | ~pt & gt) + xt + Nt | 0, Et) + Pt | 0;
  }
  function ot(vt, pt, mt, gt, Pt, xt, Nt, Et) {
    return pe(vt + ((pt | ~mt) ^ gt) + xt + Nt | 0, Et) + Pt | 0;
  }
  function ut(vt, pt, mt, gt, Pt, xt, Nt, Et) {
    return pe(vt + (pt & gt | mt & ~gt) + xt + Nt | 0, Et) + Pt | 0;
  }
  function dt(vt, pt, mt, gt, Pt, xt, Nt, Et) {
    return pe(vt + (pt ^ (mt | ~gt)) + xt + Nt | 0, Et) + Pt | 0;
  }
  return ripemd160$1 = ne, ripemd160$1;
}
var sha_js = { exports: {} }, hash$1, hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1) return hash$1;
  hasRequiredHash$1 = 1;
  var A = safeBufferExports.Buffer;
  function B(W, K) {
    this._block = A.alloc(W), this._finalSize = K, this._blockSize = W, this._len = 0;
  }
  return B.prototype.update = function(W, K) {
    typeof W == "string" && (K = K || "utf8", W = A.from(W, K));
    for (var J = this._block, L = this._blockSize, re = W.length, ie = this._len, oe = 0; oe < re; ) {
      for (var ke = ie % L, ne = Math.min(re - oe, L - ke), pe = 0; pe < ne; pe++)
        J[ke + pe] = W[oe + pe];
      ie += ne, oe += ne, ie % L === 0 && this._update(J);
    }
    return this._len += re, this;
  }, B.prototype.digest = function(W) {
    var K = this._len % this._blockSize;
    this._block[K] = 128, this._block.fill(0, K + 1), K >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var J = this._len * 8;
    if (J <= 4294967295)
      this._block.writeUInt32BE(J, this._blockSize - 4);
    else {
      var L = (J & 4294967295) >>> 0, re = (J - L) / 4294967296;
      this._block.writeUInt32BE(re, this._blockSize - 8), this._block.writeUInt32BE(L, this._blockSize - 4);
    }
    this._update(this._block);
    var ie = this._hash();
    return W ? ie.toString(W) : ie;
  }, B.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$1 = B, hash$1;
}
var sha$1, hasRequiredSha$1;
function requireSha$1() {
  if (hasRequiredSha$1) return sha$1;
  hasRequiredSha$1 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), W = safeBufferExports.Buffer, K = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], J = new Array(80);
  function L() {
    this.init(), this._w = J, B.call(this, 64, 56);
  }
  A(L, B), L.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function re(ke) {
    return ke << 5 | ke >>> 27;
  }
  function ie(ke) {
    return ke << 30 | ke >>> 2;
  }
  function oe(ke, ne, pe, rt) {
    return ke === 0 ? ne & pe | ~ne & rt : ke === 2 ? ne & pe | ne & rt | pe & rt : ne ^ pe ^ rt;
  }
  return L.prototype._update = function(ke) {
    for (var ne = this._w, pe = this._a | 0, rt = this._b | 0, nt = this._c | 0, ot = this._d | 0, ut = this._e | 0, dt = 0; dt < 16; ++dt) ne[dt] = ke.readInt32BE(dt * 4);
    for (; dt < 80; ++dt) ne[dt] = ne[dt - 3] ^ ne[dt - 8] ^ ne[dt - 14] ^ ne[dt - 16];
    for (var vt = 0; vt < 80; ++vt) {
      var pt = ~~(vt / 20), mt = re(pe) + oe(pt, rt, nt, ot) + ut + ne[vt] + K[pt] | 0;
      ut = ot, ot = nt, nt = ie(rt), rt = pe, pe = mt;
    }
    this._a = pe + this._a | 0, this._b = rt + this._b | 0, this._c = nt + this._c | 0, this._d = ot + this._d | 0, this._e = ut + this._e | 0;
  }, L.prototype._hash = function() {
    var ke = W.allocUnsafe(20);
    return ke.writeInt32BE(this._a | 0, 0), ke.writeInt32BE(this._b | 0, 4), ke.writeInt32BE(this._c | 0, 8), ke.writeInt32BE(this._d | 0, 12), ke.writeInt32BE(this._e | 0, 16), ke;
  }, sha$1 = L, sha$1;
}
var sha1$1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1$1;
  hasRequiredSha1 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), W = safeBufferExports.Buffer, K = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], J = new Array(80);
  function L() {
    this.init(), this._w = J, B.call(this, 64, 56);
  }
  A(L, B), L.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function re(ne) {
    return ne << 1 | ne >>> 31;
  }
  function ie(ne) {
    return ne << 5 | ne >>> 27;
  }
  function oe(ne) {
    return ne << 30 | ne >>> 2;
  }
  function ke(ne, pe, rt, nt) {
    return ne === 0 ? pe & rt | ~pe & nt : ne === 2 ? pe & rt | pe & nt | rt & nt : pe ^ rt ^ nt;
  }
  return L.prototype._update = function(ne) {
    for (var pe = this._w, rt = this._a | 0, nt = this._b | 0, ot = this._c | 0, ut = this._d | 0, dt = this._e | 0, vt = 0; vt < 16; ++vt) pe[vt] = ne.readInt32BE(vt * 4);
    for (; vt < 80; ++vt) pe[vt] = re(pe[vt - 3] ^ pe[vt - 8] ^ pe[vt - 14] ^ pe[vt - 16]);
    for (var pt = 0; pt < 80; ++pt) {
      var mt = ~~(pt / 20), gt = ie(rt) + ke(mt, nt, ot, ut) + dt + pe[pt] + K[mt] | 0;
      dt = ut, ut = ot, ot = oe(nt), nt = rt, rt = gt;
    }
    this._a = rt + this._a | 0, this._b = nt + this._b | 0, this._c = ot + this._c | 0, this._d = ut + this._d | 0, this._e = dt + this._e | 0;
  }, L.prototype._hash = function() {
    var ne = W.allocUnsafe(20);
    return ne.writeInt32BE(this._a | 0, 0), ne.writeInt32BE(this._b | 0, 4), ne.writeInt32BE(this._c | 0, 8), ne.writeInt32BE(this._d | 0, 12), ne.writeInt32BE(this._e | 0, 16), ne;
  }, sha1$1 = L, sha1$1;
}
var sha256$3, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$3;
  hasRequiredSha256 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), W = safeBufferExports.Buffer, K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], J = new Array(64);
  function L() {
    this.init(), this._w = J, B.call(this, 64, 56);
  }
  A(L, B), L.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function re(rt, nt, ot) {
    return ot ^ rt & (nt ^ ot);
  }
  function ie(rt, nt, ot) {
    return rt & nt | ot & (rt | nt);
  }
  function oe(rt) {
    return (rt >>> 2 | rt << 30) ^ (rt >>> 13 | rt << 19) ^ (rt >>> 22 | rt << 10);
  }
  function ke(rt) {
    return (rt >>> 6 | rt << 26) ^ (rt >>> 11 | rt << 21) ^ (rt >>> 25 | rt << 7);
  }
  function ne(rt) {
    return (rt >>> 7 | rt << 25) ^ (rt >>> 18 | rt << 14) ^ rt >>> 3;
  }
  function pe(rt) {
    return (rt >>> 17 | rt << 15) ^ (rt >>> 19 | rt << 13) ^ rt >>> 10;
  }
  return L.prototype._update = function(rt) {
    for (var nt = this._w, ot = this._a | 0, ut = this._b | 0, dt = this._c | 0, vt = this._d | 0, pt = this._e | 0, mt = this._f | 0, gt = this._g | 0, Pt = this._h | 0, xt = 0; xt < 16; ++xt) nt[xt] = rt.readInt32BE(xt * 4);
    for (; xt < 64; ++xt) nt[xt] = pe(nt[xt - 2]) + nt[xt - 7] + ne(nt[xt - 15]) + nt[xt - 16] | 0;
    for (var Nt = 0; Nt < 64; ++Nt) {
      var Et = Pt + ke(pt) + re(pt, mt, gt) + K[Nt] + nt[Nt] | 0, bt = oe(ot) + ie(ot, ut, dt) | 0;
      Pt = gt, gt = mt, mt = pt, pt = vt + Et | 0, vt = dt, dt = ut, ut = ot, ot = Et + bt | 0;
    }
    this._a = ot + this._a | 0, this._b = ut + this._b | 0, this._c = dt + this._c | 0, this._d = vt + this._d | 0, this._e = pt + this._e | 0, this._f = mt + this._f | 0, this._g = gt + this._g | 0, this._h = Pt + this._h | 0;
  }, L.prototype._hash = function() {
    var rt = W.allocUnsafe(32);
    return rt.writeInt32BE(this._a, 0), rt.writeInt32BE(this._b, 4), rt.writeInt32BE(this._c, 8), rt.writeInt32BE(this._d, 12), rt.writeInt32BE(this._e, 16), rt.writeInt32BE(this._f, 20), rt.writeInt32BE(this._g, 24), rt.writeInt32BE(this._h, 28), rt;
  }, sha256$3 = L, sha256$3;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var A = requireInherits_browser(), B = requireSha256(), W = requireHash$1(), K = safeBufferExports.Buffer, J = new Array(64);
  function L() {
    this.init(), this._w = J, W.call(this, 64, 56);
  }
  return A(L, B), L.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, L.prototype._hash = function() {
    var re = K.allocUnsafe(28);
    return re.writeInt32BE(this._a, 0), re.writeInt32BE(this._b, 4), re.writeInt32BE(this._c, 8), re.writeInt32BE(this._d, 12), re.writeInt32BE(this._e, 16), re.writeInt32BE(this._f, 20), re.writeInt32BE(this._g, 24), re;
  }, sha224$1 = L, sha224$1;
}
var sha512$1, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$1;
  hasRequiredSha512 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), W = safeBufferExports.Buffer, K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], J = new Array(160);
  function L() {
    this.init(), this._w = J, B.call(this, 128, 112);
  }
  A(L, B), L.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function re(ut, dt, vt) {
    return vt ^ ut & (dt ^ vt);
  }
  function ie(ut, dt, vt) {
    return ut & dt | vt & (ut | dt);
  }
  function oe(ut, dt) {
    return (ut >>> 28 | dt << 4) ^ (dt >>> 2 | ut << 30) ^ (dt >>> 7 | ut << 25);
  }
  function ke(ut, dt) {
    return (ut >>> 14 | dt << 18) ^ (ut >>> 18 | dt << 14) ^ (dt >>> 9 | ut << 23);
  }
  function ne(ut, dt) {
    return (ut >>> 1 | dt << 31) ^ (ut >>> 8 | dt << 24) ^ ut >>> 7;
  }
  function pe(ut, dt) {
    return (ut >>> 1 | dt << 31) ^ (ut >>> 8 | dt << 24) ^ (ut >>> 7 | dt << 25);
  }
  function rt(ut, dt) {
    return (ut >>> 19 | dt << 13) ^ (dt >>> 29 | ut << 3) ^ ut >>> 6;
  }
  function nt(ut, dt) {
    return (ut >>> 19 | dt << 13) ^ (dt >>> 29 | ut << 3) ^ (ut >>> 6 | dt << 26);
  }
  function ot(ut, dt) {
    return ut >>> 0 < dt >>> 0 ? 1 : 0;
  }
  return L.prototype._update = function(ut) {
    for (var dt = this._w, vt = this._ah | 0, pt = this._bh | 0, mt = this._ch | 0, gt = this._dh | 0, Pt = this._eh | 0, xt = this._fh | 0, Nt = this._gh | 0, Et = this._hh | 0, bt = this._al | 0, Bt = this._bl | 0, wt = this._cl | 0, st = this._dl | 0, Oe = this._el | 0, V = this._fl | 0, ce = this._gl | 0, it = this._hl | 0, at = 0; at < 32; at += 2)
      dt[at] = ut.readInt32BE(at * 4), dt[at + 1] = ut.readInt32BE(at * 4 + 4);
    for (; at < 160; at += 2) {
      var ft = dt[at - 30], lt = dt[at - 15 * 2 + 1], ct = ne(ft, lt), ht = pe(lt, ft);
      ft = dt[at - 2 * 2], lt = dt[at - 2 * 2 + 1];
      var Ce = rt(ft, lt), yt = nt(lt, ft), qt = dt[at - 7 * 2], jt = dt[at - 7 * 2 + 1], kt = dt[at - 16 * 2], $t = dt[at - 16 * 2 + 1], Mt = ht + jt | 0, Lt = ct + qt + ot(Mt, ht) | 0;
      Mt = Mt + yt | 0, Lt = Lt + Ce + ot(Mt, yt) | 0, Mt = Mt + $t | 0, Lt = Lt + kt + ot(Mt, $t) | 0, dt[at] = Lt, dt[at + 1] = Mt;
    }
    for (var Kt = 0; Kt < 160; Kt += 2) {
      Lt = dt[Kt], Mt = dt[Kt + 1];
      var Tt = ie(vt, pt, mt), Rt = ie(bt, Bt, wt), Wt = oe(vt, bt), Xt = oe(bt, vt), Zt = ke(Pt, Oe), ar = ke(Oe, Pt), fr = K[Kt], lr = K[Kt + 1], Jt = re(Pt, xt, Nt), _r = re(Oe, V, ce), sr = it + ar | 0, Mr = Et + Zt + ot(sr, it) | 0;
      sr = sr + _r | 0, Mr = Mr + Jt + ot(sr, _r) | 0, sr = sr + lr | 0, Mr = Mr + fr + ot(sr, lr) | 0, sr = sr + Mt | 0, Mr = Mr + Lt + ot(sr, Mt) | 0;
      var Sr = Xt + Rt | 0, cr = Wt + Tt + ot(Sr, Xt) | 0;
      Et = Nt, it = ce, Nt = xt, ce = V, xt = Pt, V = Oe, Oe = st + sr | 0, Pt = gt + Mr + ot(Oe, st) | 0, gt = mt, st = wt, mt = pt, wt = Bt, pt = vt, Bt = bt, bt = sr + Sr | 0, vt = Mr + cr + ot(bt, sr) | 0;
    }
    this._al = this._al + bt | 0, this._bl = this._bl + Bt | 0, this._cl = this._cl + wt | 0, this._dl = this._dl + st | 0, this._el = this._el + Oe | 0, this._fl = this._fl + V | 0, this._gl = this._gl + ce | 0, this._hl = this._hl + it | 0, this._ah = this._ah + vt + ot(this._al, bt) | 0, this._bh = this._bh + pt + ot(this._bl, Bt) | 0, this._ch = this._ch + mt + ot(this._cl, wt) | 0, this._dh = this._dh + gt + ot(this._dl, st) | 0, this._eh = this._eh + Pt + ot(this._el, Oe) | 0, this._fh = this._fh + xt + ot(this._fl, V) | 0, this._gh = this._gh + Nt + ot(this._gl, ce) | 0, this._hh = this._hh + Et + ot(this._hl, it) | 0;
  }, L.prototype._hash = function() {
    var ut = W.allocUnsafe(64);
    function dt(vt, pt, mt) {
      ut.writeInt32BE(vt, mt), ut.writeInt32BE(pt, mt + 4);
    }
    return dt(this._ah, this._al, 0), dt(this._bh, this._bl, 8), dt(this._ch, this._cl, 16), dt(this._dh, this._dl, 24), dt(this._eh, this._el, 32), dt(this._fh, this._fl, 40), dt(this._gh, this._gl, 48), dt(this._hh, this._hl, 56), ut;
  }, sha512$1 = L, sha512$1;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var A = requireInherits_browser(), B = requireSha512(), W = requireHash$1(), K = safeBufferExports.Buffer, J = new Array(160);
  function L() {
    this.init(), this._w = J, W.call(this, 128, 112);
  }
  return A(L, B), L.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, L.prototype._hash = function() {
    var re = K.allocUnsafe(48);
    function ie(oe, ke, ne) {
      re.writeInt32BE(oe, ne), re.writeInt32BE(ke, ne + 4);
    }
    return ie(this._ah, this._al, 0), ie(this._bh, this._bl, 8), ie(this._ch, this._cl, 16), ie(this._dh, this._dl, 24), ie(this._eh, this._el, 32), ie(this._fh, this._fl, 40), re;
  }, sha384$1 = L, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  var A = sha_js.exports = function(W) {
    W = W.toLowerCase();
    var K = A[W];
    if (!K) throw new Error(W + " is not supported (we accept pull requests)");
    return new K();
  };
  return A.sha = requireSha$1(), A.sha1 = requireSha1(), A.sha224 = requireSha224(), A.sha256 = requireSha256(), A.sha384 = requireSha384(), A.sha512 = requireSha512(), sha_js.exports;
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = W;
  var A = requireEvents().EventEmitter, B = requireInherits_browser();
  B(W, A), W.Readable = require_stream_readable$1(), W.Writable = require_stream_writable$1(), W.Duplex = require_stream_duplex$1(), W.Transform = require_stream_transform$1(), W.PassThrough = require_stream_passthrough$1(), W.finished = requireEndOfStream(), W.pipeline = requirePipeline(), W.Stream = W;
  function W() {
    A.call(this);
  }
  return W.prototype.pipe = function(K, J) {
    var L = this;
    function re(nt) {
      K.writable && K.write(nt) === !1 && L.pause && L.pause();
    }
    L.on("data", re);
    function ie() {
      L.readable && L.resume && L.resume();
    }
    K.on("drain", ie), !K._isStdio && (!J || J.end !== !1) && (L.on("end", ke), L.on("close", ne));
    var oe = !1;
    function ke() {
      oe || (oe = !0, K.end());
    }
    function ne() {
      oe || (oe = !0, typeof K.destroy == "function" && K.destroy());
    }
    function pe(nt) {
      if (rt(), A.listenerCount(this, "error") === 0)
        throw nt;
    }
    L.on("error", pe), K.on("error", pe);
    function rt() {
      L.removeListener("data", re), K.removeListener("drain", ie), L.removeListener("end", ke), L.removeListener("close", ne), L.removeListener("error", pe), K.removeListener("error", pe), L.removeListener("end", rt), L.removeListener("close", rt), K.removeListener("close", rt);
    }
    return L.on("end", rt), L.on("close", rt), K.on("close", rt), K.emit("pipe", L), K;
  }, streamBrowserify;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var A = safeBufferExports.Buffer, B = requireStreamBrowserify().Transform, W = requireString_decoder().StringDecoder, K = requireInherits_browser();
  function J(oe) {
    B.call(this), this.hashMode = typeof oe == "string", this.hashMode ? this[oe] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  K(J, B);
  var L = typeof Uint8Array < "u", re = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (A.prototype instanceof Uint8Array || A.TYPED_ARRAY_SUPPORT);
  function ie(oe, ke) {
    if (oe instanceof A)
      return oe;
    if (typeof oe == "string")
      return A.from(oe, ke);
    if (re && ArrayBuffer.isView(oe)) {
      if (oe.byteLength === 0)
        return A.alloc(0);
      var ne = A.from(oe.buffer, oe.byteOffset, oe.byteLength);
      if (ne.byteLength === oe.byteLength)
        return ne;
    }
    if (L && oe instanceof Uint8Array || A.isBuffer(oe) && oe.constructor && typeof oe.constructor.isBuffer == "function" && oe.constructor.isBuffer(oe))
      return A.from(oe);
    throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
  }
  return J.prototype.update = function(oe, ke, ne) {
    var pe = ie(oe, ke), rt = this._update(pe);
    return this.hashMode ? this : (ne && (rt = this._toString(rt, ne)), rt);
  }, J.prototype.setAutoPadding = function() {
  }, J.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, J.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, J.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, J.prototype._transform = function(oe, ke, ne) {
    var pe;
    try {
      this.hashMode ? this._update(oe) : this.push(this._update(oe));
    } catch (rt) {
      pe = rt;
    } finally {
      ne(pe);
    }
  }, J.prototype._flush = function(oe) {
    var ke;
    try {
      this.push(this.__final());
    } catch (ne) {
      ke = ne;
    }
    oe(ke);
  }, J.prototype._finalOrDigest = function(oe) {
    var ke = this.__final() || A.alloc(0);
    return oe && (ke = this._toString(ke, oe, !0)), ke;
  }, J.prototype._toString = function(oe, ke, ne) {
    if (this._decoder || (this._decoder = new W(ke), this._encoding = ke), this._encoding !== ke)
      throw new Error("cant switch encodings");
    var pe = this._decoder.write(oe);
    return ne && (pe += this._decoder.end()), pe;
  }, cipherBase = J, cipherBase;
}
var browser$9, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$9;
  hasRequiredBrowser$9 = 1;
  var A = requireInherits_browser(), B = requireMd5_js(), W = requireRipemd160(), K = requireSha_js(), J = requireCipherBase();
  function L(re) {
    J.call(this, "digest"), this._hash = re;
  }
  return A(L, J), L.prototype._update = function(re) {
    this._hash.update(re);
  }, L.prototype._final = function() {
    return this._hash.digest();
  }, browser$9 = function(ie) {
    return ie = ie.toLowerCase(), ie === "md5" ? new B() : ie === "rmd160" || ie === "ripemd160" ? new W() : new L(K(ie));
  }, browser$9;
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var A = requireInherits_browser(), B = safeBufferExports.Buffer, W = requireCipherBase(), K = B.alloc(128), J = 64;
  function L(re, ie) {
    W.call(this, "digest"), typeof ie == "string" && (ie = B.from(ie)), this._alg = re, this._key = ie, ie.length > J ? ie = re(ie) : ie.length < J && (ie = B.concat([ie, K], J));
    for (var oe = this._ipad = B.allocUnsafe(J), ke = this._opad = B.allocUnsafe(J), ne = 0; ne < J; ne++)
      oe[ne] = ie[ne] ^ 54, ke[ne] = ie[ne] ^ 92;
    this._hash = [oe];
  }
  return A(L, W), L.prototype._update = function(re) {
    this._hash.push(re);
  }, L.prototype._final = function() {
    var re = this._alg(B.concat(this._hash));
    return this._alg(B.concat([this._opad, re]));
  }, legacy = L, legacy;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var A = requireMd5_js();
  return md5 = function(B) {
    return new A().update(B).digest();
  }, md5;
}
var browser$8, hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8) return browser$8;
  hasRequiredBrowser$8 = 1;
  var A = requireInherits_browser(), B = requireLegacy(), W = requireCipherBase(), K = safeBufferExports.Buffer, J = requireMd5(), L = requireRipemd160(), re = requireSha_js(), ie = K.alloc(128);
  function oe(ke, ne) {
    W.call(this, "digest"), typeof ne == "string" && (ne = K.from(ne));
    var pe = ke === "sha512" || ke === "sha384" ? 128 : 64;
    if (this._alg = ke, this._key = ne, ne.length > pe) {
      var rt = ke === "rmd160" ? new L() : re(ke);
      ne = rt.update(ne).digest();
    } else ne.length < pe && (ne = K.concat([ne, ie], pe));
    for (var nt = this._ipad = K.allocUnsafe(pe), ot = this._opad = K.allocUnsafe(pe), ut = 0; ut < pe; ut++)
      nt[ut] = ne[ut] ^ 54, ot[ut] = ne[ut] ^ 92;
    this._hash = ke === "rmd160" ? new L() : re(ke), this._hash.update(nt);
  }
  return A(oe, W), oe.prototype._update = function(ke) {
    this._hash.update(ke);
  }, oe.prototype._final = function() {
    var ke = this._hash.digest(), ne = this._alg === "rmd160" ? new L() : re(this._alg);
    return ne.update(this._opad).update(ke).digest();
  }, browser$8 = function(ne, pe) {
    return ne = ne.toLowerCase(), ne === "rmd160" || ne === "ripemd160" ? new oe("rmd160", pe) : ne === "md5" ? new B(J, pe) : new oe(ne, pe);
  }, browser$8;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$2 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$2,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$7 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var A = Math.pow(2, 30) - 1;
  return precondition = function(B, W) {
    if (typeof B != "number")
      throw new TypeError("Iterations not a number");
    if (B < 0)
      throw new TypeError("Bad iterations");
    if (typeof W != "number")
      throw new TypeError("Key length not a number");
    if (W < 0 || W > A || W !== W)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding) return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var A;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    A = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var B = parseInt(process$1.version.split(".")[0].slice(1), 10);
    A = B >= 6 ? "utf-8" : "binary";
  } else
    A = "utf-8";
  return defaultEncoding_1 = A, defaultEncoding_1;
}
var toBuffer$1, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer$1;
  hasRequiredToBuffer = 1;
  var A = safeBufferExports.Buffer;
  return toBuffer$1 = function(B, W, K) {
    if (A.isBuffer(B))
      return B;
    if (typeof B == "string")
      return A.from(B, W);
    if (ArrayBuffer.isView(B))
      return A.from(B.buffer);
    throw new TypeError(K + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer$1;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var A = requireMd5(), B = requireRipemd160(), W = requireSha_js(), K = safeBufferExports.Buffer, J = requirePrecondition(), L = requireDefaultEncoding(), re = requireToBuffer(), ie = K.alloc(128), oe = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function ke(rt, nt, ot) {
    var ut = ne(rt), dt = rt === "sha512" || rt === "sha384" ? 128 : 64;
    nt.length > dt ? nt = ut(nt) : nt.length < dt && (nt = K.concat([nt, ie], dt));
    for (var vt = K.allocUnsafe(dt + oe[rt]), pt = K.allocUnsafe(dt + oe[rt]), mt = 0; mt < dt; mt++)
      vt[mt] = nt[mt] ^ 54, pt[mt] = nt[mt] ^ 92;
    var gt = K.allocUnsafe(dt + ot + 4);
    vt.copy(gt, 0, 0, dt), this.ipad1 = gt, this.ipad2 = vt, this.opad = pt, this.alg = rt, this.blocksize = dt, this.hash = ut, this.size = oe[rt];
  }
  ke.prototype.run = function(rt, nt) {
    rt.copy(nt, this.blocksize);
    var ot = this.hash(nt);
    return ot.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function ne(rt) {
    function nt(ut) {
      return W(rt).update(ut).digest();
    }
    function ot(ut) {
      return new B().update(ut).digest();
    }
    return rt === "rmd160" || rt === "ripemd160" ? ot : rt === "md5" ? A : nt;
  }
  function pe(rt, nt, ot, ut, dt) {
    J(ot, ut), rt = re(rt, L, "Password"), nt = re(nt, L, "Salt"), dt = dt || "sha1";
    var vt = new ke(dt, rt, nt.length), pt = K.allocUnsafe(ut), mt = K.allocUnsafe(nt.length + 4);
    nt.copy(mt, 0, 0, nt.length);
    for (var gt = 0, Pt = oe[dt], xt = Math.ceil(ut / Pt), Nt = 1; Nt <= xt; Nt++) {
      mt.writeUInt32BE(Nt, nt.length);
      for (var Et = vt.run(mt, vt.ipad1), bt = Et, Bt = 1; Bt < ot; Bt++) {
        bt = vt.run(bt, vt.ipad2);
        for (var wt = 0; wt < Pt; wt++) Et[wt] ^= bt[wt];
      }
      Et.copy(pt, gt), gt += Pt;
    }
    return pt;
  }
  return syncBrowser = pe, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var A = safeBufferExports.Buffer, B = requirePrecondition(), W = requireDefaultEncoding(), K = requireSyncBrowser(), J = requireToBuffer(), L, re = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, ie = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, oe = [];
  function ke(ot) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !re || !re.importKey || !re.deriveBits)
      return Promise.resolve(!1);
    if (oe[ot] !== void 0)
      return oe[ot];
    L = L || A.alloc(8);
    var ut = rt(L, L, 10, 128, ot).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return oe[ot] = ut, ut;
  }
  var ne;
  function pe() {
    return ne || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? ne = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? ne = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? ne = commonjsGlobal.setImmediate : ne = commonjsGlobal.setTimeout, ne);
  }
  function rt(ot, ut, dt, vt, pt) {
    return re.importKey(
      "raw",
      ot,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(mt) {
      return re.deriveBits({
        name: "PBKDF2",
        salt: ut,
        iterations: dt,
        hash: {
          name: pt
        }
      }, mt, vt << 3);
    }).then(function(mt) {
      return A.from(mt);
    });
  }
  function nt(ot, ut) {
    ot.then(function(dt) {
      pe()(function() {
        ut(null, dt);
      });
    }, function(dt) {
      pe()(function() {
        ut(dt);
      });
    });
  }
  return async = function(ot, ut, dt, vt, pt, mt) {
    typeof pt == "function" && (mt = pt, pt = void 0), pt = pt || "sha1";
    var gt = ie[pt.toLowerCase()];
    if (!gt || typeof commonjsGlobal.Promise != "function") {
      pe()(function() {
        var Pt;
        try {
          Pt = K(ot, ut, dt, vt, pt);
        } catch (xt) {
          return mt(xt);
        }
        mt(null, Pt);
      });
      return;
    }
    if (B(dt, vt), ot = J(ot, W, "Password"), ut = J(ut, W, "Salt"), typeof mt != "function") throw new Error("No callback provided to pbkdf2");
    nt(ke(gt).then(function(Pt) {
      return Pt ? rt(ot, ut, dt, vt, gt) : K(ot, ut, dt, vt, pt);
    }), mt);
  }, async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$7.pbkdf2 = requireAsync(), browser$7.pbkdf2Sync = requireSyncBrowser()), browser$7;
}
var browser$6 = {}, des$1 = {}, utils$4 = {}, hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$4;
  hasRequiredUtils$3 = 1, utils$4.readUInt32BE = function(J, L) {
    var re = J[0 + L] << 24 | J[1 + L] << 16 | J[2 + L] << 8 | J[3 + L];
    return re >>> 0;
  }, utils$4.writeUInt32BE = function(J, L, re) {
    J[0 + re] = L >>> 24, J[1 + re] = L >>> 16 & 255, J[2 + re] = L >>> 8 & 255, J[3 + re] = L & 255;
  }, utils$4.ip = function(J, L, re, ie) {
    for (var oe = 0, ke = 0, ne = 6; ne >= 0; ne -= 2) {
      for (var pe = 0; pe <= 24; pe += 8)
        oe <<= 1, oe |= L >>> pe + ne & 1;
      for (var pe = 0; pe <= 24; pe += 8)
        oe <<= 1, oe |= J >>> pe + ne & 1;
    }
    for (var ne = 6; ne >= 0; ne -= 2) {
      for (var pe = 1; pe <= 25; pe += 8)
        ke <<= 1, ke |= L >>> pe + ne & 1;
      for (var pe = 1; pe <= 25; pe += 8)
        ke <<= 1, ke |= J >>> pe + ne & 1;
    }
    re[ie + 0] = oe >>> 0, re[ie + 1] = ke >>> 0;
  }, utils$4.rip = function(J, L, re, ie) {
    for (var oe = 0, ke = 0, ne = 0; ne < 4; ne++)
      for (var pe = 24; pe >= 0; pe -= 8)
        oe <<= 1, oe |= L >>> pe + ne & 1, oe <<= 1, oe |= J >>> pe + ne & 1;
    for (var ne = 4; ne < 8; ne++)
      for (var pe = 24; pe >= 0; pe -= 8)
        ke <<= 1, ke |= L >>> pe + ne & 1, ke <<= 1, ke |= J >>> pe + ne & 1;
    re[ie + 0] = oe >>> 0, re[ie + 1] = ke >>> 0;
  }, utils$4.pc1 = function(J, L, re, ie) {
    for (var oe = 0, ke = 0, ne = 7; ne >= 5; ne--) {
      for (var pe = 0; pe <= 24; pe += 8)
        oe <<= 1, oe |= L >> pe + ne & 1;
      for (var pe = 0; pe <= 24; pe += 8)
        oe <<= 1, oe |= J >> pe + ne & 1;
    }
    for (var pe = 0; pe <= 24; pe += 8)
      oe <<= 1, oe |= L >> pe + ne & 1;
    for (var ne = 1; ne <= 3; ne++) {
      for (var pe = 0; pe <= 24; pe += 8)
        ke <<= 1, ke |= L >> pe + ne & 1;
      for (var pe = 0; pe <= 24; pe += 8)
        ke <<= 1, ke |= J >> pe + ne & 1;
    }
    for (var pe = 0; pe <= 24; pe += 8)
      ke <<= 1, ke |= J >> pe + ne & 1;
    re[ie + 0] = oe >>> 0, re[ie + 1] = ke >>> 0;
  }, utils$4.r28shl = function(J, L) {
    return J << L & 268435455 | J >>> 28 - L;
  };
  var A = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$4.pc2 = function(J, L, re, ie) {
    for (var oe = 0, ke = 0, ne = A.length >>> 1, pe = 0; pe < ne; pe++)
      oe <<= 1, oe |= J >>> A[pe] & 1;
    for (var pe = ne; pe < A.length; pe++)
      ke <<= 1, ke |= L >>> A[pe] & 1;
    re[ie + 0] = oe >>> 0, re[ie + 1] = ke >>> 0;
  }, utils$4.expand = function(J, L, re) {
    var ie = 0, oe = 0;
    ie = (J & 1) << 5 | J >>> 27;
    for (var ke = 23; ke >= 15; ke -= 4)
      ie <<= 6, ie |= J >>> ke & 63;
    for (var ke = 11; ke >= 3; ke -= 4)
      oe |= J >>> ke & 63, oe <<= 6;
    oe |= (J & 31) << 1 | J >>> 31, L[re + 0] = ie >>> 0, L[re + 1] = oe >>> 0;
  };
  var B = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$4.substitute = function(J, L) {
    for (var re = 0, ie = 0; ie < 4; ie++) {
      var oe = J >>> 18 - ie * 6 & 63, ke = B[ie * 64 + oe];
      re <<= 4, re |= ke;
    }
    for (var ie = 0; ie < 4; ie++) {
      var oe = L >>> 18 - ie * 6 & 63, ke = B[4 * 64 + ie * 64 + oe];
      re <<= 4, re |= ke;
    }
    return re >>> 0;
  };
  var W = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$4.permute = function(J) {
    for (var L = 0, re = 0; re < W.length; re++)
      L <<= 1, L |= J >>> W[re] & 1;
    return L >>> 0;
  }, utils$4.padSplit = function(J, L, re) {
    for (var ie = J.toString(2); ie.length < L; )
      ie = "0" + ie;
    for (var oe = [], ke = 0; ke < L; ke += re)
      oe.push(ie.slice(ke, ke + re));
    return oe.join(" ");
  }, utils$4;
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert) return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1, minimalisticAssert = A;
  function A(B, W) {
    if (!B)
      throw new Error(W || "Assertion failed");
  }
  return A.equal = function(W, K, J) {
    if (W != K)
      throw new Error(J || "Assertion failed: " + W + " != " + K);
  }, minimalisticAssert;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var A = requireMinimalisticAssert();
  function B(W) {
    this.options = W, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = W.padding !== !1;
  }
  return cipher = B, B.prototype._init = function() {
  }, B.prototype.update = function(K) {
    return K.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(K) : this._updateEncrypt(K);
  }, B.prototype._buffer = function(K, J) {
    for (var L = Math.min(this.buffer.length - this.bufferOff, K.length - J), re = 0; re < L; re++)
      this.buffer[this.bufferOff + re] = K[J + re];
    return this.bufferOff += L, L;
  }, B.prototype._flushBuffer = function(K, J) {
    return this._update(this.buffer, 0, K, J), this.bufferOff = 0, this.blockSize;
  }, B.prototype._updateEncrypt = function(K) {
    var J = 0, L = 0, re = (this.bufferOff + K.length) / this.blockSize | 0, ie = new Array(re * this.blockSize);
    this.bufferOff !== 0 && (J += this._buffer(K, J), this.bufferOff === this.buffer.length && (L += this._flushBuffer(ie, L)));
    for (var oe = K.length - (K.length - J) % this.blockSize; J < oe; J += this.blockSize)
      this._update(K, J, ie, L), L += this.blockSize;
    for (; J < K.length; J++, this.bufferOff++)
      this.buffer[this.bufferOff] = K[J];
    return ie;
  }, B.prototype._updateDecrypt = function(K) {
    for (var J = 0, L = 0, re = Math.ceil((this.bufferOff + K.length) / this.blockSize) - 1, ie = new Array(re * this.blockSize); re > 0; re--)
      J += this._buffer(K, J), L += this._flushBuffer(ie, L);
    return J += this._buffer(K, J), ie;
  }, B.prototype.final = function(K) {
    var J;
    K && (J = this.update(K));
    var L;
    return this.type === "encrypt" ? L = this._finalEncrypt() : L = this._finalDecrypt(), J ? J.concat(L) : L;
  }, B.prototype._pad = function(K, J) {
    if (J === 0)
      return !1;
    for (; J < K.length; )
      K[J++] = 0;
    return !0;
  }, B.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var K = new Array(this.blockSize);
    return this._update(this.buffer, 0, K, 0), K;
  }, B.prototype._unpad = function(K) {
    return K;
  }, B.prototype._finalDecrypt = function() {
    A.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var K = new Array(this.blockSize);
    return this._flushBuffer(K, 0), this._unpad(K);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1) return des;
  hasRequiredDes$1 = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser(), W = requireUtils$3(), K = requireCipher();
  function J() {
    this.tmp = new Array(2), this.keys = null;
  }
  function L(ie) {
    K.call(this, ie);
    var oe = new J();
    this._desState = oe, this.deriveKeys(oe, ie.key);
  }
  B(L, K), des = L, L.create = function(oe) {
    return new L(oe);
  };
  var re = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return L.prototype.deriveKeys = function(oe, ke) {
    oe.keys = new Array(16 * 2), A.equal(ke.length, this.blockSize, "Invalid key length");
    var ne = W.readUInt32BE(ke, 0), pe = W.readUInt32BE(ke, 4);
    W.pc1(ne, pe, oe.tmp, 0), ne = oe.tmp[0], pe = oe.tmp[1];
    for (var rt = 0; rt < oe.keys.length; rt += 2) {
      var nt = re[rt >>> 1];
      ne = W.r28shl(ne, nt), pe = W.r28shl(pe, nt), W.pc2(ne, pe, oe.keys, rt);
    }
  }, L.prototype._update = function(oe, ke, ne, pe) {
    var rt = this._desState, nt = W.readUInt32BE(oe, ke), ot = W.readUInt32BE(oe, ke + 4);
    W.ip(nt, ot, rt.tmp, 0), nt = rt.tmp[0], ot = rt.tmp[1], this.type === "encrypt" ? this._encrypt(rt, nt, ot, rt.tmp, 0) : this._decrypt(rt, nt, ot, rt.tmp, 0), nt = rt.tmp[0], ot = rt.tmp[1], W.writeUInt32BE(ne, nt, pe), W.writeUInt32BE(ne, ot, pe + 4);
  }, L.prototype._pad = function(oe, ke) {
    if (this.padding === !1)
      return !1;
    for (var ne = oe.length - ke, pe = ke; pe < oe.length; pe++)
      oe[pe] = ne;
    return !0;
  }, L.prototype._unpad = function(oe) {
    if (this.padding === !1)
      return oe;
    for (var ke = oe[oe.length - 1], ne = oe.length - ke; ne < oe.length; ne++)
      A.equal(oe[ne], ke);
    return oe.slice(0, oe.length - ke);
  }, L.prototype._encrypt = function(oe, ke, ne, pe, rt) {
    for (var nt = ke, ot = ne, ut = 0; ut < oe.keys.length; ut += 2) {
      var dt = oe.keys[ut], vt = oe.keys[ut + 1];
      W.expand(ot, oe.tmp, 0), dt ^= oe.tmp[0], vt ^= oe.tmp[1];
      var pt = W.substitute(dt, vt), mt = W.permute(pt), gt = ot;
      ot = (nt ^ mt) >>> 0, nt = gt;
    }
    W.rip(ot, nt, pe, rt);
  }, L.prototype._decrypt = function(oe, ke, ne, pe, rt) {
    for (var nt = ne, ot = ke, ut = oe.keys.length - 2; ut >= 0; ut -= 2) {
      var dt = oe.keys[ut], vt = oe.keys[ut + 1];
      W.expand(nt, oe.tmp, 0), dt ^= oe.tmp[0], vt ^= oe.tmp[1];
      var pt = W.substitute(dt, vt), mt = W.permute(pt), gt = nt;
      nt = (ot ^ mt) >>> 0, ot = gt;
    }
    W.rip(nt, ot, pe, rt);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser(), W = {};
  function K(L) {
    A.equal(L.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var re = 0; re < this.iv.length; re++)
      this.iv[re] = L[re];
  }
  function J(L) {
    function re(ne) {
      L.call(this, ne), this._cbcInit();
    }
    B(re, L);
    for (var ie = Object.keys(W), oe = 0; oe < ie.length; oe++) {
      var ke = ie[oe];
      re.prototype[ke] = W[ke];
    }
    return re.create = function(pe) {
      return new re(pe);
    }, re;
  }
  return cbc$1.instantiate = J, W._cbcInit = function() {
    var re = new K(this.options.iv);
    this._cbcState = re;
  }, W._update = function(re, ie, oe, ke) {
    var ne = this._cbcState, pe = this.constructor.super_.prototype, rt = ne.iv;
    if (this.type === "encrypt") {
      for (var nt = 0; nt < this.blockSize; nt++)
        rt[nt] ^= re[ie + nt];
      pe._update.call(this, rt, 0, oe, ke);
      for (var nt = 0; nt < this.blockSize; nt++)
        rt[nt] = oe[ke + nt];
    } else {
      pe._update.call(this, re, ie, oe, ke);
      for (var nt = 0; nt < this.blockSize; nt++)
        oe[ke + nt] ^= rt[nt];
      for (var nt = 0; nt < this.blockSize; nt++)
        rt[nt] = re[ie + nt];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser(), W = requireCipher(), K = requireDes$1();
  function J(re, ie) {
    A.equal(ie.length, 24, "Invalid key length");
    var oe = ie.slice(0, 8), ke = ie.slice(8, 16), ne = ie.slice(16, 24);
    re === "encrypt" ? this.ciphers = [
      K.create({ type: "encrypt", key: oe }),
      K.create({ type: "decrypt", key: ke }),
      K.create({ type: "encrypt", key: ne })
    ] : this.ciphers = [
      K.create({ type: "decrypt", key: ne }),
      K.create({ type: "encrypt", key: ke }),
      K.create({ type: "decrypt", key: oe })
    ];
  }
  function L(re) {
    W.call(this, re);
    var ie = new J(this.type, this.options.key);
    this._edeState = ie;
  }
  return B(L, W), ede = L, L.create = function(ie) {
    return new L(ie);
  }, L.prototype._update = function(ie, oe, ke, ne) {
    var pe = this._edeState;
    pe.ciphers[0]._update(ie, oe, ke, ne), pe.ciphers[1]._update(ke, ne, ke, ne), pe.ciphers[2]._update(ke, ne, ke, ne);
  }, L.prototype._pad = K.prototype._pad, L.prototype._unpad = K.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$3(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var A = requireCipherBase(), B = requireDes(), W = requireInherits_browser(), K = safeBufferExports.Buffer, J = {
    "des-ede3-cbc": B.CBC.instantiate(B.EDE),
    "des-ede3": B.EDE,
    "des-ede-cbc": B.CBC.instantiate(B.EDE),
    "des-ede": B.EDE,
    "des-cbc": B.CBC.instantiate(B.DES),
    "des-ecb": B.DES
  };
  J.des = J["des-cbc"], J.des3 = J["des-ede3-cbc"], browserifyDes = L, W(L, A);
  function L(re) {
    A.call(this);
    var ie = re.mode.toLowerCase(), oe = J[ie], ke;
    re.decrypt ? ke = "decrypt" : ke = "encrypt";
    var ne = re.key;
    K.isBuffer(ne) || (ne = K.from(ne)), (ie === "des-ede" || ie === "des-ede-cbc") && (ne = K.concat([ne, ne.slice(0, 8)]));
    var pe = re.iv;
    K.isBuffer(pe) || (pe = K.from(pe)), this._des = oe.create({
      key: ne,
      iv: pe,
      type: ke
    });
  }
  return L.prototype._update = function(re) {
    return K.from(this._des.update(re));
  }, L.prototype._final = function() {
    return K.from(this._des.final());
  }, browserifyDes;
}
var browser$5 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(A, B) {
    return A._cipher.encryptBlock(B);
  }, ecb.decrypt = function(A, B) {
    return A._cipher.decryptBlock(B);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(B, W) {
    for (var K = Math.min(B.length, W.length), J = new Buffer$1(K), L = 0; L < K; ++L)
      J[L] = B[L] ^ W[L];
    return J;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var A = requireBufferXor();
  return cbc.encrypt = function(B, W) {
    var K = A(W, B._prev);
    return B._prev = B._cipher.encryptBlock(K), B._prev;
  }, cbc.decrypt = function(B, W) {
    var K = B._prev;
    B._prev = W;
    var J = B._cipher.decryptBlock(W);
    return A(J, K);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var A = safeBufferExports.Buffer, B = requireBufferXor();
  function W(K, J, L) {
    var re = J.length, ie = B(J, K._cache);
    return K._cache = K._cache.slice(re), K._prev = A.concat([K._prev, L ? J : ie]), ie;
  }
  return cfb.encrypt = function(K, J, L) {
    for (var re = A.allocUnsafe(0), ie; J.length; )
      if (K._cache.length === 0 && (K._cache = K._cipher.encryptBlock(K._prev), K._prev = A.allocUnsafe(0)), K._cache.length <= J.length)
        ie = K._cache.length, re = A.concat([re, W(K, J.slice(0, ie), L)]), J = J.slice(ie);
      else {
        re = A.concat([re, W(K, J, L)]);
        break;
      }
    return re;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var A = safeBufferExports.Buffer;
  function B(W, K, J) {
    var L = W._cipher.encryptBlock(W._prev), re = L[0] ^ K;
    return W._prev = A.concat([
      W._prev.slice(1),
      A.from([J ? K : re])
    ]), re;
  }
  return cfb8.encrypt = function(W, K, J) {
    for (var L = K.length, re = A.allocUnsafe(L), ie = -1; ++ie < L; )
      re[ie] = B(W, K[ie], J);
    return re;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var A = safeBufferExports.Buffer;
  function B(K, J, L) {
    for (var re, ie = -1, oe = 8, ke = 0, ne, pe; ++ie < oe; )
      re = K._cipher.encryptBlock(K._prev), ne = J & 1 << 7 - ie ? 128 : 0, pe = re[0] ^ ne, ke += (pe & 128) >> ie % 8, K._prev = W(K._prev, L ? ne : pe);
    return ke;
  }
  function W(K, J) {
    var L = K.length, re = -1, ie = A.allocUnsafe(K.length);
    for (K = A.concat([K, A.from([J])]); ++re < L; )
      ie[re] = K[re] << 1 | K[re + 1] >> 7;
    return ie;
  }
  return cfb1.encrypt = function(K, J, L) {
    for (var re = J.length, ie = A.allocUnsafe(re), oe = -1; ++oe < re; )
      ie[oe] = B(K, J[oe], L);
    return ie;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var A = requireBufferXor();
  function B(W) {
    return W._prev = W._cipher.encryptBlock(W._prev), W._prev;
  }
  return ofb.encrypt = function(W, K) {
    for (; W._cache.length < K.length; )
      W._cache = Buffer$1.concat([W._cache, B(W)]);
    var J = W._cache.slice(0, K.length);
    return W._cache = W._cache.slice(K.length), A(K, J);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32) return incr32_1;
  hasRequiredIncr32 = 1;
  function A(B) {
    for (var W = B.length, K; W--; )
      if (K = B.readUInt8(W), K === 255)
        B.writeUInt8(0, W);
      else {
        K++, B.writeUInt8(K, W);
        break;
      }
  }
  return incr32_1 = A, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var A = requireBufferXor(), B = safeBufferExports.Buffer, W = requireIncr32();
  function K(L) {
    var re = L._cipher.encryptBlockRaw(L._prev);
    return W(L._prev), re;
  }
  var J = 16;
  return ctr.encrypt = function(L, re) {
    var ie = Math.ceil(re.length / J), oe = L._cache.length;
    L._cache = B.concat([
      L._cache,
      B.allocUnsafe(ie * J)
    ]);
    for (var ke = 0; ke < ie; ke++) {
      var ne = K(L), pe = oe + ke * J;
      L._cache.writeUInt32BE(ne[0], pe + 0), L._cache.writeUInt32BE(ne[1], pe + 4), L._cache.writeUInt32BE(ne[2], pe + 8), L._cache.writeUInt32BE(ne[3], pe + 12);
    }
    var rt = L._cache.slice(0, re.length);
    return L._cache = L._cache.slice(re.length), A(re, rt);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var A = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, B = require$$2;
  for (var W in B)
    B[W].module = A[B[W].mode];
  return modes_1 = B, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var A = safeBufferExports.Buffer;
  function B(ie) {
    A.isBuffer(ie) || (ie = A.from(ie));
    for (var oe = ie.length / 4 | 0, ke = new Array(oe), ne = 0; ne < oe; ne++)
      ke[ne] = ie.readUInt32BE(ne * 4);
    return ke;
  }
  function W(ie) {
    for (var oe = 0; oe < ie.length; ie++)
      ie[oe] = 0;
  }
  function K(ie, oe, ke, ne, pe) {
    for (var rt = ke[0], nt = ke[1], ot = ke[2], ut = ke[3], dt = ie[0] ^ oe[0], vt = ie[1] ^ oe[1], pt = ie[2] ^ oe[2], mt = ie[3] ^ oe[3], gt, Pt, xt, Nt, Et = 4, bt = 1; bt < pe; bt++)
      gt = rt[dt >>> 24] ^ nt[vt >>> 16 & 255] ^ ot[pt >>> 8 & 255] ^ ut[mt & 255] ^ oe[Et++], Pt = rt[vt >>> 24] ^ nt[pt >>> 16 & 255] ^ ot[mt >>> 8 & 255] ^ ut[dt & 255] ^ oe[Et++], xt = rt[pt >>> 24] ^ nt[mt >>> 16 & 255] ^ ot[dt >>> 8 & 255] ^ ut[vt & 255] ^ oe[Et++], Nt = rt[mt >>> 24] ^ nt[dt >>> 16 & 255] ^ ot[vt >>> 8 & 255] ^ ut[pt & 255] ^ oe[Et++], dt = gt, vt = Pt, pt = xt, mt = Nt;
    return gt = (ne[dt >>> 24] << 24 | ne[vt >>> 16 & 255] << 16 | ne[pt >>> 8 & 255] << 8 | ne[mt & 255]) ^ oe[Et++], Pt = (ne[vt >>> 24] << 24 | ne[pt >>> 16 & 255] << 16 | ne[mt >>> 8 & 255] << 8 | ne[dt & 255]) ^ oe[Et++], xt = (ne[pt >>> 24] << 24 | ne[mt >>> 16 & 255] << 16 | ne[dt >>> 8 & 255] << 8 | ne[vt & 255]) ^ oe[Et++], Nt = (ne[mt >>> 24] << 24 | ne[dt >>> 16 & 255] << 16 | ne[vt >>> 8 & 255] << 8 | ne[pt & 255]) ^ oe[Et++], gt = gt >>> 0, Pt = Pt >>> 0, xt = xt >>> 0, Nt = Nt >>> 0, [gt, Pt, xt, Nt];
  }
  var J = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], L = function() {
    for (var ie = new Array(256), oe = 0; oe < 256; oe++)
      oe < 128 ? ie[oe] = oe << 1 : ie[oe] = oe << 1 ^ 283;
    for (var ke = [], ne = [], pe = [[], [], [], []], rt = [[], [], [], []], nt = 0, ot = 0, ut = 0; ut < 256; ++ut) {
      var dt = ot ^ ot << 1 ^ ot << 2 ^ ot << 3 ^ ot << 4;
      dt = dt >>> 8 ^ dt & 255 ^ 99, ke[nt] = dt, ne[dt] = nt;
      var vt = ie[nt], pt = ie[vt], mt = ie[pt], gt = ie[dt] * 257 ^ dt * 16843008;
      pe[0][nt] = gt << 24 | gt >>> 8, pe[1][nt] = gt << 16 | gt >>> 16, pe[2][nt] = gt << 8 | gt >>> 24, pe[3][nt] = gt, gt = mt * 16843009 ^ pt * 65537 ^ vt * 257 ^ nt * 16843008, rt[0][dt] = gt << 24 | gt >>> 8, rt[1][dt] = gt << 16 | gt >>> 16, rt[2][dt] = gt << 8 | gt >>> 24, rt[3][dt] = gt, nt === 0 ? nt = ot = 1 : (nt = vt ^ ie[ie[ie[mt ^ vt]]], ot ^= ie[ie[ot]]);
    }
    return {
      SBOX: ke,
      INV_SBOX: ne,
      SUB_MIX: pe,
      INV_SUB_MIX: rt
    };
  }();
  function re(ie) {
    this._key = B(ie), this._reset();
  }
  return re.blockSize = 4 * 4, re.keySize = 256 / 8, re.prototype.blockSize = re.blockSize, re.prototype.keySize = re.keySize, re.prototype._reset = function() {
    for (var ie = this._key, oe = ie.length, ke = oe + 6, ne = (ke + 1) * 4, pe = [], rt = 0; rt < oe; rt++)
      pe[rt] = ie[rt];
    for (rt = oe; rt < ne; rt++) {
      var nt = pe[rt - 1];
      rt % oe === 0 ? (nt = nt << 8 | nt >>> 24, nt = L.SBOX[nt >>> 24] << 24 | L.SBOX[nt >>> 16 & 255] << 16 | L.SBOX[nt >>> 8 & 255] << 8 | L.SBOX[nt & 255], nt ^= J[rt / oe | 0] << 24) : oe > 6 && rt % oe === 4 && (nt = L.SBOX[nt >>> 24] << 24 | L.SBOX[nt >>> 16 & 255] << 16 | L.SBOX[nt >>> 8 & 255] << 8 | L.SBOX[nt & 255]), pe[rt] = pe[rt - oe] ^ nt;
    }
    for (var ot = [], ut = 0; ut < ne; ut++) {
      var dt = ne - ut, vt = pe[dt - (ut % 4 ? 0 : 4)];
      ut < 4 || dt <= 4 ? ot[ut] = vt : ot[ut] = L.INV_SUB_MIX[0][L.SBOX[vt >>> 24]] ^ L.INV_SUB_MIX[1][L.SBOX[vt >>> 16 & 255]] ^ L.INV_SUB_MIX[2][L.SBOX[vt >>> 8 & 255]] ^ L.INV_SUB_MIX[3][L.SBOX[vt & 255]];
    }
    this._nRounds = ke, this._keySchedule = pe, this._invKeySchedule = ot;
  }, re.prototype.encryptBlockRaw = function(ie) {
    return ie = B(ie), K(ie, this._keySchedule, L.SUB_MIX, L.SBOX, this._nRounds);
  }, re.prototype.encryptBlock = function(ie) {
    var oe = this.encryptBlockRaw(ie), ke = A.allocUnsafe(16);
    return ke.writeUInt32BE(oe[0], 0), ke.writeUInt32BE(oe[1], 4), ke.writeUInt32BE(oe[2], 8), ke.writeUInt32BE(oe[3], 12), ke;
  }, re.prototype.decryptBlock = function(ie) {
    ie = B(ie);
    var oe = ie[1];
    ie[1] = ie[3], ie[3] = oe;
    var ke = K(ie, this._invKeySchedule, L.INV_SUB_MIX, L.INV_SBOX, this._nRounds), ne = A.allocUnsafe(16);
    return ne.writeUInt32BE(ke[0], 0), ne.writeUInt32BE(ke[3], 4), ne.writeUInt32BE(ke[2], 8), ne.writeUInt32BE(ke[1], 12), ne;
  }, re.prototype.scrub = function() {
    W(this._keySchedule), W(this._invKeySchedule), W(this._key);
  }, aes.AES = re, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var A = safeBufferExports.Buffer, B = A.alloc(16, 0);
  function W(L) {
    return [
      L.readUInt32BE(0),
      L.readUInt32BE(4),
      L.readUInt32BE(8),
      L.readUInt32BE(12)
    ];
  }
  function K(L) {
    var re = A.allocUnsafe(16);
    return re.writeUInt32BE(L[0] >>> 0, 0), re.writeUInt32BE(L[1] >>> 0, 4), re.writeUInt32BE(L[2] >>> 0, 8), re.writeUInt32BE(L[3] >>> 0, 12), re;
  }
  function J(L) {
    this.h = L, this.state = A.alloc(16, 0), this.cache = A.allocUnsafe(0);
  }
  return J.prototype.ghash = function(L) {
    for (var re = -1; ++re < L.length; )
      this.state[re] ^= L[re];
    this._multiply();
  }, J.prototype._multiply = function() {
    for (var L = W(this.h), re = [0, 0, 0, 0], ie, oe, ke, ne = -1; ++ne < 128; ) {
      for (oe = (this.state[~~(ne / 8)] & 1 << 7 - ne % 8) !== 0, oe && (re[0] ^= L[0], re[1] ^= L[1], re[2] ^= L[2], re[3] ^= L[3]), ke = (L[3] & 1) !== 0, ie = 3; ie > 0; ie--)
        L[ie] = L[ie] >>> 1 | (L[ie - 1] & 1) << 31;
      L[0] = L[0] >>> 1, ke && (L[0] = L[0] ^ 225 << 24);
    }
    this.state = K(re);
  }, J.prototype.update = function(L) {
    this.cache = A.concat([this.cache, L]);
    for (var re; this.cache.length >= 16; )
      re = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(re);
  }, J.prototype.final = function(L, re) {
    return this.cache.length && this.ghash(A.concat([this.cache, B], 16)), this.ghash(K([0, L, 0, re])), this.state;
  }, ghash = J, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var A = requireAes(), B = safeBufferExports.Buffer, W = requireCipherBase(), K = requireInherits_browser(), J = requireGhash(), L = requireBufferXor(), re = requireIncr32();
  function ie(ne, pe) {
    var rt = 0;
    ne.length !== pe.length && rt++;
    for (var nt = Math.min(ne.length, pe.length), ot = 0; ot < nt; ++ot)
      rt += ne[ot] ^ pe[ot];
    return rt;
  }
  function oe(ne, pe, rt) {
    if (pe.length === 12)
      return ne._finID = B.concat([pe, B.from([0, 0, 0, 1])]), B.concat([pe, B.from([0, 0, 0, 2])]);
    var nt = new J(rt), ot = pe.length, ut = ot % 16;
    nt.update(pe), ut && (ut = 16 - ut, nt.update(B.alloc(ut, 0))), nt.update(B.alloc(8, 0));
    var dt = ot * 8, vt = B.alloc(8);
    vt.writeUIntBE(dt, 0, 8), nt.update(vt), ne._finID = nt.state;
    var pt = B.from(ne._finID);
    return re(pt), pt;
  }
  function ke(ne, pe, rt, nt) {
    W.call(this);
    var ot = B.alloc(4, 0);
    this._cipher = new A.AES(pe);
    var ut = this._cipher.encryptBlock(ot);
    this._ghash = new J(ut), rt = oe(this, rt, ut), this._prev = B.from(rt), this._cache = B.allocUnsafe(0), this._secCache = B.allocUnsafe(0), this._decrypt = nt, this._alen = 0, this._len = 0, this._mode = ne, this._authTag = null, this._called = !1;
  }
  return K(ke, W), ke.prototype._update = function(ne) {
    if (!this._called && this._alen) {
      var pe = 16 - this._alen % 16;
      pe < 16 && (pe = B.alloc(pe, 0), this._ghash.update(pe));
    }
    this._called = !0;
    var rt = this._mode.encrypt(this, ne);
    return this._decrypt ? this._ghash.update(ne) : this._ghash.update(rt), this._len += ne.length, rt;
  }, ke.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var ne = L(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && ie(ne, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = ne, this._cipher.scrub();
  }, ke.prototype.getAuthTag = function() {
    if (this._decrypt || !B.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, ke.prototype.setAuthTag = function(pe) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = pe;
  }, ke.prototype.setAAD = function(pe) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(pe), this._alen += pe.length;
  }, authCipher = ke, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var A = requireAes(), B = safeBufferExports.Buffer, W = requireCipherBase(), K = requireInherits_browser();
  function J(L, re, ie, oe) {
    W.call(this), this._cipher = new A.AES(re), this._prev = B.from(ie), this._cache = B.allocUnsafe(0), this._secCache = B.allocUnsafe(0), this._decrypt = oe, this._mode = L;
  }
  return K(J, W), J.prototype._update = function(L) {
    return this._mode.encrypt(this, L, this._decrypt);
  }, J.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = J, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var A = safeBufferExports.Buffer, B = requireMd5_js();
  function W(K, J, L, re) {
    if (A.isBuffer(K) || (K = A.from(K, "binary")), J && (A.isBuffer(J) || (J = A.from(J, "binary")), J.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var ie = L / 8, oe = A.alloc(ie), ke = A.alloc(re || 0), ne = A.alloc(0); ie > 0 || re > 0; ) {
      var pe = new B();
      pe.update(ne), pe.update(K), J && pe.update(J), ne = pe.digest();
      var rt = 0;
      if (ie > 0) {
        var nt = oe.length - ie;
        rt = Math.min(ie, ne.length), ne.copy(oe, nt, 0, rt), ie -= rt;
      }
      if (rt < ne.length && re > 0) {
        var ot = ke.length - re, ut = Math.min(re, ne.length - rt);
        ne.copy(ke, ot, rt, rt + ut), re -= ut;
      }
    }
    return ne.fill(0), { key: oe, iv: ke };
  }
  return evp_bytestokey = W, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var A = requireModes$1(), B = requireAuthCipher(), W = safeBufferExports.Buffer, K = requireStreamCipher(), J = requireCipherBase(), L = requireAes(), re = requireEvp_bytestokey(), ie = requireInherits_browser();
  function oe(nt, ot, ut) {
    J.call(this), this._cache = new ne(), this._cipher = new L.AES(ot), this._prev = W.from(ut), this._mode = nt, this._autopadding = !0;
  }
  ie(oe, J), oe.prototype._update = function(nt) {
    this._cache.add(nt);
    for (var ot, ut, dt = []; ot = this._cache.get(); )
      ut = this._mode.encrypt(this, ot), dt.push(ut);
    return W.concat(dt);
  };
  var ke = W.alloc(16, 16);
  oe.prototype._final = function() {
    var nt = this._cache.flush();
    if (this._autopadding)
      return nt = this._mode.encrypt(this, nt), this._cipher.scrub(), nt;
    if (!nt.equals(ke))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, oe.prototype.setAutoPadding = function(nt) {
    return this._autopadding = !!nt, this;
  };
  function ne() {
    this.cache = W.allocUnsafe(0);
  }
  ne.prototype.add = function(nt) {
    this.cache = W.concat([this.cache, nt]);
  }, ne.prototype.get = function() {
    if (this.cache.length > 15) {
      var nt = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), nt;
    }
    return null;
  }, ne.prototype.flush = function() {
    for (var nt = 16 - this.cache.length, ot = W.allocUnsafe(nt), ut = -1; ++ut < nt; )
      ot.writeUInt8(nt, ut);
    return W.concat([this.cache, ot]);
  };
  function pe(nt, ot, ut) {
    var dt = A[nt.toLowerCase()];
    if (!dt) throw new TypeError("invalid suite type");
    if (typeof ot == "string" && (ot = W.from(ot)), ot.length !== dt.key / 8) throw new TypeError("invalid key length " + ot.length);
    if (typeof ut == "string" && (ut = W.from(ut)), dt.mode !== "GCM" && ut.length !== dt.iv) throw new TypeError("invalid iv length " + ut.length);
    return dt.type === "stream" ? new K(dt.module, ot, ut) : dt.type === "auth" ? new B(dt.module, ot, ut) : new oe(dt.module, ot, ut);
  }
  function rt(nt, ot) {
    var ut = A[nt.toLowerCase()];
    if (!ut) throw new TypeError("invalid suite type");
    var dt = re(ot, !1, ut.key, ut.iv);
    return pe(nt, dt.key, dt.iv);
  }
  return encrypter.createCipheriv = pe, encrypter.createCipher = rt, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var A = requireAuthCipher(), B = safeBufferExports.Buffer, W = requireModes$1(), K = requireStreamCipher(), J = requireCipherBase(), L = requireAes(), re = requireEvp_bytestokey(), ie = requireInherits_browser();
  function oe(nt, ot, ut) {
    J.call(this), this._cache = new ke(), this._last = void 0, this._cipher = new L.AES(ot), this._prev = B.from(ut), this._mode = nt, this._autopadding = !0;
  }
  ie(oe, J), oe.prototype._update = function(nt) {
    this._cache.add(nt);
    for (var ot, ut, dt = []; ot = this._cache.get(this._autopadding); )
      ut = this._mode.decrypt(this, ot), dt.push(ut);
    return B.concat(dt);
  }, oe.prototype._final = function() {
    var nt = this._cache.flush();
    if (this._autopadding)
      return ne(this._mode.decrypt(this, nt));
    if (nt)
      throw new Error("data not multiple of block length");
  }, oe.prototype.setAutoPadding = function(nt) {
    return this._autopadding = !!nt, this;
  };
  function ke() {
    this.cache = B.allocUnsafe(0);
  }
  ke.prototype.add = function(nt) {
    this.cache = B.concat([this.cache, nt]);
  }, ke.prototype.get = function(nt) {
    var ot;
    if (nt) {
      if (this.cache.length > 16)
        return ot = this.cache.slice(0, 16), this.cache = this.cache.slice(16), ot;
    } else if (this.cache.length >= 16)
      return ot = this.cache.slice(0, 16), this.cache = this.cache.slice(16), ot;
    return null;
  }, ke.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  };
  function ne(nt) {
    var ot = nt[15];
    if (ot < 1 || ot > 16)
      throw new Error("unable to decrypt data");
    for (var ut = -1; ++ut < ot; )
      if (nt[ut + (16 - ot)] !== ot)
        throw new Error("unable to decrypt data");
    if (ot !== 16)
      return nt.slice(0, 16 - ot);
  }
  function pe(nt, ot, ut) {
    var dt = W[nt.toLowerCase()];
    if (!dt) throw new TypeError("invalid suite type");
    if (typeof ut == "string" && (ut = B.from(ut)), dt.mode !== "GCM" && ut.length !== dt.iv) throw new TypeError("invalid iv length " + ut.length);
    if (typeof ot == "string" && (ot = B.from(ot)), ot.length !== dt.key / 8) throw new TypeError("invalid key length " + ot.length);
    return dt.type === "stream" ? new K(dt.module, ot, ut, !0) : dt.type === "auth" ? new A(dt.module, ot, ut, !0) : new oe(dt.module, ot, ut);
  }
  function rt(nt, ot) {
    var ut = W[nt.toLowerCase()];
    if (!ut) throw new TypeError("invalid suite type");
    var dt = re(ot, !1, ut.key, ut.iv);
    return pe(nt, dt.key, dt.iv);
  }
  return decrypter.createDecipher = rt, decrypter.createDecipheriv = pe, decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6) return browser$5;
  hasRequiredBrowser$6 = 1;
  var A = requireEncrypter(), B = requireDecrypter(), W = require$$2;
  function K() {
    return Object.keys(W);
  }
  return browser$5.createCipher = browser$5.Cipher = A.createCipher, browser$5.createCipheriv = browser$5.Cipheriv = A.createCipheriv, browser$5.createDecipher = browser$5.Decipher = B.createDecipher, browser$5.createDecipheriv = browser$5.Decipheriv = B.createDecipheriv, browser$5.listCiphers = browser$5.getCiphers = K, browser$5;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(A) {
    A["des-ecb"] = {
      key: 8,
      iv: 0
    }, A["des-cbc"] = A.des = {
      key: 8,
      iv: 8
    }, A["des-ede3-cbc"] = A.des3 = {
      key: 24,
      iv: 8
    }, A["des-ede3"] = {
      key: 24,
      iv: 0
    }, A["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, A["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5) return browser$6;
  hasRequiredBrowser$5 = 1;
  var A = requireBrowserifyDes(), B = requireBrowser$6(), W = requireModes$1(), K = requireModes(), J = requireEvp_bytestokey();
  function L(ne, pe) {
    ne = ne.toLowerCase();
    var rt, nt;
    if (W[ne])
      rt = W[ne].key, nt = W[ne].iv;
    else if (K[ne])
      rt = K[ne].key * 8, nt = K[ne].iv;
    else
      throw new TypeError("invalid suite type");
    var ot = J(pe, !1, rt, nt);
    return ie(ne, ot.key, ot.iv);
  }
  function re(ne, pe) {
    ne = ne.toLowerCase();
    var rt, nt;
    if (W[ne])
      rt = W[ne].key, nt = W[ne].iv;
    else if (K[ne])
      rt = K[ne].key * 8, nt = K[ne].iv;
    else
      throw new TypeError("invalid suite type");
    var ot = J(pe, !1, rt, nt);
    return oe(ne, ot.key, ot.iv);
  }
  function ie(ne, pe, rt) {
    if (ne = ne.toLowerCase(), W[ne]) return B.createCipheriv(ne, pe, rt);
    if (K[ne]) return new A({ key: pe, iv: rt, mode: ne });
    throw new TypeError("invalid suite type");
  }
  function oe(ne, pe, rt) {
    if (ne = ne.toLowerCase(), W[ne]) return B.createDecipheriv(ne, pe, rt);
    if (K[ne]) return new A({ key: pe, iv: rt, mode: ne, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function ke() {
    return Object.keys(K).concat(B.getCiphers());
  }
  return browser$6.createCipher = browser$6.Cipher = L, browser$6.createCipheriv = browser$6.Cipheriv = ie, browser$6.createDecipher = browser$6.Decipher = re, browser$6.createDecipheriv = browser$6.Decipheriv = oe, browser$6.listCiphers = browser$6.getCiphers = ke, browser$6;
}
var browser$4 = {}, bn$2 = { exports: {} };
bn$2.exports;
var hasRequiredBn$2;
function requireBn$2() {
  return hasRequiredBn$2 || (hasRequiredBn$2 = 1, function(A) {
    (function(B, W) {
      function K(wt, st) {
        if (!wt) throw new Error(st || "Assertion failed");
      }
      function J(wt, st) {
        wt.super_ = st;
        var Oe = function() {
        };
        Oe.prototype = st.prototype, wt.prototype = new Oe(), wt.prototype.constructor = wt;
      }
      function L(wt, st, Oe) {
        if (L.isBN(wt))
          return wt;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, wt !== null && ((st === "le" || st === "be") && (Oe = st, st = 10), this._init(wt || 0, st || 10, Oe || "be"));
      }
      typeof B == "object" ? B.exports = L : W.BN = L, L.BN = L, L.wordSize = 26;
      var re;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? re = window.Buffer : re = require$$0$1.Buffer;
      } catch {
      }
      L.isBN = function(st) {
        return st instanceof L ? !0 : st !== null && typeof st == "object" && st.constructor.wordSize === L.wordSize && Array.isArray(st.words);
      }, L.max = function(st, Oe) {
        return st.cmp(Oe) > 0 ? st : Oe;
      }, L.min = function(st, Oe) {
        return st.cmp(Oe) < 0 ? st : Oe;
      }, L.prototype._init = function(st, Oe, V) {
        if (typeof st == "number")
          return this._initNumber(st, Oe, V);
        if (typeof st == "object")
          return this._initArray(st, Oe, V);
        Oe === "hex" && (Oe = 16), K(Oe === (Oe | 0) && Oe >= 2 && Oe <= 36), st = st.toString().replace(/\s+/g, "");
        var ce = 0;
        st[0] === "-" && (ce++, this.negative = 1), ce < st.length && (Oe === 16 ? this._parseHex(st, ce, V) : (this._parseBase(st, Oe, ce), V === "le" && this._initArray(this.toArray(), Oe, V)));
      }, L.prototype._initNumber = function(st, Oe, V) {
        st < 0 && (this.negative = 1, st = -st), st < 67108864 ? (this.words = [st & 67108863], this.length = 1) : st < 4503599627370496 ? (this.words = [
          st & 67108863,
          st / 67108864 & 67108863
        ], this.length = 2) : (K(st < 9007199254740992), this.words = [
          st & 67108863,
          st / 67108864 & 67108863,
          1
        ], this.length = 3), V === "le" && this._initArray(this.toArray(), Oe, V);
      }, L.prototype._initArray = function(st, Oe, V) {
        if (K(typeof st.length == "number"), st.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(st.length / 3), this.words = new Array(this.length);
        for (var ce = 0; ce < this.length; ce++)
          this.words[ce] = 0;
        var it, at, ft = 0;
        if (V === "be")
          for (ce = st.length - 1, it = 0; ce >= 0; ce -= 3)
            at = st[ce] | st[ce - 1] << 8 | st[ce - 2] << 16, this.words[it] |= at << ft & 67108863, this.words[it + 1] = at >>> 26 - ft & 67108863, ft += 24, ft >= 26 && (ft -= 26, it++);
        else if (V === "le")
          for (ce = 0, it = 0; ce < st.length; ce += 3)
            at = st[ce] | st[ce + 1] << 8 | st[ce + 2] << 16, this.words[it] |= at << ft & 67108863, this.words[it + 1] = at >>> 26 - ft & 67108863, ft += 24, ft >= 26 && (ft -= 26, it++);
        return this.strip();
      };
      function ie(wt, st) {
        var Oe = wt.charCodeAt(st);
        return Oe >= 65 && Oe <= 70 ? Oe - 55 : Oe >= 97 && Oe <= 102 ? Oe - 87 : Oe - 48 & 15;
      }
      function oe(wt, st, Oe) {
        var V = ie(wt, Oe);
        return Oe - 1 >= st && (V |= ie(wt, Oe - 1) << 4), V;
      }
      L.prototype._parseHex = function(st, Oe, V) {
        this.length = Math.ceil((st.length - Oe) / 6), this.words = new Array(this.length);
        for (var ce = 0; ce < this.length; ce++)
          this.words[ce] = 0;
        var it = 0, at = 0, ft;
        if (V === "be")
          for (ce = st.length - 1; ce >= Oe; ce -= 2)
            ft = oe(st, Oe, ce) << it, this.words[at] |= ft & 67108863, it >= 18 ? (it -= 18, at += 1, this.words[at] |= ft >>> 26) : it += 8;
        else {
          var lt = st.length - Oe;
          for (ce = lt % 2 === 0 ? Oe + 1 : Oe; ce < st.length; ce += 2)
            ft = oe(st, Oe, ce) << it, this.words[at] |= ft & 67108863, it >= 18 ? (it -= 18, at += 1, this.words[at] |= ft >>> 26) : it += 8;
        }
        this.strip();
      };
      function ke(wt, st, Oe, V) {
        for (var ce = 0, it = Math.min(wt.length, Oe), at = st; at < it; at++) {
          var ft = wt.charCodeAt(at) - 48;
          ce *= V, ft >= 49 ? ce += ft - 49 + 10 : ft >= 17 ? ce += ft - 17 + 10 : ce += ft;
        }
        return ce;
      }
      L.prototype._parseBase = function(st, Oe, V) {
        this.words = [0], this.length = 1;
        for (var ce = 0, it = 1; it <= 67108863; it *= Oe)
          ce++;
        ce--, it = it / Oe | 0;
        for (var at = st.length - V, ft = at % ce, lt = Math.min(at, at - ft) + V, ct = 0, ht = V; ht < lt; ht += ce)
          ct = ke(st, ht, ht + ce, Oe), this.imuln(it), this.words[0] + ct < 67108864 ? this.words[0] += ct : this._iaddn(ct);
        if (ft !== 0) {
          var Ce = 1;
          for (ct = ke(st, ht, st.length, Oe), ht = 0; ht < ft; ht++)
            Ce *= Oe;
          this.imuln(Ce), this.words[0] + ct < 67108864 ? this.words[0] += ct : this._iaddn(ct);
        }
        this.strip();
      }, L.prototype.copy = function(st) {
        st.words = new Array(this.length);
        for (var Oe = 0; Oe < this.length; Oe++)
          st.words[Oe] = this.words[Oe];
        st.length = this.length, st.negative = this.negative, st.red = this.red;
      }, L.prototype.clone = function() {
        var st = new L(null);
        return this.copy(st), st;
      }, L.prototype._expand = function(st) {
        for (; this.length < st; )
          this.words[this.length++] = 0;
        return this;
      }, L.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, L.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, L.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var ne = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], pe = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], rt = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      L.prototype.toString = function(st, Oe) {
        st = st || 10, Oe = Oe | 0 || 1;
        var V;
        if (st === 16 || st === "hex") {
          V = "";
          for (var ce = 0, it = 0, at = 0; at < this.length; at++) {
            var ft = this.words[at], lt = ((ft << ce | it) & 16777215).toString(16);
            it = ft >>> 24 - ce & 16777215, ce += 2, ce >= 26 && (ce -= 26, at--), it !== 0 || at !== this.length - 1 ? V = ne[6 - lt.length] + lt + V : V = lt + V;
          }
          for (it !== 0 && (V = it.toString(16) + V); V.length % Oe !== 0; )
            V = "0" + V;
          return this.negative !== 0 && (V = "-" + V), V;
        }
        if (st === (st | 0) && st >= 2 && st <= 36) {
          var ct = pe[st], ht = rt[st];
          V = "";
          var Ce = this.clone();
          for (Ce.negative = 0; !Ce.isZero(); ) {
            var yt = Ce.modn(ht).toString(st);
            Ce = Ce.idivn(ht), Ce.isZero() ? V = yt + V : V = ne[ct - yt.length] + yt + V;
          }
          for (this.isZero() && (V = "0" + V); V.length % Oe !== 0; )
            V = "0" + V;
          return this.negative !== 0 && (V = "-" + V), V;
        }
        K(!1, "Base should be between 2 and 36");
      }, L.prototype.toNumber = function() {
        var st = this.words[0];
        return this.length === 2 ? st += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? st += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && K(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -st : st;
      }, L.prototype.toJSON = function() {
        return this.toString(16);
      }, L.prototype.toBuffer = function(st, Oe) {
        return K(typeof re < "u"), this.toArrayLike(re, st, Oe);
      }, L.prototype.toArray = function(st, Oe) {
        return this.toArrayLike(Array, st, Oe);
      }, L.prototype.toArrayLike = function(st, Oe, V) {
        var ce = this.byteLength(), it = V || Math.max(1, ce);
        K(ce <= it, "byte array longer than desired length"), K(it > 0, "Requested array length <= 0"), this.strip();
        var at = Oe === "le", ft = new st(it), lt, ct, ht = this.clone();
        if (at) {
          for (ct = 0; !ht.isZero(); ct++)
            lt = ht.andln(255), ht.iushrn(8), ft[ct] = lt;
          for (; ct < it; ct++)
            ft[ct] = 0;
        } else {
          for (ct = 0; ct < it - ce; ct++)
            ft[ct] = 0;
          for (ct = 0; !ht.isZero(); ct++)
            lt = ht.andln(255), ht.iushrn(8), ft[it - ct - 1] = lt;
        }
        return ft;
      }, Math.clz32 ? L.prototype._countBits = function(st) {
        return 32 - Math.clz32(st);
      } : L.prototype._countBits = function(st) {
        var Oe = st, V = 0;
        return Oe >= 4096 && (V += 13, Oe >>>= 13), Oe >= 64 && (V += 7, Oe >>>= 7), Oe >= 8 && (V += 4, Oe >>>= 4), Oe >= 2 && (V += 2, Oe >>>= 2), V + Oe;
      }, L.prototype._zeroBits = function(st) {
        if (st === 0) return 26;
        var Oe = st, V = 0;
        return Oe & 8191 || (V += 13, Oe >>>= 13), Oe & 127 || (V += 7, Oe >>>= 7), Oe & 15 || (V += 4, Oe >>>= 4), Oe & 3 || (V += 2, Oe >>>= 2), Oe & 1 || V++, V;
      }, L.prototype.bitLength = function() {
        var st = this.words[this.length - 1], Oe = this._countBits(st);
        return (this.length - 1) * 26 + Oe;
      };
      function nt(wt) {
        for (var st = new Array(wt.bitLength()), Oe = 0; Oe < st.length; Oe++) {
          var V = Oe / 26 | 0, ce = Oe % 26;
          st[Oe] = (wt.words[V] & 1 << ce) >>> ce;
        }
        return st;
      }
      L.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var st = 0, Oe = 0; Oe < this.length; Oe++) {
          var V = this._zeroBits(this.words[Oe]);
          if (st += V, V !== 26) break;
        }
        return st;
      }, L.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, L.prototype.toTwos = function(st) {
        return this.negative !== 0 ? this.abs().inotn(st).iaddn(1) : this.clone();
      }, L.prototype.fromTwos = function(st) {
        return this.testn(st - 1) ? this.notn(st).iaddn(1).ineg() : this.clone();
      }, L.prototype.isNeg = function() {
        return this.negative !== 0;
      }, L.prototype.neg = function() {
        return this.clone().ineg();
      }, L.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, L.prototype.iuor = function(st) {
        for (; this.length < st.length; )
          this.words[this.length++] = 0;
        for (var Oe = 0; Oe < st.length; Oe++)
          this.words[Oe] = this.words[Oe] | st.words[Oe];
        return this.strip();
      }, L.prototype.ior = function(st) {
        return K((this.negative | st.negative) === 0), this.iuor(st);
      }, L.prototype.or = function(st) {
        return this.length > st.length ? this.clone().ior(st) : st.clone().ior(this);
      }, L.prototype.uor = function(st) {
        return this.length > st.length ? this.clone().iuor(st) : st.clone().iuor(this);
      }, L.prototype.iuand = function(st) {
        var Oe;
        this.length > st.length ? Oe = st : Oe = this;
        for (var V = 0; V < Oe.length; V++)
          this.words[V] = this.words[V] & st.words[V];
        return this.length = Oe.length, this.strip();
      }, L.prototype.iand = function(st) {
        return K((this.negative | st.negative) === 0), this.iuand(st);
      }, L.prototype.and = function(st) {
        return this.length > st.length ? this.clone().iand(st) : st.clone().iand(this);
      }, L.prototype.uand = function(st) {
        return this.length > st.length ? this.clone().iuand(st) : st.clone().iuand(this);
      }, L.prototype.iuxor = function(st) {
        var Oe, V;
        this.length > st.length ? (Oe = this, V = st) : (Oe = st, V = this);
        for (var ce = 0; ce < V.length; ce++)
          this.words[ce] = Oe.words[ce] ^ V.words[ce];
        if (this !== Oe)
          for (; ce < Oe.length; ce++)
            this.words[ce] = Oe.words[ce];
        return this.length = Oe.length, this.strip();
      }, L.prototype.ixor = function(st) {
        return K((this.negative | st.negative) === 0), this.iuxor(st);
      }, L.prototype.xor = function(st) {
        return this.length > st.length ? this.clone().ixor(st) : st.clone().ixor(this);
      }, L.prototype.uxor = function(st) {
        return this.length > st.length ? this.clone().iuxor(st) : st.clone().iuxor(this);
      }, L.prototype.inotn = function(st) {
        K(typeof st == "number" && st >= 0);
        var Oe = Math.ceil(st / 26) | 0, V = st % 26;
        this._expand(Oe), V > 0 && Oe--;
        for (var ce = 0; ce < Oe; ce++)
          this.words[ce] = ~this.words[ce] & 67108863;
        return V > 0 && (this.words[ce] = ~this.words[ce] & 67108863 >> 26 - V), this.strip();
      }, L.prototype.notn = function(st) {
        return this.clone().inotn(st);
      }, L.prototype.setn = function(st, Oe) {
        K(typeof st == "number" && st >= 0);
        var V = st / 26 | 0, ce = st % 26;
        return this._expand(V + 1), Oe ? this.words[V] = this.words[V] | 1 << ce : this.words[V] = this.words[V] & ~(1 << ce), this.strip();
      }, L.prototype.iadd = function(st) {
        var Oe;
        if (this.negative !== 0 && st.negative === 0)
          return this.negative = 0, Oe = this.isub(st), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && st.negative !== 0)
          return st.negative = 0, Oe = this.isub(st), st.negative = 1, Oe._normSign();
        var V, ce;
        this.length > st.length ? (V = this, ce = st) : (V = st, ce = this);
        for (var it = 0, at = 0; at < ce.length; at++)
          Oe = (V.words[at] | 0) + (ce.words[at] | 0) + it, this.words[at] = Oe & 67108863, it = Oe >>> 26;
        for (; it !== 0 && at < V.length; at++)
          Oe = (V.words[at] | 0) + it, this.words[at] = Oe & 67108863, it = Oe >>> 26;
        if (this.length = V.length, it !== 0)
          this.words[this.length] = it, this.length++;
        else if (V !== this)
          for (; at < V.length; at++)
            this.words[at] = V.words[at];
        return this;
      }, L.prototype.add = function(st) {
        var Oe;
        return st.negative !== 0 && this.negative === 0 ? (st.negative = 0, Oe = this.sub(st), st.negative ^= 1, Oe) : st.negative === 0 && this.negative !== 0 ? (this.negative = 0, Oe = st.sub(this), this.negative = 1, Oe) : this.length > st.length ? this.clone().iadd(st) : st.clone().iadd(this);
      }, L.prototype.isub = function(st) {
        if (st.negative !== 0) {
          st.negative = 0;
          var Oe = this.iadd(st);
          return st.negative = 1, Oe._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(st), this.negative = 1, this._normSign();
        var V = this.cmp(st);
        if (V === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var ce, it;
        V > 0 ? (ce = this, it = st) : (ce = st, it = this);
        for (var at = 0, ft = 0; ft < it.length; ft++)
          Oe = (ce.words[ft] | 0) - (it.words[ft] | 0) + at, at = Oe >> 26, this.words[ft] = Oe & 67108863;
        for (; at !== 0 && ft < ce.length; ft++)
          Oe = (ce.words[ft] | 0) + at, at = Oe >> 26, this.words[ft] = Oe & 67108863;
        if (at === 0 && ft < ce.length && ce !== this)
          for (; ft < ce.length; ft++)
            this.words[ft] = ce.words[ft];
        return this.length = Math.max(this.length, ft), ce !== this && (this.negative = 1), this.strip();
      }, L.prototype.sub = function(st) {
        return this.clone().isub(st);
      };
      function ot(wt, st, Oe) {
        Oe.negative = st.negative ^ wt.negative;
        var V = wt.length + st.length | 0;
        Oe.length = V, V = V - 1 | 0;
        var ce = wt.words[0] | 0, it = st.words[0] | 0, at = ce * it, ft = at & 67108863, lt = at / 67108864 | 0;
        Oe.words[0] = ft;
        for (var ct = 1; ct < V; ct++) {
          for (var ht = lt >>> 26, Ce = lt & 67108863, yt = Math.min(ct, st.length - 1), qt = Math.max(0, ct - wt.length + 1); qt <= yt; qt++) {
            var jt = ct - qt | 0;
            ce = wt.words[jt] | 0, it = st.words[qt] | 0, at = ce * it + Ce, ht += at / 67108864 | 0, Ce = at & 67108863;
          }
          Oe.words[ct] = Ce | 0, lt = ht | 0;
        }
        return lt !== 0 ? Oe.words[ct] = lt | 0 : Oe.length--, Oe.strip();
      }
      var ut = function(st, Oe, V) {
        var ce = st.words, it = Oe.words, at = V.words, ft = 0, lt, ct, ht, Ce = ce[0] | 0, yt = Ce & 8191, qt = Ce >>> 13, jt = ce[1] | 0, kt = jt & 8191, $t = jt >>> 13, Mt = ce[2] | 0, Lt = Mt & 8191, Kt = Mt >>> 13, Tt = ce[3] | 0, Rt = Tt & 8191, Wt = Tt >>> 13, Xt = ce[4] | 0, Zt = Xt & 8191, ar = Xt >>> 13, fr = ce[5] | 0, lr = fr & 8191, Jt = fr >>> 13, _r = ce[6] | 0, sr = _r & 8191, Mr = _r >>> 13, Sr = ce[7] | 0, cr = Sr & 8191, Br = Sr >>> 13, $r = ce[8] | 0, yr = $r & 8191, kr = $r >>> 13, Tr = ce[9] | 0, It = Tr & 8191, St = Tr >>> 13, At = it[0] | 0, Ot = At & 8191, Gt = At >>> 13, zt = it[1] | 0, Vt = zt & 8191, Er = zt >>> 13, wr = it[2] | 0, hr = wr & 8191, Pr = wr >>> 13, gr = it[3] | 0, vr = gr & 8191, qr = gr >>> 13, Ir = it[4] | 0, Ut = Ir & 8191, Ct = Ir >>> 13, Dt = it[5] | 0, Ht = Dt & 8191, Yt = Dt >>> 13, Qt = it[6] | 0, er = Qt & 8191, or = Qt >>> 13, ur = it[7] | 0, ir = ur & 8191, Ar = ur >>> 13, pr = it[8] | 0, Ft = pr & 8191, tr = pr >>> 13, rr = it[9] | 0, nr = rr & 8191, xr = rr >>> 13;
        V.negative = st.negative ^ Oe.negative, V.length = 19, lt = Math.imul(yt, Ot), ct = Math.imul(yt, Gt), ct = ct + Math.imul(qt, Ot) | 0, ht = Math.imul(qt, Gt);
        var br = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (br >>> 26) | 0, br &= 67108863, lt = Math.imul(kt, Ot), ct = Math.imul(kt, Gt), ct = ct + Math.imul($t, Ot) | 0, ht = Math.imul($t, Gt), lt = lt + Math.imul(yt, Vt) | 0, ct = ct + Math.imul(yt, Er) | 0, ct = ct + Math.imul(qt, Vt) | 0, ht = ht + Math.imul(qt, Er) | 0;
        var dr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, lt = Math.imul(Lt, Ot), ct = Math.imul(Lt, Gt), ct = ct + Math.imul(Kt, Ot) | 0, ht = Math.imul(Kt, Gt), lt = lt + Math.imul(kt, Vt) | 0, ct = ct + Math.imul(kt, Er) | 0, ct = ct + Math.imul($t, Vt) | 0, ht = ht + Math.imul($t, Er) | 0, lt = lt + Math.imul(yt, hr) | 0, ct = ct + Math.imul(yt, Pr) | 0, ct = ct + Math.imul(qt, hr) | 0, ht = ht + Math.imul(qt, Pr) | 0;
        var Rr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, lt = Math.imul(Rt, Ot), ct = Math.imul(Rt, Gt), ct = ct + Math.imul(Wt, Ot) | 0, ht = Math.imul(Wt, Gt), lt = lt + Math.imul(Lt, Vt) | 0, ct = ct + Math.imul(Lt, Er) | 0, ct = ct + Math.imul(Kt, Vt) | 0, ht = ht + Math.imul(Kt, Er) | 0, lt = lt + Math.imul(kt, hr) | 0, ct = ct + Math.imul(kt, Pr) | 0, ct = ct + Math.imul($t, hr) | 0, ht = ht + Math.imul($t, Pr) | 0, lt = lt + Math.imul(yt, vr) | 0, ct = ct + Math.imul(yt, qr) | 0, ct = ct + Math.imul(qt, vr) | 0, ht = ht + Math.imul(qt, qr) | 0;
        var Nr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, lt = Math.imul(Zt, Ot), ct = Math.imul(Zt, Gt), ct = ct + Math.imul(ar, Ot) | 0, ht = Math.imul(ar, Gt), lt = lt + Math.imul(Rt, Vt) | 0, ct = ct + Math.imul(Rt, Er) | 0, ct = ct + Math.imul(Wt, Vt) | 0, ht = ht + Math.imul(Wt, Er) | 0, lt = lt + Math.imul(Lt, hr) | 0, ct = ct + Math.imul(Lt, Pr) | 0, ct = ct + Math.imul(Kt, hr) | 0, ht = ht + Math.imul(Kt, Pr) | 0, lt = lt + Math.imul(kt, vr) | 0, ct = ct + Math.imul(kt, qr) | 0, ct = ct + Math.imul($t, vr) | 0, ht = ht + Math.imul($t, qr) | 0, lt = lt + Math.imul(yt, Ut) | 0, ct = ct + Math.imul(yt, Ct) | 0, ct = ct + Math.imul(qt, Ut) | 0, ht = ht + Math.imul(qt, Ct) | 0;
        var Or = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (Or >>> 26) | 0, Or &= 67108863, lt = Math.imul(lr, Ot), ct = Math.imul(lr, Gt), ct = ct + Math.imul(Jt, Ot) | 0, ht = Math.imul(Jt, Gt), lt = lt + Math.imul(Zt, Vt) | 0, ct = ct + Math.imul(Zt, Er) | 0, ct = ct + Math.imul(ar, Vt) | 0, ht = ht + Math.imul(ar, Er) | 0, lt = lt + Math.imul(Rt, hr) | 0, ct = ct + Math.imul(Rt, Pr) | 0, ct = ct + Math.imul(Wt, hr) | 0, ht = ht + Math.imul(Wt, Pr) | 0, lt = lt + Math.imul(Lt, vr) | 0, ct = ct + Math.imul(Lt, qr) | 0, ct = ct + Math.imul(Kt, vr) | 0, ht = ht + Math.imul(Kt, qr) | 0, lt = lt + Math.imul(kt, Ut) | 0, ct = ct + Math.imul(kt, Ct) | 0, ct = ct + Math.imul($t, Ut) | 0, ht = ht + Math.imul($t, Ct) | 0, lt = lt + Math.imul(yt, Ht) | 0, ct = ct + Math.imul(yt, Yt) | 0, ct = ct + Math.imul(qt, Ht) | 0, ht = ht + Math.imul(qt, Yt) | 0;
        var Cr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (Cr >>> 26) | 0, Cr &= 67108863, lt = Math.imul(sr, Ot), ct = Math.imul(sr, Gt), ct = ct + Math.imul(Mr, Ot) | 0, ht = Math.imul(Mr, Gt), lt = lt + Math.imul(lr, Vt) | 0, ct = ct + Math.imul(lr, Er) | 0, ct = ct + Math.imul(Jt, Vt) | 0, ht = ht + Math.imul(Jt, Er) | 0, lt = lt + Math.imul(Zt, hr) | 0, ct = ct + Math.imul(Zt, Pr) | 0, ct = ct + Math.imul(ar, hr) | 0, ht = ht + Math.imul(ar, Pr) | 0, lt = lt + Math.imul(Rt, vr) | 0, ct = ct + Math.imul(Rt, qr) | 0, ct = ct + Math.imul(Wt, vr) | 0, ht = ht + Math.imul(Wt, qr) | 0, lt = lt + Math.imul(Lt, Ut) | 0, ct = ct + Math.imul(Lt, Ct) | 0, ct = ct + Math.imul(Kt, Ut) | 0, ht = ht + Math.imul(Kt, Ct) | 0, lt = lt + Math.imul(kt, Ht) | 0, ct = ct + Math.imul(kt, Yt) | 0, ct = ct + Math.imul($t, Ht) | 0, ht = ht + Math.imul($t, Yt) | 0, lt = lt + Math.imul(yt, er) | 0, ct = ct + Math.imul(yt, or) | 0, ct = ct + Math.imul(qt, er) | 0, ht = ht + Math.imul(qt, or) | 0;
        var Lr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, lt = Math.imul(cr, Ot), ct = Math.imul(cr, Gt), ct = ct + Math.imul(Br, Ot) | 0, ht = Math.imul(Br, Gt), lt = lt + Math.imul(sr, Vt) | 0, ct = ct + Math.imul(sr, Er) | 0, ct = ct + Math.imul(Mr, Vt) | 0, ht = ht + Math.imul(Mr, Er) | 0, lt = lt + Math.imul(lr, hr) | 0, ct = ct + Math.imul(lr, Pr) | 0, ct = ct + Math.imul(Jt, hr) | 0, ht = ht + Math.imul(Jt, Pr) | 0, lt = lt + Math.imul(Zt, vr) | 0, ct = ct + Math.imul(Zt, qr) | 0, ct = ct + Math.imul(ar, vr) | 0, ht = ht + Math.imul(ar, qr) | 0, lt = lt + Math.imul(Rt, Ut) | 0, ct = ct + Math.imul(Rt, Ct) | 0, ct = ct + Math.imul(Wt, Ut) | 0, ht = ht + Math.imul(Wt, Ct) | 0, lt = lt + Math.imul(Lt, Ht) | 0, ct = ct + Math.imul(Lt, Yt) | 0, ct = ct + Math.imul(Kt, Ht) | 0, ht = ht + Math.imul(Kt, Yt) | 0, lt = lt + Math.imul(kt, er) | 0, ct = ct + Math.imul(kt, or) | 0, ct = ct + Math.imul($t, er) | 0, ht = ht + Math.imul($t, or) | 0, lt = lt + Math.imul(yt, ir) | 0, ct = ct + Math.imul(yt, Ar) | 0, ct = ct + Math.imul(qt, ir) | 0, ht = ht + Math.imul(qt, Ar) | 0;
        var Dr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, lt = Math.imul(yr, Ot), ct = Math.imul(yr, Gt), ct = ct + Math.imul(kr, Ot) | 0, ht = Math.imul(kr, Gt), lt = lt + Math.imul(cr, Vt) | 0, ct = ct + Math.imul(cr, Er) | 0, ct = ct + Math.imul(Br, Vt) | 0, ht = ht + Math.imul(Br, Er) | 0, lt = lt + Math.imul(sr, hr) | 0, ct = ct + Math.imul(sr, Pr) | 0, ct = ct + Math.imul(Mr, hr) | 0, ht = ht + Math.imul(Mr, Pr) | 0, lt = lt + Math.imul(lr, vr) | 0, ct = ct + Math.imul(lr, qr) | 0, ct = ct + Math.imul(Jt, vr) | 0, ht = ht + Math.imul(Jt, qr) | 0, lt = lt + Math.imul(Zt, Ut) | 0, ct = ct + Math.imul(Zt, Ct) | 0, ct = ct + Math.imul(ar, Ut) | 0, ht = ht + Math.imul(ar, Ct) | 0, lt = lt + Math.imul(Rt, Ht) | 0, ct = ct + Math.imul(Rt, Yt) | 0, ct = ct + Math.imul(Wt, Ht) | 0, ht = ht + Math.imul(Wt, Yt) | 0, lt = lt + Math.imul(Lt, er) | 0, ct = ct + Math.imul(Lt, or) | 0, ct = ct + Math.imul(Kt, er) | 0, ht = ht + Math.imul(Kt, or) | 0, lt = lt + Math.imul(kt, ir) | 0, ct = ct + Math.imul(kt, Ar) | 0, ct = ct + Math.imul($t, ir) | 0, ht = ht + Math.imul($t, Ar) | 0, lt = lt + Math.imul(yt, Ft) | 0, ct = ct + Math.imul(yt, tr) | 0, ct = ct + Math.imul(qt, Ft) | 0, ht = ht + Math.imul(qt, tr) | 0;
        var Ur = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, lt = Math.imul(It, Ot), ct = Math.imul(It, Gt), ct = ct + Math.imul(St, Ot) | 0, ht = Math.imul(St, Gt), lt = lt + Math.imul(yr, Vt) | 0, ct = ct + Math.imul(yr, Er) | 0, ct = ct + Math.imul(kr, Vt) | 0, ht = ht + Math.imul(kr, Er) | 0, lt = lt + Math.imul(cr, hr) | 0, ct = ct + Math.imul(cr, Pr) | 0, ct = ct + Math.imul(Br, hr) | 0, ht = ht + Math.imul(Br, Pr) | 0, lt = lt + Math.imul(sr, vr) | 0, ct = ct + Math.imul(sr, qr) | 0, ct = ct + Math.imul(Mr, vr) | 0, ht = ht + Math.imul(Mr, qr) | 0, lt = lt + Math.imul(lr, Ut) | 0, ct = ct + Math.imul(lr, Ct) | 0, ct = ct + Math.imul(Jt, Ut) | 0, ht = ht + Math.imul(Jt, Ct) | 0, lt = lt + Math.imul(Zt, Ht) | 0, ct = ct + Math.imul(Zt, Yt) | 0, ct = ct + Math.imul(ar, Ht) | 0, ht = ht + Math.imul(ar, Yt) | 0, lt = lt + Math.imul(Rt, er) | 0, ct = ct + Math.imul(Rt, or) | 0, ct = ct + Math.imul(Wt, er) | 0, ht = ht + Math.imul(Wt, or) | 0, lt = lt + Math.imul(Lt, ir) | 0, ct = ct + Math.imul(Lt, Ar) | 0, ct = ct + Math.imul(Kt, ir) | 0, ht = ht + Math.imul(Kt, Ar) | 0, lt = lt + Math.imul(kt, Ft) | 0, ct = ct + Math.imul(kt, tr) | 0, ct = ct + Math.imul($t, Ft) | 0, ht = ht + Math.imul($t, tr) | 0, lt = lt + Math.imul(yt, nr) | 0, ct = ct + Math.imul(yt, xr) | 0, ct = ct + Math.imul(qt, nr) | 0, ht = ht + Math.imul(qt, xr) | 0;
        var Fr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, lt = Math.imul(It, Vt), ct = Math.imul(It, Er), ct = ct + Math.imul(St, Vt) | 0, ht = Math.imul(St, Er), lt = lt + Math.imul(yr, hr) | 0, ct = ct + Math.imul(yr, Pr) | 0, ct = ct + Math.imul(kr, hr) | 0, ht = ht + Math.imul(kr, Pr) | 0, lt = lt + Math.imul(cr, vr) | 0, ct = ct + Math.imul(cr, qr) | 0, ct = ct + Math.imul(Br, vr) | 0, ht = ht + Math.imul(Br, qr) | 0, lt = lt + Math.imul(sr, Ut) | 0, ct = ct + Math.imul(sr, Ct) | 0, ct = ct + Math.imul(Mr, Ut) | 0, ht = ht + Math.imul(Mr, Ct) | 0, lt = lt + Math.imul(lr, Ht) | 0, ct = ct + Math.imul(lr, Yt) | 0, ct = ct + Math.imul(Jt, Ht) | 0, ht = ht + Math.imul(Jt, Yt) | 0, lt = lt + Math.imul(Zt, er) | 0, ct = ct + Math.imul(Zt, or) | 0, ct = ct + Math.imul(ar, er) | 0, ht = ht + Math.imul(ar, or) | 0, lt = lt + Math.imul(Rt, ir) | 0, ct = ct + Math.imul(Rt, Ar) | 0, ct = ct + Math.imul(Wt, ir) | 0, ht = ht + Math.imul(Wt, Ar) | 0, lt = lt + Math.imul(Lt, Ft) | 0, ct = ct + Math.imul(Lt, tr) | 0, ct = ct + Math.imul(Kt, Ft) | 0, ht = ht + Math.imul(Kt, tr) | 0, lt = lt + Math.imul(kt, nr) | 0, ct = ct + Math.imul(kt, xr) | 0, ct = ct + Math.imul($t, nr) | 0, ht = ht + Math.imul($t, xr) | 0;
        var jr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, lt = Math.imul(It, hr), ct = Math.imul(It, Pr), ct = ct + Math.imul(St, hr) | 0, ht = Math.imul(St, Pr), lt = lt + Math.imul(yr, vr) | 0, ct = ct + Math.imul(yr, qr) | 0, ct = ct + Math.imul(kr, vr) | 0, ht = ht + Math.imul(kr, qr) | 0, lt = lt + Math.imul(cr, Ut) | 0, ct = ct + Math.imul(cr, Ct) | 0, ct = ct + Math.imul(Br, Ut) | 0, ht = ht + Math.imul(Br, Ct) | 0, lt = lt + Math.imul(sr, Ht) | 0, ct = ct + Math.imul(sr, Yt) | 0, ct = ct + Math.imul(Mr, Ht) | 0, ht = ht + Math.imul(Mr, Yt) | 0, lt = lt + Math.imul(lr, er) | 0, ct = ct + Math.imul(lr, or) | 0, ct = ct + Math.imul(Jt, er) | 0, ht = ht + Math.imul(Jt, or) | 0, lt = lt + Math.imul(Zt, ir) | 0, ct = ct + Math.imul(Zt, Ar) | 0, ct = ct + Math.imul(ar, ir) | 0, ht = ht + Math.imul(ar, Ar) | 0, lt = lt + Math.imul(Rt, Ft) | 0, ct = ct + Math.imul(Rt, tr) | 0, ct = ct + Math.imul(Wt, Ft) | 0, ht = ht + Math.imul(Wt, tr) | 0, lt = lt + Math.imul(Lt, nr) | 0, ct = ct + Math.imul(Lt, xr) | 0, ct = ct + Math.imul(Kt, nr) | 0, ht = ht + Math.imul(Kt, xr) | 0;
        var Hr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, lt = Math.imul(It, vr), ct = Math.imul(It, qr), ct = ct + Math.imul(St, vr) | 0, ht = Math.imul(St, qr), lt = lt + Math.imul(yr, Ut) | 0, ct = ct + Math.imul(yr, Ct) | 0, ct = ct + Math.imul(kr, Ut) | 0, ht = ht + Math.imul(kr, Ct) | 0, lt = lt + Math.imul(cr, Ht) | 0, ct = ct + Math.imul(cr, Yt) | 0, ct = ct + Math.imul(Br, Ht) | 0, ht = ht + Math.imul(Br, Yt) | 0, lt = lt + Math.imul(sr, er) | 0, ct = ct + Math.imul(sr, or) | 0, ct = ct + Math.imul(Mr, er) | 0, ht = ht + Math.imul(Mr, or) | 0, lt = lt + Math.imul(lr, ir) | 0, ct = ct + Math.imul(lr, Ar) | 0, ct = ct + Math.imul(Jt, ir) | 0, ht = ht + Math.imul(Jt, Ar) | 0, lt = lt + Math.imul(Zt, Ft) | 0, ct = ct + Math.imul(Zt, tr) | 0, ct = ct + Math.imul(ar, Ft) | 0, ht = ht + Math.imul(ar, tr) | 0, lt = lt + Math.imul(Rt, nr) | 0, ct = ct + Math.imul(Rt, xr) | 0, ct = ct + Math.imul(Wt, nr) | 0, ht = ht + Math.imul(Wt, xr) | 0;
        var Wr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, lt = Math.imul(It, Ut), ct = Math.imul(It, Ct), ct = ct + Math.imul(St, Ut) | 0, ht = Math.imul(St, Ct), lt = lt + Math.imul(yr, Ht) | 0, ct = ct + Math.imul(yr, Yt) | 0, ct = ct + Math.imul(kr, Ht) | 0, ht = ht + Math.imul(kr, Yt) | 0, lt = lt + Math.imul(cr, er) | 0, ct = ct + Math.imul(cr, or) | 0, ct = ct + Math.imul(Br, er) | 0, ht = ht + Math.imul(Br, or) | 0, lt = lt + Math.imul(sr, ir) | 0, ct = ct + Math.imul(sr, Ar) | 0, ct = ct + Math.imul(Mr, ir) | 0, ht = ht + Math.imul(Mr, Ar) | 0, lt = lt + Math.imul(lr, Ft) | 0, ct = ct + Math.imul(lr, tr) | 0, ct = ct + Math.imul(Jt, Ft) | 0, ht = ht + Math.imul(Jt, tr) | 0, lt = lt + Math.imul(Zt, nr) | 0, ct = ct + Math.imul(Zt, xr) | 0, ct = ct + Math.imul(ar, nr) | 0, ht = ht + Math.imul(ar, xr) | 0;
        var Gr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, lt = Math.imul(It, Ht), ct = Math.imul(It, Yt), ct = ct + Math.imul(St, Ht) | 0, ht = Math.imul(St, Yt), lt = lt + Math.imul(yr, er) | 0, ct = ct + Math.imul(yr, or) | 0, ct = ct + Math.imul(kr, er) | 0, ht = ht + Math.imul(kr, or) | 0, lt = lt + Math.imul(cr, ir) | 0, ct = ct + Math.imul(cr, Ar) | 0, ct = ct + Math.imul(Br, ir) | 0, ht = ht + Math.imul(Br, Ar) | 0, lt = lt + Math.imul(sr, Ft) | 0, ct = ct + Math.imul(sr, tr) | 0, ct = ct + Math.imul(Mr, Ft) | 0, ht = ht + Math.imul(Mr, tr) | 0, lt = lt + Math.imul(lr, nr) | 0, ct = ct + Math.imul(lr, xr) | 0, ct = ct + Math.imul(Jt, nr) | 0, ht = ht + Math.imul(Jt, xr) | 0;
        var zr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, lt = Math.imul(It, er), ct = Math.imul(It, or), ct = ct + Math.imul(St, er) | 0, ht = Math.imul(St, or), lt = lt + Math.imul(yr, ir) | 0, ct = ct + Math.imul(yr, Ar) | 0, ct = ct + Math.imul(kr, ir) | 0, ht = ht + Math.imul(kr, Ar) | 0, lt = lt + Math.imul(cr, Ft) | 0, ct = ct + Math.imul(cr, tr) | 0, ct = ct + Math.imul(Br, Ft) | 0, ht = ht + Math.imul(Br, tr) | 0, lt = lt + Math.imul(sr, nr) | 0, ct = ct + Math.imul(sr, xr) | 0, ct = ct + Math.imul(Mr, nr) | 0, ht = ht + Math.imul(Mr, xr) | 0;
        var Vr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, lt = Math.imul(It, ir), ct = Math.imul(It, Ar), ct = ct + Math.imul(St, ir) | 0, ht = Math.imul(St, Ar), lt = lt + Math.imul(yr, Ft) | 0, ct = ct + Math.imul(yr, tr) | 0, ct = ct + Math.imul(kr, Ft) | 0, ht = ht + Math.imul(kr, tr) | 0, lt = lt + Math.imul(cr, nr) | 0, ct = ct + Math.imul(cr, xr) | 0, ct = ct + Math.imul(Br, nr) | 0, ht = ht + Math.imul(Br, xr) | 0;
        var Xr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, lt = Math.imul(It, Ft), ct = Math.imul(It, tr), ct = ct + Math.imul(St, Ft) | 0, ht = Math.imul(St, tr), lt = lt + Math.imul(yr, nr) | 0, ct = ct + Math.imul(yr, xr) | 0, ct = ct + Math.imul(kr, nr) | 0, ht = ht + Math.imul(kr, xr) | 0;
        var Yr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        ft = (ht + (ct >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, lt = Math.imul(It, nr), ct = Math.imul(It, xr), ct = ct + Math.imul(St, nr) | 0, ht = Math.imul(St, xr);
        var Jr = (ft + lt | 0) + ((ct & 8191) << 13) | 0;
        return ft = (ht + (ct >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, at[0] = br, at[1] = dr, at[2] = Rr, at[3] = Nr, at[4] = Or, at[5] = Cr, at[6] = Lr, at[7] = Dr, at[8] = Ur, at[9] = Fr, at[10] = jr, at[11] = Hr, at[12] = Wr, at[13] = Gr, at[14] = zr, at[15] = Vr, at[16] = Xr, at[17] = Yr, at[18] = Jr, ft !== 0 && (at[19] = ft, V.length++), V;
      };
      Math.imul || (ut = ot);
      function dt(wt, st, Oe) {
        Oe.negative = st.negative ^ wt.negative, Oe.length = wt.length + st.length;
        for (var V = 0, ce = 0, it = 0; it < Oe.length - 1; it++) {
          var at = ce;
          ce = 0;
          for (var ft = V & 67108863, lt = Math.min(it, st.length - 1), ct = Math.max(0, it - wt.length + 1); ct <= lt; ct++) {
            var ht = it - ct, Ce = wt.words[ht] | 0, yt = st.words[ct] | 0, qt = Ce * yt, jt = qt & 67108863;
            at = at + (qt / 67108864 | 0) | 0, jt = jt + ft | 0, ft = jt & 67108863, at = at + (jt >>> 26) | 0, ce += at >>> 26, at &= 67108863;
          }
          Oe.words[it] = ft, V = at, at = ce;
        }
        return V !== 0 ? Oe.words[it] = V : Oe.length--, Oe.strip();
      }
      function vt(wt, st, Oe) {
        var V = new pt();
        return V.mulp(wt, st, Oe);
      }
      L.prototype.mulTo = function(st, Oe) {
        var V, ce = this.length + st.length;
        return this.length === 10 && st.length === 10 ? V = ut(this, st, Oe) : ce < 63 ? V = ot(this, st, Oe) : ce < 1024 ? V = dt(this, st, Oe) : V = vt(this, st, Oe), V;
      };
      function pt(wt, st) {
        this.x = wt, this.y = st;
      }
      pt.prototype.makeRBT = function(st) {
        for (var Oe = new Array(st), V = L.prototype._countBits(st) - 1, ce = 0; ce < st; ce++)
          Oe[ce] = this.revBin(ce, V, st);
        return Oe;
      }, pt.prototype.revBin = function(st, Oe, V) {
        if (st === 0 || st === V - 1) return st;
        for (var ce = 0, it = 0; it < Oe; it++)
          ce |= (st & 1) << Oe - it - 1, st >>= 1;
        return ce;
      }, pt.prototype.permute = function(st, Oe, V, ce, it, at) {
        for (var ft = 0; ft < at; ft++)
          ce[ft] = Oe[st[ft]], it[ft] = V[st[ft]];
      }, pt.prototype.transform = function(st, Oe, V, ce, it, at) {
        this.permute(at, st, Oe, V, ce, it);
        for (var ft = 1; ft < it; ft <<= 1)
          for (var lt = ft << 1, ct = Math.cos(2 * Math.PI / lt), ht = Math.sin(2 * Math.PI / lt), Ce = 0; Ce < it; Ce += lt)
            for (var yt = ct, qt = ht, jt = 0; jt < ft; jt++) {
              var kt = V[Ce + jt], $t = ce[Ce + jt], Mt = V[Ce + jt + ft], Lt = ce[Ce + jt + ft], Kt = yt * Mt - qt * Lt;
              Lt = yt * Lt + qt * Mt, Mt = Kt, V[Ce + jt] = kt + Mt, ce[Ce + jt] = $t + Lt, V[Ce + jt + ft] = kt - Mt, ce[Ce + jt + ft] = $t - Lt, jt !== lt && (Kt = ct * yt - ht * qt, qt = ct * qt + ht * yt, yt = Kt);
            }
      }, pt.prototype.guessLen13b = function(st, Oe) {
        var V = Math.max(Oe, st) | 1, ce = V & 1, it = 0;
        for (V = V / 2 | 0; V; V = V >>> 1)
          it++;
        return 1 << it + 1 + ce;
      }, pt.prototype.conjugate = function(st, Oe, V) {
        if (!(V <= 1))
          for (var ce = 0; ce < V / 2; ce++) {
            var it = st[ce];
            st[ce] = st[V - ce - 1], st[V - ce - 1] = it, it = Oe[ce], Oe[ce] = -Oe[V - ce - 1], Oe[V - ce - 1] = -it;
          }
      }, pt.prototype.normalize13b = function(st, Oe) {
        for (var V = 0, ce = 0; ce < Oe / 2; ce++) {
          var it = Math.round(st[2 * ce + 1] / Oe) * 8192 + Math.round(st[2 * ce] / Oe) + V;
          st[ce] = it & 67108863, it < 67108864 ? V = 0 : V = it / 67108864 | 0;
        }
        return st;
      }, pt.prototype.convert13b = function(st, Oe, V, ce) {
        for (var it = 0, at = 0; at < Oe; at++)
          it = it + (st[at] | 0), V[2 * at] = it & 8191, it = it >>> 13, V[2 * at + 1] = it & 8191, it = it >>> 13;
        for (at = 2 * Oe; at < ce; ++at)
          V[at] = 0;
        K(it === 0), K((it & -8192) === 0);
      }, pt.prototype.stub = function(st) {
        for (var Oe = new Array(st), V = 0; V < st; V++)
          Oe[V] = 0;
        return Oe;
      }, pt.prototype.mulp = function(st, Oe, V) {
        var ce = 2 * this.guessLen13b(st.length, Oe.length), it = this.makeRBT(ce), at = this.stub(ce), ft = new Array(ce), lt = new Array(ce), ct = new Array(ce), ht = new Array(ce), Ce = new Array(ce), yt = new Array(ce), qt = V.words;
        qt.length = ce, this.convert13b(st.words, st.length, ft, ce), this.convert13b(Oe.words, Oe.length, ht, ce), this.transform(ft, at, lt, ct, ce, it), this.transform(ht, at, Ce, yt, ce, it);
        for (var jt = 0; jt < ce; jt++) {
          var kt = lt[jt] * Ce[jt] - ct[jt] * yt[jt];
          ct[jt] = lt[jt] * yt[jt] + ct[jt] * Ce[jt], lt[jt] = kt;
        }
        return this.conjugate(lt, ct, ce), this.transform(lt, ct, qt, at, ce, it), this.conjugate(qt, at, ce), this.normalize13b(qt, ce), V.negative = st.negative ^ Oe.negative, V.length = st.length + Oe.length, V.strip();
      }, L.prototype.mul = function(st) {
        var Oe = new L(null);
        return Oe.words = new Array(this.length + st.length), this.mulTo(st, Oe);
      }, L.prototype.mulf = function(st) {
        var Oe = new L(null);
        return Oe.words = new Array(this.length + st.length), vt(this, st, Oe);
      }, L.prototype.imul = function(st) {
        return this.clone().mulTo(st, this);
      }, L.prototype.imuln = function(st) {
        K(typeof st == "number"), K(st < 67108864);
        for (var Oe = 0, V = 0; V < this.length; V++) {
          var ce = (this.words[V] | 0) * st, it = (ce & 67108863) + (Oe & 67108863);
          Oe >>= 26, Oe += ce / 67108864 | 0, Oe += it >>> 26, this.words[V] = it & 67108863;
        }
        return Oe !== 0 && (this.words[V] = Oe, this.length++), this;
      }, L.prototype.muln = function(st) {
        return this.clone().imuln(st);
      }, L.prototype.sqr = function() {
        return this.mul(this);
      }, L.prototype.isqr = function() {
        return this.imul(this.clone());
      }, L.prototype.pow = function(st) {
        var Oe = nt(st);
        if (Oe.length === 0) return new L(1);
        for (var V = this, ce = 0; ce < Oe.length && Oe[ce] === 0; ce++, V = V.sqr())
          ;
        if (++ce < Oe.length)
          for (var it = V.sqr(); ce < Oe.length; ce++, it = it.sqr())
            Oe[ce] !== 0 && (V = V.mul(it));
        return V;
      }, L.prototype.iushln = function(st) {
        K(typeof st == "number" && st >= 0);
        var Oe = st % 26, V = (st - Oe) / 26, ce = 67108863 >>> 26 - Oe << 26 - Oe, it;
        if (Oe !== 0) {
          var at = 0;
          for (it = 0; it < this.length; it++) {
            var ft = this.words[it] & ce, lt = (this.words[it] | 0) - ft << Oe;
            this.words[it] = lt | at, at = ft >>> 26 - Oe;
          }
          at && (this.words[it] = at, this.length++);
        }
        if (V !== 0) {
          for (it = this.length - 1; it >= 0; it--)
            this.words[it + V] = this.words[it];
          for (it = 0; it < V; it++)
            this.words[it] = 0;
          this.length += V;
        }
        return this.strip();
      }, L.prototype.ishln = function(st) {
        return K(this.negative === 0), this.iushln(st);
      }, L.prototype.iushrn = function(st, Oe, V) {
        K(typeof st == "number" && st >= 0);
        var ce;
        Oe ? ce = (Oe - Oe % 26) / 26 : ce = 0;
        var it = st % 26, at = Math.min((st - it) / 26, this.length), ft = 67108863 ^ 67108863 >>> it << it, lt = V;
        if (ce -= at, ce = Math.max(0, ce), lt) {
          for (var ct = 0; ct < at; ct++)
            lt.words[ct] = this.words[ct];
          lt.length = at;
        }
        if (at !== 0) if (this.length > at)
          for (this.length -= at, ct = 0; ct < this.length; ct++)
            this.words[ct] = this.words[ct + at];
        else
          this.words[0] = 0, this.length = 1;
        var ht = 0;
        for (ct = this.length - 1; ct >= 0 && (ht !== 0 || ct >= ce); ct--) {
          var Ce = this.words[ct] | 0;
          this.words[ct] = ht << 26 - it | Ce >>> it, ht = Ce & ft;
        }
        return lt && ht !== 0 && (lt.words[lt.length++] = ht), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, L.prototype.ishrn = function(st, Oe, V) {
        return K(this.negative === 0), this.iushrn(st, Oe, V);
      }, L.prototype.shln = function(st) {
        return this.clone().ishln(st);
      }, L.prototype.ushln = function(st) {
        return this.clone().iushln(st);
      }, L.prototype.shrn = function(st) {
        return this.clone().ishrn(st);
      }, L.prototype.ushrn = function(st) {
        return this.clone().iushrn(st);
      }, L.prototype.testn = function(st) {
        K(typeof st == "number" && st >= 0);
        var Oe = st % 26, V = (st - Oe) / 26, ce = 1 << Oe;
        if (this.length <= V) return !1;
        var it = this.words[V];
        return !!(it & ce);
      }, L.prototype.imaskn = function(st) {
        K(typeof st == "number" && st >= 0);
        var Oe = st % 26, V = (st - Oe) / 26;
        if (K(this.negative === 0, "imaskn works only with positive numbers"), this.length <= V)
          return this;
        if (Oe !== 0 && V++, this.length = Math.min(V, this.length), Oe !== 0) {
          var ce = 67108863 ^ 67108863 >>> Oe << Oe;
          this.words[this.length - 1] &= ce;
        }
        return this.strip();
      }, L.prototype.maskn = function(st) {
        return this.clone().imaskn(st);
      }, L.prototype.iaddn = function(st) {
        return K(typeof st == "number"), K(st < 67108864), st < 0 ? this.isubn(-st) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < st ? (this.words[0] = st - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(st), this.negative = 1, this) : this._iaddn(st);
      }, L.prototype._iaddn = function(st) {
        this.words[0] += st;
        for (var Oe = 0; Oe < this.length && this.words[Oe] >= 67108864; Oe++)
          this.words[Oe] -= 67108864, Oe === this.length - 1 ? this.words[Oe + 1] = 1 : this.words[Oe + 1]++;
        return this.length = Math.max(this.length, Oe + 1), this;
      }, L.prototype.isubn = function(st) {
        if (K(typeof st == "number"), K(st < 67108864), st < 0) return this.iaddn(-st);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(st), this.negative = 1, this;
        if (this.words[0] -= st, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var Oe = 0; Oe < this.length && this.words[Oe] < 0; Oe++)
            this.words[Oe] += 67108864, this.words[Oe + 1] -= 1;
        return this.strip();
      }, L.prototype.addn = function(st) {
        return this.clone().iaddn(st);
      }, L.prototype.subn = function(st) {
        return this.clone().isubn(st);
      }, L.prototype.iabs = function() {
        return this.negative = 0, this;
      }, L.prototype.abs = function() {
        return this.clone().iabs();
      }, L.prototype._ishlnsubmul = function(st, Oe, V) {
        var ce = st.length + V, it;
        this._expand(ce);
        var at, ft = 0;
        for (it = 0; it < st.length; it++) {
          at = (this.words[it + V] | 0) + ft;
          var lt = (st.words[it] | 0) * Oe;
          at -= lt & 67108863, ft = (at >> 26) - (lt / 67108864 | 0), this.words[it + V] = at & 67108863;
        }
        for (; it < this.length - V; it++)
          at = (this.words[it + V] | 0) + ft, ft = at >> 26, this.words[it + V] = at & 67108863;
        if (ft === 0) return this.strip();
        for (K(ft === -1), ft = 0, it = 0; it < this.length; it++)
          at = -(this.words[it] | 0) + ft, ft = at >> 26, this.words[it] = at & 67108863;
        return this.negative = 1, this.strip();
      }, L.prototype._wordDiv = function(st, Oe) {
        var V = this.length - st.length, ce = this.clone(), it = st, at = it.words[it.length - 1] | 0, ft = this._countBits(at);
        V = 26 - ft, V !== 0 && (it = it.ushln(V), ce.iushln(V), at = it.words[it.length - 1] | 0);
        var lt = ce.length - it.length, ct;
        if (Oe !== "mod") {
          ct = new L(null), ct.length = lt + 1, ct.words = new Array(ct.length);
          for (var ht = 0; ht < ct.length; ht++)
            ct.words[ht] = 0;
        }
        var Ce = ce.clone()._ishlnsubmul(it, 1, lt);
        Ce.negative === 0 && (ce = Ce, ct && (ct.words[lt] = 1));
        for (var yt = lt - 1; yt >= 0; yt--) {
          var qt = (ce.words[it.length + yt] | 0) * 67108864 + (ce.words[it.length + yt - 1] | 0);
          for (qt = Math.min(qt / at | 0, 67108863), ce._ishlnsubmul(it, qt, yt); ce.negative !== 0; )
            qt--, ce.negative = 0, ce._ishlnsubmul(it, 1, yt), ce.isZero() || (ce.negative ^= 1);
          ct && (ct.words[yt] = qt);
        }
        return ct && ct.strip(), ce.strip(), Oe !== "div" && V !== 0 && ce.iushrn(V), {
          div: ct || null,
          mod: ce
        };
      }, L.prototype.divmod = function(st, Oe, V) {
        if (K(!st.isZero()), this.isZero())
          return {
            div: new L(0),
            mod: new L(0)
          };
        var ce, it, at;
        return this.negative !== 0 && st.negative === 0 ? (at = this.neg().divmod(st, Oe), Oe !== "mod" && (ce = at.div.neg()), Oe !== "div" && (it = at.mod.neg(), V && it.negative !== 0 && it.iadd(st)), {
          div: ce,
          mod: it
        }) : this.negative === 0 && st.negative !== 0 ? (at = this.divmod(st.neg(), Oe), Oe !== "mod" && (ce = at.div.neg()), {
          div: ce,
          mod: at.mod
        }) : this.negative & st.negative ? (at = this.neg().divmod(st.neg(), Oe), Oe !== "div" && (it = at.mod.neg(), V && it.negative !== 0 && it.isub(st)), {
          div: at.div,
          mod: it
        }) : st.length > this.length || this.cmp(st) < 0 ? {
          div: new L(0),
          mod: this
        } : st.length === 1 ? Oe === "div" ? {
          div: this.divn(st.words[0]),
          mod: null
        } : Oe === "mod" ? {
          div: null,
          mod: new L(this.modn(st.words[0]))
        } : {
          div: this.divn(st.words[0]),
          mod: new L(this.modn(st.words[0]))
        } : this._wordDiv(st, Oe);
      }, L.prototype.div = function(st) {
        return this.divmod(st, "div", !1).div;
      }, L.prototype.mod = function(st) {
        return this.divmod(st, "mod", !1).mod;
      }, L.prototype.umod = function(st) {
        return this.divmod(st, "mod", !0).mod;
      }, L.prototype.divRound = function(st) {
        var Oe = this.divmod(st);
        if (Oe.mod.isZero()) return Oe.div;
        var V = Oe.div.negative !== 0 ? Oe.mod.isub(st) : Oe.mod, ce = st.ushrn(1), it = st.andln(1), at = V.cmp(ce);
        return at < 0 || it === 1 && at === 0 ? Oe.div : Oe.div.negative !== 0 ? Oe.div.isubn(1) : Oe.div.iaddn(1);
      }, L.prototype.modn = function(st) {
        K(st <= 67108863);
        for (var Oe = (1 << 26) % st, V = 0, ce = this.length - 1; ce >= 0; ce--)
          V = (Oe * V + (this.words[ce] | 0)) % st;
        return V;
      }, L.prototype.idivn = function(st) {
        K(st <= 67108863);
        for (var Oe = 0, V = this.length - 1; V >= 0; V--) {
          var ce = (this.words[V] | 0) + Oe * 67108864;
          this.words[V] = ce / st | 0, Oe = ce % st;
        }
        return this.strip();
      }, L.prototype.divn = function(st) {
        return this.clone().idivn(st);
      }, L.prototype.egcd = function(st) {
        K(st.negative === 0), K(!st.isZero());
        var Oe = this, V = st.clone();
        Oe.negative !== 0 ? Oe = Oe.umod(st) : Oe = Oe.clone();
        for (var ce = new L(1), it = new L(0), at = new L(0), ft = new L(1), lt = 0; Oe.isEven() && V.isEven(); )
          Oe.iushrn(1), V.iushrn(1), ++lt;
        for (var ct = V.clone(), ht = Oe.clone(); !Oe.isZero(); ) {
          for (var Ce = 0, yt = 1; !(Oe.words[0] & yt) && Ce < 26; ++Ce, yt <<= 1) ;
          if (Ce > 0)
            for (Oe.iushrn(Ce); Ce-- > 0; )
              (ce.isOdd() || it.isOdd()) && (ce.iadd(ct), it.isub(ht)), ce.iushrn(1), it.iushrn(1);
          for (var qt = 0, jt = 1; !(V.words[0] & jt) && qt < 26; ++qt, jt <<= 1) ;
          if (qt > 0)
            for (V.iushrn(qt); qt-- > 0; )
              (at.isOdd() || ft.isOdd()) && (at.iadd(ct), ft.isub(ht)), at.iushrn(1), ft.iushrn(1);
          Oe.cmp(V) >= 0 ? (Oe.isub(V), ce.isub(at), it.isub(ft)) : (V.isub(Oe), at.isub(ce), ft.isub(it));
        }
        return {
          a: at,
          b: ft,
          gcd: V.iushln(lt)
        };
      }, L.prototype._invmp = function(st) {
        K(st.negative === 0), K(!st.isZero());
        var Oe = this, V = st.clone();
        Oe.negative !== 0 ? Oe = Oe.umod(st) : Oe = Oe.clone();
        for (var ce = new L(1), it = new L(0), at = V.clone(); Oe.cmpn(1) > 0 && V.cmpn(1) > 0; ) {
          for (var ft = 0, lt = 1; !(Oe.words[0] & lt) && ft < 26; ++ft, lt <<= 1) ;
          if (ft > 0)
            for (Oe.iushrn(ft); ft-- > 0; )
              ce.isOdd() && ce.iadd(at), ce.iushrn(1);
          for (var ct = 0, ht = 1; !(V.words[0] & ht) && ct < 26; ++ct, ht <<= 1) ;
          if (ct > 0)
            for (V.iushrn(ct); ct-- > 0; )
              it.isOdd() && it.iadd(at), it.iushrn(1);
          Oe.cmp(V) >= 0 ? (Oe.isub(V), ce.isub(it)) : (V.isub(Oe), it.isub(ce));
        }
        var Ce;
        return Oe.cmpn(1) === 0 ? Ce = ce : Ce = it, Ce.cmpn(0) < 0 && Ce.iadd(st), Ce;
      }, L.prototype.gcd = function(st) {
        if (this.isZero()) return st.abs();
        if (st.isZero()) return this.abs();
        var Oe = this.clone(), V = st.clone();
        Oe.negative = 0, V.negative = 0;
        for (var ce = 0; Oe.isEven() && V.isEven(); ce++)
          Oe.iushrn(1), V.iushrn(1);
        do {
          for (; Oe.isEven(); )
            Oe.iushrn(1);
          for (; V.isEven(); )
            V.iushrn(1);
          var it = Oe.cmp(V);
          if (it < 0) {
            var at = Oe;
            Oe = V, V = at;
          } else if (it === 0 || V.cmpn(1) === 0)
            break;
          Oe.isub(V);
        } while (!0);
        return V.iushln(ce);
      }, L.prototype.invm = function(st) {
        return this.egcd(st).a.umod(st);
      }, L.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, L.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, L.prototype.andln = function(st) {
        return this.words[0] & st;
      }, L.prototype.bincn = function(st) {
        K(typeof st == "number");
        var Oe = st % 26, V = (st - Oe) / 26, ce = 1 << Oe;
        if (this.length <= V)
          return this._expand(V + 1), this.words[V] |= ce, this;
        for (var it = ce, at = V; it !== 0 && at < this.length; at++) {
          var ft = this.words[at] | 0;
          ft += it, it = ft >>> 26, ft &= 67108863, this.words[at] = ft;
        }
        return it !== 0 && (this.words[at] = it, this.length++), this;
      }, L.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, L.prototype.cmpn = function(st) {
        var Oe = st < 0;
        if (this.negative !== 0 && !Oe) return -1;
        if (this.negative === 0 && Oe) return 1;
        this.strip();
        var V;
        if (this.length > 1)
          V = 1;
        else {
          Oe && (st = -st), K(st <= 67108863, "Number is too big");
          var ce = this.words[0] | 0;
          V = ce === st ? 0 : ce < st ? -1 : 1;
        }
        return this.negative !== 0 ? -V | 0 : V;
      }, L.prototype.cmp = function(st) {
        if (this.negative !== 0 && st.negative === 0) return -1;
        if (this.negative === 0 && st.negative !== 0) return 1;
        var Oe = this.ucmp(st);
        return this.negative !== 0 ? -Oe | 0 : Oe;
      }, L.prototype.ucmp = function(st) {
        if (this.length > st.length) return 1;
        if (this.length < st.length) return -1;
        for (var Oe = 0, V = this.length - 1; V >= 0; V--) {
          var ce = this.words[V] | 0, it = st.words[V] | 0;
          if (ce !== it) {
            ce < it ? Oe = -1 : ce > it && (Oe = 1);
            break;
          }
        }
        return Oe;
      }, L.prototype.gtn = function(st) {
        return this.cmpn(st) === 1;
      }, L.prototype.gt = function(st) {
        return this.cmp(st) === 1;
      }, L.prototype.gten = function(st) {
        return this.cmpn(st) >= 0;
      }, L.prototype.gte = function(st) {
        return this.cmp(st) >= 0;
      }, L.prototype.ltn = function(st) {
        return this.cmpn(st) === -1;
      }, L.prototype.lt = function(st) {
        return this.cmp(st) === -1;
      }, L.prototype.lten = function(st) {
        return this.cmpn(st) <= 0;
      }, L.prototype.lte = function(st) {
        return this.cmp(st) <= 0;
      }, L.prototype.eqn = function(st) {
        return this.cmpn(st) === 0;
      }, L.prototype.eq = function(st) {
        return this.cmp(st) === 0;
      }, L.red = function(st) {
        return new bt(st);
      }, L.prototype.toRed = function(st) {
        return K(!this.red, "Already a number in reduction context"), K(this.negative === 0, "red works only with positives"), st.convertTo(this)._forceRed(st);
      }, L.prototype.fromRed = function() {
        return K(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, L.prototype._forceRed = function(st) {
        return this.red = st, this;
      }, L.prototype.forceRed = function(st) {
        return K(!this.red, "Already a number in reduction context"), this._forceRed(st);
      }, L.prototype.redAdd = function(st) {
        return K(this.red, "redAdd works only with red numbers"), this.red.add(this, st);
      }, L.prototype.redIAdd = function(st) {
        return K(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, st);
      }, L.prototype.redSub = function(st) {
        return K(this.red, "redSub works only with red numbers"), this.red.sub(this, st);
      }, L.prototype.redISub = function(st) {
        return K(this.red, "redISub works only with red numbers"), this.red.isub(this, st);
      }, L.prototype.redShl = function(st) {
        return K(this.red, "redShl works only with red numbers"), this.red.shl(this, st);
      }, L.prototype.redMul = function(st) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, st), this.red.mul(this, st);
      }, L.prototype.redIMul = function(st) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, st), this.red.imul(this, st);
      }, L.prototype.redSqr = function() {
        return K(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, L.prototype.redISqr = function() {
        return K(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, L.prototype.redSqrt = function() {
        return K(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, L.prototype.redInvm = function() {
        return K(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, L.prototype.redNeg = function() {
        return K(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, L.prototype.redPow = function(st) {
        return K(this.red && !st.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, st);
      };
      var mt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function gt(wt, st) {
        this.name = wt, this.p = new L(st, 16), this.n = this.p.bitLength(), this.k = new L(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      gt.prototype._tmp = function() {
        var st = new L(null);
        return st.words = new Array(Math.ceil(this.n / 13)), st;
      }, gt.prototype.ireduce = function(st) {
        var Oe = st, V;
        do
          this.split(Oe, this.tmp), Oe = this.imulK(Oe), Oe = Oe.iadd(this.tmp), V = Oe.bitLength();
        while (V > this.n);
        var ce = V < this.n ? -1 : Oe.ucmp(this.p);
        return ce === 0 ? (Oe.words[0] = 0, Oe.length = 1) : ce > 0 ? Oe.isub(this.p) : Oe.strip !== void 0 ? Oe.strip() : Oe._strip(), Oe;
      }, gt.prototype.split = function(st, Oe) {
        st.iushrn(this.n, 0, Oe);
      }, gt.prototype.imulK = function(st) {
        return st.imul(this.k);
      };
      function Pt() {
        gt.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      J(Pt, gt), Pt.prototype.split = function(st, Oe) {
        for (var V = 4194303, ce = Math.min(st.length, 9), it = 0; it < ce; it++)
          Oe.words[it] = st.words[it];
        if (Oe.length = ce, st.length <= 9) {
          st.words[0] = 0, st.length = 1;
          return;
        }
        var at = st.words[9];
        for (Oe.words[Oe.length++] = at & V, it = 10; it < st.length; it++) {
          var ft = st.words[it] | 0;
          st.words[it - 10] = (ft & V) << 4 | at >>> 22, at = ft;
        }
        at >>>= 22, st.words[it - 10] = at, at === 0 && st.length > 10 ? st.length -= 10 : st.length -= 9;
      }, Pt.prototype.imulK = function(st) {
        st.words[st.length] = 0, st.words[st.length + 1] = 0, st.length += 2;
        for (var Oe = 0, V = 0; V < st.length; V++) {
          var ce = st.words[V] | 0;
          Oe += ce * 977, st.words[V] = Oe & 67108863, Oe = ce * 64 + (Oe / 67108864 | 0);
        }
        return st.words[st.length - 1] === 0 && (st.length--, st.words[st.length - 1] === 0 && st.length--), st;
      };
      function xt() {
        gt.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      J(xt, gt);
      function Nt() {
        gt.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      J(Nt, gt);
      function Et() {
        gt.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      J(Et, gt), Et.prototype.imulK = function(st) {
        for (var Oe = 0, V = 0; V < st.length; V++) {
          var ce = (st.words[V] | 0) * 19 + Oe, it = ce & 67108863;
          ce >>>= 26, st.words[V] = it, Oe = ce;
        }
        return Oe !== 0 && (st.words[st.length++] = Oe), st;
      }, L._prime = function(st) {
        if (mt[st]) return mt[st];
        var Oe;
        if (st === "k256")
          Oe = new Pt();
        else if (st === "p224")
          Oe = new xt();
        else if (st === "p192")
          Oe = new Nt();
        else if (st === "p25519")
          Oe = new Et();
        else
          throw new Error("Unknown prime " + st);
        return mt[st] = Oe, Oe;
      };
      function bt(wt) {
        if (typeof wt == "string") {
          var st = L._prime(wt);
          this.m = st.p, this.prime = st;
        } else
          K(wt.gtn(1), "modulus must be greater than 1"), this.m = wt, this.prime = null;
      }
      bt.prototype._verify1 = function(st) {
        K(st.negative === 0, "red works only with positives"), K(st.red, "red works only with red numbers");
      }, bt.prototype._verify2 = function(st, Oe) {
        K((st.negative | Oe.negative) === 0, "red works only with positives"), K(
          st.red && st.red === Oe.red,
          "red works only with red numbers"
        );
      }, bt.prototype.imod = function(st) {
        return this.prime ? this.prime.ireduce(st)._forceRed(this) : st.umod(this.m)._forceRed(this);
      }, bt.prototype.neg = function(st) {
        return st.isZero() ? st.clone() : this.m.sub(st)._forceRed(this);
      }, bt.prototype.add = function(st, Oe) {
        this._verify2(st, Oe);
        var V = st.add(Oe);
        return V.cmp(this.m) >= 0 && V.isub(this.m), V._forceRed(this);
      }, bt.prototype.iadd = function(st, Oe) {
        this._verify2(st, Oe);
        var V = st.iadd(Oe);
        return V.cmp(this.m) >= 0 && V.isub(this.m), V;
      }, bt.prototype.sub = function(st, Oe) {
        this._verify2(st, Oe);
        var V = st.sub(Oe);
        return V.cmpn(0) < 0 && V.iadd(this.m), V._forceRed(this);
      }, bt.prototype.isub = function(st, Oe) {
        this._verify2(st, Oe);
        var V = st.isub(Oe);
        return V.cmpn(0) < 0 && V.iadd(this.m), V;
      }, bt.prototype.shl = function(st, Oe) {
        return this._verify1(st), this.imod(st.ushln(Oe));
      }, bt.prototype.imul = function(st, Oe) {
        return this._verify2(st, Oe), this.imod(st.imul(Oe));
      }, bt.prototype.mul = function(st, Oe) {
        return this._verify2(st, Oe), this.imod(st.mul(Oe));
      }, bt.prototype.isqr = function(st) {
        return this.imul(st, st.clone());
      }, bt.prototype.sqr = function(st) {
        return this.mul(st, st);
      }, bt.prototype.sqrt = function(st) {
        if (st.isZero()) return st.clone();
        var Oe = this.m.andln(3);
        if (K(Oe % 2 === 1), Oe === 3) {
          var V = this.m.add(new L(1)).iushrn(2);
          return this.pow(st, V);
        }
        for (var ce = this.m.subn(1), it = 0; !ce.isZero() && ce.andln(1) === 0; )
          it++, ce.iushrn(1);
        K(!ce.isZero());
        var at = new L(1).toRed(this), ft = at.redNeg(), lt = this.m.subn(1).iushrn(1), ct = this.m.bitLength();
        for (ct = new L(2 * ct * ct).toRed(this); this.pow(ct, lt).cmp(ft) !== 0; )
          ct.redIAdd(ft);
        for (var ht = this.pow(ct, ce), Ce = this.pow(st, ce.addn(1).iushrn(1)), yt = this.pow(st, ce), qt = it; yt.cmp(at) !== 0; ) {
          for (var jt = yt, kt = 0; jt.cmp(at) !== 0; kt++)
            jt = jt.redSqr();
          K(kt < qt);
          var $t = this.pow(ht, new L(1).iushln(qt - kt - 1));
          Ce = Ce.redMul($t), ht = $t.redSqr(), yt = yt.redMul(ht), qt = kt;
        }
        return Ce;
      }, bt.prototype.invm = function(st) {
        var Oe = st._invmp(this.m);
        return Oe.negative !== 0 ? (Oe.negative = 0, this.imod(Oe).redNeg()) : this.imod(Oe);
      }, bt.prototype.pow = function(st, Oe) {
        if (Oe.isZero()) return new L(1).toRed(this);
        if (Oe.cmpn(1) === 0) return st.clone();
        var V = 4, ce = new Array(1 << V);
        ce[0] = new L(1).toRed(this), ce[1] = st;
        for (var it = 2; it < ce.length; it++)
          ce[it] = this.mul(ce[it - 1], st);
        var at = ce[0], ft = 0, lt = 0, ct = Oe.bitLength() % 26;
        for (ct === 0 && (ct = 26), it = Oe.length - 1; it >= 0; it--) {
          for (var ht = Oe.words[it], Ce = ct - 1; Ce >= 0; Ce--) {
            var yt = ht >> Ce & 1;
            if (at !== ce[0] && (at = this.sqr(at)), yt === 0 && ft === 0) {
              lt = 0;
              continue;
            }
            ft <<= 1, ft |= yt, lt++, !(lt !== V && (it !== 0 || Ce !== 0)) && (at = this.mul(at, ce[ft]), lt = 0, ft = 0);
          }
          ct = 26;
        }
        return at;
      }, bt.prototype.convertTo = function(st) {
        var Oe = st.umod(this.m);
        return Oe === st ? Oe.clone() : Oe;
      }, bt.prototype.convertFrom = function(st) {
        var Oe = st.clone();
        return Oe.red = null, Oe;
      }, L.mont = function(st) {
        return new Bt(st);
      };
      function Bt(wt) {
        bt.call(this, wt), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new L(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      J(Bt, bt), Bt.prototype.convertTo = function(st) {
        return this.imod(st.ushln(this.shift));
      }, Bt.prototype.convertFrom = function(st) {
        var Oe = this.imod(st.mul(this.rinv));
        return Oe.red = null, Oe;
      }, Bt.prototype.imul = function(st, Oe) {
        if (st.isZero() || Oe.isZero())
          return st.words[0] = 0, st.length = 1, st;
        var V = st.imul(Oe), ce = V.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), it = V.isub(ce).iushrn(this.shift), at = it;
        return it.cmp(this.m) >= 0 ? at = it.isub(this.m) : it.cmpn(0) < 0 && (at = it.iadd(this.m)), at._forceRed(this);
      }, Bt.prototype.mul = function(st, Oe) {
        if (st.isZero() || Oe.isZero()) return new L(0)._forceRed(this);
        var V = st.mul(Oe), ce = V.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), it = V.isub(ce).iushrn(this.shift), at = it;
        return it.cmp(this.m) >= 0 ? at = it.isub(this.m) : it.cmpn(0) < 0 && (at = it.iadd(this.m)), at._forceRed(this);
      }, Bt.prototype.invm = function(st) {
        var Oe = this.imod(st._invmp(this.m).mul(this.r2));
        return Oe._forceRed(this);
      };
    })(A, commonjsGlobal);
  }(bn$2)), bn$2.exports;
}
var brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var A;
  brorand.exports = function(J) {
    return A || (A = new B(null)), A.generate(J);
  };
  function B(K) {
    this.rand = K;
  }
  if (brorand.exports.Rand = B, B.prototype.generate = function(J) {
    return this._rand(J);
  }, B.prototype._rand = function(J) {
    if (this.rand.getBytes)
      return this.rand.getBytes(J);
    for (var L = new Uint8Array(J), re = 0; re < L.length; re++)
      L[re] = this.rand.getByte();
    return L;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? B.prototype._rand = function(J) {
      var L = new Uint8Array(J);
      return self.crypto.getRandomValues(L), L;
    } : self.msCrypto && self.msCrypto.getRandomValues ? B.prototype._rand = function(J) {
      var L = new Uint8Array(J);
      return self.msCrypto.getRandomValues(L), L;
    } : typeof window == "object" && (B.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var W = requireCryptoBrowserify();
      if (typeof W.randomBytes != "function")
        throw new Error("Not supported");
      B.prototype._rand = function(J) {
        return W.randomBytes(J);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var A = requireBn$2(), B = requireBrorand();
  function W(K) {
    this.rand = K || new B.Rand();
  }
  return mr = W, W.create = function(J) {
    return new W(J);
  }, W.prototype._randbelow = function(J) {
    var L = J.bitLength(), re = Math.ceil(L / 8);
    do
      var ie = new A(this.rand.generate(re));
    while (ie.cmp(J) >= 0);
    return ie;
  }, W.prototype._randrange = function(J, L) {
    var re = L.sub(J);
    return J.add(this._randbelow(re));
  }, W.prototype.test = function(J, L, re) {
    var ie = J.bitLength(), oe = A.mont(J), ke = new A(1).toRed(oe);
    L || (L = Math.max(1, ie / 48 | 0));
    for (var ne = J.subn(1), pe = 0; !ne.testn(pe); pe++)
      ;
    for (var rt = J.shrn(pe), nt = ne.toRed(oe), ot = !0; L > 0; L--) {
      var ut = this._randrange(new A(2), ne);
      re && re(ut);
      var dt = ut.toRed(oe).redPow(rt);
      if (!(dt.cmp(ke) === 0 || dt.cmp(nt) === 0)) {
        for (var vt = 1; vt < pe; vt++) {
          if (dt = dt.redSqr(), dt.cmp(ke) === 0)
            return !1;
          if (dt.cmp(nt) === 0)
            break;
        }
        if (vt === pe)
          return !1;
      }
    }
    return ot;
  }, W.prototype.getDivisor = function(J, L) {
    var re = J.bitLength(), ie = A.mont(J), oe = new A(1).toRed(ie);
    L || (L = Math.max(1, re / 48 | 0));
    for (var ke = J.subn(1), ne = 0; !ke.testn(ne); ne++)
      ;
    for (var pe = J.shrn(ne), rt = ke.toRed(ie); L > 0; L--) {
      var nt = this._randrange(new A(2), ke), ot = J.gcd(nt);
      if (ot.cmpn(1) !== 0)
        return ot;
      var ut = nt.toRed(ie).redPow(pe);
      if (!(ut.cmp(oe) === 0 || ut.cmp(rt) === 0)) {
        for (var dt = 1; dt < ne; dt++) {
          if (ut = ut.redSqr(), ut.cmp(oe) === 0)
            return ut.fromRed().subn(1).gcd(J);
          if (ut.cmp(rt) === 0)
            break;
        }
        if (dt === ne)
          return ut = ut.redSqr(), ut.fromRed().subn(1).gcd(J);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var A = requireBrowser$b();
  generatePrime = dt, dt.simpleSieve = ot, dt.fermatTest = ut;
  var B = requireBn$2(), W = new B(24), K = requireMr(), J = new K(), L = new B(1), re = new B(2), ie = new B(5);
  new B(16), new B(8);
  var oe = new B(10), ke = new B(3);
  new B(7);
  var ne = new B(11), pe = new B(4);
  new B(12);
  var rt = null;
  function nt() {
    if (rt !== null)
      return rt;
    var vt = 1048576, pt = [];
    pt[0] = 2;
    for (var mt = 1, gt = 3; gt < vt; gt += 2) {
      for (var Pt = Math.ceil(Math.sqrt(gt)), xt = 0; xt < mt && pt[xt] <= Pt && gt % pt[xt] !== 0; xt++)
        ;
      mt !== xt && pt[xt] <= Pt || (pt[mt++] = gt);
    }
    return rt = pt, pt;
  }
  function ot(vt) {
    for (var pt = nt(), mt = 0; mt < pt.length; mt++)
      if (vt.modn(pt[mt]) === 0)
        return vt.cmpn(pt[mt]) === 0;
    return !0;
  }
  function ut(vt) {
    var pt = B.mont(vt);
    return re.toRed(pt).redPow(vt.subn(1)).fromRed().cmpn(1) === 0;
  }
  function dt(vt, pt) {
    if (vt < 16)
      return pt === 2 || pt === 5 ? new B([140, 123]) : new B([140, 39]);
    pt = new B(pt);
    for (var mt, gt; ; ) {
      for (mt = new B(A(Math.ceil(vt / 8))); mt.bitLength() > vt; )
        mt.ishrn(1);
      if (mt.isEven() && mt.iadd(L), mt.testn(1) || mt.iadd(re), pt.cmp(re)) {
        if (!pt.cmp(ie))
          for (; mt.mod(oe).cmp(ke); )
            mt.iadd(pe);
      } else for (; mt.mod(W).cmp(ne); )
        mt.iadd(pe);
      if (gt = mt.shrn(1), ot(gt) && ot(mt) && ut(gt) && ut(mt) && J.test(gt) && J.test(mt))
        return mt;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var A = requireBn$2(), B = requireMr(), W = new B(), K = new A(24), J = new A(11), L = new A(10), re = new A(3), ie = new A(7), oe = requireGeneratePrime(), ke = requireBrowser$b();
  dh = ot;
  function ne(dt, vt) {
    return vt = vt || "utf8", Buffer$1.isBuffer(dt) || (dt = new Buffer$1(dt, vt)), this._pub = new A(dt), this;
  }
  function pe(dt, vt) {
    return vt = vt || "utf8", Buffer$1.isBuffer(dt) || (dt = new Buffer$1(dt, vt)), this._priv = new A(dt), this;
  }
  var rt = {};
  function nt(dt, vt) {
    var pt = vt.toString("hex"), mt = [pt, dt.toString(16)].join("_");
    if (mt in rt)
      return rt[mt];
    var gt = 0;
    if (dt.isEven() || !oe.simpleSieve || !oe.fermatTest(dt) || !W.test(dt))
      return gt += 1, pt === "02" || pt === "05" ? gt += 8 : gt += 4, rt[mt] = gt, gt;
    W.test(dt.shrn(1)) || (gt += 2);
    var Pt;
    switch (pt) {
      case "02":
        dt.mod(K).cmp(J) && (gt += 8);
        break;
      case "05":
        Pt = dt.mod(L), Pt.cmp(re) && Pt.cmp(ie) && (gt += 8);
        break;
      default:
        gt += 4;
    }
    return rt[mt] = gt, gt;
  }
  function ot(dt, vt, pt) {
    this.setGenerator(vt), this.__prime = new A(dt), this._prime = A.mont(this.__prime), this._primeLen = dt.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, pt ? (this.setPublicKey = ne, this.setPrivateKey = pe) : this._primeCode = 8;
  }
  Object.defineProperty(ot.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = nt(this.__prime, this.__gen)), this._primeCode;
    }
  }), ot.prototype.generateKeys = function() {
    return this._priv || (this._priv = new A(ke(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, ot.prototype.computeSecret = function(dt) {
    dt = new A(dt), dt = dt.toRed(this._prime);
    var vt = dt.redPow(this._priv).fromRed(), pt = new Buffer$1(vt.toArray()), mt = this.getPrime();
    if (pt.length < mt.length) {
      var gt = new Buffer$1(mt.length - pt.length);
      gt.fill(0), pt = Buffer$1.concat([gt, pt]);
    }
    return pt;
  }, ot.prototype.getPublicKey = function(vt) {
    return ut(this._pub, vt);
  }, ot.prototype.getPrivateKey = function(vt) {
    return ut(this._priv, vt);
  }, ot.prototype.getPrime = function(dt) {
    return ut(this.__prime, dt);
  }, ot.prototype.getGenerator = function(dt) {
    return ut(this._gen, dt);
  }, ot.prototype.setGenerator = function(dt, vt) {
    return vt = vt || "utf8", Buffer$1.isBuffer(dt) || (dt = new Buffer$1(dt, vt)), this.__gen = dt, this._gen = new A(dt), this;
  };
  function ut(dt, vt) {
    var pt = new Buffer$1(dt.toArray());
    return vt ? pt.toString(vt) : pt;
  }
  return dh;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$4;
  hasRequiredBrowser$4 = 1;
  var A = requireGeneratePrime(), B = require$$1$1, W = requireDh();
  function K(re) {
    var ie = new Buffer$1(B[re].prime, "hex"), oe = new Buffer$1(B[re].gen, "hex");
    return new W(ie, oe);
  }
  var J = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function L(re, ie, oe, ke) {
    return Buffer$1.isBuffer(ie) || J[ie] === void 0 ? L(re, "binary", ie, oe) : (ie = ie || "binary", ke = ke || "binary", oe = oe || new Buffer$1([2]), Buffer$1.isBuffer(oe) || (oe = new Buffer$1(oe, ke)), typeof re == "number" ? new W(A(re, oe), oe, !0) : (Buffer$1.isBuffer(re) || (re = new Buffer$1(re, ie)), new W(re, oe, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = K, browser$4.createDiffieHellman = browser$4.DiffieHellman = L, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: A } : processNextickArgs.exports = process$1;
  function A(B, W, K, J) {
    if (typeof B != "function")
      throw new TypeError('"callback" argument must be a function');
    var L = arguments.length, re, ie;
    switch (L) {
      case 0:
      case 1:
        return process$1.nextTick(B);
      case 2:
        return process$1.nextTick(function() {
          B.call(null, W);
        });
      case 3:
        return process$1.nextTick(function() {
          B.call(null, W, K);
        });
      case 4:
        return process$1.nextTick(function() {
          B.call(null, W, K, J);
        });
      default:
        for (re = new Array(L - 1), ie = 0; ie < re.length; )
          re[ie++] = arguments[ie];
        return process$1.nextTick(function() {
          B.apply(null, re);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var A = {}.toString;
  return isarray = Array.isArray || function(B) {
    return A.call(B) == "[object Array]";
  }, isarray;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = requireEvents().EventEmitter), streamBrowser;
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(A, B) {
    var W = require$$0$1, K = W.Buffer;
    function J(re, ie) {
      for (var oe in re)
        ie[oe] = re[oe];
    }
    K.from && K.alloc && K.allocUnsafe && K.allocUnsafeSlow ? A.exports = W : (J(W, B), B.Buffer = L);
    function L(re, ie, oe) {
      return K(re, ie, oe);
    }
    J(K, L), L.from = function(re, ie, oe) {
      if (typeof re == "number")
        throw new TypeError("Argument must not be a number");
      return K(re, ie, oe);
    }, L.alloc = function(re, ie, oe) {
      if (typeof re != "number")
        throw new TypeError("Argument must be a number");
      var ke = K(re);
      return ie !== void 0 ? typeof oe == "string" ? ke.fill(ie, oe) : ke.fill(ie) : ke.fill(0), ke;
    }, L.allocUnsafe = function(re) {
      if (typeof re != "number")
        throw new TypeError("Argument must be a number");
      return K(re);
    }, L.allocUnsafeSlow = function(re) {
      if (typeof re != "number")
        throw new TypeError("Argument must be a number");
      return W.SlowBuffer(re);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  function A(ut) {
    return Array.isArray ? Array.isArray(ut) : ot(ut) === "[object Array]";
  }
  util.isArray = A;
  function B(ut) {
    return typeof ut == "boolean";
  }
  util.isBoolean = B;
  function W(ut) {
    return ut === null;
  }
  util.isNull = W;
  function K(ut) {
    return ut == null;
  }
  util.isNullOrUndefined = K;
  function J(ut) {
    return typeof ut == "number";
  }
  util.isNumber = J;
  function L(ut) {
    return typeof ut == "string";
  }
  util.isString = L;
  function re(ut) {
    return typeof ut == "symbol";
  }
  util.isSymbol = re;
  function ie(ut) {
    return ut === void 0;
  }
  util.isUndefined = ie;
  function oe(ut) {
    return ot(ut) === "[object RegExp]";
  }
  util.isRegExp = oe;
  function ke(ut) {
    return typeof ut == "object" && ut !== null;
  }
  util.isObject = ke;
  function ne(ut) {
    return ot(ut) === "[object Date]";
  }
  util.isDate = ne;
  function pe(ut) {
    return ot(ut) === "[object Error]" || ut instanceof Error;
  }
  util.isError = pe;
  function rt(ut) {
    return typeof ut == "function";
  }
  util.isFunction = rt;
  function nt(ut) {
    return ut === null || typeof ut == "boolean" || typeof ut == "number" || typeof ut == "string" || typeof ut == "symbol" || // ES6 symbol
    typeof ut > "u";
  }
  util.isPrimitive = nt, util.isBuffer = require$$0$1.Buffer.isBuffer;
  function ot(ut) {
    return Object.prototype.toString.call(ut);
  }
  return util;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(A) {
    function B(L, re) {
      if (!(L instanceof re))
        throw new TypeError("Cannot call a class as a function");
    }
    var W = requireSafeBuffer().Buffer, K = requireUtil$1();
    function J(L, re, ie) {
      L.copy(re, ie);
    }
    A.exports = function() {
      function L() {
        B(this, L), this.head = null, this.tail = null, this.length = 0;
      }
      return L.prototype.push = function(ie) {
        var oe = { data: ie, next: null };
        this.length > 0 ? this.tail.next = oe : this.head = oe, this.tail = oe, ++this.length;
      }, L.prototype.unshift = function(ie) {
        var oe = { data: ie, next: this.head };
        this.length === 0 && (this.tail = oe), this.head = oe, ++this.length;
      }, L.prototype.shift = function() {
        if (this.length !== 0) {
          var ie = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ie;
        }
      }, L.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, L.prototype.join = function(ie) {
        if (this.length === 0) return "";
        for (var oe = this.head, ke = "" + oe.data; oe = oe.next; )
          ke += ie + oe.data;
        return ke;
      }, L.prototype.concat = function(ie) {
        if (this.length === 0) return W.alloc(0);
        for (var oe = W.allocUnsafe(ie >>> 0), ke = this.head, ne = 0; ke; )
          J(ke.data, oe, ne), ne += ke.data.length, ke = ke.next;
        return oe;
      }, L;
    }(), K && K.inspect && K.inspect.custom && (A.exports.prototype[K.inspect.custom] = function() {
      var L = K.inspect({ length: this.length });
      return this.constructor.name + " " + L;
    });
  }(BufferList)), BufferList.exports;
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var A = requireProcessNextickArgs();
  function B(J, L) {
    var re = this, ie = this._readableState && this._readableState.destroyed, oe = this._writableState && this._writableState.destroyed;
    return ie || oe ? (L ? L(J) : J && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, A.nextTick(K, this, J)) : A.nextTick(K, this, J)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(J || null, function(ke) {
      !L && ke ? re._writableState ? re._writableState.errorEmitted || (re._writableState.errorEmitted = !0, A.nextTick(K, re, ke)) : A.nextTick(K, re, ke) : L && L(ke);
    }), this);
  }
  function W() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function K(J, L) {
    J.emit("error", L);
  }
  return destroy_1 = {
    destroy: B,
    undestroy: W
  }, destroy_1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var A = requireProcessNextickArgs();
  _stream_writable = ut;
  function B(at) {
    var ft = this;
    this.next = null, this.entry = null, this.finish = function() {
      it(ft, at);
    };
  }
  var W = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : A.nextTick, K;
  ut.WritableState = nt;
  var J = Object.create(requireUtil());
  J.inherits = requireInherits_browser();
  var L = {
    deprecate: requireBrowser$a()
  }, re = requireStreamBrowser(), ie = requireSafeBuffer().Buffer, oe = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ke(at) {
    return ie.from(at);
  }
  function ne(at) {
    return ie.isBuffer(at) || at instanceof oe;
  }
  var pe = requireDestroy();
  J.inherits(ut, re);
  function rt() {
  }
  function nt(at, ft) {
    K = K || require_stream_duplex(), at = at || {};
    var lt = ft instanceof K;
    this.objectMode = !!at.objectMode, lt && (this.objectMode = this.objectMode || !!at.writableObjectMode);
    var ct = at.highWaterMark, ht = at.writableHighWaterMark, Ce = this.objectMode ? 16 : 16 * 1024;
    ct || ct === 0 ? this.highWaterMark = ct : lt && (ht || ht === 0) ? this.highWaterMark = ht : this.highWaterMark = Ce, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var yt = at.decodeStrings === !1;
    this.decodeStrings = !yt, this.defaultEncoding = at.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(qt) {
      Nt(ft, qt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new B(this);
  }
  nt.prototype.getBuffer = function() {
    for (var ft = this.bufferedRequest, lt = []; ft; )
      lt.push(ft), ft = ft.next;
    return lt;
  }, function() {
    try {
      Object.defineProperty(nt.prototype, "buffer", {
        get: L.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ot;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ot = Function.prototype[Symbol.hasInstance], Object.defineProperty(ut, Symbol.hasInstance, {
    value: function(at) {
      return ot.call(this, at) ? !0 : this !== ut ? !1 : at && at._writableState instanceof nt;
    }
  })) : ot = function(at) {
    return at instanceof this;
  };
  function ut(at) {
    if (K = K || require_stream_duplex(), !ot.call(ut, this) && !(this instanceof K))
      return new ut(at);
    this._writableState = new nt(at, this), this.writable = !0, at && (typeof at.write == "function" && (this._write = at.write), typeof at.writev == "function" && (this._writev = at.writev), typeof at.destroy == "function" && (this._destroy = at.destroy), typeof at.final == "function" && (this._final = at.final)), re.call(this);
  }
  ut.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function dt(at, ft) {
    var lt = new Error("write after end");
    at.emit("error", lt), A.nextTick(ft, lt);
  }
  function vt(at, ft, lt, ct) {
    var ht = !0, Ce = !1;
    return lt === null ? Ce = new TypeError("May not write null values to stream") : typeof lt != "string" && lt !== void 0 && !ft.objectMode && (Ce = new TypeError("Invalid non-string/buffer chunk")), Ce && (at.emit("error", Ce), A.nextTick(ct, Ce), ht = !1), ht;
  }
  ut.prototype.write = function(at, ft, lt) {
    var ct = this._writableState, ht = !1, Ce = !ct.objectMode && ne(at);
    return Ce && !ie.isBuffer(at) && (at = ke(at)), typeof ft == "function" && (lt = ft, ft = null), Ce ? ft = "buffer" : ft || (ft = ct.defaultEncoding), typeof lt != "function" && (lt = rt), ct.ended ? dt(this, lt) : (Ce || vt(this, ct, at, lt)) && (ct.pendingcb++, ht = mt(this, ct, Ce, at, ft, lt)), ht;
  }, ut.prototype.cork = function() {
    var at = this._writableState;
    at.corked++;
  }, ut.prototype.uncork = function() {
    var at = this._writableState;
    at.corked && (at.corked--, !at.writing && !at.corked && !at.bufferProcessing && at.bufferedRequest && Bt(this, at));
  }, ut.prototype.setDefaultEncoding = function(ft) {
    if (typeof ft == "string" && (ft = ft.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ft + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + ft);
    return this._writableState.defaultEncoding = ft, this;
  };
  function pt(at, ft, lt) {
    return !at.objectMode && at.decodeStrings !== !1 && typeof ft == "string" && (ft = ie.from(ft, lt)), ft;
  }
  Object.defineProperty(ut.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function mt(at, ft, lt, ct, ht, Ce) {
    if (!lt) {
      var yt = pt(ft, ct, ht);
      ct !== yt && (lt = !0, ht = "buffer", ct = yt);
    }
    var qt = ft.objectMode ? 1 : ct.length;
    ft.length += qt;
    var jt = ft.length < ft.highWaterMark;
    if (jt || (ft.needDrain = !0), ft.writing || ft.corked) {
      var kt = ft.lastBufferedRequest;
      ft.lastBufferedRequest = {
        chunk: ct,
        encoding: ht,
        isBuf: lt,
        callback: Ce,
        next: null
      }, kt ? kt.next = ft.lastBufferedRequest : ft.bufferedRequest = ft.lastBufferedRequest, ft.bufferedRequestCount += 1;
    } else
      gt(at, ft, !1, qt, ct, ht, Ce);
    return jt;
  }
  function gt(at, ft, lt, ct, ht, Ce, yt) {
    ft.writelen = ct, ft.writecb = yt, ft.writing = !0, ft.sync = !0, lt ? at._writev(ht, ft.onwrite) : at._write(ht, Ce, ft.onwrite), ft.sync = !1;
  }
  function Pt(at, ft, lt, ct, ht) {
    --ft.pendingcb, lt ? (A.nextTick(ht, ct), A.nextTick(V, at, ft), at._writableState.errorEmitted = !0, at.emit("error", ct)) : (ht(ct), at._writableState.errorEmitted = !0, at.emit("error", ct), V(at, ft));
  }
  function xt(at) {
    at.writing = !1, at.writecb = null, at.length -= at.writelen, at.writelen = 0;
  }
  function Nt(at, ft) {
    var lt = at._writableState, ct = lt.sync, ht = lt.writecb;
    if (xt(lt), ft) Pt(at, lt, ct, ft, ht);
    else {
      var Ce = wt(lt);
      !Ce && !lt.corked && !lt.bufferProcessing && lt.bufferedRequest && Bt(at, lt), ct ? W(Et, at, lt, Ce, ht) : Et(at, lt, Ce, ht);
    }
  }
  function Et(at, ft, lt, ct) {
    lt || bt(at, ft), ft.pendingcb--, ct(), V(at, ft);
  }
  function bt(at, ft) {
    ft.length === 0 && ft.needDrain && (ft.needDrain = !1, at.emit("drain"));
  }
  function Bt(at, ft) {
    ft.bufferProcessing = !0;
    var lt = ft.bufferedRequest;
    if (at._writev && lt && lt.next) {
      var ct = ft.bufferedRequestCount, ht = new Array(ct), Ce = ft.corkedRequestsFree;
      Ce.entry = lt;
      for (var yt = 0, qt = !0; lt; )
        ht[yt] = lt, lt.isBuf || (qt = !1), lt = lt.next, yt += 1;
      ht.allBuffers = qt, gt(at, ft, !0, ft.length, ht, "", Ce.finish), ft.pendingcb++, ft.lastBufferedRequest = null, Ce.next ? (ft.corkedRequestsFree = Ce.next, Ce.next = null) : ft.corkedRequestsFree = new B(ft), ft.bufferedRequestCount = 0;
    } else {
      for (; lt; ) {
        var jt = lt.chunk, kt = lt.encoding, $t = lt.callback, Mt = ft.objectMode ? 1 : jt.length;
        if (gt(at, ft, !1, Mt, jt, kt, $t), lt = lt.next, ft.bufferedRequestCount--, ft.writing)
          break;
      }
      lt === null && (ft.lastBufferedRequest = null);
    }
    ft.bufferedRequest = lt, ft.bufferProcessing = !1;
  }
  ut.prototype._write = function(at, ft, lt) {
    lt(new Error("_write() is not implemented"));
  }, ut.prototype._writev = null, ut.prototype.end = function(at, ft, lt) {
    var ct = this._writableState;
    typeof at == "function" ? (lt = at, at = null, ft = null) : typeof ft == "function" && (lt = ft, ft = null), at != null && this.write(at, ft), ct.corked && (ct.corked = 1, this.uncork()), ct.ending || ce(this, ct, lt);
  };
  function wt(at) {
    return at.ending && at.length === 0 && at.bufferedRequest === null && !at.finished && !at.writing;
  }
  function st(at, ft) {
    at._final(function(lt) {
      ft.pendingcb--, lt && at.emit("error", lt), ft.prefinished = !0, at.emit("prefinish"), V(at, ft);
    });
  }
  function Oe(at, ft) {
    !ft.prefinished && !ft.finalCalled && (typeof at._final == "function" ? (ft.pendingcb++, ft.finalCalled = !0, A.nextTick(st, at, ft)) : (ft.prefinished = !0, at.emit("prefinish")));
  }
  function V(at, ft) {
    var lt = wt(ft);
    return lt && (Oe(at, ft), ft.pendingcb === 0 && (ft.finished = !0, at.emit("finish"))), lt;
  }
  function ce(at, ft, lt) {
    ft.ending = !0, V(at, ft), lt && (ft.finished ? A.nextTick(lt) : at.once("finish", lt)), ft.ended = !0, at.writable = !1;
  }
  function it(at, ft, lt) {
    var ct = at.entry;
    for (at.entry = null; ct; ) {
      var ht = ct.callback;
      ft.pendingcb--, ht(lt), ct = ct.next;
    }
    ft.corkedRequestsFree.next = at;
  }
  return Object.defineProperty(ut.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(at) {
      this._writableState && (this._writableState.destroyed = at);
    }
  }), ut.prototype.destroy = pe.destroy, ut.prototype._undestroy = pe.undestroy, ut.prototype._destroy = function(at, ft) {
    this.end(), ft(at);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var A = requireProcessNextickArgs(), B = Object.keys || function(pe) {
    var rt = [];
    for (var nt in pe)
      rt.push(nt);
    return rt;
  };
  _stream_duplex = oe;
  var W = Object.create(requireUtil());
  W.inherits = requireInherits_browser();
  var K = require_stream_readable(), J = require_stream_writable();
  W.inherits(oe, K);
  for (var L = B(J.prototype), re = 0; re < L.length; re++) {
    var ie = L[re];
    oe.prototype[ie] || (oe.prototype[ie] = J.prototype[ie]);
  }
  function oe(pe) {
    if (!(this instanceof oe)) return new oe(pe);
    K.call(this, pe), J.call(this, pe), pe && pe.readable === !1 && (this.readable = !1), pe && pe.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, pe && pe.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", ke);
  }
  Object.defineProperty(oe.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function ke() {
    this.allowHalfOpen || this._writableState.ended || A.nextTick(ne, this);
  }
  function ne(pe) {
    pe.end();
  }
  return Object.defineProperty(oe.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(pe) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = pe, this._writableState.destroyed = pe);
    }
  }), oe.prototype._destroy = function(pe, rt) {
    this.push(null), this.end(), A.nextTick(rt, pe);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var A = requireProcessNextickArgs();
  _stream_readable = pt;
  var B = requireIsarray(), W;
  pt.ReadableState = vt, requireEvents().EventEmitter;
  var K = function($t, Mt) {
    return $t.listeners(Mt).length;
  }, J = requireStreamBrowser(), L = requireSafeBuffer().Buffer, re = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ie($t) {
    return L.from($t);
  }
  function oe($t) {
    return L.isBuffer($t) || $t instanceof re;
  }
  var ke = Object.create(requireUtil());
  ke.inherits = requireInherits_browser();
  var ne = requireUtil$1(), pe = void 0;
  ne && ne.debuglog ? pe = ne.debuglog("stream") : pe = function() {
  };
  var rt = requireBufferList(), nt = requireDestroy(), ot;
  ke.inherits(pt, J);
  var ut = ["error", "close", "destroy", "pause", "resume"];
  function dt($t, Mt, Lt) {
    if (typeof $t.prependListener == "function") return $t.prependListener(Mt, Lt);
    !$t._events || !$t._events[Mt] ? $t.on(Mt, Lt) : B($t._events[Mt]) ? $t._events[Mt].unshift(Lt) : $t._events[Mt] = [Lt, $t._events[Mt]];
  }
  function vt($t, Mt) {
    W = W || require_stream_duplex(), $t = $t || {};
    var Lt = Mt instanceof W;
    this.objectMode = !!$t.objectMode, Lt && (this.objectMode = this.objectMode || !!$t.readableObjectMode);
    var Kt = $t.highWaterMark, Tt = $t.readableHighWaterMark, Rt = this.objectMode ? 16 : 16 * 1024;
    Kt || Kt === 0 ? this.highWaterMark = Kt : Lt && (Tt || Tt === 0) ? this.highWaterMark = Tt : this.highWaterMark = Rt, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new rt(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = $t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, $t.encoding && (ot || (ot = requireString_decoder().StringDecoder), this.decoder = new ot($t.encoding), this.encoding = $t.encoding);
  }
  function pt($t) {
    if (W = W || require_stream_duplex(), !(this instanceof pt)) return new pt($t);
    this._readableState = new vt($t, this), this.readable = !0, $t && (typeof $t.read == "function" && (this._read = $t.read), typeof $t.destroy == "function" && (this._destroy = $t.destroy)), J.call(this);
  }
  Object.defineProperty(pt.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function($t) {
      this._readableState && (this._readableState.destroyed = $t);
    }
  }), pt.prototype.destroy = nt.destroy, pt.prototype._undestroy = nt.undestroy, pt.prototype._destroy = function($t, Mt) {
    this.push(null), Mt($t);
  }, pt.prototype.push = function($t, Mt) {
    var Lt = this._readableState, Kt;
    return Lt.objectMode ? Kt = !0 : typeof $t == "string" && (Mt = Mt || Lt.defaultEncoding, Mt !== Lt.encoding && ($t = L.from($t, Mt), Mt = ""), Kt = !0), mt(this, $t, Mt, !1, Kt);
  }, pt.prototype.unshift = function($t) {
    return mt(this, $t, null, !0, !1);
  };
  function mt($t, Mt, Lt, Kt, Tt) {
    var Rt = $t._readableState;
    if (Mt === null)
      Rt.reading = !1, Bt($t, Rt);
    else {
      var Wt;
      Tt || (Wt = Pt(Rt, Mt)), Wt ? $t.emit("error", Wt) : Rt.objectMode || Mt && Mt.length > 0 ? (typeof Mt != "string" && !Rt.objectMode && Object.getPrototypeOf(Mt) !== L.prototype && (Mt = ie(Mt)), Kt ? Rt.endEmitted ? $t.emit("error", new Error("stream.unshift() after end event")) : gt($t, Rt, Mt, !0) : Rt.ended ? $t.emit("error", new Error("stream.push() after EOF")) : (Rt.reading = !1, Rt.decoder && !Lt ? (Mt = Rt.decoder.write(Mt), Rt.objectMode || Mt.length !== 0 ? gt($t, Rt, Mt, !1) : Oe($t, Rt)) : gt($t, Rt, Mt, !1))) : Kt || (Rt.reading = !1);
    }
    return xt(Rt);
  }
  function gt($t, Mt, Lt, Kt) {
    Mt.flowing && Mt.length === 0 && !Mt.sync ? ($t.emit("data", Lt), $t.read(0)) : (Mt.length += Mt.objectMode ? 1 : Lt.length, Kt ? Mt.buffer.unshift(Lt) : Mt.buffer.push(Lt), Mt.needReadable && wt($t)), Oe($t, Mt);
  }
  function Pt($t, Mt) {
    var Lt;
    return !oe(Mt) && typeof Mt != "string" && Mt !== void 0 && !$t.objectMode && (Lt = new TypeError("Invalid non-string/buffer chunk")), Lt;
  }
  function xt($t) {
    return !$t.ended && ($t.needReadable || $t.length < $t.highWaterMark || $t.length === 0);
  }
  pt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, pt.prototype.setEncoding = function($t) {
    return ot || (ot = requireString_decoder().StringDecoder), this._readableState.decoder = new ot($t), this._readableState.encoding = $t, this;
  };
  var Nt = 8388608;
  function Et($t) {
    return $t >= Nt ? $t = Nt : ($t--, $t |= $t >>> 1, $t |= $t >>> 2, $t |= $t >>> 4, $t |= $t >>> 8, $t |= $t >>> 16, $t++), $t;
  }
  function bt($t, Mt) {
    return $t <= 0 || Mt.length === 0 && Mt.ended ? 0 : Mt.objectMode ? 1 : $t !== $t ? Mt.flowing && Mt.length ? Mt.buffer.head.data.length : Mt.length : ($t > Mt.highWaterMark && (Mt.highWaterMark = Et($t)), $t <= Mt.length ? $t : Mt.ended ? Mt.length : (Mt.needReadable = !0, 0));
  }
  pt.prototype.read = function($t) {
    pe("read", $t), $t = parseInt($t, 10);
    var Mt = this._readableState, Lt = $t;
    if ($t !== 0 && (Mt.emittedReadable = !1), $t === 0 && Mt.needReadable && (Mt.length >= Mt.highWaterMark || Mt.ended))
      return pe("read: emitReadable", Mt.length, Mt.ended), Mt.length === 0 && Mt.ended ? qt(this) : wt(this), null;
    if ($t = bt($t, Mt), $t === 0 && Mt.ended)
      return Mt.length === 0 && qt(this), null;
    var Kt = Mt.needReadable;
    pe("need readable", Kt), (Mt.length === 0 || Mt.length - $t < Mt.highWaterMark) && (Kt = !0, pe("length less than watermark", Kt)), Mt.ended || Mt.reading ? (Kt = !1, pe("reading or ended", Kt)) : Kt && (pe("do read"), Mt.reading = !0, Mt.sync = !0, Mt.length === 0 && (Mt.needReadable = !0), this._read(Mt.highWaterMark), Mt.sync = !1, Mt.reading || ($t = bt(Lt, Mt)));
    var Tt;
    return $t > 0 ? Tt = ct($t, Mt) : Tt = null, Tt === null ? (Mt.needReadable = !0, $t = 0) : Mt.length -= $t, Mt.length === 0 && (Mt.ended || (Mt.needReadable = !0), Lt !== $t && Mt.ended && qt(this)), Tt !== null && this.emit("data", Tt), Tt;
  };
  function Bt($t, Mt) {
    if (!Mt.ended) {
      if (Mt.decoder) {
        var Lt = Mt.decoder.end();
        Lt && Lt.length && (Mt.buffer.push(Lt), Mt.length += Mt.objectMode ? 1 : Lt.length);
      }
      Mt.ended = !0, wt($t);
    }
  }
  function wt($t) {
    var Mt = $t._readableState;
    Mt.needReadable = !1, Mt.emittedReadable || (pe("emitReadable", Mt.flowing), Mt.emittedReadable = !0, Mt.sync ? A.nextTick(st, $t) : st($t));
  }
  function st($t) {
    pe("emit readable"), $t.emit("readable"), lt($t);
  }
  function Oe($t, Mt) {
    Mt.readingMore || (Mt.readingMore = !0, A.nextTick(V, $t, Mt));
  }
  function V($t, Mt) {
    for (var Lt = Mt.length; !Mt.reading && !Mt.flowing && !Mt.ended && Mt.length < Mt.highWaterMark && (pe("maybeReadMore read 0"), $t.read(0), Lt !== Mt.length); )
      Lt = Mt.length;
    Mt.readingMore = !1;
  }
  pt.prototype._read = function($t) {
    this.emit("error", new Error("_read() is not implemented"));
  }, pt.prototype.pipe = function($t, Mt) {
    var Lt = this, Kt = this._readableState;
    switch (Kt.pipesCount) {
      case 0:
        Kt.pipes = $t;
        break;
      case 1:
        Kt.pipes = [Kt.pipes, $t];
        break;
      default:
        Kt.pipes.push($t);
        break;
    }
    Kt.pipesCount += 1, pe("pipe count=%d opts=%j", Kt.pipesCount, Mt);
    var Tt = (!Mt || Mt.end !== !1) && $t !== process$1.stdout && $t !== process$1.stderr, Rt = Tt ? Xt : Sr;
    Kt.endEmitted ? A.nextTick(Rt) : Lt.once("end", Rt), $t.on("unpipe", Wt);
    function Wt(cr, Br) {
      pe("onunpipe"), cr === Lt && Br && Br.hasUnpiped === !1 && (Br.hasUnpiped = !0, fr());
    }
    function Xt() {
      pe("onend"), $t.end();
    }
    var Zt = ce(Lt);
    $t.on("drain", Zt);
    var ar = !1;
    function fr() {
      pe("cleanup"), $t.removeListener("close", sr), $t.removeListener("finish", Mr), $t.removeListener("drain", Zt), $t.removeListener("error", _r), $t.removeListener("unpipe", Wt), Lt.removeListener("end", Xt), Lt.removeListener("end", Sr), Lt.removeListener("data", Jt), ar = !0, Kt.awaitDrain && (!$t._writableState || $t._writableState.needDrain) && Zt();
    }
    var lr = !1;
    Lt.on("data", Jt);
    function Jt(cr) {
      pe("ondata"), lr = !1;
      var Br = $t.write(cr);
      Br === !1 && !lr && ((Kt.pipesCount === 1 && Kt.pipes === $t || Kt.pipesCount > 1 && kt(Kt.pipes, $t) !== -1) && !ar && (pe("false write response, pause", Kt.awaitDrain), Kt.awaitDrain++, lr = !0), Lt.pause());
    }
    function _r(cr) {
      pe("onerror", cr), Sr(), $t.removeListener("error", _r), K($t, "error") === 0 && $t.emit("error", cr);
    }
    dt($t, "error", _r);
    function sr() {
      $t.removeListener("finish", Mr), Sr();
    }
    $t.once("close", sr);
    function Mr() {
      pe("onfinish"), $t.removeListener("close", sr), Sr();
    }
    $t.once("finish", Mr);
    function Sr() {
      pe("unpipe"), Lt.unpipe($t);
    }
    return $t.emit("pipe", Lt), Kt.flowing || (pe("pipe resume"), Lt.resume()), $t;
  };
  function ce($t) {
    return function() {
      var Mt = $t._readableState;
      pe("pipeOnDrain", Mt.awaitDrain), Mt.awaitDrain && Mt.awaitDrain--, Mt.awaitDrain === 0 && K($t, "data") && (Mt.flowing = !0, lt($t));
    };
  }
  pt.prototype.unpipe = function($t) {
    var Mt = this._readableState, Lt = { hasUnpiped: !1 };
    if (Mt.pipesCount === 0) return this;
    if (Mt.pipesCount === 1)
      return $t && $t !== Mt.pipes ? this : ($t || ($t = Mt.pipes), Mt.pipes = null, Mt.pipesCount = 0, Mt.flowing = !1, $t && $t.emit("unpipe", this, Lt), this);
    if (!$t) {
      var Kt = Mt.pipes, Tt = Mt.pipesCount;
      Mt.pipes = null, Mt.pipesCount = 0, Mt.flowing = !1;
      for (var Rt = 0; Rt < Tt; Rt++)
        Kt[Rt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var Wt = kt(Mt.pipes, $t);
    return Wt === -1 ? this : (Mt.pipes.splice(Wt, 1), Mt.pipesCount -= 1, Mt.pipesCount === 1 && (Mt.pipes = Mt.pipes[0]), $t.emit("unpipe", this, Lt), this);
  }, pt.prototype.on = function($t, Mt) {
    var Lt = J.prototype.on.call(this, $t, Mt);
    if ($t === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if ($t === "readable") {
      var Kt = this._readableState;
      !Kt.endEmitted && !Kt.readableListening && (Kt.readableListening = Kt.needReadable = !0, Kt.emittedReadable = !1, Kt.reading ? Kt.length && wt(this) : A.nextTick(it, this));
    }
    return Lt;
  }, pt.prototype.addListener = pt.prototype.on;
  function it($t) {
    pe("readable nexttick read 0"), $t.read(0);
  }
  pt.prototype.resume = function() {
    var $t = this._readableState;
    return $t.flowing || (pe("resume"), $t.flowing = !0, at(this, $t)), this;
  };
  function at($t, Mt) {
    Mt.resumeScheduled || (Mt.resumeScheduled = !0, A.nextTick(ft, $t, Mt));
  }
  function ft($t, Mt) {
    Mt.reading || (pe("resume read 0"), $t.read(0)), Mt.resumeScheduled = !1, Mt.awaitDrain = 0, $t.emit("resume"), lt($t), Mt.flowing && !Mt.reading && $t.read(0);
  }
  pt.prototype.pause = function() {
    return pe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (pe("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function lt($t) {
    var Mt = $t._readableState;
    for (pe("flow", Mt.flowing); Mt.flowing && $t.read() !== null; )
      ;
  }
  pt.prototype.wrap = function($t) {
    var Mt = this, Lt = this._readableState, Kt = !1;
    $t.on("end", function() {
      if (pe("wrapped end"), Lt.decoder && !Lt.ended) {
        var Wt = Lt.decoder.end();
        Wt && Wt.length && Mt.push(Wt);
      }
      Mt.push(null);
    }), $t.on("data", function(Wt) {
      if (pe("wrapped data"), Lt.decoder && (Wt = Lt.decoder.write(Wt)), !(Lt.objectMode && Wt == null) && !(!Lt.objectMode && (!Wt || !Wt.length))) {
        var Xt = Mt.push(Wt);
        Xt || (Kt = !0, $t.pause());
      }
    });
    for (var Tt in $t)
      this[Tt] === void 0 && typeof $t[Tt] == "function" && (this[Tt] = /* @__PURE__ */ function(Wt) {
        return function() {
          return $t[Wt].apply($t, arguments);
        };
      }(Tt));
    for (var Rt = 0; Rt < ut.length; Rt++)
      $t.on(ut[Rt], this.emit.bind(this, ut[Rt]));
    return this._read = function(Wt) {
      pe("wrapped _read", Wt), Kt && (Kt = !1, $t.resume());
    }, this;
  }, Object.defineProperty(pt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), pt._fromList = ct;
  function ct($t, Mt) {
    if (Mt.length === 0) return null;
    var Lt;
    return Mt.objectMode ? Lt = Mt.buffer.shift() : !$t || $t >= Mt.length ? (Mt.decoder ? Lt = Mt.buffer.join("") : Mt.buffer.length === 1 ? Lt = Mt.buffer.head.data : Lt = Mt.buffer.concat(Mt.length), Mt.buffer.clear()) : Lt = ht($t, Mt.buffer, Mt.decoder), Lt;
  }
  function ht($t, Mt, Lt) {
    var Kt;
    return $t < Mt.head.data.length ? (Kt = Mt.head.data.slice(0, $t), Mt.head.data = Mt.head.data.slice($t)) : $t === Mt.head.data.length ? Kt = Mt.shift() : Kt = Lt ? Ce($t, Mt) : yt($t, Mt), Kt;
  }
  function Ce($t, Mt) {
    var Lt = Mt.head, Kt = 1, Tt = Lt.data;
    for ($t -= Tt.length; Lt = Lt.next; ) {
      var Rt = Lt.data, Wt = $t > Rt.length ? Rt.length : $t;
      if (Wt === Rt.length ? Tt += Rt : Tt += Rt.slice(0, $t), $t -= Wt, $t === 0) {
        Wt === Rt.length ? (++Kt, Lt.next ? Mt.head = Lt.next : Mt.head = Mt.tail = null) : (Mt.head = Lt, Lt.data = Rt.slice(Wt));
        break;
      }
      ++Kt;
    }
    return Mt.length -= Kt, Tt;
  }
  function yt($t, Mt) {
    var Lt = L.allocUnsafe($t), Kt = Mt.head, Tt = 1;
    for (Kt.data.copy(Lt), $t -= Kt.data.length; Kt = Kt.next; ) {
      var Rt = Kt.data, Wt = $t > Rt.length ? Rt.length : $t;
      if (Rt.copy(Lt, Lt.length - $t, 0, Wt), $t -= Wt, $t === 0) {
        Wt === Rt.length ? (++Tt, Kt.next ? Mt.head = Kt.next : Mt.head = Mt.tail = null) : (Mt.head = Kt, Kt.data = Rt.slice(Wt));
        break;
      }
      ++Tt;
    }
    return Mt.length -= Tt, Lt;
  }
  function qt($t) {
    var Mt = $t._readableState;
    if (Mt.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    Mt.endEmitted || (Mt.ended = !0, A.nextTick(jt, Mt, $t));
  }
  function jt($t, Mt) {
    !$t.endEmitted && $t.length === 0 && ($t.endEmitted = !0, Mt.readable = !1, Mt.emit("end"));
  }
  function kt($t, Mt) {
    for (var Lt = 0, Kt = $t.length; Lt < Kt; Lt++)
      if ($t[Lt] === Mt) return Lt;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = K;
  var A = require_stream_duplex(), B = Object.create(requireUtil());
  B.inherits = requireInherits_browser(), B.inherits(K, A);
  function W(re, ie) {
    var oe = this._transformState;
    oe.transforming = !1;
    var ke = oe.writecb;
    if (!ke)
      return this.emit("error", new Error("write callback called multiple times"));
    oe.writechunk = null, oe.writecb = null, ie != null && this.push(ie), ke(re);
    var ne = this._readableState;
    ne.reading = !1, (ne.needReadable || ne.length < ne.highWaterMark) && this._read(ne.highWaterMark);
  }
  function K(re) {
    if (!(this instanceof K)) return new K(re);
    A.call(this, re), this._transformState = {
      afterTransform: W.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, re && (typeof re.transform == "function" && (this._transform = re.transform), typeof re.flush == "function" && (this._flush = re.flush)), this.on("prefinish", J);
  }
  function J() {
    var re = this;
    typeof this._flush == "function" ? this._flush(function(ie, oe) {
      L(re, ie, oe);
    }) : L(this, null, null);
  }
  K.prototype.push = function(re, ie) {
    return this._transformState.needTransform = !1, A.prototype.push.call(this, re, ie);
  }, K.prototype._transform = function(re, ie, oe) {
    throw new Error("_transform() is not implemented");
  }, K.prototype._write = function(re, ie, oe) {
    var ke = this._transformState;
    if (ke.writecb = oe, ke.writechunk = re, ke.writeencoding = ie, !ke.transforming) {
      var ne = this._readableState;
      (ke.needTransform || ne.needReadable || ne.length < ne.highWaterMark) && this._read(ne.highWaterMark);
    }
  }, K.prototype._read = function(re) {
    var ie = this._transformState;
    ie.writechunk !== null && ie.writecb && !ie.transforming ? (ie.transforming = !0, this._transform(ie.writechunk, ie.writeencoding, ie.afterTransform)) : ie.needTransform = !0;
  }, K.prototype._destroy = function(re, ie) {
    var oe = this;
    A.prototype._destroy.call(this, re, function(ke) {
      ie(ke), oe.emit("close");
    });
  };
  function L(re, ie, oe) {
    if (ie) return re.emit("error", ie);
    if (oe != null && re.push(oe), re._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (re._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return re.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = W;
  var A = require_stream_transform(), B = Object.create(requireUtil());
  B.inherits = requireInherits_browser(), B.inherits(W, A);
  function W(K) {
    if (!(this instanceof W)) return new W(K);
    A.call(this, K);
  }
  return W.prototype._transform = function(K, J, L) {
    L(null, K);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(A, B) {
    B = A.exports = require_stream_readable(), B.Stream = B, B.Readable = B, B.Writable = require_stream_writable(), B.Duplex = require_stream_duplex(), B.Transform = require_stream_transform(), B.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign = { exports: {} }, bn$1 = { exports: {} };
bn$1.exports;
var hasRequiredBn$1;
function requireBn$1() {
  return hasRequiredBn$1 || (hasRequiredBn$1 = 1, function(A) {
    (function(B, W) {
      function K(Oe, V) {
        if (!Oe) throw new Error(V || "Assertion failed");
      }
      function J(Oe, V) {
        Oe.super_ = V;
        var ce = function() {
        };
        ce.prototype = V.prototype, Oe.prototype = new ce(), Oe.prototype.constructor = Oe;
      }
      function L(Oe, V, ce) {
        if (L.isBN(Oe))
          return Oe;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, Oe !== null && ((V === "le" || V === "be") && (ce = V, V = 10), this._init(Oe || 0, V || 10, ce || "be"));
      }
      typeof B == "object" ? B.exports = L : W.BN = L, L.BN = L, L.wordSize = 26;
      var re;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? re = window.Buffer : re = require$$0$1.Buffer;
      } catch {
      }
      L.isBN = function(V) {
        return V instanceof L ? !0 : V !== null && typeof V == "object" && V.constructor.wordSize === L.wordSize && Array.isArray(V.words);
      }, L.max = function(V, ce) {
        return V.cmp(ce) > 0 ? V : ce;
      }, L.min = function(V, ce) {
        return V.cmp(ce) < 0 ? V : ce;
      }, L.prototype._init = function(V, ce, it) {
        if (typeof V == "number")
          return this._initNumber(V, ce, it);
        if (typeof V == "object")
          return this._initArray(V, ce, it);
        ce === "hex" && (ce = 16), K(ce === (ce | 0) && ce >= 2 && ce <= 36), V = V.toString().replace(/\s+/g, "");
        var at = 0;
        V[0] === "-" && (at++, this.negative = 1), at < V.length && (ce === 16 ? this._parseHex(V, at, it) : (this._parseBase(V, ce, at), it === "le" && this._initArray(this.toArray(), ce, it)));
      }, L.prototype._initNumber = function(V, ce, it) {
        V < 0 && (this.negative = 1, V = -V), V < 67108864 ? (this.words = [V & 67108863], this.length = 1) : V < 4503599627370496 ? (this.words = [
          V & 67108863,
          V / 67108864 & 67108863
        ], this.length = 2) : (K(V < 9007199254740992), this.words = [
          V & 67108863,
          V / 67108864 & 67108863,
          1
        ], this.length = 3), it === "le" && this._initArray(this.toArray(), ce, it);
      }, L.prototype._initArray = function(V, ce, it) {
        if (K(typeof V.length == "number"), V.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(V.length / 3), this.words = new Array(this.length);
        for (var at = 0; at < this.length; at++)
          this.words[at] = 0;
        var ft, lt, ct = 0;
        if (it === "be")
          for (at = V.length - 1, ft = 0; at >= 0; at -= 3)
            lt = V[at] | V[at - 1] << 8 | V[at - 2] << 16, this.words[ft] |= lt << ct & 67108863, this.words[ft + 1] = lt >>> 26 - ct & 67108863, ct += 24, ct >= 26 && (ct -= 26, ft++);
        else if (it === "le")
          for (at = 0, ft = 0; at < V.length; at += 3)
            lt = V[at] | V[at + 1] << 8 | V[at + 2] << 16, this.words[ft] |= lt << ct & 67108863, this.words[ft + 1] = lt >>> 26 - ct & 67108863, ct += 24, ct >= 26 && (ct -= 26, ft++);
        return this._strip();
      };
      function ie(Oe, V) {
        var ce = Oe.charCodeAt(V);
        if (ce >= 48 && ce <= 57)
          return ce - 48;
        if (ce >= 65 && ce <= 70)
          return ce - 55;
        if (ce >= 97 && ce <= 102)
          return ce - 87;
        K(!1, "Invalid character in " + Oe);
      }
      function oe(Oe, V, ce) {
        var it = ie(Oe, ce);
        return ce - 1 >= V && (it |= ie(Oe, ce - 1) << 4), it;
      }
      L.prototype._parseHex = function(V, ce, it) {
        this.length = Math.ceil((V.length - ce) / 6), this.words = new Array(this.length);
        for (var at = 0; at < this.length; at++)
          this.words[at] = 0;
        var ft = 0, lt = 0, ct;
        if (it === "be")
          for (at = V.length - 1; at >= ce; at -= 2)
            ct = oe(V, ce, at) << ft, this.words[lt] |= ct & 67108863, ft >= 18 ? (ft -= 18, lt += 1, this.words[lt] |= ct >>> 26) : ft += 8;
        else {
          var ht = V.length - ce;
          for (at = ht % 2 === 0 ? ce + 1 : ce; at < V.length; at += 2)
            ct = oe(V, ce, at) << ft, this.words[lt] |= ct & 67108863, ft >= 18 ? (ft -= 18, lt += 1, this.words[lt] |= ct >>> 26) : ft += 8;
        }
        this._strip();
      };
      function ke(Oe, V, ce, it) {
        for (var at = 0, ft = 0, lt = Math.min(Oe.length, ce), ct = V; ct < lt; ct++) {
          var ht = Oe.charCodeAt(ct) - 48;
          at *= it, ht >= 49 ? ft = ht - 49 + 10 : ht >= 17 ? ft = ht - 17 + 10 : ft = ht, K(ht >= 0 && ft < it, "Invalid character"), at += ft;
        }
        return at;
      }
      L.prototype._parseBase = function(V, ce, it) {
        this.words = [0], this.length = 1;
        for (var at = 0, ft = 1; ft <= 67108863; ft *= ce)
          at++;
        at--, ft = ft / ce | 0;
        for (var lt = V.length - it, ct = lt % at, ht = Math.min(lt, lt - ct) + it, Ce = 0, yt = it; yt < ht; yt += at)
          Ce = ke(V, yt, yt + at, ce), this.imuln(ft), this.words[0] + Ce < 67108864 ? this.words[0] += Ce : this._iaddn(Ce);
        if (ct !== 0) {
          var qt = 1;
          for (Ce = ke(V, yt, V.length, ce), yt = 0; yt < ct; yt++)
            qt *= ce;
          this.imuln(qt), this.words[0] + Ce < 67108864 ? this.words[0] += Ce : this._iaddn(Ce);
        }
        this._strip();
      }, L.prototype.copy = function(V) {
        V.words = new Array(this.length);
        for (var ce = 0; ce < this.length; ce++)
          V.words[ce] = this.words[ce];
        V.length = this.length, V.negative = this.negative, V.red = this.red;
      };
      function ne(Oe, V) {
        Oe.words = V.words, Oe.length = V.length, Oe.negative = V.negative, Oe.red = V.red;
      }
      if (L.prototype._move = function(V) {
        ne(V, this);
      }, L.prototype.clone = function() {
        var V = new L(null);
        return this.copy(V), V;
      }, L.prototype._expand = function(V) {
        for (; this.length < V; )
          this.words[this.length++] = 0;
        return this;
      }, L.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, L.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          L.prototype[Symbol.for("nodejs.util.inspect.custom")] = pe;
        } catch {
          L.prototype.inspect = pe;
        }
      else
        L.prototype.inspect = pe;
      function pe() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var rt = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], nt = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], ot = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      L.prototype.toString = function(V, ce) {
        V = V || 10, ce = ce | 0 || 1;
        var it;
        if (V === 16 || V === "hex") {
          it = "";
          for (var at = 0, ft = 0, lt = 0; lt < this.length; lt++) {
            var ct = this.words[lt], ht = ((ct << at | ft) & 16777215).toString(16);
            ft = ct >>> 24 - at & 16777215, at += 2, at >= 26 && (at -= 26, lt--), ft !== 0 || lt !== this.length - 1 ? it = rt[6 - ht.length] + ht + it : it = ht + it;
          }
          for (ft !== 0 && (it = ft.toString(16) + it); it.length % ce !== 0; )
            it = "0" + it;
          return this.negative !== 0 && (it = "-" + it), it;
        }
        if (V === (V | 0) && V >= 2 && V <= 36) {
          var Ce = nt[V], yt = ot[V];
          it = "";
          var qt = this.clone();
          for (qt.negative = 0; !qt.isZero(); ) {
            var jt = qt.modrn(yt).toString(V);
            qt = qt.idivn(yt), qt.isZero() ? it = jt + it : it = rt[Ce - jt.length] + jt + it;
          }
          for (this.isZero() && (it = "0" + it); it.length % ce !== 0; )
            it = "0" + it;
          return this.negative !== 0 && (it = "-" + it), it;
        }
        K(!1, "Base should be between 2 and 36");
      }, L.prototype.toNumber = function() {
        var V = this.words[0];
        return this.length === 2 ? V += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? V += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && K(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -V : V;
      }, L.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, re && (L.prototype.toBuffer = function(V, ce) {
        return this.toArrayLike(re, V, ce);
      }), L.prototype.toArray = function(V, ce) {
        return this.toArrayLike(Array, V, ce);
      };
      var ut = function(V, ce) {
        return V.allocUnsafe ? V.allocUnsafe(ce) : new V(ce);
      };
      L.prototype.toArrayLike = function(V, ce, it) {
        this._strip();
        var at = this.byteLength(), ft = it || Math.max(1, at);
        K(at <= ft, "byte array longer than desired length"), K(ft > 0, "Requested array length <= 0");
        var lt = ut(V, ft), ct = ce === "le" ? "LE" : "BE";
        return this["_toArrayLike" + ct](lt, at), lt;
      }, L.prototype._toArrayLikeLE = function(V, ce) {
        for (var it = 0, at = 0, ft = 0, lt = 0; ft < this.length; ft++) {
          var ct = this.words[ft] << lt | at;
          V[it++] = ct & 255, it < V.length && (V[it++] = ct >> 8 & 255), it < V.length && (V[it++] = ct >> 16 & 255), lt === 6 ? (it < V.length && (V[it++] = ct >> 24 & 255), at = 0, lt = 0) : (at = ct >>> 24, lt += 2);
        }
        if (it < V.length)
          for (V[it++] = at; it < V.length; )
            V[it++] = 0;
      }, L.prototype._toArrayLikeBE = function(V, ce) {
        for (var it = V.length - 1, at = 0, ft = 0, lt = 0; ft < this.length; ft++) {
          var ct = this.words[ft] << lt | at;
          V[it--] = ct & 255, it >= 0 && (V[it--] = ct >> 8 & 255), it >= 0 && (V[it--] = ct >> 16 & 255), lt === 6 ? (it >= 0 && (V[it--] = ct >> 24 & 255), at = 0, lt = 0) : (at = ct >>> 24, lt += 2);
        }
        if (it >= 0)
          for (V[it--] = at; it >= 0; )
            V[it--] = 0;
      }, Math.clz32 ? L.prototype._countBits = function(V) {
        return 32 - Math.clz32(V);
      } : L.prototype._countBits = function(V) {
        var ce = V, it = 0;
        return ce >= 4096 && (it += 13, ce >>>= 13), ce >= 64 && (it += 7, ce >>>= 7), ce >= 8 && (it += 4, ce >>>= 4), ce >= 2 && (it += 2, ce >>>= 2), it + ce;
      }, L.prototype._zeroBits = function(V) {
        if (V === 0) return 26;
        var ce = V, it = 0;
        return ce & 8191 || (it += 13, ce >>>= 13), ce & 127 || (it += 7, ce >>>= 7), ce & 15 || (it += 4, ce >>>= 4), ce & 3 || (it += 2, ce >>>= 2), ce & 1 || it++, it;
      }, L.prototype.bitLength = function() {
        var V = this.words[this.length - 1], ce = this._countBits(V);
        return (this.length - 1) * 26 + ce;
      };
      function dt(Oe) {
        for (var V = new Array(Oe.bitLength()), ce = 0; ce < V.length; ce++) {
          var it = ce / 26 | 0, at = ce % 26;
          V[ce] = Oe.words[it] >>> at & 1;
        }
        return V;
      }
      L.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var V = 0, ce = 0; ce < this.length; ce++) {
          var it = this._zeroBits(this.words[ce]);
          if (V += it, it !== 26) break;
        }
        return V;
      }, L.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, L.prototype.toTwos = function(V) {
        return this.negative !== 0 ? this.abs().inotn(V).iaddn(1) : this.clone();
      }, L.prototype.fromTwos = function(V) {
        return this.testn(V - 1) ? this.notn(V).iaddn(1).ineg() : this.clone();
      }, L.prototype.isNeg = function() {
        return this.negative !== 0;
      }, L.prototype.neg = function() {
        return this.clone().ineg();
      }, L.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, L.prototype.iuor = function(V) {
        for (; this.length < V.length; )
          this.words[this.length++] = 0;
        for (var ce = 0; ce < V.length; ce++)
          this.words[ce] = this.words[ce] | V.words[ce];
        return this._strip();
      }, L.prototype.ior = function(V) {
        return K((this.negative | V.negative) === 0), this.iuor(V);
      }, L.prototype.or = function(V) {
        return this.length > V.length ? this.clone().ior(V) : V.clone().ior(this);
      }, L.prototype.uor = function(V) {
        return this.length > V.length ? this.clone().iuor(V) : V.clone().iuor(this);
      }, L.prototype.iuand = function(V) {
        var ce;
        this.length > V.length ? ce = V : ce = this;
        for (var it = 0; it < ce.length; it++)
          this.words[it] = this.words[it] & V.words[it];
        return this.length = ce.length, this._strip();
      }, L.prototype.iand = function(V) {
        return K((this.negative | V.negative) === 0), this.iuand(V);
      }, L.prototype.and = function(V) {
        return this.length > V.length ? this.clone().iand(V) : V.clone().iand(this);
      }, L.prototype.uand = function(V) {
        return this.length > V.length ? this.clone().iuand(V) : V.clone().iuand(this);
      }, L.prototype.iuxor = function(V) {
        var ce, it;
        this.length > V.length ? (ce = this, it = V) : (ce = V, it = this);
        for (var at = 0; at < it.length; at++)
          this.words[at] = ce.words[at] ^ it.words[at];
        if (this !== ce)
          for (; at < ce.length; at++)
            this.words[at] = ce.words[at];
        return this.length = ce.length, this._strip();
      }, L.prototype.ixor = function(V) {
        return K((this.negative | V.negative) === 0), this.iuxor(V);
      }, L.prototype.xor = function(V) {
        return this.length > V.length ? this.clone().ixor(V) : V.clone().ixor(this);
      }, L.prototype.uxor = function(V) {
        return this.length > V.length ? this.clone().iuxor(V) : V.clone().iuxor(this);
      }, L.prototype.inotn = function(V) {
        K(typeof V == "number" && V >= 0);
        var ce = Math.ceil(V / 26) | 0, it = V % 26;
        this._expand(ce), it > 0 && ce--;
        for (var at = 0; at < ce; at++)
          this.words[at] = ~this.words[at] & 67108863;
        return it > 0 && (this.words[at] = ~this.words[at] & 67108863 >> 26 - it), this._strip();
      }, L.prototype.notn = function(V) {
        return this.clone().inotn(V);
      }, L.prototype.setn = function(V, ce) {
        K(typeof V == "number" && V >= 0);
        var it = V / 26 | 0, at = V % 26;
        return this._expand(it + 1), ce ? this.words[it] = this.words[it] | 1 << at : this.words[it] = this.words[it] & ~(1 << at), this._strip();
      }, L.prototype.iadd = function(V) {
        var ce;
        if (this.negative !== 0 && V.negative === 0)
          return this.negative = 0, ce = this.isub(V), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && V.negative !== 0)
          return V.negative = 0, ce = this.isub(V), V.negative = 1, ce._normSign();
        var it, at;
        this.length > V.length ? (it = this, at = V) : (it = V, at = this);
        for (var ft = 0, lt = 0; lt < at.length; lt++)
          ce = (it.words[lt] | 0) + (at.words[lt] | 0) + ft, this.words[lt] = ce & 67108863, ft = ce >>> 26;
        for (; ft !== 0 && lt < it.length; lt++)
          ce = (it.words[lt] | 0) + ft, this.words[lt] = ce & 67108863, ft = ce >>> 26;
        if (this.length = it.length, ft !== 0)
          this.words[this.length] = ft, this.length++;
        else if (it !== this)
          for (; lt < it.length; lt++)
            this.words[lt] = it.words[lt];
        return this;
      }, L.prototype.add = function(V) {
        var ce;
        return V.negative !== 0 && this.negative === 0 ? (V.negative = 0, ce = this.sub(V), V.negative ^= 1, ce) : V.negative === 0 && this.negative !== 0 ? (this.negative = 0, ce = V.sub(this), this.negative = 1, ce) : this.length > V.length ? this.clone().iadd(V) : V.clone().iadd(this);
      }, L.prototype.isub = function(V) {
        if (V.negative !== 0) {
          V.negative = 0;
          var ce = this.iadd(V);
          return V.negative = 1, ce._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(V), this.negative = 1, this._normSign();
        var it = this.cmp(V);
        if (it === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var at, ft;
        it > 0 ? (at = this, ft = V) : (at = V, ft = this);
        for (var lt = 0, ct = 0; ct < ft.length; ct++)
          ce = (at.words[ct] | 0) - (ft.words[ct] | 0) + lt, lt = ce >> 26, this.words[ct] = ce & 67108863;
        for (; lt !== 0 && ct < at.length; ct++)
          ce = (at.words[ct] | 0) + lt, lt = ce >> 26, this.words[ct] = ce & 67108863;
        if (lt === 0 && ct < at.length && at !== this)
          for (; ct < at.length; ct++)
            this.words[ct] = at.words[ct];
        return this.length = Math.max(this.length, ct), at !== this && (this.negative = 1), this._strip();
      }, L.prototype.sub = function(V) {
        return this.clone().isub(V);
      };
      function vt(Oe, V, ce) {
        ce.negative = V.negative ^ Oe.negative;
        var it = Oe.length + V.length | 0;
        ce.length = it, it = it - 1 | 0;
        var at = Oe.words[0] | 0, ft = V.words[0] | 0, lt = at * ft, ct = lt & 67108863, ht = lt / 67108864 | 0;
        ce.words[0] = ct;
        for (var Ce = 1; Ce < it; Ce++) {
          for (var yt = ht >>> 26, qt = ht & 67108863, jt = Math.min(Ce, V.length - 1), kt = Math.max(0, Ce - Oe.length + 1); kt <= jt; kt++) {
            var $t = Ce - kt | 0;
            at = Oe.words[$t] | 0, ft = V.words[kt] | 0, lt = at * ft + qt, yt += lt / 67108864 | 0, qt = lt & 67108863;
          }
          ce.words[Ce] = qt | 0, ht = yt | 0;
        }
        return ht !== 0 ? ce.words[Ce] = ht | 0 : ce.length--, ce._strip();
      }
      var pt = function(V, ce, it) {
        var at = V.words, ft = ce.words, lt = it.words, ct = 0, ht, Ce, yt, qt = at[0] | 0, jt = qt & 8191, kt = qt >>> 13, $t = at[1] | 0, Mt = $t & 8191, Lt = $t >>> 13, Kt = at[2] | 0, Tt = Kt & 8191, Rt = Kt >>> 13, Wt = at[3] | 0, Xt = Wt & 8191, Zt = Wt >>> 13, ar = at[4] | 0, fr = ar & 8191, lr = ar >>> 13, Jt = at[5] | 0, _r = Jt & 8191, sr = Jt >>> 13, Mr = at[6] | 0, Sr = Mr & 8191, cr = Mr >>> 13, Br = at[7] | 0, $r = Br & 8191, yr = Br >>> 13, kr = at[8] | 0, Tr = kr & 8191, It = kr >>> 13, St = at[9] | 0, At = St & 8191, Ot = St >>> 13, Gt = ft[0] | 0, zt = Gt & 8191, Vt = Gt >>> 13, Er = ft[1] | 0, wr = Er & 8191, hr = Er >>> 13, Pr = ft[2] | 0, gr = Pr & 8191, vr = Pr >>> 13, qr = ft[3] | 0, Ir = qr & 8191, Ut = qr >>> 13, Ct = ft[4] | 0, Dt = Ct & 8191, Ht = Ct >>> 13, Yt = ft[5] | 0, Qt = Yt & 8191, er = Yt >>> 13, or = ft[6] | 0, ur = or & 8191, ir = or >>> 13, Ar = ft[7] | 0, pr = Ar & 8191, Ft = Ar >>> 13, tr = ft[8] | 0, rr = tr & 8191, nr = tr >>> 13, xr = ft[9] | 0, br = xr & 8191, dr = xr >>> 13;
        it.negative = V.negative ^ ce.negative, it.length = 19, ht = Math.imul(jt, zt), Ce = Math.imul(jt, Vt), Ce = Ce + Math.imul(kt, zt) | 0, yt = Math.imul(kt, Vt);
        var Rr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, ht = Math.imul(Mt, zt), Ce = Math.imul(Mt, Vt), Ce = Ce + Math.imul(Lt, zt) | 0, yt = Math.imul(Lt, Vt), ht = ht + Math.imul(jt, wr) | 0, Ce = Ce + Math.imul(jt, hr) | 0, Ce = Ce + Math.imul(kt, wr) | 0, yt = yt + Math.imul(kt, hr) | 0;
        var Nr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, ht = Math.imul(Tt, zt), Ce = Math.imul(Tt, Vt), Ce = Ce + Math.imul(Rt, zt) | 0, yt = Math.imul(Rt, Vt), ht = ht + Math.imul(Mt, wr) | 0, Ce = Ce + Math.imul(Mt, hr) | 0, Ce = Ce + Math.imul(Lt, wr) | 0, yt = yt + Math.imul(Lt, hr) | 0, ht = ht + Math.imul(jt, gr) | 0, Ce = Ce + Math.imul(jt, vr) | 0, Ce = Ce + Math.imul(kt, gr) | 0, yt = yt + Math.imul(kt, vr) | 0;
        var Or = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Or >>> 26) | 0, Or &= 67108863, ht = Math.imul(Xt, zt), Ce = Math.imul(Xt, Vt), Ce = Ce + Math.imul(Zt, zt) | 0, yt = Math.imul(Zt, Vt), ht = ht + Math.imul(Tt, wr) | 0, Ce = Ce + Math.imul(Tt, hr) | 0, Ce = Ce + Math.imul(Rt, wr) | 0, yt = yt + Math.imul(Rt, hr) | 0, ht = ht + Math.imul(Mt, gr) | 0, Ce = Ce + Math.imul(Mt, vr) | 0, Ce = Ce + Math.imul(Lt, gr) | 0, yt = yt + Math.imul(Lt, vr) | 0, ht = ht + Math.imul(jt, Ir) | 0, Ce = Ce + Math.imul(jt, Ut) | 0, Ce = Ce + Math.imul(kt, Ir) | 0, yt = yt + Math.imul(kt, Ut) | 0;
        var Cr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Cr >>> 26) | 0, Cr &= 67108863, ht = Math.imul(fr, zt), Ce = Math.imul(fr, Vt), Ce = Ce + Math.imul(lr, zt) | 0, yt = Math.imul(lr, Vt), ht = ht + Math.imul(Xt, wr) | 0, Ce = Ce + Math.imul(Xt, hr) | 0, Ce = Ce + Math.imul(Zt, wr) | 0, yt = yt + Math.imul(Zt, hr) | 0, ht = ht + Math.imul(Tt, gr) | 0, Ce = Ce + Math.imul(Tt, vr) | 0, Ce = Ce + Math.imul(Rt, gr) | 0, yt = yt + Math.imul(Rt, vr) | 0, ht = ht + Math.imul(Mt, Ir) | 0, Ce = Ce + Math.imul(Mt, Ut) | 0, Ce = Ce + Math.imul(Lt, Ir) | 0, yt = yt + Math.imul(Lt, Ut) | 0, ht = ht + Math.imul(jt, Dt) | 0, Ce = Ce + Math.imul(jt, Ht) | 0, Ce = Ce + Math.imul(kt, Dt) | 0, yt = yt + Math.imul(kt, Ht) | 0;
        var Lr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, ht = Math.imul(_r, zt), Ce = Math.imul(_r, Vt), Ce = Ce + Math.imul(sr, zt) | 0, yt = Math.imul(sr, Vt), ht = ht + Math.imul(fr, wr) | 0, Ce = Ce + Math.imul(fr, hr) | 0, Ce = Ce + Math.imul(lr, wr) | 0, yt = yt + Math.imul(lr, hr) | 0, ht = ht + Math.imul(Xt, gr) | 0, Ce = Ce + Math.imul(Xt, vr) | 0, Ce = Ce + Math.imul(Zt, gr) | 0, yt = yt + Math.imul(Zt, vr) | 0, ht = ht + Math.imul(Tt, Ir) | 0, Ce = Ce + Math.imul(Tt, Ut) | 0, Ce = Ce + Math.imul(Rt, Ir) | 0, yt = yt + Math.imul(Rt, Ut) | 0, ht = ht + Math.imul(Mt, Dt) | 0, Ce = Ce + Math.imul(Mt, Ht) | 0, Ce = Ce + Math.imul(Lt, Dt) | 0, yt = yt + Math.imul(Lt, Ht) | 0, ht = ht + Math.imul(jt, Qt) | 0, Ce = Ce + Math.imul(jt, er) | 0, Ce = Ce + Math.imul(kt, Qt) | 0, yt = yt + Math.imul(kt, er) | 0;
        var Dr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, ht = Math.imul(Sr, zt), Ce = Math.imul(Sr, Vt), Ce = Ce + Math.imul(cr, zt) | 0, yt = Math.imul(cr, Vt), ht = ht + Math.imul(_r, wr) | 0, Ce = Ce + Math.imul(_r, hr) | 0, Ce = Ce + Math.imul(sr, wr) | 0, yt = yt + Math.imul(sr, hr) | 0, ht = ht + Math.imul(fr, gr) | 0, Ce = Ce + Math.imul(fr, vr) | 0, Ce = Ce + Math.imul(lr, gr) | 0, yt = yt + Math.imul(lr, vr) | 0, ht = ht + Math.imul(Xt, Ir) | 0, Ce = Ce + Math.imul(Xt, Ut) | 0, Ce = Ce + Math.imul(Zt, Ir) | 0, yt = yt + Math.imul(Zt, Ut) | 0, ht = ht + Math.imul(Tt, Dt) | 0, Ce = Ce + Math.imul(Tt, Ht) | 0, Ce = Ce + Math.imul(Rt, Dt) | 0, yt = yt + Math.imul(Rt, Ht) | 0, ht = ht + Math.imul(Mt, Qt) | 0, Ce = Ce + Math.imul(Mt, er) | 0, Ce = Ce + Math.imul(Lt, Qt) | 0, yt = yt + Math.imul(Lt, er) | 0, ht = ht + Math.imul(jt, ur) | 0, Ce = Ce + Math.imul(jt, ir) | 0, Ce = Ce + Math.imul(kt, ur) | 0, yt = yt + Math.imul(kt, ir) | 0;
        var Ur = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, ht = Math.imul($r, zt), Ce = Math.imul($r, Vt), Ce = Ce + Math.imul(yr, zt) | 0, yt = Math.imul(yr, Vt), ht = ht + Math.imul(Sr, wr) | 0, Ce = Ce + Math.imul(Sr, hr) | 0, Ce = Ce + Math.imul(cr, wr) | 0, yt = yt + Math.imul(cr, hr) | 0, ht = ht + Math.imul(_r, gr) | 0, Ce = Ce + Math.imul(_r, vr) | 0, Ce = Ce + Math.imul(sr, gr) | 0, yt = yt + Math.imul(sr, vr) | 0, ht = ht + Math.imul(fr, Ir) | 0, Ce = Ce + Math.imul(fr, Ut) | 0, Ce = Ce + Math.imul(lr, Ir) | 0, yt = yt + Math.imul(lr, Ut) | 0, ht = ht + Math.imul(Xt, Dt) | 0, Ce = Ce + Math.imul(Xt, Ht) | 0, Ce = Ce + Math.imul(Zt, Dt) | 0, yt = yt + Math.imul(Zt, Ht) | 0, ht = ht + Math.imul(Tt, Qt) | 0, Ce = Ce + Math.imul(Tt, er) | 0, Ce = Ce + Math.imul(Rt, Qt) | 0, yt = yt + Math.imul(Rt, er) | 0, ht = ht + Math.imul(Mt, ur) | 0, Ce = Ce + Math.imul(Mt, ir) | 0, Ce = Ce + Math.imul(Lt, ur) | 0, yt = yt + Math.imul(Lt, ir) | 0, ht = ht + Math.imul(jt, pr) | 0, Ce = Ce + Math.imul(jt, Ft) | 0, Ce = Ce + Math.imul(kt, pr) | 0, yt = yt + Math.imul(kt, Ft) | 0;
        var Fr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, ht = Math.imul(Tr, zt), Ce = Math.imul(Tr, Vt), Ce = Ce + Math.imul(It, zt) | 0, yt = Math.imul(It, Vt), ht = ht + Math.imul($r, wr) | 0, Ce = Ce + Math.imul($r, hr) | 0, Ce = Ce + Math.imul(yr, wr) | 0, yt = yt + Math.imul(yr, hr) | 0, ht = ht + Math.imul(Sr, gr) | 0, Ce = Ce + Math.imul(Sr, vr) | 0, Ce = Ce + Math.imul(cr, gr) | 0, yt = yt + Math.imul(cr, vr) | 0, ht = ht + Math.imul(_r, Ir) | 0, Ce = Ce + Math.imul(_r, Ut) | 0, Ce = Ce + Math.imul(sr, Ir) | 0, yt = yt + Math.imul(sr, Ut) | 0, ht = ht + Math.imul(fr, Dt) | 0, Ce = Ce + Math.imul(fr, Ht) | 0, Ce = Ce + Math.imul(lr, Dt) | 0, yt = yt + Math.imul(lr, Ht) | 0, ht = ht + Math.imul(Xt, Qt) | 0, Ce = Ce + Math.imul(Xt, er) | 0, Ce = Ce + Math.imul(Zt, Qt) | 0, yt = yt + Math.imul(Zt, er) | 0, ht = ht + Math.imul(Tt, ur) | 0, Ce = Ce + Math.imul(Tt, ir) | 0, Ce = Ce + Math.imul(Rt, ur) | 0, yt = yt + Math.imul(Rt, ir) | 0, ht = ht + Math.imul(Mt, pr) | 0, Ce = Ce + Math.imul(Mt, Ft) | 0, Ce = Ce + Math.imul(Lt, pr) | 0, yt = yt + Math.imul(Lt, Ft) | 0, ht = ht + Math.imul(jt, rr) | 0, Ce = Ce + Math.imul(jt, nr) | 0, Ce = Ce + Math.imul(kt, rr) | 0, yt = yt + Math.imul(kt, nr) | 0;
        var jr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, ht = Math.imul(At, zt), Ce = Math.imul(At, Vt), Ce = Ce + Math.imul(Ot, zt) | 0, yt = Math.imul(Ot, Vt), ht = ht + Math.imul(Tr, wr) | 0, Ce = Ce + Math.imul(Tr, hr) | 0, Ce = Ce + Math.imul(It, wr) | 0, yt = yt + Math.imul(It, hr) | 0, ht = ht + Math.imul($r, gr) | 0, Ce = Ce + Math.imul($r, vr) | 0, Ce = Ce + Math.imul(yr, gr) | 0, yt = yt + Math.imul(yr, vr) | 0, ht = ht + Math.imul(Sr, Ir) | 0, Ce = Ce + Math.imul(Sr, Ut) | 0, Ce = Ce + Math.imul(cr, Ir) | 0, yt = yt + Math.imul(cr, Ut) | 0, ht = ht + Math.imul(_r, Dt) | 0, Ce = Ce + Math.imul(_r, Ht) | 0, Ce = Ce + Math.imul(sr, Dt) | 0, yt = yt + Math.imul(sr, Ht) | 0, ht = ht + Math.imul(fr, Qt) | 0, Ce = Ce + Math.imul(fr, er) | 0, Ce = Ce + Math.imul(lr, Qt) | 0, yt = yt + Math.imul(lr, er) | 0, ht = ht + Math.imul(Xt, ur) | 0, Ce = Ce + Math.imul(Xt, ir) | 0, Ce = Ce + Math.imul(Zt, ur) | 0, yt = yt + Math.imul(Zt, ir) | 0, ht = ht + Math.imul(Tt, pr) | 0, Ce = Ce + Math.imul(Tt, Ft) | 0, Ce = Ce + Math.imul(Rt, pr) | 0, yt = yt + Math.imul(Rt, Ft) | 0, ht = ht + Math.imul(Mt, rr) | 0, Ce = Ce + Math.imul(Mt, nr) | 0, Ce = Ce + Math.imul(Lt, rr) | 0, yt = yt + Math.imul(Lt, nr) | 0, ht = ht + Math.imul(jt, br) | 0, Ce = Ce + Math.imul(jt, dr) | 0, Ce = Ce + Math.imul(kt, br) | 0, yt = yt + Math.imul(kt, dr) | 0;
        var Hr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, ht = Math.imul(At, wr), Ce = Math.imul(At, hr), Ce = Ce + Math.imul(Ot, wr) | 0, yt = Math.imul(Ot, hr), ht = ht + Math.imul(Tr, gr) | 0, Ce = Ce + Math.imul(Tr, vr) | 0, Ce = Ce + Math.imul(It, gr) | 0, yt = yt + Math.imul(It, vr) | 0, ht = ht + Math.imul($r, Ir) | 0, Ce = Ce + Math.imul($r, Ut) | 0, Ce = Ce + Math.imul(yr, Ir) | 0, yt = yt + Math.imul(yr, Ut) | 0, ht = ht + Math.imul(Sr, Dt) | 0, Ce = Ce + Math.imul(Sr, Ht) | 0, Ce = Ce + Math.imul(cr, Dt) | 0, yt = yt + Math.imul(cr, Ht) | 0, ht = ht + Math.imul(_r, Qt) | 0, Ce = Ce + Math.imul(_r, er) | 0, Ce = Ce + Math.imul(sr, Qt) | 0, yt = yt + Math.imul(sr, er) | 0, ht = ht + Math.imul(fr, ur) | 0, Ce = Ce + Math.imul(fr, ir) | 0, Ce = Ce + Math.imul(lr, ur) | 0, yt = yt + Math.imul(lr, ir) | 0, ht = ht + Math.imul(Xt, pr) | 0, Ce = Ce + Math.imul(Xt, Ft) | 0, Ce = Ce + Math.imul(Zt, pr) | 0, yt = yt + Math.imul(Zt, Ft) | 0, ht = ht + Math.imul(Tt, rr) | 0, Ce = Ce + Math.imul(Tt, nr) | 0, Ce = Ce + Math.imul(Rt, rr) | 0, yt = yt + Math.imul(Rt, nr) | 0, ht = ht + Math.imul(Mt, br) | 0, Ce = Ce + Math.imul(Mt, dr) | 0, Ce = Ce + Math.imul(Lt, br) | 0, yt = yt + Math.imul(Lt, dr) | 0;
        var Wr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, ht = Math.imul(At, gr), Ce = Math.imul(At, vr), Ce = Ce + Math.imul(Ot, gr) | 0, yt = Math.imul(Ot, vr), ht = ht + Math.imul(Tr, Ir) | 0, Ce = Ce + Math.imul(Tr, Ut) | 0, Ce = Ce + Math.imul(It, Ir) | 0, yt = yt + Math.imul(It, Ut) | 0, ht = ht + Math.imul($r, Dt) | 0, Ce = Ce + Math.imul($r, Ht) | 0, Ce = Ce + Math.imul(yr, Dt) | 0, yt = yt + Math.imul(yr, Ht) | 0, ht = ht + Math.imul(Sr, Qt) | 0, Ce = Ce + Math.imul(Sr, er) | 0, Ce = Ce + Math.imul(cr, Qt) | 0, yt = yt + Math.imul(cr, er) | 0, ht = ht + Math.imul(_r, ur) | 0, Ce = Ce + Math.imul(_r, ir) | 0, Ce = Ce + Math.imul(sr, ur) | 0, yt = yt + Math.imul(sr, ir) | 0, ht = ht + Math.imul(fr, pr) | 0, Ce = Ce + Math.imul(fr, Ft) | 0, Ce = Ce + Math.imul(lr, pr) | 0, yt = yt + Math.imul(lr, Ft) | 0, ht = ht + Math.imul(Xt, rr) | 0, Ce = Ce + Math.imul(Xt, nr) | 0, Ce = Ce + Math.imul(Zt, rr) | 0, yt = yt + Math.imul(Zt, nr) | 0, ht = ht + Math.imul(Tt, br) | 0, Ce = Ce + Math.imul(Tt, dr) | 0, Ce = Ce + Math.imul(Rt, br) | 0, yt = yt + Math.imul(Rt, dr) | 0;
        var Gr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, ht = Math.imul(At, Ir), Ce = Math.imul(At, Ut), Ce = Ce + Math.imul(Ot, Ir) | 0, yt = Math.imul(Ot, Ut), ht = ht + Math.imul(Tr, Dt) | 0, Ce = Ce + Math.imul(Tr, Ht) | 0, Ce = Ce + Math.imul(It, Dt) | 0, yt = yt + Math.imul(It, Ht) | 0, ht = ht + Math.imul($r, Qt) | 0, Ce = Ce + Math.imul($r, er) | 0, Ce = Ce + Math.imul(yr, Qt) | 0, yt = yt + Math.imul(yr, er) | 0, ht = ht + Math.imul(Sr, ur) | 0, Ce = Ce + Math.imul(Sr, ir) | 0, Ce = Ce + Math.imul(cr, ur) | 0, yt = yt + Math.imul(cr, ir) | 0, ht = ht + Math.imul(_r, pr) | 0, Ce = Ce + Math.imul(_r, Ft) | 0, Ce = Ce + Math.imul(sr, pr) | 0, yt = yt + Math.imul(sr, Ft) | 0, ht = ht + Math.imul(fr, rr) | 0, Ce = Ce + Math.imul(fr, nr) | 0, Ce = Ce + Math.imul(lr, rr) | 0, yt = yt + Math.imul(lr, nr) | 0, ht = ht + Math.imul(Xt, br) | 0, Ce = Ce + Math.imul(Xt, dr) | 0, Ce = Ce + Math.imul(Zt, br) | 0, yt = yt + Math.imul(Zt, dr) | 0;
        var zr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, ht = Math.imul(At, Dt), Ce = Math.imul(At, Ht), Ce = Ce + Math.imul(Ot, Dt) | 0, yt = Math.imul(Ot, Ht), ht = ht + Math.imul(Tr, Qt) | 0, Ce = Ce + Math.imul(Tr, er) | 0, Ce = Ce + Math.imul(It, Qt) | 0, yt = yt + Math.imul(It, er) | 0, ht = ht + Math.imul($r, ur) | 0, Ce = Ce + Math.imul($r, ir) | 0, Ce = Ce + Math.imul(yr, ur) | 0, yt = yt + Math.imul(yr, ir) | 0, ht = ht + Math.imul(Sr, pr) | 0, Ce = Ce + Math.imul(Sr, Ft) | 0, Ce = Ce + Math.imul(cr, pr) | 0, yt = yt + Math.imul(cr, Ft) | 0, ht = ht + Math.imul(_r, rr) | 0, Ce = Ce + Math.imul(_r, nr) | 0, Ce = Ce + Math.imul(sr, rr) | 0, yt = yt + Math.imul(sr, nr) | 0, ht = ht + Math.imul(fr, br) | 0, Ce = Ce + Math.imul(fr, dr) | 0, Ce = Ce + Math.imul(lr, br) | 0, yt = yt + Math.imul(lr, dr) | 0;
        var Vr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, ht = Math.imul(At, Qt), Ce = Math.imul(At, er), Ce = Ce + Math.imul(Ot, Qt) | 0, yt = Math.imul(Ot, er), ht = ht + Math.imul(Tr, ur) | 0, Ce = Ce + Math.imul(Tr, ir) | 0, Ce = Ce + Math.imul(It, ur) | 0, yt = yt + Math.imul(It, ir) | 0, ht = ht + Math.imul($r, pr) | 0, Ce = Ce + Math.imul($r, Ft) | 0, Ce = Ce + Math.imul(yr, pr) | 0, yt = yt + Math.imul(yr, Ft) | 0, ht = ht + Math.imul(Sr, rr) | 0, Ce = Ce + Math.imul(Sr, nr) | 0, Ce = Ce + Math.imul(cr, rr) | 0, yt = yt + Math.imul(cr, nr) | 0, ht = ht + Math.imul(_r, br) | 0, Ce = Ce + Math.imul(_r, dr) | 0, Ce = Ce + Math.imul(sr, br) | 0, yt = yt + Math.imul(sr, dr) | 0;
        var Xr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, ht = Math.imul(At, ur), Ce = Math.imul(At, ir), Ce = Ce + Math.imul(Ot, ur) | 0, yt = Math.imul(Ot, ir), ht = ht + Math.imul(Tr, pr) | 0, Ce = Ce + Math.imul(Tr, Ft) | 0, Ce = Ce + Math.imul(It, pr) | 0, yt = yt + Math.imul(It, Ft) | 0, ht = ht + Math.imul($r, rr) | 0, Ce = Ce + Math.imul($r, nr) | 0, Ce = Ce + Math.imul(yr, rr) | 0, yt = yt + Math.imul(yr, nr) | 0, ht = ht + Math.imul(Sr, br) | 0, Ce = Ce + Math.imul(Sr, dr) | 0, Ce = Ce + Math.imul(cr, br) | 0, yt = yt + Math.imul(cr, dr) | 0;
        var Yr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, ht = Math.imul(At, pr), Ce = Math.imul(At, Ft), Ce = Ce + Math.imul(Ot, pr) | 0, yt = Math.imul(Ot, Ft), ht = ht + Math.imul(Tr, rr) | 0, Ce = Ce + Math.imul(Tr, nr) | 0, Ce = Ce + Math.imul(It, rr) | 0, yt = yt + Math.imul(It, nr) | 0, ht = ht + Math.imul($r, br) | 0, Ce = Ce + Math.imul($r, dr) | 0, Ce = Ce + Math.imul(yr, br) | 0, yt = yt + Math.imul(yr, dr) | 0;
        var Jr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, ht = Math.imul(At, rr), Ce = Math.imul(At, nr), Ce = Ce + Math.imul(Ot, rr) | 0, yt = Math.imul(Ot, nr), ht = ht + Math.imul(Tr, br) | 0, Ce = Ce + Math.imul(Tr, dr) | 0, Ce = Ce + Math.imul(It, br) | 0, yt = yt + Math.imul(It, dr) | 0;
        var Qr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, ht = Math.imul(At, br), Ce = Math.imul(At, dr), Ce = Ce + Math.imul(Ot, br) | 0, yt = Math.imul(Ot, dr);
        var Zr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        return ct = (yt + (Ce >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, lt[0] = Rr, lt[1] = Nr, lt[2] = Or, lt[3] = Cr, lt[4] = Lr, lt[5] = Dr, lt[6] = Ur, lt[7] = Fr, lt[8] = jr, lt[9] = Hr, lt[10] = Wr, lt[11] = Gr, lt[12] = zr, lt[13] = Vr, lt[14] = Xr, lt[15] = Yr, lt[16] = Jr, lt[17] = Qr, lt[18] = Zr, ct !== 0 && (lt[19] = ct, it.length++), it;
      };
      Math.imul || (pt = vt);
      function mt(Oe, V, ce) {
        ce.negative = V.negative ^ Oe.negative, ce.length = Oe.length + V.length;
        for (var it = 0, at = 0, ft = 0; ft < ce.length - 1; ft++) {
          var lt = at;
          at = 0;
          for (var ct = it & 67108863, ht = Math.min(ft, V.length - 1), Ce = Math.max(0, ft - Oe.length + 1); Ce <= ht; Ce++) {
            var yt = ft - Ce, qt = Oe.words[yt] | 0, jt = V.words[Ce] | 0, kt = qt * jt, $t = kt & 67108863;
            lt = lt + (kt / 67108864 | 0) | 0, $t = $t + ct | 0, ct = $t & 67108863, lt = lt + ($t >>> 26) | 0, at += lt >>> 26, lt &= 67108863;
          }
          ce.words[ft] = ct, it = lt, lt = at;
        }
        return it !== 0 ? ce.words[ft] = it : ce.length--, ce._strip();
      }
      function gt(Oe, V, ce) {
        return mt(Oe, V, ce);
      }
      L.prototype.mulTo = function(V, ce) {
        var it, at = this.length + V.length;
        return this.length === 10 && V.length === 10 ? it = pt(this, V, ce) : at < 63 ? it = vt(this, V, ce) : at < 1024 ? it = mt(this, V, ce) : it = gt(this, V, ce), it;
      }, L.prototype.mul = function(V) {
        var ce = new L(null);
        return ce.words = new Array(this.length + V.length), this.mulTo(V, ce);
      }, L.prototype.mulf = function(V) {
        var ce = new L(null);
        return ce.words = new Array(this.length + V.length), gt(this, V, ce);
      }, L.prototype.imul = function(V) {
        return this.clone().mulTo(V, this);
      }, L.prototype.imuln = function(V) {
        var ce = V < 0;
        ce && (V = -V), K(typeof V == "number"), K(V < 67108864);
        for (var it = 0, at = 0; at < this.length; at++) {
          var ft = (this.words[at] | 0) * V, lt = (ft & 67108863) + (it & 67108863);
          it >>= 26, it += ft / 67108864 | 0, it += lt >>> 26, this.words[at] = lt & 67108863;
        }
        return it !== 0 && (this.words[at] = it, this.length++), ce ? this.ineg() : this;
      }, L.prototype.muln = function(V) {
        return this.clone().imuln(V);
      }, L.prototype.sqr = function() {
        return this.mul(this);
      }, L.prototype.isqr = function() {
        return this.imul(this.clone());
      }, L.prototype.pow = function(V) {
        var ce = dt(V);
        if (ce.length === 0) return new L(1);
        for (var it = this, at = 0; at < ce.length && ce[at] === 0; at++, it = it.sqr())
          ;
        if (++at < ce.length)
          for (var ft = it.sqr(); at < ce.length; at++, ft = ft.sqr())
            ce[at] !== 0 && (it = it.mul(ft));
        return it;
      }, L.prototype.iushln = function(V) {
        K(typeof V == "number" && V >= 0);
        var ce = V % 26, it = (V - ce) / 26, at = 67108863 >>> 26 - ce << 26 - ce, ft;
        if (ce !== 0) {
          var lt = 0;
          for (ft = 0; ft < this.length; ft++) {
            var ct = this.words[ft] & at, ht = (this.words[ft] | 0) - ct << ce;
            this.words[ft] = ht | lt, lt = ct >>> 26 - ce;
          }
          lt && (this.words[ft] = lt, this.length++);
        }
        if (it !== 0) {
          for (ft = this.length - 1; ft >= 0; ft--)
            this.words[ft + it] = this.words[ft];
          for (ft = 0; ft < it; ft++)
            this.words[ft] = 0;
          this.length += it;
        }
        return this._strip();
      }, L.prototype.ishln = function(V) {
        return K(this.negative === 0), this.iushln(V);
      }, L.prototype.iushrn = function(V, ce, it) {
        K(typeof V == "number" && V >= 0);
        var at;
        ce ? at = (ce - ce % 26) / 26 : at = 0;
        var ft = V % 26, lt = Math.min((V - ft) / 26, this.length), ct = 67108863 ^ 67108863 >>> ft << ft, ht = it;
        if (at -= lt, at = Math.max(0, at), ht) {
          for (var Ce = 0; Ce < lt; Ce++)
            ht.words[Ce] = this.words[Ce];
          ht.length = lt;
        }
        if (lt !== 0) if (this.length > lt)
          for (this.length -= lt, Ce = 0; Ce < this.length; Ce++)
            this.words[Ce] = this.words[Ce + lt];
        else
          this.words[0] = 0, this.length = 1;
        var yt = 0;
        for (Ce = this.length - 1; Ce >= 0 && (yt !== 0 || Ce >= at); Ce--) {
          var qt = this.words[Ce] | 0;
          this.words[Ce] = yt << 26 - ft | qt >>> ft, yt = qt & ct;
        }
        return ht && yt !== 0 && (ht.words[ht.length++] = yt), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, L.prototype.ishrn = function(V, ce, it) {
        return K(this.negative === 0), this.iushrn(V, ce, it);
      }, L.prototype.shln = function(V) {
        return this.clone().ishln(V);
      }, L.prototype.ushln = function(V) {
        return this.clone().iushln(V);
      }, L.prototype.shrn = function(V) {
        return this.clone().ishrn(V);
      }, L.prototype.ushrn = function(V) {
        return this.clone().iushrn(V);
      }, L.prototype.testn = function(V) {
        K(typeof V == "number" && V >= 0);
        var ce = V % 26, it = (V - ce) / 26, at = 1 << ce;
        if (this.length <= it) return !1;
        var ft = this.words[it];
        return !!(ft & at);
      }, L.prototype.imaskn = function(V) {
        K(typeof V == "number" && V >= 0);
        var ce = V % 26, it = (V - ce) / 26;
        if (K(this.negative === 0, "imaskn works only with positive numbers"), this.length <= it)
          return this;
        if (ce !== 0 && it++, this.length = Math.min(it, this.length), ce !== 0) {
          var at = 67108863 ^ 67108863 >>> ce << ce;
          this.words[this.length - 1] &= at;
        }
        return this._strip();
      }, L.prototype.maskn = function(V) {
        return this.clone().imaskn(V);
      }, L.prototype.iaddn = function(V) {
        return K(typeof V == "number"), K(V < 67108864), V < 0 ? this.isubn(-V) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= V ? (this.words[0] = V - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(V), this.negative = 1, this) : this._iaddn(V);
      }, L.prototype._iaddn = function(V) {
        this.words[0] += V;
        for (var ce = 0; ce < this.length && this.words[ce] >= 67108864; ce++)
          this.words[ce] -= 67108864, ce === this.length - 1 ? this.words[ce + 1] = 1 : this.words[ce + 1]++;
        return this.length = Math.max(this.length, ce + 1), this;
      }, L.prototype.isubn = function(V) {
        if (K(typeof V == "number"), K(V < 67108864), V < 0) return this.iaddn(-V);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(V), this.negative = 1, this;
        if (this.words[0] -= V, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var ce = 0; ce < this.length && this.words[ce] < 0; ce++)
            this.words[ce] += 67108864, this.words[ce + 1] -= 1;
        return this._strip();
      }, L.prototype.addn = function(V) {
        return this.clone().iaddn(V);
      }, L.prototype.subn = function(V) {
        return this.clone().isubn(V);
      }, L.prototype.iabs = function() {
        return this.negative = 0, this;
      }, L.prototype.abs = function() {
        return this.clone().iabs();
      }, L.prototype._ishlnsubmul = function(V, ce, it) {
        var at = V.length + it, ft;
        this._expand(at);
        var lt, ct = 0;
        for (ft = 0; ft < V.length; ft++) {
          lt = (this.words[ft + it] | 0) + ct;
          var ht = (V.words[ft] | 0) * ce;
          lt -= ht & 67108863, ct = (lt >> 26) - (ht / 67108864 | 0), this.words[ft + it] = lt & 67108863;
        }
        for (; ft < this.length - it; ft++)
          lt = (this.words[ft + it] | 0) + ct, ct = lt >> 26, this.words[ft + it] = lt & 67108863;
        if (ct === 0) return this._strip();
        for (K(ct === -1), ct = 0, ft = 0; ft < this.length; ft++)
          lt = -(this.words[ft] | 0) + ct, ct = lt >> 26, this.words[ft] = lt & 67108863;
        return this.negative = 1, this._strip();
      }, L.prototype._wordDiv = function(V, ce) {
        var it = this.length - V.length, at = this.clone(), ft = V, lt = ft.words[ft.length - 1] | 0, ct = this._countBits(lt);
        it = 26 - ct, it !== 0 && (ft = ft.ushln(it), at.iushln(it), lt = ft.words[ft.length - 1] | 0);
        var ht = at.length - ft.length, Ce;
        if (ce !== "mod") {
          Ce = new L(null), Ce.length = ht + 1, Ce.words = new Array(Ce.length);
          for (var yt = 0; yt < Ce.length; yt++)
            Ce.words[yt] = 0;
        }
        var qt = at.clone()._ishlnsubmul(ft, 1, ht);
        qt.negative === 0 && (at = qt, Ce && (Ce.words[ht] = 1));
        for (var jt = ht - 1; jt >= 0; jt--) {
          var kt = (at.words[ft.length + jt] | 0) * 67108864 + (at.words[ft.length + jt - 1] | 0);
          for (kt = Math.min(kt / lt | 0, 67108863), at._ishlnsubmul(ft, kt, jt); at.negative !== 0; )
            kt--, at.negative = 0, at._ishlnsubmul(ft, 1, jt), at.isZero() || (at.negative ^= 1);
          Ce && (Ce.words[jt] = kt);
        }
        return Ce && Ce._strip(), at._strip(), ce !== "div" && it !== 0 && at.iushrn(it), {
          div: Ce || null,
          mod: at
        };
      }, L.prototype.divmod = function(V, ce, it) {
        if (K(!V.isZero()), this.isZero())
          return {
            div: new L(0),
            mod: new L(0)
          };
        var at, ft, lt;
        return this.negative !== 0 && V.negative === 0 ? (lt = this.neg().divmod(V, ce), ce !== "mod" && (at = lt.div.neg()), ce !== "div" && (ft = lt.mod.neg(), it && ft.negative !== 0 && ft.iadd(V)), {
          div: at,
          mod: ft
        }) : this.negative === 0 && V.negative !== 0 ? (lt = this.divmod(V.neg(), ce), ce !== "mod" && (at = lt.div.neg()), {
          div: at,
          mod: lt.mod
        }) : this.negative & V.negative ? (lt = this.neg().divmod(V.neg(), ce), ce !== "div" && (ft = lt.mod.neg(), it && ft.negative !== 0 && ft.isub(V)), {
          div: lt.div,
          mod: ft
        }) : V.length > this.length || this.cmp(V) < 0 ? {
          div: new L(0),
          mod: this
        } : V.length === 1 ? ce === "div" ? {
          div: this.divn(V.words[0]),
          mod: null
        } : ce === "mod" ? {
          div: null,
          mod: new L(this.modrn(V.words[0]))
        } : {
          div: this.divn(V.words[0]),
          mod: new L(this.modrn(V.words[0]))
        } : this._wordDiv(V, ce);
      }, L.prototype.div = function(V) {
        return this.divmod(V, "div", !1).div;
      }, L.prototype.mod = function(V) {
        return this.divmod(V, "mod", !1).mod;
      }, L.prototype.umod = function(V) {
        return this.divmod(V, "mod", !0).mod;
      }, L.prototype.divRound = function(V) {
        var ce = this.divmod(V);
        if (ce.mod.isZero()) return ce.div;
        var it = ce.div.negative !== 0 ? ce.mod.isub(V) : ce.mod, at = V.ushrn(1), ft = V.andln(1), lt = it.cmp(at);
        return lt < 0 || ft === 1 && lt === 0 ? ce.div : ce.div.negative !== 0 ? ce.div.isubn(1) : ce.div.iaddn(1);
      }, L.prototype.modrn = function(V) {
        var ce = V < 0;
        ce && (V = -V), K(V <= 67108863);
        for (var it = (1 << 26) % V, at = 0, ft = this.length - 1; ft >= 0; ft--)
          at = (it * at + (this.words[ft] | 0)) % V;
        return ce ? -at : at;
      }, L.prototype.modn = function(V) {
        return this.modrn(V);
      }, L.prototype.idivn = function(V) {
        var ce = V < 0;
        ce && (V = -V), K(V <= 67108863);
        for (var it = 0, at = this.length - 1; at >= 0; at--) {
          var ft = (this.words[at] | 0) + it * 67108864;
          this.words[at] = ft / V | 0, it = ft % V;
        }
        return this._strip(), ce ? this.ineg() : this;
      }, L.prototype.divn = function(V) {
        return this.clone().idivn(V);
      }, L.prototype.egcd = function(V) {
        K(V.negative === 0), K(!V.isZero());
        var ce = this, it = V.clone();
        ce.negative !== 0 ? ce = ce.umod(V) : ce = ce.clone();
        for (var at = new L(1), ft = new L(0), lt = new L(0), ct = new L(1), ht = 0; ce.isEven() && it.isEven(); )
          ce.iushrn(1), it.iushrn(1), ++ht;
        for (var Ce = it.clone(), yt = ce.clone(); !ce.isZero(); ) {
          for (var qt = 0, jt = 1; !(ce.words[0] & jt) && qt < 26; ++qt, jt <<= 1) ;
          if (qt > 0)
            for (ce.iushrn(qt); qt-- > 0; )
              (at.isOdd() || ft.isOdd()) && (at.iadd(Ce), ft.isub(yt)), at.iushrn(1), ft.iushrn(1);
          for (var kt = 0, $t = 1; !(it.words[0] & $t) && kt < 26; ++kt, $t <<= 1) ;
          if (kt > 0)
            for (it.iushrn(kt); kt-- > 0; )
              (lt.isOdd() || ct.isOdd()) && (lt.iadd(Ce), ct.isub(yt)), lt.iushrn(1), ct.iushrn(1);
          ce.cmp(it) >= 0 ? (ce.isub(it), at.isub(lt), ft.isub(ct)) : (it.isub(ce), lt.isub(at), ct.isub(ft));
        }
        return {
          a: lt,
          b: ct,
          gcd: it.iushln(ht)
        };
      }, L.prototype._invmp = function(V) {
        K(V.negative === 0), K(!V.isZero());
        var ce = this, it = V.clone();
        ce.negative !== 0 ? ce = ce.umod(V) : ce = ce.clone();
        for (var at = new L(1), ft = new L(0), lt = it.clone(); ce.cmpn(1) > 0 && it.cmpn(1) > 0; ) {
          for (var ct = 0, ht = 1; !(ce.words[0] & ht) && ct < 26; ++ct, ht <<= 1) ;
          if (ct > 0)
            for (ce.iushrn(ct); ct-- > 0; )
              at.isOdd() && at.iadd(lt), at.iushrn(1);
          for (var Ce = 0, yt = 1; !(it.words[0] & yt) && Ce < 26; ++Ce, yt <<= 1) ;
          if (Ce > 0)
            for (it.iushrn(Ce); Ce-- > 0; )
              ft.isOdd() && ft.iadd(lt), ft.iushrn(1);
          ce.cmp(it) >= 0 ? (ce.isub(it), at.isub(ft)) : (it.isub(ce), ft.isub(at));
        }
        var qt;
        return ce.cmpn(1) === 0 ? qt = at : qt = ft, qt.cmpn(0) < 0 && qt.iadd(V), qt;
      }, L.prototype.gcd = function(V) {
        if (this.isZero()) return V.abs();
        if (V.isZero()) return this.abs();
        var ce = this.clone(), it = V.clone();
        ce.negative = 0, it.negative = 0;
        for (var at = 0; ce.isEven() && it.isEven(); at++)
          ce.iushrn(1), it.iushrn(1);
        do {
          for (; ce.isEven(); )
            ce.iushrn(1);
          for (; it.isEven(); )
            it.iushrn(1);
          var ft = ce.cmp(it);
          if (ft < 0) {
            var lt = ce;
            ce = it, it = lt;
          } else if (ft === 0 || it.cmpn(1) === 0)
            break;
          ce.isub(it);
        } while (!0);
        return it.iushln(at);
      }, L.prototype.invm = function(V) {
        return this.egcd(V).a.umod(V);
      }, L.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, L.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, L.prototype.andln = function(V) {
        return this.words[0] & V;
      }, L.prototype.bincn = function(V) {
        K(typeof V == "number");
        var ce = V % 26, it = (V - ce) / 26, at = 1 << ce;
        if (this.length <= it)
          return this._expand(it + 1), this.words[it] |= at, this;
        for (var ft = at, lt = it; ft !== 0 && lt < this.length; lt++) {
          var ct = this.words[lt] | 0;
          ct += ft, ft = ct >>> 26, ct &= 67108863, this.words[lt] = ct;
        }
        return ft !== 0 && (this.words[lt] = ft, this.length++), this;
      }, L.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, L.prototype.cmpn = function(V) {
        var ce = V < 0;
        if (this.negative !== 0 && !ce) return -1;
        if (this.negative === 0 && ce) return 1;
        this._strip();
        var it;
        if (this.length > 1)
          it = 1;
        else {
          ce && (V = -V), K(V <= 67108863, "Number is too big");
          var at = this.words[0] | 0;
          it = at === V ? 0 : at < V ? -1 : 1;
        }
        return this.negative !== 0 ? -it | 0 : it;
      }, L.prototype.cmp = function(V) {
        if (this.negative !== 0 && V.negative === 0) return -1;
        if (this.negative === 0 && V.negative !== 0) return 1;
        var ce = this.ucmp(V);
        return this.negative !== 0 ? -ce | 0 : ce;
      }, L.prototype.ucmp = function(V) {
        if (this.length > V.length) return 1;
        if (this.length < V.length) return -1;
        for (var ce = 0, it = this.length - 1; it >= 0; it--) {
          var at = this.words[it] | 0, ft = V.words[it] | 0;
          if (at !== ft) {
            at < ft ? ce = -1 : at > ft && (ce = 1);
            break;
          }
        }
        return ce;
      }, L.prototype.gtn = function(V) {
        return this.cmpn(V) === 1;
      }, L.prototype.gt = function(V) {
        return this.cmp(V) === 1;
      }, L.prototype.gten = function(V) {
        return this.cmpn(V) >= 0;
      }, L.prototype.gte = function(V) {
        return this.cmp(V) >= 0;
      }, L.prototype.ltn = function(V) {
        return this.cmpn(V) === -1;
      }, L.prototype.lt = function(V) {
        return this.cmp(V) === -1;
      }, L.prototype.lten = function(V) {
        return this.cmpn(V) <= 0;
      }, L.prototype.lte = function(V) {
        return this.cmp(V) <= 0;
      }, L.prototype.eqn = function(V) {
        return this.cmpn(V) === 0;
      }, L.prototype.eq = function(V) {
        return this.cmp(V) === 0;
      }, L.red = function(V) {
        return new wt(V);
      }, L.prototype.toRed = function(V) {
        return K(!this.red, "Already a number in reduction context"), K(this.negative === 0, "red works only with positives"), V.convertTo(this)._forceRed(V);
      }, L.prototype.fromRed = function() {
        return K(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, L.prototype._forceRed = function(V) {
        return this.red = V, this;
      }, L.prototype.forceRed = function(V) {
        return K(!this.red, "Already a number in reduction context"), this._forceRed(V);
      }, L.prototype.redAdd = function(V) {
        return K(this.red, "redAdd works only with red numbers"), this.red.add(this, V);
      }, L.prototype.redIAdd = function(V) {
        return K(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, V);
      }, L.prototype.redSub = function(V) {
        return K(this.red, "redSub works only with red numbers"), this.red.sub(this, V);
      }, L.prototype.redISub = function(V) {
        return K(this.red, "redISub works only with red numbers"), this.red.isub(this, V);
      }, L.prototype.redShl = function(V) {
        return K(this.red, "redShl works only with red numbers"), this.red.shl(this, V);
      }, L.prototype.redMul = function(V) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, V), this.red.mul(this, V);
      }, L.prototype.redIMul = function(V) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, V), this.red.imul(this, V);
      }, L.prototype.redSqr = function() {
        return K(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, L.prototype.redISqr = function() {
        return K(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, L.prototype.redSqrt = function() {
        return K(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, L.prototype.redInvm = function() {
        return K(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, L.prototype.redNeg = function() {
        return K(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, L.prototype.redPow = function(V) {
        return K(this.red && !V.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, V);
      };
      var Pt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function xt(Oe, V) {
        this.name = Oe, this.p = new L(V, 16), this.n = this.p.bitLength(), this.k = new L(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      xt.prototype._tmp = function() {
        var V = new L(null);
        return V.words = new Array(Math.ceil(this.n / 13)), V;
      }, xt.prototype.ireduce = function(V) {
        var ce = V, it;
        do
          this.split(ce, this.tmp), ce = this.imulK(ce), ce = ce.iadd(this.tmp), it = ce.bitLength();
        while (it > this.n);
        var at = it < this.n ? -1 : ce.ucmp(this.p);
        return at === 0 ? (ce.words[0] = 0, ce.length = 1) : at > 0 ? ce.isub(this.p) : ce.strip !== void 0 ? ce.strip() : ce._strip(), ce;
      }, xt.prototype.split = function(V, ce) {
        V.iushrn(this.n, 0, ce);
      }, xt.prototype.imulK = function(V) {
        return V.imul(this.k);
      };
      function Nt() {
        xt.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      J(Nt, xt), Nt.prototype.split = function(V, ce) {
        for (var it = 4194303, at = Math.min(V.length, 9), ft = 0; ft < at; ft++)
          ce.words[ft] = V.words[ft];
        if (ce.length = at, V.length <= 9) {
          V.words[0] = 0, V.length = 1;
          return;
        }
        var lt = V.words[9];
        for (ce.words[ce.length++] = lt & it, ft = 10; ft < V.length; ft++) {
          var ct = V.words[ft] | 0;
          V.words[ft - 10] = (ct & it) << 4 | lt >>> 22, lt = ct;
        }
        lt >>>= 22, V.words[ft - 10] = lt, lt === 0 && V.length > 10 ? V.length -= 10 : V.length -= 9;
      }, Nt.prototype.imulK = function(V) {
        V.words[V.length] = 0, V.words[V.length + 1] = 0, V.length += 2;
        for (var ce = 0, it = 0; it < V.length; it++) {
          var at = V.words[it] | 0;
          ce += at * 977, V.words[it] = ce & 67108863, ce = at * 64 + (ce / 67108864 | 0);
        }
        return V.words[V.length - 1] === 0 && (V.length--, V.words[V.length - 1] === 0 && V.length--), V;
      };
      function Et() {
        xt.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      J(Et, xt);
      function bt() {
        xt.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      J(bt, xt);
      function Bt() {
        xt.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      J(Bt, xt), Bt.prototype.imulK = function(V) {
        for (var ce = 0, it = 0; it < V.length; it++) {
          var at = (V.words[it] | 0) * 19 + ce, ft = at & 67108863;
          at >>>= 26, V.words[it] = ft, ce = at;
        }
        return ce !== 0 && (V.words[V.length++] = ce), V;
      }, L._prime = function(V) {
        if (Pt[V]) return Pt[V];
        var ce;
        if (V === "k256")
          ce = new Nt();
        else if (V === "p224")
          ce = new Et();
        else if (V === "p192")
          ce = new bt();
        else if (V === "p25519")
          ce = new Bt();
        else
          throw new Error("Unknown prime " + V);
        return Pt[V] = ce, ce;
      };
      function wt(Oe) {
        if (typeof Oe == "string") {
          var V = L._prime(Oe);
          this.m = V.p, this.prime = V;
        } else
          K(Oe.gtn(1), "modulus must be greater than 1"), this.m = Oe, this.prime = null;
      }
      wt.prototype._verify1 = function(V) {
        K(V.negative === 0, "red works only with positives"), K(V.red, "red works only with red numbers");
      }, wt.prototype._verify2 = function(V, ce) {
        K((V.negative | ce.negative) === 0, "red works only with positives"), K(
          V.red && V.red === ce.red,
          "red works only with red numbers"
        );
      }, wt.prototype.imod = function(V) {
        return this.prime ? this.prime.ireduce(V)._forceRed(this) : (ne(V, V.umod(this.m)._forceRed(this)), V);
      }, wt.prototype.neg = function(V) {
        return V.isZero() ? V.clone() : this.m.sub(V)._forceRed(this);
      }, wt.prototype.add = function(V, ce) {
        this._verify2(V, ce);
        var it = V.add(ce);
        return it.cmp(this.m) >= 0 && it.isub(this.m), it._forceRed(this);
      }, wt.prototype.iadd = function(V, ce) {
        this._verify2(V, ce);
        var it = V.iadd(ce);
        return it.cmp(this.m) >= 0 && it.isub(this.m), it;
      }, wt.prototype.sub = function(V, ce) {
        this._verify2(V, ce);
        var it = V.sub(ce);
        return it.cmpn(0) < 0 && it.iadd(this.m), it._forceRed(this);
      }, wt.prototype.isub = function(V, ce) {
        this._verify2(V, ce);
        var it = V.isub(ce);
        return it.cmpn(0) < 0 && it.iadd(this.m), it;
      }, wt.prototype.shl = function(V, ce) {
        return this._verify1(V), this.imod(V.ushln(ce));
      }, wt.prototype.imul = function(V, ce) {
        return this._verify2(V, ce), this.imod(V.imul(ce));
      }, wt.prototype.mul = function(V, ce) {
        return this._verify2(V, ce), this.imod(V.mul(ce));
      }, wt.prototype.isqr = function(V) {
        return this.imul(V, V.clone());
      }, wt.prototype.sqr = function(V) {
        return this.mul(V, V);
      }, wt.prototype.sqrt = function(V) {
        if (V.isZero()) return V.clone();
        var ce = this.m.andln(3);
        if (K(ce % 2 === 1), ce === 3) {
          var it = this.m.add(new L(1)).iushrn(2);
          return this.pow(V, it);
        }
        for (var at = this.m.subn(1), ft = 0; !at.isZero() && at.andln(1) === 0; )
          ft++, at.iushrn(1);
        K(!at.isZero());
        var lt = new L(1).toRed(this), ct = lt.redNeg(), ht = this.m.subn(1).iushrn(1), Ce = this.m.bitLength();
        for (Ce = new L(2 * Ce * Ce).toRed(this); this.pow(Ce, ht).cmp(ct) !== 0; )
          Ce.redIAdd(ct);
        for (var yt = this.pow(Ce, at), qt = this.pow(V, at.addn(1).iushrn(1)), jt = this.pow(V, at), kt = ft; jt.cmp(lt) !== 0; ) {
          for (var $t = jt, Mt = 0; $t.cmp(lt) !== 0; Mt++)
            $t = $t.redSqr();
          K(Mt < kt);
          var Lt = this.pow(yt, new L(1).iushln(kt - Mt - 1));
          qt = qt.redMul(Lt), yt = Lt.redSqr(), jt = jt.redMul(yt), kt = Mt;
        }
        return qt;
      }, wt.prototype.invm = function(V) {
        var ce = V._invmp(this.m);
        return ce.negative !== 0 ? (ce.negative = 0, this.imod(ce).redNeg()) : this.imod(ce);
      }, wt.prototype.pow = function(V, ce) {
        if (ce.isZero()) return new L(1).toRed(this);
        if (ce.cmpn(1) === 0) return V.clone();
        var it = 4, at = new Array(1 << it);
        at[0] = new L(1).toRed(this), at[1] = V;
        for (var ft = 2; ft < at.length; ft++)
          at[ft] = this.mul(at[ft - 1], V);
        var lt = at[0], ct = 0, ht = 0, Ce = ce.bitLength() % 26;
        for (Ce === 0 && (Ce = 26), ft = ce.length - 1; ft >= 0; ft--) {
          for (var yt = ce.words[ft], qt = Ce - 1; qt >= 0; qt--) {
            var jt = yt >> qt & 1;
            if (lt !== at[0] && (lt = this.sqr(lt)), jt === 0 && ct === 0) {
              ht = 0;
              continue;
            }
            ct <<= 1, ct |= jt, ht++, !(ht !== it && (ft !== 0 || qt !== 0)) && (lt = this.mul(lt, at[ct]), ht = 0, ct = 0);
          }
          Ce = 26;
        }
        return lt;
      }, wt.prototype.convertTo = function(V) {
        var ce = V.umod(this.m);
        return ce === V ? ce.clone() : ce;
      }, wt.prototype.convertFrom = function(V) {
        var ce = V.clone();
        return ce.red = null, ce;
      }, L.mont = function(V) {
        return new st(V);
      };
      function st(Oe) {
        wt.call(this, Oe), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new L(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      J(st, wt), st.prototype.convertTo = function(V) {
        return this.imod(V.ushln(this.shift));
      }, st.prototype.convertFrom = function(V) {
        var ce = this.imod(V.mul(this.rinv));
        return ce.red = null, ce;
      }, st.prototype.imul = function(V, ce) {
        if (V.isZero() || ce.isZero())
          return V.words[0] = 0, V.length = 1, V;
        var it = V.imul(ce), at = it.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ft = it.isub(at).iushrn(this.shift), lt = ft;
        return ft.cmp(this.m) >= 0 ? lt = ft.isub(this.m) : ft.cmpn(0) < 0 && (lt = ft.iadd(this.m)), lt._forceRed(this);
      }, st.prototype.mul = function(V, ce) {
        if (V.isZero() || ce.isZero()) return new L(0)._forceRed(this);
        var it = V.mul(ce), at = it.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ft = it.isub(at).iushrn(this.shift), lt = ft;
        return ft.cmp(this.m) >= 0 ? lt = ft.isub(this.m) : ft.cmpn(0) < 0 && (lt = ft.iadd(this.m)), lt._forceRed(this);
      }, st.prototype.invm = function(V) {
        var ce = this.imod(V._invmp(this.m).mul(this.r2));
        return ce._forceRed(this);
      };
    })(A, commonjsGlobal);
  }(bn$1)), bn$1.exports;
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var A = requireBn$1(), B = requireBrowser$b(), W = safeBufferExports.Buffer;
  function K(re) {
    var ie = re.modulus.byteLength(), oe;
    do
      oe = new A(B(ie));
    while (oe.cmp(re.modulus) >= 0 || !oe.umod(re.prime1) || !oe.umod(re.prime2));
    return oe;
  }
  function J(re) {
    var ie = K(re), oe = ie.toRed(A.mont(re.modulus)).redPow(new A(re.publicExponent)).fromRed();
    return { blinder: oe, unblinder: ie.invm(re.modulus) };
  }
  function L(re, ie) {
    var oe = J(ie), ke = ie.modulus.byteLength(), ne = new A(re).mul(oe.blinder).umod(ie.modulus), pe = ne.toRed(A.mont(ie.prime1)), rt = ne.toRed(A.mont(ie.prime2)), nt = ie.coefficient, ot = ie.prime1, ut = ie.prime2, dt = pe.redPow(ie.exponent1).fromRed(), vt = rt.redPow(ie.exponent2).fromRed(), pt = dt.isub(vt).imul(nt).umod(ot).imul(ut);
    return vt.iadd(pt).imul(oe.unblinder).umod(ie.modulus).toArrayLike(W, "be", ke);
  }
  return L.getr = K, browserifyRsa = L, browserifyRsa;
}
var elliptic = {};
const version = "6.6.1", require$$0 = {
  version
};
var utils$3 = {}, utils$2 = {}, hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(A) {
    var B = A;
    function W(L, re) {
      if (Array.isArray(L))
        return L.slice();
      if (!L)
        return [];
      var ie = [];
      if (typeof L != "string") {
        for (var oe = 0; oe < L.length; oe++)
          ie[oe] = L[oe] | 0;
        return ie;
      }
      if (re === "hex") {
        L = L.replace(/[^a-z0-9]+/ig, ""), L.length % 2 !== 0 && (L = "0" + L);
        for (var oe = 0; oe < L.length; oe += 2)
          ie.push(parseInt(L[oe] + L[oe + 1], 16));
      } else
        for (var oe = 0; oe < L.length; oe++) {
          var ke = L.charCodeAt(oe), ne = ke >> 8, pe = ke & 255;
          ne ? ie.push(ne, pe) : ie.push(pe);
        }
      return ie;
    }
    B.toArray = W;
    function K(L) {
      return L.length === 1 ? "0" + L : L;
    }
    B.zero2 = K;
    function J(L) {
      for (var re = "", ie = 0; ie < L.length; ie++)
        re += K(L[ie].toString(16));
      return re;
    }
    B.toHex = J, B.encode = function(re, ie) {
      return ie === "hex" ? J(re) : re;
    };
  }(utils$2)), utils$2;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(A) {
    var B = A, W = requireBn$2(), K = requireMinimalisticAssert(), J = requireUtils$2();
    B.assert = K, B.toArray = J.toArray, B.zero2 = J.zero2, B.toHex = J.toHex, B.encode = J.encode;
    function L(ne, pe, rt) {
      var nt = new Array(Math.max(ne.bitLength(), rt) + 1), ot;
      for (ot = 0; ot < nt.length; ot += 1)
        nt[ot] = 0;
      var ut = 1 << pe + 1, dt = ne.clone();
      for (ot = 0; ot < nt.length; ot++) {
        var vt, pt = dt.andln(ut - 1);
        dt.isOdd() ? (pt > (ut >> 1) - 1 ? vt = (ut >> 1) - pt : vt = pt, dt.isubn(vt)) : vt = 0, nt[ot] = vt, dt.iushrn(1);
      }
      return nt;
    }
    B.getNAF = L;
    function re(ne, pe) {
      var rt = [
        [],
        []
      ];
      ne = ne.clone(), pe = pe.clone();
      for (var nt = 0, ot = 0, ut; ne.cmpn(-nt) > 0 || pe.cmpn(-ot) > 0; ) {
        var dt = ne.andln(3) + nt & 3, vt = pe.andln(3) + ot & 3;
        dt === 3 && (dt = -1), vt === 3 && (vt = -1);
        var pt;
        dt & 1 ? (ut = ne.andln(7) + nt & 7, (ut === 3 || ut === 5) && vt === 2 ? pt = -dt : pt = dt) : pt = 0, rt[0].push(pt);
        var mt;
        vt & 1 ? (ut = pe.andln(7) + ot & 7, (ut === 3 || ut === 5) && dt === 2 ? mt = -vt : mt = vt) : mt = 0, rt[1].push(mt), 2 * nt === pt + 1 && (nt = 1 - nt), 2 * ot === mt + 1 && (ot = 1 - ot), ne.iushrn(1), pe.iushrn(1);
      }
      return rt;
    }
    B.getJSF = re;
    function ie(ne, pe, rt) {
      var nt = "_" + pe;
      ne.prototype[pe] = function() {
        return this[nt] !== void 0 ? this[nt] : this[nt] = rt.call(this);
      };
    }
    B.cachedProperty = ie;
    function oe(ne) {
      return typeof ne == "string" ? B.toArray(ne, "hex") : ne;
    }
    B.parseBytes = oe;
    function ke(ne) {
      return new W(ne, "hex", "le");
    }
    B.intFromLE = ke;
  }(utils$3)), utils$3;
}
var curve = {}, base$3, hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1) return base$3;
  hasRequiredBase$1 = 1;
  var A = requireBn$2(), B = requireUtils$1(), W = B.getNAF, K = B.getJSF, J = B.assert;
  function L(ie, oe) {
    this.type = ie, this.p = new A(oe.p, 16), this.red = oe.prime ? A.red(oe.prime) : A.mont(this.p), this.zero = new A(0).toRed(this.red), this.one = new A(1).toRed(this.red), this.two = new A(2).toRed(this.red), this.n = oe.n && new A(oe.n, 16), this.g = oe.g && this.pointFromJSON(oe.g, oe.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var ke = this.n && this.p.div(this.n);
    !ke || ke.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$3 = L, L.prototype.point = function() {
    throw new Error("Not implemented");
  }, L.prototype.validate = function() {
    throw new Error("Not implemented");
  }, L.prototype._fixedNafMul = function(oe, ke) {
    J(oe.precomputed);
    var ne = oe._getDoubles(), pe = W(ke, 1, this._bitLength), rt = (1 << ne.step + 1) - (ne.step % 2 === 0 ? 2 : 1);
    rt /= 3;
    var nt = [], ot, ut;
    for (ot = 0; ot < pe.length; ot += ne.step) {
      ut = 0;
      for (var dt = ot + ne.step - 1; dt >= ot; dt--)
        ut = (ut << 1) + pe[dt];
      nt.push(ut);
    }
    for (var vt = this.jpoint(null, null, null), pt = this.jpoint(null, null, null), mt = rt; mt > 0; mt--) {
      for (ot = 0; ot < nt.length; ot++)
        ut = nt[ot], ut === mt ? pt = pt.mixedAdd(ne.points[ot]) : ut === -mt && (pt = pt.mixedAdd(ne.points[ot].neg()));
      vt = vt.add(pt);
    }
    return vt.toP();
  }, L.prototype._wnafMul = function(oe, ke) {
    var ne = 4, pe = oe._getNAFPoints(ne);
    ne = pe.wnd;
    for (var rt = pe.points, nt = W(ke, ne, this._bitLength), ot = this.jpoint(null, null, null), ut = nt.length - 1; ut >= 0; ut--) {
      for (var dt = 0; ut >= 0 && nt[ut] === 0; ut--)
        dt++;
      if (ut >= 0 && dt++, ot = ot.dblp(dt), ut < 0)
        break;
      var vt = nt[ut];
      J(vt !== 0), oe.type === "affine" ? vt > 0 ? ot = ot.mixedAdd(rt[vt - 1 >> 1]) : ot = ot.mixedAdd(rt[-vt - 1 >> 1].neg()) : vt > 0 ? ot = ot.add(rt[vt - 1 >> 1]) : ot = ot.add(rt[-vt - 1 >> 1].neg());
    }
    return oe.type === "affine" ? ot.toP() : ot;
  }, L.prototype._wnafMulAdd = function(oe, ke, ne, pe, rt) {
    var nt = this._wnafT1, ot = this._wnafT2, ut = this._wnafT3, dt = 0, vt, pt, mt;
    for (vt = 0; vt < pe; vt++) {
      mt = ke[vt];
      var gt = mt._getNAFPoints(oe);
      nt[vt] = gt.wnd, ot[vt] = gt.points;
    }
    for (vt = pe - 1; vt >= 1; vt -= 2) {
      var Pt = vt - 1, xt = vt;
      if (nt[Pt] !== 1 || nt[xt] !== 1) {
        ut[Pt] = W(ne[Pt], nt[Pt], this._bitLength), ut[xt] = W(ne[xt], nt[xt], this._bitLength), dt = Math.max(ut[Pt].length, dt), dt = Math.max(ut[xt].length, dt);
        continue;
      }
      var Nt = [
        ke[Pt],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        ke[xt]
        /* 7 */
      ];
      ke[Pt].y.cmp(ke[xt].y) === 0 ? (Nt[1] = ke[Pt].add(ke[xt]), Nt[2] = ke[Pt].toJ().mixedAdd(ke[xt].neg())) : ke[Pt].y.cmp(ke[xt].y.redNeg()) === 0 ? (Nt[1] = ke[Pt].toJ().mixedAdd(ke[xt]), Nt[2] = ke[Pt].add(ke[xt].neg())) : (Nt[1] = ke[Pt].toJ().mixedAdd(ke[xt]), Nt[2] = ke[Pt].toJ().mixedAdd(ke[xt].neg()));
      var Et = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], bt = K(ne[Pt], ne[xt]);
      for (dt = Math.max(bt[0].length, dt), ut[Pt] = new Array(dt), ut[xt] = new Array(dt), pt = 0; pt < dt; pt++) {
        var Bt = bt[0][pt] | 0, wt = bt[1][pt] | 0;
        ut[Pt][pt] = Et[(Bt + 1) * 3 + (wt + 1)], ut[xt][pt] = 0, ot[Pt] = Nt;
      }
    }
    var st = this.jpoint(null, null, null), Oe = this._wnafT4;
    for (vt = dt; vt >= 0; vt--) {
      for (var V = 0; vt >= 0; ) {
        var ce = !0;
        for (pt = 0; pt < pe; pt++)
          Oe[pt] = ut[pt][vt] | 0, Oe[pt] !== 0 && (ce = !1);
        if (!ce)
          break;
        V++, vt--;
      }
      if (vt >= 0 && V++, st = st.dblp(V), vt < 0)
        break;
      for (pt = 0; pt < pe; pt++) {
        var it = Oe[pt];
        it !== 0 && (it > 0 ? mt = ot[pt][it - 1 >> 1] : it < 0 && (mt = ot[pt][-it - 1 >> 1].neg()), mt.type === "affine" ? st = st.mixedAdd(mt) : st = st.add(mt));
      }
    }
    for (vt = 0; vt < pe; vt++)
      ot[vt] = null;
    return rt ? st : st.toP();
  };
  function re(ie, oe) {
    this.curve = ie, this.type = oe, this.precomputed = null;
  }
  return L.BasePoint = re, re.prototype.eq = function() {
    throw new Error("Not implemented");
  }, re.prototype.validate = function() {
    return this.curve.validate(this);
  }, L.prototype.decodePoint = function(oe, ke) {
    oe = B.toArray(oe, ke);
    var ne = this.p.byteLength();
    if ((oe[0] === 4 || oe[0] === 6 || oe[0] === 7) && oe.length - 1 === 2 * ne) {
      oe[0] === 6 ? J(oe[oe.length - 1] % 2 === 0) : oe[0] === 7 && J(oe[oe.length - 1] % 2 === 1);
      var pe = this.point(
        oe.slice(1, 1 + ne),
        oe.slice(1 + ne, 1 + 2 * ne)
      );
      return pe;
    } else if ((oe[0] === 2 || oe[0] === 3) && oe.length - 1 === ne)
      return this.pointFromX(oe.slice(1, 1 + ne), oe[0] === 3);
    throw new Error("Unknown point format");
  }, re.prototype.encodeCompressed = function(oe) {
    return this.encode(oe, !0);
  }, re.prototype._encode = function(oe) {
    var ke = this.curve.p.byteLength(), ne = this.getX().toArray("be", ke);
    return oe ? [this.getY().isEven() ? 2 : 3].concat(ne) : [4].concat(ne, this.getY().toArray("be", ke));
  }, re.prototype.encode = function(oe, ke) {
    return B.encode(this._encode(ke), oe);
  }, re.prototype.precompute = function(oe) {
    if (this.precomputed)
      return this;
    var ke = {
      doubles: null,
      naf: null,
      beta: null
    };
    return ke.naf = this._getNAFPoints(8), ke.doubles = this._getDoubles(4, oe), ke.beta = this._getBeta(), this.precomputed = ke, this;
  }, re.prototype._hasDoubles = function(oe) {
    if (!this.precomputed)
      return !1;
    var ke = this.precomputed.doubles;
    return ke ? ke.points.length >= Math.ceil((oe.bitLength() + 1) / ke.step) : !1;
  }, re.prototype._getDoubles = function(oe, ke) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var ne = [this], pe = this, rt = 0; rt < ke; rt += oe) {
      for (var nt = 0; nt < oe; nt++)
        pe = pe.dbl();
      ne.push(pe);
    }
    return {
      step: oe,
      points: ne
    };
  }, re.prototype._getNAFPoints = function(oe) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var ke = [this], ne = (1 << oe) - 1, pe = ne === 1 ? null : this.dbl(), rt = 1; rt < ne; rt++)
      ke[rt] = ke[rt - 1].add(pe);
    return {
      wnd: oe,
      points: ke
    };
  }, re.prototype._getBeta = function() {
    return null;
  }, re.prototype.dblp = function(oe) {
    for (var ke = this, ne = 0; ne < oe; ne++)
      ke = ke.dbl();
    return ke;
  }, base$3;
}
var short, hasRequiredShort;
function requireShort() {
  if (hasRequiredShort) return short;
  hasRequiredShort = 1;
  var A = requireUtils$1(), B = requireBn$2(), W = requireInherits_browser(), K = requireBase$1(), J = A.assert;
  function L(oe) {
    K.call(this, "short", oe), this.a = new B(oe.a, 16).toRed(this.red), this.b = new B(oe.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(oe), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  W(L, K), short = L, L.prototype._getEndomorphism = function(ke) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var ne, pe;
      if (ke.beta)
        ne = new B(ke.beta, 16).toRed(this.red);
      else {
        var rt = this._getEndoRoots(this.p);
        ne = rt[0].cmp(rt[1]) < 0 ? rt[0] : rt[1], ne = ne.toRed(this.red);
      }
      if (ke.lambda)
        pe = new B(ke.lambda, 16);
      else {
        var nt = this._getEndoRoots(this.n);
        this.g.mul(nt[0]).x.cmp(this.g.x.redMul(ne)) === 0 ? pe = nt[0] : (pe = nt[1], J(this.g.mul(pe).x.cmp(this.g.x.redMul(ne)) === 0));
      }
      var ot;
      return ke.basis ? ot = ke.basis.map(function(ut) {
        return {
          a: new B(ut.a, 16),
          b: new B(ut.b, 16)
        };
      }) : ot = this._getEndoBasis(pe), {
        beta: ne,
        lambda: pe,
        basis: ot
      };
    }
  }, L.prototype._getEndoRoots = function(ke) {
    var ne = ke === this.p ? this.red : B.mont(ke), pe = new B(2).toRed(ne).redInvm(), rt = pe.redNeg(), nt = new B(3).toRed(ne).redNeg().redSqrt().redMul(pe), ot = rt.redAdd(nt).fromRed(), ut = rt.redSub(nt).fromRed();
    return [ot, ut];
  }, L.prototype._getEndoBasis = function(ke) {
    for (var ne = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), pe = ke, rt = this.n.clone(), nt = new B(1), ot = new B(0), ut = new B(0), dt = new B(1), vt, pt, mt, gt, Pt, xt, Nt, Et = 0, bt, Bt; pe.cmpn(0) !== 0; ) {
      var wt = rt.div(pe);
      bt = rt.sub(wt.mul(pe)), Bt = ut.sub(wt.mul(nt));
      var st = dt.sub(wt.mul(ot));
      if (!mt && bt.cmp(ne) < 0)
        vt = Nt.neg(), pt = nt, mt = bt.neg(), gt = Bt;
      else if (mt && ++Et === 2)
        break;
      Nt = bt, rt = pe, pe = bt, ut = nt, nt = Bt, dt = ot, ot = st;
    }
    Pt = bt.neg(), xt = Bt;
    var Oe = mt.sqr().add(gt.sqr()), V = Pt.sqr().add(xt.sqr());
    return V.cmp(Oe) >= 0 && (Pt = vt, xt = pt), mt.negative && (mt = mt.neg(), gt = gt.neg()), Pt.negative && (Pt = Pt.neg(), xt = xt.neg()), [
      { a: mt, b: gt },
      { a: Pt, b: xt }
    ];
  }, L.prototype._endoSplit = function(ke) {
    var ne = this.endo.basis, pe = ne[0], rt = ne[1], nt = rt.b.mul(ke).divRound(this.n), ot = pe.b.neg().mul(ke).divRound(this.n), ut = nt.mul(pe.a), dt = ot.mul(rt.a), vt = nt.mul(pe.b), pt = ot.mul(rt.b), mt = ke.sub(ut).sub(dt), gt = vt.add(pt).neg();
    return { k1: mt, k2: gt };
  }, L.prototype.pointFromX = function(ke, ne) {
    ke = new B(ke, 16), ke.red || (ke = ke.toRed(this.red));
    var pe = ke.redSqr().redMul(ke).redIAdd(ke.redMul(this.a)).redIAdd(this.b), rt = pe.redSqrt();
    if (rt.redSqr().redSub(pe).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var nt = rt.fromRed().isOdd();
    return (ne && !nt || !ne && nt) && (rt = rt.redNeg()), this.point(ke, rt);
  }, L.prototype.validate = function(ke) {
    if (ke.inf)
      return !0;
    var ne = ke.x, pe = ke.y, rt = this.a.redMul(ne), nt = ne.redSqr().redMul(ne).redIAdd(rt).redIAdd(this.b);
    return pe.redSqr().redISub(nt).cmpn(0) === 0;
  }, L.prototype._endoWnafMulAdd = function(ke, ne, pe) {
    for (var rt = this._endoWnafT1, nt = this._endoWnafT2, ot = 0; ot < ke.length; ot++) {
      var ut = this._endoSplit(ne[ot]), dt = ke[ot], vt = dt._getBeta();
      ut.k1.negative && (ut.k1.ineg(), dt = dt.neg(!0)), ut.k2.negative && (ut.k2.ineg(), vt = vt.neg(!0)), rt[ot * 2] = dt, rt[ot * 2 + 1] = vt, nt[ot * 2] = ut.k1, nt[ot * 2 + 1] = ut.k2;
    }
    for (var pt = this._wnafMulAdd(1, rt, nt, ot * 2, pe), mt = 0; mt < ot * 2; mt++)
      rt[mt] = null, nt[mt] = null;
    return pt;
  };
  function re(oe, ke, ne, pe) {
    K.BasePoint.call(this, oe, "affine"), ke === null && ne === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new B(ke, 16), this.y = new B(ne, 16), pe && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  W(re, K.BasePoint), L.prototype.point = function(ke, ne, pe) {
    return new re(this, ke, ne, pe);
  }, L.prototype.pointFromJSON = function(ke, ne) {
    return re.fromJSON(this, ke, ne);
  }, re.prototype._getBeta = function() {
    if (this.curve.endo) {
      var ke = this.precomputed;
      if (ke && ke.beta)
        return ke.beta;
      var ne = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (ke) {
        var pe = this.curve, rt = function(nt) {
          return pe.point(nt.x.redMul(pe.endo.beta), nt.y);
        };
        ke.beta = ne, ne.precomputed = {
          beta: null,
          naf: ke.naf && {
            wnd: ke.naf.wnd,
            points: ke.naf.points.map(rt)
          },
          doubles: ke.doubles && {
            step: ke.doubles.step,
            points: ke.doubles.points.map(rt)
          }
        };
      }
      return ne;
    }
  }, re.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, re.fromJSON = function(ke, ne, pe) {
    typeof ne == "string" && (ne = JSON.parse(ne));
    var rt = ke.point(ne[0], ne[1], pe);
    if (!ne[2])
      return rt;
    function nt(ut) {
      return ke.point(ut[0], ut[1], pe);
    }
    var ot = ne[2];
    return rt.precomputed = {
      beta: null,
      doubles: ot.doubles && {
        step: ot.doubles.step,
        points: [rt].concat(ot.doubles.points.map(nt))
      },
      naf: ot.naf && {
        wnd: ot.naf.wnd,
        points: [rt].concat(ot.naf.points.map(nt))
      }
    }, rt;
  }, re.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, re.prototype.isInfinity = function() {
    return this.inf;
  }, re.prototype.add = function(ke) {
    if (this.inf)
      return ke;
    if (ke.inf)
      return this;
    if (this.eq(ke))
      return this.dbl();
    if (this.neg().eq(ke))
      return this.curve.point(null, null);
    if (this.x.cmp(ke.x) === 0)
      return this.curve.point(null, null);
    var ne = this.y.redSub(ke.y);
    ne.cmpn(0) !== 0 && (ne = ne.redMul(this.x.redSub(ke.x).redInvm()));
    var pe = ne.redSqr().redISub(this.x).redISub(ke.x), rt = ne.redMul(this.x.redSub(pe)).redISub(this.y);
    return this.curve.point(pe, rt);
  }, re.prototype.dbl = function() {
    if (this.inf)
      return this;
    var ke = this.y.redAdd(this.y);
    if (ke.cmpn(0) === 0)
      return this.curve.point(null, null);
    var ne = this.curve.a, pe = this.x.redSqr(), rt = ke.redInvm(), nt = pe.redAdd(pe).redIAdd(pe).redIAdd(ne).redMul(rt), ot = nt.redSqr().redISub(this.x.redAdd(this.x)), ut = nt.redMul(this.x.redSub(ot)).redISub(this.y);
    return this.curve.point(ot, ut);
  }, re.prototype.getX = function() {
    return this.x.fromRed();
  }, re.prototype.getY = function() {
    return this.y.fromRed();
  }, re.prototype.mul = function(ke) {
    return ke = new B(ke, 16), this.isInfinity() ? this : this._hasDoubles(ke) ? this.curve._fixedNafMul(this, ke) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [ke]) : this.curve._wnafMul(this, ke);
  }, re.prototype.mulAdd = function(ke, ne, pe) {
    var rt = [this, ne], nt = [ke, pe];
    return this.curve.endo ? this.curve._endoWnafMulAdd(rt, nt) : this.curve._wnafMulAdd(1, rt, nt, 2);
  }, re.prototype.jmulAdd = function(ke, ne, pe) {
    var rt = [this, ne], nt = [ke, pe];
    return this.curve.endo ? this.curve._endoWnafMulAdd(rt, nt, !0) : this.curve._wnafMulAdd(1, rt, nt, 2, !0);
  }, re.prototype.eq = function(ke) {
    return this === ke || this.inf === ke.inf && (this.inf || this.x.cmp(ke.x) === 0 && this.y.cmp(ke.y) === 0);
  }, re.prototype.neg = function(ke) {
    if (this.inf)
      return this;
    var ne = this.curve.point(this.x, this.y.redNeg());
    if (ke && this.precomputed) {
      var pe = this.precomputed, rt = function(nt) {
        return nt.neg();
      };
      ne.precomputed = {
        naf: pe.naf && {
          wnd: pe.naf.wnd,
          points: pe.naf.points.map(rt)
        },
        doubles: pe.doubles && {
          step: pe.doubles.step,
          points: pe.doubles.points.map(rt)
        }
      };
    }
    return ne;
  }, re.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var ke = this.curve.jpoint(this.x, this.y, this.curve.one);
    return ke;
  };
  function ie(oe, ke, ne, pe) {
    K.BasePoint.call(this, oe, "jacobian"), ke === null && ne === null && pe === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new B(0)) : (this.x = new B(ke, 16), this.y = new B(ne, 16), this.z = new B(pe, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return W(ie, K.BasePoint), L.prototype.jpoint = function(ke, ne, pe) {
    return new ie(this, ke, ne, pe);
  }, ie.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var ke = this.z.redInvm(), ne = ke.redSqr(), pe = this.x.redMul(ne), rt = this.y.redMul(ne).redMul(ke);
    return this.curve.point(pe, rt);
  }, ie.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, ie.prototype.add = function(ke) {
    if (this.isInfinity())
      return ke;
    if (ke.isInfinity())
      return this;
    var ne = ke.z.redSqr(), pe = this.z.redSqr(), rt = this.x.redMul(ne), nt = ke.x.redMul(pe), ot = this.y.redMul(ne.redMul(ke.z)), ut = ke.y.redMul(pe.redMul(this.z)), dt = rt.redSub(nt), vt = ot.redSub(ut);
    if (dt.cmpn(0) === 0)
      return vt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var pt = dt.redSqr(), mt = pt.redMul(dt), gt = rt.redMul(pt), Pt = vt.redSqr().redIAdd(mt).redISub(gt).redISub(gt), xt = vt.redMul(gt.redISub(Pt)).redISub(ot.redMul(mt)), Nt = this.z.redMul(ke.z).redMul(dt);
    return this.curve.jpoint(Pt, xt, Nt);
  }, ie.prototype.mixedAdd = function(ke) {
    if (this.isInfinity())
      return ke.toJ();
    if (ke.isInfinity())
      return this;
    var ne = this.z.redSqr(), pe = this.x, rt = ke.x.redMul(ne), nt = this.y, ot = ke.y.redMul(ne).redMul(this.z), ut = pe.redSub(rt), dt = nt.redSub(ot);
    if (ut.cmpn(0) === 0)
      return dt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var vt = ut.redSqr(), pt = vt.redMul(ut), mt = pe.redMul(vt), gt = dt.redSqr().redIAdd(pt).redISub(mt).redISub(mt), Pt = dt.redMul(mt.redISub(gt)).redISub(nt.redMul(pt)), xt = this.z.redMul(ut);
    return this.curve.jpoint(gt, Pt, xt);
  }, ie.prototype.dblp = function(ke) {
    if (ke === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!ke)
      return this.dbl();
    var ne;
    if (this.curve.zeroA || this.curve.threeA) {
      var pe = this;
      for (ne = 0; ne < ke; ne++)
        pe = pe.dbl();
      return pe;
    }
    var rt = this.curve.a, nt = this.curve.tinv, ot = this.x, ut = this.y, dt = this.z, vt = dt.redSqr().redSqr(), pt = ut.redAdd(ut);
    for (ne = 0; ne < ke; ne++) {
      var mt = ot.redSqr(), gt = pt.redSqr(), Pt = gt.redSqr(), xt = mt.redAdd(mt).redIAdd(mt).redIAdd(rt.redMul(vt)), Nt = ot.redMul(gt), Et = xt.redSqr().redISub(Nt.redAdd(Nt)), bt = Nt.redISub(Et), Bt = xt.redMul(bt);
      Bt = Bt.redIAdd(Bt).redISub(Pt);
      var wt = pt.redMul(dt);
      ne + 1 < ke && (vt = vt.redMul(Pt)), ot = Et, dt = wt, pt = Bt;
    }
    return this.curve.jpoint(ot, pt.redMul(nt), dt);
  }, ie.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, ie.prototype._zeroDbl = function() {
    var ke, ne, pe;
    if (this.zOne) {
      var rt = this.x.redSqr(), nt = this.y.redSqr(), ot = nt.redSqr(), ut = this.x.redAdd(nt).redSqr().redISub(rt).redISub(ot);
      ut = ut.redIAdd(ut);
      var dt = rt.redAdd(rt).redIAdd(rt), vt = dt.redSqr().redISub(ut).redISub(ut), pt = ot.redIAdd(ot);
      pt = pt.redIAdd(pt), pt = pt.redIAdd(pt), ke = vt, ne = dt.redMul(ut.redISub(vt)).redISub(pt), pe = this.y.redAdd(this.y);
    } else {
      var mt = this.x.redSqr(), gt = this.y.redSqr(), Pt = gt.redSqr(), xt = this.x.redAdd(gt).redSqr().redISub(mt).redISub(Pt);
      xt = xt.redIAdd(xt);
      var Nt = mt.redAdd(mt).redIAdd(mt), Et = Nt.redSqr(), bt = Pt.redIAdd(Pt);
      bt = bt.redIAdd(bt), bt = bt.redIAdd(bt), ke = Et.redISub(xt).redISub(xt), ne = Nt.redMul(xt.redISub(ke)).redISub(bt), pe = this.y.redMul(this.z), pe = pe.redIAdd(pe);
    }
    return this.curve.jpoint(ke, ne, pe);
  }, ie.prototype._threeDbl = function() {
    var ke, ne, pe;
    if (this.zOne) {
      var rt = this.x.redSqr(), nt = this.y.redSqr(), ot = nt.redSqr(), ut = this.x.redAdd(nt).redSqr().redISub(rt).redISub(ot);
      ut = ut.redIAdd(ut);
      var dt = rt.redAdd(rt).redIAdd(rt).redIAdd(this.curve.a), vt = dt.redSqr().redISub(ut).redISub(ut);
      ke = vt;
      var pt = ot.redIAdd(ot);
      pt = pt.redIAdd(pt), pt = pt.redIAdd(pt), ne = dt.redMul(ut.redISub(vt)).redISub(pt), pe = this.y.redAdd(this.y);
    } else {
      var mt = this.z.redSqr(), gt = this.y.redSqr(), Pt = this.x.redMul(gt), xt = this.x.redSub(mt).redMul(this.x.redAdd(mt));
      xt = xt.redAdd(xt).redIAdd(xt);
      var Nt = Pt.redIAdd(Pt);
      Nt = Nt.redIAdd(Nt);
      var Et = Nt.redAdd(Nt);
      ke = xt.redSqr().redISub(Et), pe = this.y.redAdd(this.z).redSqr().redISub(gt).redISub(mt);
      var bt = gt.redSqr();
      bt = bt.redIAdd(bt), bt = bt.redIAdd(bt), bt = bt.redIAdd(bt), ne = xt.redMul(Nt.redISub(ke)).redISub(bt);
    }
    return this.curve.jpoint(ke, ne, pe);
  }, ie.prototype._dbl = function() {
    var ke = this.curve.a, ne = this.x, pe = this.y, rt = this.z, nt = rt.redSqr().redSqr(), ot = ne.redSqr(), ut = pe.redSqr(), dt = ot.redAdd(ot).redIAdd(ot).redIAdd(ke.redMul(nt)), vt = ne.redAdd(ne);
    vt = vt.redIAdd(vt);
    var pt = vt.redMul(ut), mt = dt.redSqr().redISub(pt.redAdd(pt)), gt = pt.redISub(mt), Pt = ut.redSqr();
    Pt = Pt.redIAdd(Pt), Pt = Pt.redIAdd(Pt), Pt = Pt.redIAdd(Pt);
    var xt = dt.redMul(gt).redISub(Pt), Nt = pe.redAdd(pe).redMul(rt);
    return this.curve.jpoint(mt, xt, Nt);
  }, ie.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var ke = this.x.redSqr(), ne = this.y.redSqr(), pe = this.z.redSqr(), rt = ne.redSqr(), nt = ke.redAdd(ke).redIAdd(ke), ot = nt.redSqr(), ut = this.x.redAdd(ne).redSqr().redISub(ke).redISub(rt);
    ut = ut.redIAdd(ut), ut = ut.redAdd(ut).redIAdd(ut), ut = ut.redISub(ot);
    var dt = ut.redSqr(), vt = rt.redIAdd(rt);
    vt = vt.redIAdd(vt), vt = vt.redIAdd(vt), vt = vt.redIAdd(vt);
    var pt = nt.redIAdd(ut).redSqr().redISub(ot).redISub(dt).redISub(vt), mt = ne.redMul(pt);
    mt = mt.redIAdd(mt), mt = mt.redIAdd(mt);
    var gt = this.x.redMul(dt).redISub(mt);
    gt = gt.redIAdd(gt), gt = gt.redIAdd(gt);
    var Pt = this.y.redMul(pt.redMul(vt.redISub(pt)).redISub(ut.redMul(dt)));
    Pt = Pt.redIAdd(Pt), Pt = Pt.redIAdd(Pt), Pt = Pt.redIAdd(Pt);
    var xt = this.z.redAdd(ut).redSqr().redISub(pe).redISub(dt);
    return this.curve.jpoint(gt, Pt, xt);
  }, ie.prototype.mul = function(ke, ne) {
    return ke = new B(ke, ne), this.curve._wnafMul(this, ke);
  }, ie.prototype.eq = function(ke) {
    if (ke.type === "affine")
      return this.eq(ke.toJ());
    if (this === ke)
      return !0;
    var ne = this.z.redSqr(), pe = ke.z.redSqr();
    if (this.x.redMul(pe).redISub(ke.x.redMul(ne)).cmpn(0) !== 0)
      return !1;
    var rt = ne.redMul(this.z), nt = pe.redMul(ke.z);
    return this.y.redMul(nt).redISub(ke.y.redMul(rt)).cmpn(0) === 0;
  }, ie.prototype.eqXToP = function(ke) {
    var ne = this.z.redSqr(), pe = ke.toRed(this.curve.red).redMul(ne);
    if (this.x.cmp(pe) === 0)
      return !0;
    for (var rt = ke.clone(), nt = this.curve.redN.redMul(ne); ; ) {
      if (rt.iadd(this.curve.n), rt.cmp(this.curve.p) >= 0)
        return !1;
      if (pe.redIAdd(nt), this.x.cmp(pe) === 0)
        return !0;
    }
  }, ie.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, ie.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
var mont, hasRequiredMont;
function requireMont() {
  if (hasRequiredMont) return mont;
  hasRequiredMont = 1;
  var A = requireBn$2(), B = requireInherits_browser(), W = requireBase$1(), K = requireUtils$1();
  function J(re) {
    W.call(this, "mont", re), this.a = new A(re.a, 16).toRed(this.red), this.b = new A(re.b, 16).toRed(this.red), this.i4 = new A(4).toRed(this.red).redInvm(), this.two = new A(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  B(J, W), mont = J, J.prototype.validate = function(ie) {
    var oe = ie.normalize().x, ke = oe.redSqr(), ne = ke.redMul(oe).redAdd(ke.redMul(this.a)).redAdd(oe), pe = ne.redSqrt();
    return pe.redSqr().cmp(ne) === 0;
  };
  function L(re, ie, oe) {
    W.BasePoint.call(this, re, "projective"), ie === null && oe === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new A(ie, 16), this.z = new A(oe, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return B(L, W.BasePoint), J.prototype.decodePoint = function(ie, oe) {
    return this.point(K.toArray(ie, oe), 1);
  }, J.prototype.point = function(ie, oe) {
    return new L(this, ie, oe);
  }, J.prototype.pointFromJSON = function(ie) {
    return L.fromJSON(this, ie);
  }, L.prototype.precompute = function() {
  }, L.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, L.fromJSON = function(ie, oe) {
    return new L(ie, oe[0], oe[1] || ie.one);
  }, L.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, L.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, L.prototype.dbl = function() {
    var ie = this.x.redAdd(this.z), oe = ie.redSqr(), ke = this.x.redSub(this.z), ne = ke.redSqr(), pe = oe.redSub(ne), rt = oe.redMul(ne), nt = pe.redMul(ne.redAdd(this.curve.a24.redMul(pe)));
    return this.curve.point(rt, nt);
  }, L.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, L.prototype.diffAdd = function(ie, oe) {
    var ke = this.x.redAdd(this.z), ne = this.x.redSub(this.z), pe = ie.x.redAdd(ie.z), rt = ie.x.redSub(ie.z), nt = rt.redMul(ke), ot = pe.redMul(ne), ut = oe.z.redMul(nt.redAdd(ot).redSqr()), dt = oe.x.redMul(nt.redISub(ot).redSqr());
    return this.curve.point(ut, dt);
  }, L.prototype.mul = function(ie) {
    for (var oe = ie.clone(), ke = this, ne = this.curve.point(null, null), pe = this, rt = []; oe.cmpn(0) !== 0; oe.iushrn(1))
      rt.push(oe.andln(1));
    for (var nt = rt.length - 1; nt >= 0; nt--)
      rt[nt] === 0 ? (ke = ke.diffAdd(ne, pe), ne = ne.dbl()) : (ne = ke.diffAdd(ne, pe), ke = ke.dbl());
    return ne;
  }, L.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, L.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, L.prototype.eq = function(ie) {
    return this.getX().cmp(ie.getX()) === 0;
  }, L.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, L.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards) return edwards;
  hasRequiredEdwards = 1;
  var A = requireUtils$1(), B = requireBn$2(), W = requireInherits_browser(), K = requireBase$1(), J = A.assert;
  function L(ie) {
    this.twisted = (ie.a | 0) !== 1, this.mOneA = this.twisted && (ie.a | 0) === -1, this.extended = this.mOneA, K.call(this, "edwards", ie), this.a = new B(ie.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new B(ie.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new B(ie.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), J(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (ie.c | 0) === 1;
  }
  W(L, K), edwards = L, L.prototype._mulA = function(oe) {
    return this.mOneA ? oe.redNeg() : this.a.redMul(oe);
  }, L.prototype._mulC = function(oe) {
    return this.oneC ? oe : this.c.redMul(oe);
  }, L.prototype.jpoint = function(oe, ke, ne, pe) {
    return this.point(oe, ke, ne, pe);
  }, L.prototype.pointFromX = function(oe, ke) {
    oe = new B(oe, 16), oe.red || (oe = oe.toRed(this.red));
    var ne = oe.redSqr(), pe = this.c2.redSub(this.a.redMul(ne)), rt = this.one.redSub(this.c2.redMul(this.d).redMul(ne)), nt = pe.redMul(rt.redInvm()), ot = nt.redSqrt();
    if (ot.redSqr().redSub(nt).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var ut = ot.fromRed().isOdd();
    return (ke && !ut || !ke && ut) && (ot = ot.redNeg()), this.point(oe, ot);
  }, L.prototype.pointFromY = function(oe, ke) {
    oe = new B(oe, 16), oe.red || (oe = oe.toRed(this.red));
    var ne = oe.redSqr(), pe = ne.redSub(this.c2), rt = ne.redMul(this.d).redMul(this.c2).redSub(this.a), nt = pe.redMul(rt.redInvm());
    if (nt.cmp(this.zero) === 0) {
      if (ke)
        throw new Error("invalid point");
      return this.point(this.zero, oe);
    }
    var ot = nt.redSqrt();
    if (ot.redSqr().redSub(nt).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return ot.fromRed().isOdd() !== ke && (ot = ot.redNeg()), this.point(ot, oe);
  }, L.prototype.validate = function(oe) {
    if (oe.isInfinity())
      return !0;
    oe.normalize();
    var ke = oe.x.redSqr(), ne = oe.y.redSqr(), pe = ke.redMul(this.a).redAdd(ne), rt = this.c2.redMul(this.one.redAdd(this.d.redMul(ke).redMul(ne)));
    return pe.cmp(rt) === 0;
  };
  function re(ie, oe, ke, ne, pe) {
    K.BasePoint.call(this, ie, "projective"), oe === null && ke === null && ne === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new B(oe, 16), this.y = new B(ke, 16), this.z = ne ? new B(ne, 16) : this.curve.one, this.t = pe && new B(pe, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return W(re, K.BasePoint), L.prototype.pointFromJSON = function(oe) {
    return re.fromJSON(this, oe);
  }, L.prototype.point = function(oe, ke, ne, pe) {
    return new re(this, oe, ke, ne, pe);
  }, re.fromJSON = function(oe, ke) {
    return new re(oe, ke[0], ke[1], ke[2]);
  }, re.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, re.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, re.prototype._extDbl = function() {
    var oe = this.x.redSqr(), ke = this.y.redSqr(), ne = this.z.redSqr();
    ne = ne.redIAdd(ne);
    var pe = this.curve._mulA(oe), rt = this.x.redAdd(this.y).redSqr().redISub(oe).redISub(ke), nt = pe.redAdd(ke), ot = nt.redSub(ne), ut = pe.redSub(ke), dt = rt.redMul(ot), vt = nt.redMul(ut), pt = rt.redMul(ut), mt = ot.redMul(nt);
    return this.curve.point(dt, vt, mt, pt);
  }, re.prototype._projDbl = function() {
    var oe = this.x.redAdd(this.y).redSqr(), ke = this.x.redSqr(), ne = this.y.redSqr(), pe, rt, nt, ot, ut, dt;
    if (this.curve.twisted) {
      ot = this.curve._mulA(ke);
      var vt = ot.redAdd(ne);
      this.zOne ? (pe = oe.redSub(ke).redSub(ne).redMul(vt.redSub(this.curve.two)), rt = vt.redMul(ot.redSub(ne)), nt = vt.redSqr().redSub(vt).redSub(vt)) : (ut = this.z.redSqr(), dt = vt.redSub(ut).redISub(ut), pe = oe.redSub(ke).redISub(ne).redMul(dt), rt = vt.redMul(ot.redSub(ne)), nt = vt.redMul(dt));
    } else
      ot = ke.redAdd(ne), ut = this.curve._mulC(this.z).redSqr(), dt = ot.redSub(ut).redSub(ut), pe = this.curve._mulC(oe.redISub(ot)).redMul(dt), rt = this.curve._mulC(ot).redMul(ke.redISub(ne)), nt = ot.redMul(dt);
    return this.curve.point(pe, rt, nt);
  }, re.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, re.prototype._extAdd = function(oe) {
    var ke = this.y.redSub(this.x).redMul(oe.y.redSub(oe.x)), ne = this.y.redAdd(this.x).redMul(oe.y.redAdd(oe.x)), pe = this.t.redMul(this.curve.dd).redMul(oe.t), rt = this.z.redMul(oe.z.redAdd(oe.z)), nt = ne.redSub(ke), ot = rt.redSub(pe), ut = rt.redAdd(pe), dt = ne.redAdd(ke), vt = nt.redMul(ot), pt = ut.redMul(dt), mt = nt.redMul(dt), gt = ot.redMul(ut);
    return this.curve.point(vt, pt, gt, mt);
  }, re.prototype._projAdd = function(oe) {
    var ke = this.z.redMul(oe.z), ne = ke.redSqr(), pe = this.x.redMul(oe.x), rt = this.y.redMul(oe.y), nt = this.curve.d.redMul(pe).redMul(rt), ot = ne.redSub(nt), ut = ne.redAdd(nt), dt = this.x.redAdd(this.y).redMul(oe.x.redAdd(oe.y)).redISub(pe).redISub(rt), vt = ke.redMul(ot).redMul(dt), pt, mt;
    return this.curve.twisted ? (pt = ke.redMul(ut).redMul(rt.redSub(this.curve._mulA(pe))), mt = ot.redMul(ut)) : (pt = ke.redMul(ut).redMul(rt.redSub(pe)), mt = this.curve._mulC(ot).redMul(ut)), this.curve.point(vt, pt, mt);
  }, re.prototype.add = function(oe) {
    return this.isInfinity() ? oe : oe.isInfinity() ? this : this.curve.extended ? this._extAdd(oe) : this._projAdd(oe);
  }, re.prototype.mul = function(oe) {
    return this._hasDoubles(oe) ? this.curve._fixedNafMul(this, oe) : this.curve._wnafMul(this, oe);
  }, re.prototype.mulAdd = function(oe, ke, ne) {
    return this.curve._wnafMulAdd(1, [this, ke], [oe, ne], 2, !1);
  }, re.prototype.jmulAdd = function(oe, ke, ne) {
    return this.curve._wnafMulAdd(1, [this, ke], [oe, ne], 2, !0);
  }, re.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var oe = this.z.redInvm();
    return this.x = this.x.redMul(oe), this.y = this.y.redMul(oe), this.t && (this.t = this.t.redMul(oe)), this.z = this.curve.one, this.zOne = !0, this;
  }, re.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, re.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, re.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, re.prototype.eq = function(oe) {
    return this === oe || this.getX().cmp(oe.getX()) === 0 && this.getY().cmp(oe.getY()) === 0;
  }, re.prototype.eqXToP = function(oe) {
    var ke = oe.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(ke) === 0)
      return !0;
    for (var ne = oe.clone(), pe = this.curve.redN.redMul(this.z); ; ) {
      if (ne.iadd(this.curve.n), ne.cmp(this.curve.p) >= 0)
        return !1;
      if (ke.redIAdd(pe), this.x.cmp(ke) === 0)
        return !0;
    }
  }, re.prototype.toP = re.prototype.normalize, re.prototype.mixedAdd = re.prototype.add, edwards;
}
var hasRequiredCurve;
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, function(A) {
    var B = A;
    B.base = requireBase$1(), B.short = requireShort(), B.mont = requireMont(), B.edwards = requireEdwards();
  }(curve)), curve;
}
var curves = {}, hash = {}, utils$1 = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$1;
  hasRequiredUtils = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser();
  utils$1.inherits = B;
  function W(st, Oe) {
    return (st.charCodeAt(Oe) & 64512) !== 55296 || Oe < 0 || Oe + 1 >= st.length ? !1 : (st.charCodeAt(Oe + 1) & 64512) === 56320;
  }
  function K(st, Oe) {
    if (Array.isArray(st))
      return st.slice();
    if (!st)
      return [];
    var V = [];
    if (typeof st == "string")
      if (Oe) {
        if (Oe === "hex")
          for (st = st.replace(/[^a-z0-9]+/ig, ""), st.length % 2 !== 0 && (st = "0" + st), it = 0; it < st.length; it += 2)
            V.push(parseInt(st[it] + st[it + 1], 16));
      } else for (var ce = 0, it = 0; it < st.length; it++) {
        var at = st.charCodeAt(it);
        at < 128 ? V[ce++] = at : at < 2048 ? (V[ce++] = at >> 6 | 192, V[ce++] = at & 63 | 128) : W(st, it) ? (at = 65536 + ((at & 1023) << 10) + (st.charCodeAt(++it) & 1023), V[ce++] = at >> 18 | 240, V[ce++] = at >> 12 & 63 | 128, V[ce++] = at >> 6 & 63 | 128, V[ce++] = at & 63 | 128) : (V[ce++] = at >> 12 | 224, V[ce++] = at >> 6 & 63 | 128, V[ce++] = at & 63 | 128);
      }
    else
      for (it = 0; it < st.length; it++)
        V[it] = st[it] | 0;
    return V;
  }
  utils$1.toArray = K;
  function J(st) {
    for (var Oe = "", V = 0; V < st.length; V++)
      Oe += ie(st[V].toString(16));
    return Oe;
  }
  utils$1.toHex = J;
  function L(st) {
    var Oe = st >>> 24 | st >>> 8 & 65280 | st << 8 & 16711680 | (st & 255) << 24;
    return Oe >>> 0;
  }
  utils$1.htonl = L;
  function re(st, Oe) {
    for (var V = "", ce = 0; ce < st.length; ce++) {
      var it = st[ce];
      Oe === "little" && (it = L(it)), V += oe(it.toString(16));
    }
    return V;
  }
  utils$1.toHex32 = re;
  function ie(st) {
    return st.length === 1 ? "0" + st : st;
  }
  utils$1.zero2 = ie;
  function oe(st) {
    return st.length === 7 ? "0" + st : st.length === 6 ? "00" + st : st.length === 5 ? "000" + st : st.length === 4 ? "0000" + st : st.length === 3 ? "00000" + st : st.length === 2 ? "000000" + st : st.length === 1 ? "0000000" + st : st;
  }
  utils$1.zero8 = oe;
  function ke(st, Oe, V, ce) {
    var it = V - Oe;
    A(it % 4 === 0);
    for (var at = new Array(it / 4), ft = 0, lt = Oe; ft < at.length; ft++, lt += 4) {
      var ct;
      ce === "big" ? ct = st[lt] << 24 | st[lt + 1] << 16 | st[lt + 2] << 8 | st[lt + 3] : ct = st[lt + 3] << 24 | st[lt + 2] << 16 | st[lt + 1] << 8 | st[lt], at[ft] = ct >>> 0;
    }
    return at;
  }
  utils$1.join32 = ke;
  function ne(st, Oe) {
    for (var V = new Array(st.length * 4), ce = 0, it = 0; ce < st.length; ce++, it += 4) {
      var at = st[ce];
      Oe === "big" ? (V[it] = at >>> 24, V[it + 1] = at >>> 16 & 255, V[it + 2] = at >>> 8 & 255, V[it + 3] = at & 255) : (V[it + 3] = at >>> 24, V[it + 2] = at >>> 16 & 255, V[it + 1] = at >>> 8 & 255, V[it] = at & 255);
    }
    return V;
  }
  utils$1.split32 = ne;
  function pe(st, Oe) {
    return st >>> Oe | st << 32 - Oe;
  }
  utils$1.rotr32 = pe;
  function rt(st, Oe) {
    return st << Oe | st >>> 32 - Oe;
  }
  utils$1.rotl32 = rt;
  function nt(st, Oe) {
    return st + Oe >>> 0;
  }
  utils$1.sum32 = nt;
  function ot(st, Oe, V) {
    return st + Oe + V >>> 0;
  }
  utils$1.sum32_3 = ot;
  function ut(st, Oe, V, ce) {
    return st + Oe + V + ce >>> 0;
  }
  utils$1.sum32_4 = ut;
  function dt(st, Oe, V, ce, it) {
    return st + Oe + V + ce + it >>> 0;
  }
  utils$1.sum32_5 = dt;
  function vt(st, Oe, V, ce) {
    var it = st[Oe], at = st[Oe + 1], ft = ce + at >>> 0, lt = (ft < ce ? 1 : 0) + V + it;
    st[Oe] = lt >>> 0, st[Oe + 1] = ft;
  }
  utils$1.sum64 = vt;
  function pt(st, Oe, V, ce) {
    var it = Oe + ce >>> 0, at = (it < Oe ? 1 : 0) + st + V;
    return at >>> 0;
  }
  utils$1.sum64_hi = pt;
  function mt(st, Oe, V, ce) {
    var it = Oe + ce;
    return it >>> 0;
  }
  utils$1.sum64_lo = mt;
  function gt(st, Oe, V, ce, it, at, ft, lt) {
    var ct = 0, ht = Oe;
    ht = ht + ce >>> 0, ct += ht < Oe ? 1 : 0, ht = ht + at >>> 0, ct += ht < at ? 1 : 0, ht = ht + lt >>> 0, ct += ht < lt ? 1 : 0;
    var Ce = st + V + it + ft + ct;
    return Ce >>> 0;
  }
  utils$1.sum64_4_hi = gt;
  function Pt(st, Oe, V, ce, it, at, ft, lt) {
    var ct = Oe + ce + at + lt;
    return ct >>> 0;
  }
  utils$1.sum64_4_lo = Pt;
  function xt(st, Oe, V, ce, it, at, ft, lt, ct, ht) {
    var Ce = 0, yt = Oe;
    yt = yt + ce >>> 0, Ce += yt < Oe ? 1 : 0, yt = yt + at >>> 0, Ce += yt < at ? 1 : 0, yt = yt + lt >>> 0, Ce += yt < lt ? 1 : 0, yt = yt + ht >>> 0, Ce += yt < ht ? 1 : 0;
    var qt = st + V + it + ft + ct + Ce;
    return qt >>> 0;
  }
  utils$1.sum64_5_hi = xt;
  function Nt(st, Oe, V, ce, it, at, ft, lt, ct, ht) {
    var Ce = Oe + ce + at + lt + ht;
    return Ce >>> 0;
  }
  utils$1.sum64_5_lo = Nt;
  function Et(st, Oe, V) {
    var ce = Oe << 32 - V | st >>> V;
    return ce >>> 0;
  }
  utils$1.rotr64_hi = Et;
  function bt(st, Oe, V) {
    var ce = st << 32 - V | Oe >>> V;
    return ce >>> 0;
  }
  utils$1.rotr64_lo = bt;
  function Bt(st, Oe, V) {
    return st >>> V;
  }
  utils$1.shr64_hi = Bt;
  function wt(st, Oe, V) {
    var ce = st << 32 - V | Oe >>> V;
    return ce >>> 0;
  }
  return utils$1.shr64_lo = wt, utils$1;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  var A = requireUtils(), B = requireMinimalisticAssert();
  function W() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$1.BlockHash = W, W.prototype.update = function(J, L) {
    if (J = A.toArray(J, L), this.pending ? this.pending = this.pending.concat(J) : this.pending = J, this.pendingTotal += J.length, this.pending.length >= this._delta8) {
      J = this.pending;
      var re = J.length % this._delta8;
      this.pending = J.slice(J.length - re, J.length), this.pending.length === 0 && (this.pending = null), J = A.join32(J, 0, J.length - re, this.endian);
      for (var ie = 0; ie < J.length; ie += this._delta32)
        this._update(J, ie, ie + this._delta32);
    }
    return this;
  }, W.prototype.digest = function(J) {
    return this.update(this._pad()), B(this.pending === null), this._digest(J);
  }, W.prototype._pad = function() {
    var J = this.pendingTotal, L = this._delta8, re = L - (J + this.padLength) % L, ie = new Array(re + this.padLength);
    ie[0] = 128;
    for (var oe = 1; oe < re; oe++)
      ie[oe] = 0;
    if (J <<= 3, this.endian === "big") {
      for (var ke = 8; ke < this.padLength; ke++)
        ie[oe++] = 0;
      ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = J >>> 24 & 255, ie[oe++] = J >>> 16 & 255, ie[oe++] = J >>> 8 & 255, ie[oe++] = J & 255;
    } else
      for (ie[oe++] = J & 255, ie[oe++] = J >>> 8 & 255, ie[oe++] = J >>> 16 & 255, ie[oe++] = J >>> 24 & 255, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, ke = 8; ke < this.padLength; ke++)
        ie[oe++] = 0;
    return ie;
  }, common$1;
}
var sha = {}, common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  var A = requireUtils(), B = A.rotr32;
  function W(ne, pe, rt, nt) {
    if (ne === 0)
      return K(pe, rt, nt);
    if (ne === 1 || ne === 3)
      return L(pe, rt, nt);
    if (ne === 2)
      return J(pe, rt, nt);
  }
  common.ft_1 = W;
  function K(ne, pe, rt) {
    return ne & pe ^ ~ne & rt;
  }
  common.ch32 = K;
  function J(ne, pe, rt) {
    return ne & pe ^ ne & rt ^ pe & rt;
  }
  common.maj32 = J;
  function L(ne, pe, rt) {
    return ne ^ pe ^ rt;
  }
  common.p32 = L;
  function re(ne) {
    return B(ne, 2) ^ B(ne, 13) ^ B(ne, 22);
  }
  common.s0_256 = re;
  function ie(ne) {
    return B(ne, 6) ^ B(ne, 11) ^ B(ne, 25);
  }
  common.s1_256 = ie;
  function oe(ne) {
    return B(ne, 7) ^ B(ne, 18) ^ ne >>> 3;
  }
  common.g0_256 = oe;
  function ke(ne) {
    return B(ne, 17) ^ B(ne, 19) ^ ne >>> 10;
  }
  return common.g1_256 = ke, common;
}
var _1, hasRequired_1;
function require_1() {
  if (hasRequired_1) return _1;
  hasRequired_1 = 1;
  var A = requireUtils(), B = requireCommon$1(), W = requireCommon(), K = A.rotl32, J = A.sum32, L = A.sum32_5, re = W.ft_1, ie = B.BlockHash, oe = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function ke() {
    if (!(this instanceof ke))
      return new ke();
    ie.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return A.inherits(ke, ie), _1 = ke, ke.blockSize = 512, ke.outSize = 160, ke.hmacStrength = 80, ke.padLength = 64, ke.prototype._update = function(pe, rt) {
    for (var nt = this.W, ot = 0; ot < 16; ot++)
      nt[ot] = pe[rt + ot];
    for (; ot < nt.length; ot++)
      nt[ot] = K(nt[ot - 3] ^ nt[ot - 8] ^ nt[ot - 14] ^ nt[ot - 16], 1);
    var ut = this.h[0], dt = this.h[1], vt = this.h[2], pt = this.h[3], mt = this.h[4];
    for (ot = 0; ot < nt.length; ot++) {
      var gt = ~~(ot / 20), Pt = L(K(ut, 5), re(gt, dt, vt, pt), mt, nt[ot], oe[gt]);
      mt = pt, pt = vt, vt = K(dt, 30), dt = ut, ut = Pt;
    }
    this.h[0] = J(this.h[0], ut), this.h[1] = J(this.h[1], dt), this.h[2] = J(this.h[2], vt), this.h[3] = J(this.h[3], pt), this.h[4] = J(this.h[4], mt);
  }, ke.prototype._digest = function(pe) {
    return pe === "hex" ? A.toHex32(this.h, "big") : A.split32(this.h, "big");
  }, _1;
}
var _256, hasRequired_256;
function require_256() {
  if (hasRequired_256) return _256;
  hasRequired_256 = 1;
  var A = requireUtils(), B = requireCommon$1(), W = requireCommon(), K = requireMinimalisticAssert(), J = A.sum32, L = A.sum32_4, re = A.sum32_5, ie = W.ch32, oe = W.maj32, ke = W.s0_256, ne = W.s1_256, pe = W.g0_256, rt = W.g1_256, nt = B.BlockHash, ot = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function ut() {
    if (!(this instanceof ut))
      return new ut();
    nt.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = ot, this.W = new Array(64);
  }
  return A.inherits(ut, nt), _256 = ut, ut.blockSize = 512, ut.outSize = 256, ut.hmacStrength = 192, ut.padLength = 64, ut.prototype._update = function(vt, pt) {
    for (var mt = this.W, gt = 0; gt < 16; gt++)
      mt[gt] = vt[pt + gt];
    for (; gt < mt.length; gt++)
      mt[gt] = L(rt(mt[gt - 2]), mt[gt - 7], pe(mt[gt - 15]), mt[gt - 16]);
    var Pt = this.h[0], xt = this.h[1], Nt = this.h[2], Et = this.h[3], bt = this.h[4], Bt = this.h[5], wt = this.h[6], st = this.h[7];
    for (K(this.k.length === mt.length), gt = 0; gt < mt.length; gt++) {
      var Oe = re(st, ne(bt), ie(bt, Bt, wt), this.k[gt], mt[gt]), V = J(ke(Pt), oe(Pt, xt, Nt));
      st = wt, wt = Bt, Bt = bt, bt = J(Et, Oe), Et = Nt, Nt = xt, xt = Pt, Pt = J(Oe, V);
    }
    this.h[0] = J(this.h[0], Pt), this.h[1] = J(this.h[1], xt), this.h[2] = J(this.h[2], Nt), this.h[3] = J(this.h[3], Et), this.h[4] = J(this.h[4], bt), this.h[5] = J(this.h[5], Bt), this.h[6] = J(this.h[6], wt), this.h[7] = J(this.h[7], st);
  }, ut.prototype._digest = function(vt) {
    return vt === "hex" ? A.toHex32(this.h, "big") : A.split32(this.h, "big");
  }, _256;
}
var _224, hasRequired_224;
function require_224() {
  if (hasRequired_224) return _224;
  hasRequired_224 = 1;
  var A = requireUtils(), B = require_256();
  function W() {
    if (!(this instanceof W))
      return new W();
    B.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return A.inherits(W, B), _224 = W, W.blockSize = 512, W.outSize = 224, W.hmacStrength = 192, W.padLength = 64, W.prototype._digest = function(J) {
    return J === "hex" ? A.toHex32(this.h.slice(0, 7), "big") : A.split32(this.h.slice(0, 7), "big");
  }, _224;
}
var _512, hasRequired_512;
function require_512() {
  if (hasRequired_512) return _512;
  hasRequired_512 = 1;
  var A = requireUtils(), B = requireCommon$1(), W = requireMinimalisticAssert(), K = A.rotr64_hi, J = A.rotr64_lo, L = A.shr64_hi, re = A.shr64_lo, ie = A.sum64, oe = A.sum64_hi, ke = A.sum64_lo, ne = A.sum64_4_hi, pe = A.sum64_4_lo, rt = A.sum64_5_hi, nt = A.sum64_5_lo, ot = B.BlockHash, ut = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function dt() {
    if (!(this instanceof dt))
      return new dt();
    ot.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = ut, this.W = new Array(160);
  }
  A.inherits(dt, ot), _512 = dt, dt.blockSize = 1024, dt.outSize = 512, dt.hmacStrength = 192, dt.padLength = 128, dt.prototype._prepareBlock = function(V, ce) {
    for (var it = this.W, at = 0; at < 32; at++)
      it[at] = V[ce + at];
    for (; at < it.length; at += 2) {
      var ft = wt(it[at - 4], it[at - 3]), lt = st(it[at - 4], it[at - 3]), ct = it[at - 14], ht = it[at - 13], Ce = bt(it[at - 30], it[at - 29]), yt = Bt(it[at - 30], it[at - 29]), qt = it[at - 32], jt = it[at - 31];
      it[at] = ne(
        ft,
        lt,
        ct,
        ht,
        Ce,
        yt,
        qt,
        jt
      ), it[at + 1] = pe(
        ft,
        lt,
        ct,
        ht,
        Ce,
        yt,
        qt,
        jt
      );
    }
  }, dt.prototype._update = function(V, ce) {
    this._prepareBlock(V, ce);
    var it = this.W, at = this.h[0], ft = this.h[1], lt = this.h[2], ct = this.h[3], ht = this.h[4], Ce = this.h[5], yt = this.h[6], qt = this.h[7], jt = this.h[8], kt = this.h[9], $t = this.h[10], Mt = this.h[11], Lt = this.h[12], Kt = this.h[13], Tt = this.h[14], Rt = this.h[15];
    W(this.k.length === it.length);
    for (var Wt = 0; Wt < it.length; Wt += 2) {
      var Xt = Tt, Zt = Rt, ar = Nt(jt, kt), fr = Et(jt, kt), lr = vt(jt, kt, $t, Mt, Lt), Jt = pt(jt, kt, $t, Mt, Lt, Kt), _r = this.k[Wt], sr = this.k[Wt + 1], Mr = it[Wt], Sr = it[Wt + 1], cr = rt(
        Xt,
        Zt,
        ar,
        fr,
        lr,
        Jt,
        _r,
        sr,
        Mr,
        Sr
      ), Br = nt(
        Xt,
        Zt,
        ar,
        fr,
        lr,
        Jt,
        _r,
        sr,
        Mr,
        Sr
      );
      Xt = Pt(at, ft), Zt = xt(at, ft), ar = mt(at, ft, lt, ct, ht), fr = gt(at, ft, lt, ct, ht, Ce);
      var $r = oe(Xt, Zt, ar, fr), yr = ke(Xt, Zt, ar, fr);
      Tt = Lt, Rt = Kt, Lt = $t, Kt = Mt, $t = jt, Mt = kt, jt = oe(yt, qt, cr, Br), kt = ke(qt, qt, cr, Br), yt = ht, qt = Ce, ht = lt, Ce = ct, lt = at, ct = ft, at = oe(cr, Br, $r, yr), ft = ke(cr, Br, $r, yr);
    }
    ie(this.h, 0, at, ft), ie(this.h, 2, lt, ct), ie(this.h, 4, ht, Ce), ie(this.h, 6, yt, qt), ie(this.h, 8, jt, kt), ie(this.h, 10, $t, Mt), ie(this.h, 12, Lt, Kt), ie(this.h, 14, Tt, Rt);
  }, dt.prototype._digest = function(V) {
    return V === "hex" ? A.toHex32(this.h, "big") : A.split32(this.h, "big");
  };
  function vt(Oe, V, ce, it, at) {
    var ft = Oe & ce ^ ~Oe & at;
    return ft < 0 && (ft += 4294967296), ft;
  }
  function pt(Oe, V, ce, it, at, ft) {
    var lt = V & it ^ ~V & ft;
    return lt < 0 && (lt += 4294967296), lt;
  }
  function mt(Oe, V, ce, it, at) {
    var ft = Oe & ce ^ Oe & at ^ ce & at;
    return ft < 0 && (ft += 4294967296), ft;
  }
  function gt(Oe, V, ce, it, at, ft) {
    var lt = V & it ^ V & ft ^ it & ft;
    return lt < 0 && (lt += 4294967296), lt;
  }
  function Pt(Oe, V) {
    var ce = K(Oe, V, 28), it = K(V, Oe, 2), at = K(V, Oe, 7), ft = ce ^ it ^ at;
    return ft < 0 && (ft += 4294967296), ft;
  }
  function xt(Oe, V) {
    var ce = J(Oe, V, 28), it = J(V, Oe, 2), at = J(V, Oe, 7), ft = ce ^ it ^ at;
    return ft < 0 && (ft += 4294967296), ft;
  }
  function Nt(Oe, V) {
    var ce = K(Oe, V, 14), it = K(Oe, V, 18), at = K(V, Oe, 9), ft = ce ^ it ^ at;
    return ft < 0 && (ft += 4294967296), ft;
  }
  function Et(Oe, V) {
    var ce = J(Oe, V, 14), it = J(Oe, V, 18), at = J(V, Oe, 9), ft = ce ^ it ^ at;
    return ft < 0 && (ft += 4294967296), ft;
  }
  function bt(Oe, V) {
    var ce = K(Oe, V, 1), it = K(Oe, V, 8), at = L(Oe, V, 7), ft = ce ^ it ^ at;
    return ft < 0 && (ft += 4294967296), ft;
  }
  function Bt(Oe, V) {
    var ce = J(Oe, V, 1), it = J(Oe, V, 8), at = re(Oe, V, 7), ft = ce ^ it ^ at;
    return ft < 0 && (ft += 4294967296), ft;
  }
  function wt(Oe, V) {
    var ce = K(Oe, V, 19), it = K(V, Oe, 29), at = L(Oe, V, 6), ft = ce ^ it ^ at;
    return ft < 0 && (ft += 4294967296), ft;
  }
  function st(Oe, V) {
    var ce = J(Oe, V, 19), it = J(V, Oe, 29), at = re(Oe, V, 6), ft = ce ^ it ^ at;
    return ft < 0 && (ft += 4294967296), ft;
  }
  return _512;
}
var _384, hasRequired_384;
function require_384() {
  if (hasRequired_384) return _384;
  hasRequired_384 = 1;
  var A = requireUtils(), B = require_512();
  function W() {
    if (!(this instanceof W))
      return new W();
    B.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return A.inherits(W, B), _384 = W, W.blockSize = 1024, W.outSize = 384, W.hmacStrength = 192, W.padLength = 128, W.prototype._digest = function(J) {
    return J === "hex" ? A.toHex32(this.h.slice(0, 12), "big") : A.split32(this.h.slice(0, 12), "big");
  }, _384;
}
var hasRequiredSha;
function requireSha() {
  return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha;
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd) return ripemd;
  hasRequiredRipemd = 1;
  var A = requireUtils(), B = requireCommon$1(), W = A.rotl32, K = A.sum32, J = A.sum32_3, L = A.sum32_4, re = B.BlockHash;
  function ie() {
    if (!(this instanceof ie))
      return new ie();
    re.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  A.inherits(ie, re), ripemd.ripemd160 = ie, ie.blockSize = 512, ie.outSize = 160, ie.hmacStrength = 192, ie.padLength = 64, ie.prototype._update = function(dt, vt) {
    for (var pt = this.h[0], mt = this.h[1], gt = this.h[2], Pt = this.h[3], xt = this.h[4], Nt = pt, Et = mt, bt = gt, Bt = Pt, wt = xt, st = 0; st < 80; st++) {
      var Oe = K(
        W(
          L(pt, oe(st, mt, gt, Pt), dt[pe[st] + vt], ke(st)),
          nt[st]
        ),
        xt
      );
      pt = xt, xt = Pt, Pt = W(gt, 10), gt = mt, mt = Oe, Oe = K(
        W(
          L(Nt, oe(79 - st, Et, bt, Bt), dt[rt[st] + vt], ne(st)),
          ot[st]
        ),
        wt
      ), Nt = wt, wt = Bt, Bt = W(bt, 10), bt = Et, Et = Oe;
    }
    Oe = J(this.h[1], gt, Bt), this.h[1] = J(this.h[2], Pt, wt), this.h[2] = J(this.h[3], xt, Nt), this.h[3] = J(this.h[4], pt, Et), this.h[4] = J(this.h[0], mt, bt), this.h[0] = Oe;
  }, ie.prototype._digest = function(dt) {
    return dt === "hex" ? A.toHex32(this.h, "little") : A.split32(this.h, "little");
  };
  function oe(ut, dt, vt, pt) {
    return ut <= 15 ? dt ^ vt ^ pt : ut <= 31 ? dt & vt | ~dt & pt : ut <= 47 ? (dt | ~vt) ^ pt : ut <= 63 ? dt & pt | vt & ~pt : dt ^ (vt | ~pt);
  }
  function ke(ut) {
    return ut <= 15 ? 0 : ut <= 31 ? 1518500249 : ut <= 47 ? 1859775393 : ut <= 63 ? 2400959708 : 2840853838;
  }
  function ne(ut) {
    return ut <= 15 ? 1352829926 : ut <= 31 ? 1548603684 : ut <= 47 ? 1836072691 : ut <= 63 ? 2053994217 : 0;
  }
  var pe = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], rt = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], nt = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], ot = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac, hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  var A = requireUtils(), B = requireMinimalisticAssert();
  function W(K, J, L) {
    if (!(this instanceof W))
      return new W(K, J, L);
    this.Hash = K, this.blockSize = K.blockSize / 8, this.outSize = K.outSize / 8, this.inner = null, this.outer = null, this._init(A.toArray(J, L));
  }
  return hmac = W, W.prototype._init = function(J) {
    J.length > this.blockSize && (J = new this.Hash().update(J).digest()), B(J.length <= this.blockSize);
    for (var L = J.length; L < this.blockSize; L++)
      J.push(0);
    for (L = 0; L < J.length; L++)
      J[L] ^= 54;
    for (this.inner = new this.Hash().update(J), L = 0; L < J.length; L++)
      J[L] ^= 106;
    this.outer = new this.Hash().update(J);
  }, W.prototype.update = function(J, L) {
    return this.inner.update(J, L), this;
  }, W.prototype.digest = function(J) {
    return this.outer.update(this.inner.digest()), this.outer.digest(J);
  }, hmac;
}
var hasRequiredHash;
function requireHash() {
  return hasRequiredHash || (hasRequiredHash = 1, function(A) {
    var B = A;
    B.utils = requireUtils(), B.common = requireCommon$1(), B.sha = requireSha(), B.ripemd = requireRipemd(), B.hmac = requireHmac(), B.sha1 = B.sha.sha1, B.sha256 = B.sha.sha256, B.sha224 = B.sha.sha224, B.sha384 = B.sha.sha384, B.sha512 = B.sha.sha512, B.ripemd160 = B.ripemd.ripemd160;
  }(hash)), hash;
}
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
var hasRequiredCurves;
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, function(A) {
    var B = A, W = requireHash(), K = requireCurve(), J = requireUtils$1(), L = J.assert;
    function re(ke) {
      ke.type === "short" ? this.curve = new K.short(ke) : ke.type === "edwards" ? this.curve = new K.edwards(ke) : this.curve = new K.mont(ke), this.g = this.curve.g, this.n = this.curve.n, this.hash = ke.hash, L(this.g.validate(), "Invalid curve"), L(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    B.PresetCurve = re;
    function ie(ke, ne) {
      Object.defineProperty(B, ke, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var pe = new re(ne);
          return Object.defineProperty(B, ke, {
            configurable: !0,
            enumerable: !0,
            value: pe
          }), pe;
        }
      });
    }
    ie("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: W.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), ie("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: W.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), ie("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: W.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), ie("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: W.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), ie("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: W.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), ie("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: W.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), ie("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: W.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var oe;
    try {
      oe = requireSecp256k1();
    } catch {
      oe = void 0;
    }
    ie("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: W.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        oe
      ]
    });
  }(curves)), curves;
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg) return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var A = requireHash(), B = requireUtils$2(), W = requireMinimalisticAssert();
  function K(J) {
    if (!(this instanceof K))
      return new K(J);
    this.hash = J.hash, this.predResist = !!J.predResist, this.outLen = this.hash.outSize, this.minEntropy = J.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var L = B.toArray(J.entropy, J.entropyEnc || "hex"), re = B.toArray(J.nonce, J.nonceEnc || "hex"), ie = B.toArray(J.pers, J.persEnc || "hex");
    W(
      L.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(L, re, ie);
  }
  return hmacDrbg = K, K.prototype._init = function(L, re, ie) {
    var oe = L.concat(re).concat(ie);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var ke = 0; ke < this.V.length; ke++)
      this.K[ke] = 0, this.V[ke] = 1;
    this._update(oe), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, K.prototype._hmac = function() {
    return new A.hmac(this.hash, this.K);
  }, K.prototype._update = function(L) {
    var re = this._hmac().update(this.V).update([0]);
    L && (re = re.update(L)), this.K = re.digest(), this.V = this._hmac().update(this.V).digest(), L && (this.K = this._hmac().update(this.V).update([1]).update(L).digest(), this.V = this._hmac().update(this.V).digest());
  }, K.prototype.reseed = function(L, re, ie, oe) {
    typeof re != "string" && (oe = ie, ie = re, re = null), L = B.toArray(L, re), ie = B.toArray(ie, oe), W(
      L.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(L.concat(ie || [])), this._reseed = 1;
  }, K.prototype.generate = function(L, re, ie, oe) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof re != "string" && (oe = ie, ie = re, re = null), ie && (ie = B.toArray(ie, oe || "hex"), this._update(ie));
    for (var ke = []; ke.length < L; )
      this.V = this._hmac().update(this.V).digest(), ke = ke.concat(this.V);
    var ne = ke.slice(0, L);
    return this._update(ie), this._reseed++, B.encode(ne, re);
  }, hmacDrbg;
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1) return key$1;
  hasRequiredKey$1 = 1;
  var A = requireBn$2(), B = requireUtils$1(), W = B.assert;
  function K(J, L) {
    this.ec = J, this.priv = null, this.pub = null, L.priv && this._importPrivate(L.priv, L.privEnc), L.pub && this._importPublic(L.pub, L.pubEnc);
  }
  return key$1 = K, K.fromPublic = function(L, re, ie) {
    return re instanceof K ? re : new K(L, {
      pub: re,
      pubEnc: ie
    });
  }, K.fromPrivate = function(L, re, ie) {
    return re instanceof K ? re : new K(L, {
      priv: re,
      privEnc: ie
    });
  }, K.prototype.validate = function() {
    var L = this.getPublic();
    return L.isInfinity() ? { result: !1, reason: "Invalid public key" } : L.validate() ? L.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, K.prototype.getPublic = function(L, re) {
    return typeof L == "string" && (re = L, L = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), re ? this.pub.encode(re, L) : this.pub;
  }, K.prototype.getPrivate = function(L) {
    return L === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, K.prototype._importPrivate = function(L, re) {
    this.priv = new A(L, re || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, K.prototype._importPublic = function(L, re) {
    if (L.x || L.y) {
      this.ec.curve.type === "mont" ? W(L.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && W(L.x && L.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(L.x, L.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(L, re);
  }, K.prototype.derive = function(L) {
    return L.validate() || W(L.validate(), "public point not validated"), L.mul(this.priv).getX();
  }, K.prototype.sign = function(L, re, ie) {
    return this.ec.sign(L, this, re, ie);
  }, K.prototype.verify = function(L, re, ie) {
    return this.ec.verify(L, re, this, void 0, ie);
  }, K.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1;
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1) return signature$1;
  hasRequiredSignature$1 = 1;
  var A = requireBn$2(), B = requireUtils$1(), W = B.assert;
  function K(oe, ke) {
    if (oe instanceof K)
      return oe;
    this._importDER(oe, ke) || (W(oe.r && oe.s, "Signature without r or s"), this.r = new A(oe.r, 16), this.s = new A(oe.s, 16), oe.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = oe.recoveryParam);
  }
  signature$1 = K;
  function J() {
    this.place = 0;
  }
  function L(oe, ke) {
    var ne = oe[ke.place++];
    if (!(ne & 128))
      return ne;
    var pe = ne & 15;
    if (pe === 0 || pe > 4 || oe[ke.place] === 0)
      return !1;
    for (var rt = 0, nt = 0, ot = ke.place; nt < pe; nt++, ot++)
      rt <<= 8, rt |= oe[ot], rt >>>= 0;
    return rt <= 127 ? !1 : (ke.place = ot, rt);
  }
  function re(oe) {
    for (var ke = 0, ne = oe.length - 1; !oe[ke] && !(oe[ke + 1] & 128) && ke < ne; )
      ke++;
    return ke === 0 ? oe : oe.slice(ke);
  }
  K.prototype._importDER = function(ke, ne) {
    ke = B.toArray(ke, ne);
    var pe = new J();
    if (ke[pe.place++] !== 48)
      return !1;
    var rt = L(ke, pe);
    if (rt === !1 || rt + pe.place !== ke.length || ke[pe.place++] !== 2)
      return !1;
    var nt = L(ke, pe);
    if (nt === !1 || ke[pe.place] & 128)
      return !1;
    var ot = ke.slice(pe.place, nt + pe.place);
    if (pe.place += nt, ke[pe.place++] !== 2)
      return !1;
    var ut = L(ke, pe);
    if (ut === !1 || ke.length !== ut + pe.place || ke[pe.place] & 128)
      return !1;
    var dt = ke.slice(pe.place, ut + pe.place);
    if (ot[0] === 0)
      if (ot[1] & 128)
        ot = ot.slice(1);
      else
        return !1;
    if (dt[0] === 0)
      if (dt[1] & 128)
        dt = dt.slice(1);
      else
        return !1;
    return this.r = new A(ot), this.s = new A(dt), this.recoveryParam = null, !0;
  };
  function ie(oe, ke) {
    if (ke < 128) {
      oe.push(ke);
      return;
    }
    var ne = 1 + (Math.log(ke) / Math.LN2 >>> 3);
    for (oe.push(ne | 128); --ne; )
      oe.push(ke >>> (ne << 3) & 255);
    oe.push(ke);
  }
  return K.prototype.toDER = function(ke) {
    var ne = this.r.toArray(), pe = this.s.toArray();
    for (ne[0] & 128 && (ne = [0].concat(ne)), pe[0] & 128 && (pe = [0].concat(pe)), ne = re(ne), pe = re(pe); !pe[0] && !(pe[1] & 128); )
      pe = pe.slice(1);
    var rt = [2];
    ie(rt, ne.length), rt = rt.concat(ne), rt.push(2), ie(rt, pe.length);
    var nt = rt.concat(pe), ot = [48];
    return ie(ot, nt.length), ot = ot.concat(nt), B.encode(ot, ke);
  }, signature$1;
}
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var A = requireBn$2(), B = requireHmacDrbg(), W = requireUtils$1(), K = requireCurves(), J = requireBrorand(), L = W.assert, re = requireKey$1(), ie = requireSignature$1();
  function oe(ke) {
    if (!(this instanceof oe))
      return new oe(ke);
    typeof ke == "string" && (L(
      Object.prototype.hasOwnProperty.call(K, ke),
      "Unknown curve " + ke
    ), ke = K[ke]), ke instanceof K.PresetCurve && (ke = { curve: ke }), this.curve = ke.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = ke.curve.g, this.g.precompute(ke.curve.n.bitLength() + 1), this.hash = ke.hash || ke.curve.hash;
  }
  return ec = oe, oe.prototype.keyPair = function(ne) {
    return new re(this, ne);
  }, oe.prototype.keyFromPrivate = function(ne, pe) {
    return re.fromPrivate(this, ne, pe);
  }, oe.prototype.keyFromPublic = function(ne, pe) {
    return re.fromPublic(this, ne, pe);
  }, oe.prototype.genKeyPair = function(ne) {
    ne || (ne = {});
    for (var pe = new B({
      hash: this.hash,
      pers: ne.pers,
      persEnc: ne.persEnc || "utf8",
      entropy: ne.entropy || J(this.hash.hmacStrength),
      entropyEnc: ne.entropy && ne.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), rt = this.n.byteLength(), nt = this.n.sub(new A(2)); ; ) {
      var ot = new A(pe.generate(rt));
      if (!(ot.cmp(nt) > 0))
        return ot.iaddn(1), this.keyFromPrivate(ot);
    }
  }, oe.prototype._truncateToN = function(ne, pe, rt) {
    var nt;
    if (A.isBN(ne) || typeof ne == "number")
      ne = new A(ne, 16), nt = ne.byteLength();
    else if (typeof ne == "object")
      nt = ne.length, ne = new A(ne, 16);
    else {
      var ot = ne.toString();
      nt = ot.length + 1 >>> 1, ne = new A(ot, 16);
    }
    typeof rt != "number" && (rt = nt * 8);
    var ut = rt - this.n.bitLength();
    return ut > 0 && (ne = ne.ushrn(ut)), !pe && ne.cmp(this.n) >= 0 ? ne.sub(this.n) : ne;
  }, oe.prototype.sign = function(ne, pe, rt, nt) {
    if (typeof rt == "object" && (nt = rt, rt = null), nt || (nt = {}), typeof ne != "string" && typeof ne != "number" && !A.isBN(ne)) {
      L(
        typeof ne == "object" && ne && typeof ne.length == "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      ), L(ne.length >>> 0 === ne.length);
      for (var ot = 0; ot < ne.length; ot++) L((ne[ot] & 255) === ne[ot]);
    }
    pe = this.keyFromPrivate(pe, rt), ne = this._truncateToN(ne, !1, nt.msgBitLength), L(!ne.isNeg(), "Can not sign a negative message");
    var ut = this.n.byteLength(), dt = pe.getPrivate().toArray("be", ut), vt = ne.toArray("be", ut);
    L(new A(vt).eq(ne), "Can not sign message");
    for (var pt = new B({
      hash: this.hash,
      entropy: dt,
      nonce: vt,
      pers: nt.pers,
      persEnc: nt.persEnc || "utf8"
    }), mt = this.n.sub(new A(1)), gt = 0; ; gt++) {
      var Pt = nt.k ? nt.k(gt) : new A(pt.generate(this.n.byteLength()));
      if (Pt = this._truncateToN(Pt, !0), !(Pt.cmpn(1) <= 0 || Pt.cmp(mt) >= 0)) {
        var xt = this.g.mul(Pt);
        if (!xt.isInfinity()) {
          var Nt = xt.getX(), Et = Nt.umod(this.n);
          if (Et.cmpn(0) !== 0) {
            var bt = Pt.invm(this.n).mul(Et.mul(pe.getPrivate()).iadd(ne));
            if (bt = bt.umod(this.n), bt.cmpn(0) !== 0) {
              var Bt = (xt.getY().isOdd() ? 1 : 0) | (Nt.cmp(Et) !== 0 ? 2 : 0);
              return nt.canonical && bt.cmp(this.nh) > 0 && (bt = this.n.sub(bt), Bt ^= 1), new ie({ r: Et, s: bt, recoveryParam: Bt });
            }
          }
        }
      }
    }
  }, oe.prototype.verify = function(ne, pe, rt, nt, ot) {
    ot || (ot = {}), ne = this._truncateToN(ne, !1, ot.msgBitLength), rt = this.keyFromPublic(rt, nt), pe = new ie(pe, "hex");
    var ut = pe.r, dt = pe.s;
    if (ut.cmpn(1) < 0 || ut.cmp(this.n) >= 0 || dt.cmpn(1) < 0 || dt.cmp(this.n) >= 0)
      return !1;
    var vt = dt.invm(this.n), pt = vt.mul(ne).umod(this.n), mt = vt.mul(ut).umod(this.n), gt;
    return this.curve._maxwellTrick ? (gt = this.g.jmulAdd(pt, rt.getPublic(), mt), gt.isInfinity() ? !1 : gt.eqXToP(ut)) : (gt = this.g.mulAdd(pt, rt.getPublic(), mt), gt.isInfinity() ? !1 : gt.getX().umod(this.n).cmp(ut) === 0);
  }, oe.prototype.recoverPubKey = function(ke, ne, pe, rt) {
    L((3 & pe) === pe, "The recovery param is more than two bits"), ne = new ie(ne, rt);
    var nt = this.n, ot = new A(ke), ut = ne.r, dt = ne.s, vt = pe & 1, pt = pe >> 1;
    if (ut.cmp(this.curve.p.umod(this.curve.n)) >= 0 && pt)
      throw new Error("Unable to find sencond key candinate");
    pt ? ut = this.curve.pointFromX(ut.add(this.curve.n), vt) : ut = this.curve.pointFromX(ut, vt);
    var mt = ne.r.invm(nt), gt = nt.sub(ot).mul(mt).umod(nt), Pt = dt.mul(mt).umod(nt);
    return this.g.mulAdd(gt, ut, Pt);
  }, oe.prototype.getKeyRecoveryParam = function(ke, ne, pe, rt) {
    if (ne = new ie(ne, rt), ne.recoveryParam !== null)
      return ne.recoveryParam;
    for (var nt = 0; nt < 4; nt++) {
      var ot;
      try {
        ot = this.recoverPubKey(ke, ne, nt);
      } catch {
        continue;
      }
      if (ot.eq(pe))
        return nt;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var key, hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  var A = requireUtils$1(), B = A.assert, W = A.parseBytes, K = A.cachedProperty;
  function J(L, re) {
    this.eddsa = L, this._secret = W(re.secret), L.isPoint(re.pub) ? this._pub = re.pub : this._pubBytes = W(re.pub);
  }
  return J.fromPublic = function(re, ie) {
    return ie instanceof J ? ie : new J(re, { pub: ie });
  }, J.fromSecret = function(re, ie) {
    return ie instanceof J ? ie : new J(re, { secret: ie });
  }, J.prototype.secret = function() {
    return this._secret;
  }, K(J, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), K(J, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), K(J, "privBytes", function() {
    var re = this.eddsa, ie = this.hash(), oe = re.encodingLength - 1, ke = ie.slice(0, re.encodingLength);
    return ke[0] &= 248, ke[oe] &= 127, ke[oe] |= 64, ke;
  }), K(J, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), K(J, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), K(J, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), J.prototype.sign = function(re) {
    return B(this._secret, "KeyPair can only verify"), this.eddsa.sign(re, this);
  }, J.prototype.verify = function(re, ie) {
    return this.eddsa.verify(re, ie, this);
  }, J.prototype.getSecret = function(re) {
    return B(this._secret, "KeyPair is public only"), A.encode(this.secret(), re);
  }, J.prototype.getPublic = function(re) {
    return A.encode(this.pubBytes(), re);
  }, key = J, key;
}
var signature, hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  var A = requireBn$2(), B = requireUtils$1(), W = B.assert, K = B.cachedProperty, J = B.parseBytes;
  function L(re, ie) {
    this.eddsa = re, typeof ie != "object" && (ie = J(ie)), Array.isArray(ie) && (W(ie.length === re.encodingLength * 2, "Signature has invalid size"), ie = {
      R: ie.slice(0, re.encodingLength),
      S: ie.slice(re.encodingLength)
    }), W(ie.R && ie.S, "Signature without R or S"), re.isPoint(ie.R) && (this._R = ie.R), ie.S instanceof A && (this._S = ie.S), this._Rencoded = Array.isArray(ie.R) ? ie.R : ie.Rencoded, this._Sencoded = Array.isArray(ie.S) ? ie.S : ie.Sencoded;
  }
  return K(L, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), K(L, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), K(L, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), K(L, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), L.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, L.prototype.toHex = function() {
    return B.encode(this.toBytes(), "hex").toUpperCase();
  }, signature = L, signature;
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa) return eddsa;
  hasRequiredEddsa = 1;
  var A = requireHash(), B = requireCurves(), W = requireUtils$1(), K = W.assert, J = W.parseBytes, L = requireKey(), re = requireSignature();
  function ie(oe) {
    if (K(oe === "ed25519", "only tested with ed25519 so far"), !(this instanceof ie))
      return new ie(oe);
    oe = B[oe].curve, this.curve = oe, this.g = oe.g, this.g.precompute(oe.n.bitLength() + 1), this.pointClass = oe.point().constructor, this.encodingLength = Math.ceil(oe.n.bitLength() / 8), this.hash = A.sha512;
  }
  return eddsa = ie, ie.prototype.sign = function(ke, ne) {
    ke = J(ke);
    var pe = this.keyFromSecret(ne), rt = this.hashInt(pe.messagePrefix(), ke), nt = this.g.mul(rt), ot = this.encodePoint(nt), ut = this.hashInt(ot, pe.pubBytes(), ke).mul(pe.priv()), dt = rt.add(ut).umod(this.curve.n);
    return this.makeSignature({ R: nt, S: dt, Rencoded: ot });
  }, ie.prototype.verify = function(ke, ne, pe) {
    if (ke = J(ke), ne = this.makeSignature(ne), ne.S().gte(ne.eddsa.curve.n) || ne.S().isNeg())
      return !1;
    var rt = this.keyFromPublic(pe), nt = this.hashInt(ne.Rencoded(), rt.pubBytes(), ke), ot = this.g.mul(ne.S()), ut = ne.R().add(rt.pub().mul(nt));
    return ut.eq(ot);
  }, ie.prototype.hashInt = function() {
    for (var ke = this.hash(), ne = 0; ne < arguments.length; ne++)
      ke.update(arguments[ne]);
    return W.intFromLE(ke.digest()).umod(this.curve.n);
  }, ie.prototype.keyFromPublic = function(ke) {
    return L.fromPublic(this, ke);
  }, ie.prototype.keyFromSecret = function(ke) {
    return L.fromSecret(this, ke);
  }, ie.prototype.makeSignature = function(ke) {
    return ke instanceof re ? ke : new re(this, ke);
  }, ie.prototype.encodePoint = function(ke) {
    var ne = ke.getY().toArray("le", this.encodingLength);
    return ne[this.encodingLength - 1] |= ke.getX().isOdd() ? 128 : 0, ne;
  }, ie.prototype.decodePoint = function(ke) {
    ke = W.parseBytes(ke);
    var ne = ke.length - 1, pe = ke.slice(0, ne).concat(ke[ne] & -129), rt = (ke[ne] & 128) !== 0, nt = W.intFromLE(pe);
    return this.curve.pointFromY(nt, rt);
  }, ie.prototype.encodeInt = function(ke) {
    return ke.toArray("le", this.encodingLength);
  }, ie.prototype.decodeInt = function(ke) {
    return W.intFromLE(ke);
  }, ie.prototype.isPoint = function(ke) {
    return ke instanceof this.pointClass;
  }, eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(A) {
    var B = A;
    B.version = require$$0.version, B.utils = requireUtils$1(), B.rand = requireBrorand(), B.curve = requireCurve(), B.curves = requireCurves(), B.ec = requireEc(), B.eddsa = requireEddsa();
  }(elliptic)), elliptic;
}
var bn = { exports: {} };
bn.exports;
var hasRequiredBn;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, function(A) {
    (function(B, W) {
      function K(Oe, V) {
        if (!Oe) throw new Error(V || "Assertion failed");
      }
      function J(Oe, V) {
        Oe.super_ = V;
        var ce = function() {
        };
        ce.prototype = V.prototype, Oe.prototype = new ce(), Oe.prototype.constructor = Oe;
      }
      function L(Oe, V, ce) {
        if (L.isBN(Oe))
          return Oe;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, Oe !== null && ((V === "le" || V === "be") && (ce = V, V = 10), this._init(Oe || 0, V || 10, ce || "be"));
      }
      typeof B == "object" ? B.exports = L : W.BN = L, L.BN = L, L.wordSize = 26;
      var re;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? re = window.Buffer : re = require$$0$1.Buffer;
      } catch {
      }
      L.isBN = function(V) {
        return V instanceof L ? !0 : V !== null && typeof V == "object" && V.constructor.wordSize === L.wordSize && Array.isArray(V.words);
      }, L.max = function(V, ce) {
        return V.cmp(ce) > 0 ? V : ce;
      }, L.min = function(V, ce) {
        return V.cmp(ce) < 0 ? V : ce;
      }, L.prototype._init = function(V, ce, it) {
        if (typeof V == "number")
          return this._initNumber(V, ce, it);
        if (typeof V == "object")
          return this._initArray(V, ce, it);
        ce === "hex" && (ce = 16), K(ce === (ce | 0) && ce >= 2 && ce <= 36), V = V.toString().replace(/\s+/g, "");
        var at = 0;
        V[0] === "-" && (at++, this.negative = 1), at < V.length && (ce === 16 ? this._parseHex(V, at, it) : (this._parseBase(V, ce, at), it === "le" && this._initArray(this.toArray(), ce, it)));
      }, L.prototype._initNumber = function(V, ce, it) {
        V < 0 && (this.negative = 1, V = -V), V < 67108864 ? (this.words = [V & 67108863], this.length = 1) : V < 4503599627370496 ? (this.words = [
          V & 67108863,
          V / 67108864 & 67108863
        ], this.length = 2) : (K(V < 9007199254740992), this.words = [
          V & 67108863,
          V / 67108864 & 67108863,
          1
        ], this.length = 3), it === "le" && this._initArray(this.toArray(), ce, it);
      }, L.prototype._initArray = function(V, ce, it) {
        if (K(typeof V.length == "number"), V.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(V.length / 3), this.words = new Array(this.length);
        for (var at = 0; at < this.length; at++)
          this.words[at] = 0;
        var ft, lt, ct = 0;
        if (it === "be")
          for (at = V.length - 1, ft = 0; at >= 0; at -= 3)
            lt = V[at] | V[at - 1] << 8 | V[at - 2] << 16, this.words[ft] |= lt << ct & 67108863, this.words[ft + 1] = lt >>> 26 - ct & 67108863, ct += 24, ct >= 26 && (ct -= 26, ft++);
        else if (it === "le")
          for (at = 0, ft = 0; at < V.length; at += 3)
            lt = V[at] | V[at + 1] << 8 | V[at + 2] << 16, this.words[ft] |= lt << ct & 67108863, this.words[ft + 1] = lt >>> 26 - ct & 67108863, ct += 24, ct >= 26 && (ct -= 26, ft++);
        return this._strip();
      };
      function ie(Oe, V) {
        var ce = Oe.charCodeAt(V);
        if (ce >= 48 && ce <= 57)
          return ce - 48;
        if (ce >= 65 && ce <= 70)
          return ce - 55;
        if (ce >= 97 && ce <= 102)
          return ce - 87;
        K(!1, "Invalid character in " + Oe);
      }
      function oe(Oe, V, ce) {
        var it = ie(Oe, ce);
        return ce - 1 >= V && (it |= ie(Oe, ce - 1) << 4), it;
      }
      L.prototype._parseHex = function(V, ce, it) {
        this.length = Math.ceil((V.length - ce) / 6), this.words = new Array(this.length);
        for (var at = 0; at < this.length; at++)
          this.words[at] = 0;
        var ft = 0, lt = 0, ct;
        if (it === "be")
          for (at = V.length - 1; at >= ce; at -= 2)
            ct = oe(V, ce, at) << ft, this.words[lt] |= ct & 67108863, ft >= 18 ? (ft -= 18, lt += 1, this.words[lt] |= ct >>> 26) : ft += 8;
        else {
          var ht = V.length - ce;
          for (at = ht % 2 === 0 ? ce + 1 : ce; at < V.length; at += 2)
            ct = oe(V, ce, at) << ft, this.words[lt] |= ct & 67108863, ft >= 18 ? (ft -= 18, lt += 1, this.words[lt] |= ct >>> 26) : ft += 8;
        }
        this._strip();
      };
      function ke(Oe, V, ce, it) {
        for (var at = 0, ft = 0, lt = Math.min(Oe.length, ce), ct = V; ct < lt; ct++) {
          var ht = Oe.charCodeAt(ct) - 48;
          at *= it, ht >= 49 ? ft = ht - 49 + 10 : ht >= 17 ? ft = ht - 17 + 10 : ft = ht, K(ht >= 0 && ft < it, "Invalid character"), at += ft;
        }
        return at;
      }
      L.prototype._parseBase = function(V, ce, it) {
        this.words = [0], this.length = 1;
        for (var at = 0, ft = 1; ft <= 67108863; ft *= ce)
          at++;
        at--, ft = ft / ce | 0;
        for (var lt = V.length - it, ct = lt % at, ht = Math.min(lt, lt - ct) + it, Ce = 0, yt = it; yt < ht; yt += at)
          Ce = ke(V, yt, yt + at, ce), this.imuln(ft), this.words[0] + Ce < 67108864 ? this.words[0] += Ce : this._iaddn(Ce);
        if (ct !== 0) {
          var qt = 1;
          for (Ce = ke(V, yt, V.length, ce), yt = 0; yt < ct; yt++)
            qt *= ce;
          this.imuln(qt), this.words[0] + Ce < 67108864 ? this.words[0] += Ce : this._iaddn(Ce);
        }
        this._strip();
      }, L.prototype.copy = function(V) {
        V.words = new Array(this.length);
        for (var ce = 0; ce < this.length; ce++)
          V.words[ce] = this.words[ce];
        V.length = this.length, V.negative = this.negative, V.red = this.red;
      };
      function ne(Oe, V) {
        Oe.words = V.words, Oe.length = V.length, Oe.negative = V.negative, Oe.red = V.red;
      }
      if (L.prototype._move = function(V) {
        ne(V, this);
      }, L.prototype.clone = function() {
        var V = new L(null);
        return this.copy(V), V;
      }, L.prototype._expand = function(V) {
        for (; this.length < V; )
          this.words[this.length++] = 0;
        return this;
      }, L.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, L.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          L.prototype[Symbol.for("nodejs.util.inspect.custom")] = pe;
        } catch {
          L.prototype.inspect = pe;
        }
      else
        L.prototype.inspect = pe;
      function pe() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var rt = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], nt = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], ot = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      L.prototype.toString = function(V, ce) {
        V = V || 10, ce = ce | 0 || 1;
        var it;
        if (V === 16 || V === "hex") {
          it = "";
          for (var at = 0, ft = 0, lt = 0; lt < this.length; lt++) {
            var ct = this.words[lt], ht = ((ct << at | ft) & 16777215).toString(16);
            ft = ct >>> 24 - at & 16777215, at += 2, at >= 26 && (at -= 26, lt--), ft !== 0 || lt !== this.length - 1 ? it = rt[6 - ht.length] + ht + it : it = ht + it;
          }
          for (ft !== 0 && (it = ft.toString(16) + it); it.length % ce !== 0; )
            it = "0" + it;
          return this.negative !== 0 && (it = "-" + it), it;
        }
        if (V === (V | 0) && V >= 2 && V <= 36) {
          var Ce = nt[V], yt = ot[V];
          it = "";
          var qt = this.clone();
          for (qt.negative = 0; !qt.isZero(); ) {
            var jt = qt.modrn(yt).toString(V);
            qt = qt.idivn(yt), qt.isZero() ? it = jt + it : it = rt[Ce - jt.length] + jt + it;
          }
          for (this.isZero() && (it = "0" + it); it.length % ce !== 0; )
            it = "0" + it;
          return this.negative !== 0 && (it = "-" + it), it;
        }
        K(!1, "Base should be between 2 and 36");
      }, L.prototype.toNumber = function() {
        var V = this.words[0];
        return this.length === 2 ? V += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? V += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && K(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -V : V;
      }, L.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, re && (L.prototype.toBuffer = function(V, ce) {
        return this.toArrayLike(re, V, ce);
      }), L.prototype.toArray = function(V, ce) {
        return this.toArrayLike(Array, V, ce);
      };
      var ut = function(V, ce) {
        return V.allocUnsafe ? V.allocUnsafe(ce) : new V(ce);
      };
      L.prototype.toArrayLike = function(V, ce, it) {
        this._strip();
        var at = this.byteLength(), ft = it || Math.max(1, at);
        K(at <= ft, "byte array longer than desired length"), K(ft > 0, "Requested array length <= 0");
        var lt = ut(V, ft), ct = ce === "le" ? "LE" : "BE";
        return this["_toArrayLike" + ct](lt, at), lt;
      }, L.prototype._toArrayLikeLE = function(V, ce) {
        for (var it = 0, at = 0, ft = 0, lt = 0; ft < this.length; ft++) {
          var ct = this.words[ft] << lt | at;
          V[it++] = ct & 255, it < V.length && (V[it++] = ct >> 8 & 255), it < V.length && (V[it++] = ct >> 16 & 255), lt === 6 ? (it < V.length && (V[it++] = ct >> 24 & 255), at = 0, lt = 0) : (at = ct >>> 24, lt += 2);
        }
        if (it < V.length)
          for (V[it++] = at; it < V.length; )
            V[it++] = 0;
      }, L.prototype._toArrayLikeBE = function(V, ce) {
        for (var it = V.length - 1, at = 0, ft = 0, lt = 0; ft < this.length; ft++) {
          var ct = this.words[ft] << lt | at;
          V[it--] = ct & 255, it >= 0 && (V[it--] = ct >> 8 & 255), it >= 0 && (V[it--] = ct >> 16 & 255), lt === 6 ? (it >= 0 && (V[it--] = ct >> 24 & 255), at = 0, lt = 0) : (at = ct >>> 24, lt += 2);
        }
        if (it >= 0)
          for (V[it--] = at; it >= 0; )
            V[it--] = 0;
      }, Math.clz32 ? L.prototype._countBits = function(V) {
        return 32 - Math.clz32(V);
      } : L.prototype._countBits = function(V) {
        var ce = V, it = 0;
        return ce >= 4096 && (it += 13, ce >>>= 13), ce >= 64 && (it += 7, ce >>>= 7), ce >= 8 && (it += 4, ce >>>= 4), ce >= 2 && (it += 2, ce >>>= 2), it + ce;
      }, L.prototype._zeroBits = function(V) {
        if (V === 0) return 26;
        var ce = V, it = 0;
        return ce & 8191 || (it += 13, ce >>>= 13), ce & 127 || (it += 7, ce >>>= 7), ce & 15 || (it += 4, ce >>>= 4), ce & 3 || (it += 2, ce >>>= 2), ce & 1 || it++, it;
      }, L.prototype.bitLength = function() {
        var V = this.words[this.length - 1], ce = this._countBits(V);
        return (this.length - 1) * 26 + ce;
      };
      function dt(Oe) {
        for (var V = new Array(Oe.bitLength()), ce = 0; ce < V.length; ce++) {
          var it = ce / 26 | 0, at = ce % 26;
          V[ce] = Oe.words[it] >>> at & 1;
        }
        return V;
      }
      L.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var V = 0, ce = 0; ce < this.length; ce++) {
          var it = this._zeroBits(this.words[ce]);
          if (V += it, it !== 26) break;
        }
        return V;
      }, L.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, L.prototype.toTwos = function(V) {
        return this.negative !== 0 ? this.abs().inotn(V).iaddn(1) : this.clone();
      }, L.prototype.fromTwos = function(V) {
        return this.testn(V - 1) ? this.notn(V).iaddn(1).ineg() : this.clone();
      }, L.prototype.isNeg = function() {
        return this.negative !== 0;
      }, L.prototype.neg = function() {
        return this.clone().ineg();
      }, L.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, L.prototype.iuor = function(V) {
        for (; this.length < V.length; )
          this.words[this.length++] = 0;
        for (var ce = 0; ce < V.length; ce++)
          this.words[ce] = this.words[ce] | V.words[ce];
        return this._strip();
      }, L.prototype.ior = function(V) {
        return K((this.negative | V.negative) === 0), this.iuor(V);
      }, L.prototype.or = function(V) {
        return this.length > V.length ? this.clone().ior(V) : V.clone().ior(this);
      }, L.prototype.uor = function(V) {
        return this.length > V.length ? this.clone().iuor(V) : V.clone().iuor(this);
      }, L.prototype.iuand = function(V) {
        var ce;
        this.length > V.length ? ce = V : ce = this;
        for (var it = 0; it < ce.length; it++)
          this.words[it] = this.words[it] & V.words[it];
        return this.length = ce.length, this._strip();
      }, L.prototype.iand = function(V) {
        return K((this.negative | V.negative) === 0), this.iuand(V);
      }, L.prototype.and = function(V) {
        return this.length > V.length ? this.clone().iand(V) : V.clone().iand(this);
      }, L.prototype.uand = function(V) {
        return this.length > V.length ? this.clone().iuand(V) : V.clone().iuand(this);
      }, L.prototype.iuxor = function(V) {
        var ce, it;
        this.length > V.length ? (ce = this, it = V) : (ce = V, it = this);
        for (var at = 0; at < it.length; at++)
          this.words[at] = ce.words[at] ^ it.words[at];
        if (this !== ce)
          for (; at < ce.length; at++)
            this.words[at] = ce.words[at];
        return this.length = ce.length, this._strip();
      }, L.prototype.ixor = function(V) {
        return K((this.negative | V.negative) === 0), this.iuxor(V);
      }, L.prototype.xor = function(V) {
        return this.length > V.length ? this.clone().ixor(V) : V.clone().ixor(this);
      }, L.prototype.uxor = function(V) {
        return this.length > V.length ? this.clone().iuxor(V) : V.clone().iuxor(this);
      }, L.prototype.inotn = function(V) {
        K(typeof V == "number" && V >= 0);
        var ce = Math.ceil(V / 26) | 0, it = V % 26;
        this._expand(ce), it > 0 && ce--;
        for (var at = 0; at < ce; at++)
          this.words[at] = ~this.words[at] & 67108863;
        return it > 0 && (this.words[at] = ~this.words[at] & 67108863 >> 26 - it), this._strip();
      }, L.prototype.notn = function(V) {
        return this.clone().inotn(V);
      }, L.prototype.setn = function(V, ce) {
        K(typeof V == "number" && V >= 0);
        var it = V / 26 | 0, at = V % 26;
        return this._expand(it + 1), ce ? this.words[it] = this.words[it] | 1 << at : this.words[it] = this.words[it] & ~(1 << at), this._strip();
      }, L.prototype.iadd = function(V) {
        var ce;
        if (this.negative !== 0 && V.negative === 0)
          return this.negative = 0, ce = this.isub(V), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && V.negative !== 0)
          return V.negative = 0, ce = this.isub(V), V.negative = 1, ce._normSign();
        var it, at;
        this.length > V.length ? (it = this, at = V) : (it = V, at = this);
        for (var ft = 0, lt = 0; lt < at.length; lt++)
          ce = (it.words[lt] | 0) + (at.words[lt] | 0) + ft, this.words[lt] = ce & 67108863, ft = ce >>> 26;
        for (; ft !== 0 && lt < it.length; lt++)
          ce = (it.words[lt] | 0) + ft, this.words[lt] = ce & 67108863, ft = ce >>> 26;
        if (this.length = it.length, ft !== 0)
          this.words[this.length] = ft, this.length++;
        else if (it !== this)
          for (; lt < it.length; lt++)
            this.words[lt] = it.words[lt];
        return this;
      }, L.prototype.add = function(V) {
        var ce;
        return V.negative !== 0 && this.negative === 0 ? (V.negative = 0, ce = this.sub(V), V.negative ^= 1, ce) : V.negative === 0 && this.negative !== 0 ? (this.negative = 0, ce = V.sub(this), this.negative = 1, ce) : this.length > V.length ? this.clone().iadd(V) : V.clone().iadd(this);
      }, L.prototype.isub = function(V) {
        if (V.negative !== 0) {
          V.negative = 0;
          var ce = this.iadd(V);
          return V.negative = 1, ce._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(V), this.negative = 1, this._normSign();
        var it = this.cmp(V);
        if (it === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var at, ft;
        it > 0 ? (at = this, ft = V) : (at = V, ft = this);
        for (var lt = 0, ct = 0; ct < ft.length; ct++)
          ce = (at.words[ct] | 0) - (ft.words[ct] | 0) + lt, lt = ce >> 26, this.words[ct] = ce & 67108863;
        for (; lt !== 0 && ct < at.length; ct++)
          ce = (at.words[ct] | 0) + lt, lt = ce >> 26, this.words[ct] = ce & 67108863;
        if (lt === 0 && ct < at.length && at !== this)
          for (; ct < at.length; ct++)
            this.words[ct] = at.words[ct];
        return this.length = Math.max(this.length, ct), at !== this && (this.negative = 1), this._strip();
      }, L.prototype.sub = function(V) {
        return this.clone().isub(V);
      };
      function vt(Oe, V, ce) {
        ce.negative = V.negative ^ Oe.negative;
        var it = Oe.length + V.length | 0;
        ce.length = it, it = it - 1 | 0;
        var at = Oe.words[0] | 0, ft = V.words[0] | 0, lt = at * ft, ct = lt & 67108863, ht = lt / 67108864 | 0;
        ce.words[0] = ct;
        for (var Ce = 1; Ce < it; Ce++) {
          for (var yt = ht >>> 26, qt = ht & 67108863, jt = Math.min(Ce, V.length - 1), kt = Math.max(0, Ce - Oe.length + 1); kt <= jt; kt++) {
            var $t = Ce - kt | 0;
            at = Oe.words[$t] | 0, ft = V.words[kt] | 0, lt = at * ft + qt, yt += lt / 67108864 | 0, qt = lt & 67108863;
          }
          ce.words[Ce] = qt | 0, ht = yt | 0;
        }
        return ht !== 0 ? ce.words[Ce] = ht | 0 : ce.length--, ce._strip();
      }
      var pt = function(V, ce, it) {
        var at = V.words, ft = ce.words, lt = it.words, ct = 0, ht, Ce, yt, qt = at[0] | 0, jt = qt & 8191, kt = qt >>> 13, $t = at[1] | 0, Mt = $t & 8191, Lt = $t >>> 13, Kt = at[2] | 0, Tt = Kt & 8191, Rt = Kt >>> 13, Wt = at[3] | 0, Xt = Wt & 8191, Zt = Wt >>> 13, ar = at[4] | 0, fr = ar & 8191, lr = ar >>> 13, Jt = at[5] | 0, _r = Jt & 8191, sr = Jt >>> 13, Mr = at[6] | 0, Sr = Mr & 8191, cr = Mr >>> 13, Br = at[7] | 0, $r = Br & 8191, yr = Br >>> 13, kr = at[8] | 0, Tr = kr & 8191, It = kr >>> 13, St = at[9] | 0, At = St & 8191, Ot = St >>> 13, Gt = ft[0] | 0, zt = Gt & 8191, Vt = Gt >>> 13, Er = ft[1] | 0, wr = Er & 8191, hr = Er >>> 13, Pr = ft[2] | 0, gr = Pr & 8191, vr = Pr >>> 13, qr = ft[3] | 0, Ir = qr & 8191, Ut = qr >>> 13, Ct = ft[4] | 0, Dt = Ct & 8191, Ht = Ct >>> 13, Yt = ft[5] | 0, Qt = Yt & 8191, er = Yt >>> 13, or = ft[6] | 0, ur = or & 8191, ir = or >>> 13, Ar = ft[7] | 0, pr = Ar & 8191, Ft = Ar >>> 13, tr = ft[8] | 0, rr = tr & 8191, nr = tr >>> 13, xr = ft[9] | 0, br = xr & 8191, dr = xr >>> 13;
        it.negative = V.negative ^ ce.negative, it.length = 19, ht = Math.imul(jt, zt), Ce = Math.imul(jt, Vt), Ce = Ce + Math.imul(kt, zt) | 0, yt = Math.imul(kt, Vt);
        var Rr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, ht = Math.imul(Mt, zt), Ce = Math.imul(Mt, Vt), Ce = Ce + Math.imul(Lt, zt) | 0, yt = Math.imul(Lt, Vt), ht = ht + Math.imul(jt, wr) | 0, Ce = Ce + Math.imul(jt, hr) | 0, Ce = Ce + Math.imul(kt, wr) | 0, yt = yt + Math.imul(kt, hr) | 0;
        var Nr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, ht = Math.imul(Tt, zt), Ce = Math.imul(Tt, Vt), Ce = Ce + Math.imul(Rt, zt) | 0, yt = Math.imul(Rt, Vt), ht = ht + Math.imul(Mt, wr) | 0, Ce = Ce + Math.imul(Mt, hr) | 0, Ce = Ce + Math.imul(Lt, wr) | 0, yt = yt + Math.imul(Lt, hr) | 0, ht = ht + Math.imul(jt, gr) | 0, Ce = Ce + Math.imul(jt, vr) | 0, Ce = Ce + Math.imul(kt, gr) | 0, yt = yt + Math.imul(kt, vr) | 0;
        var Or = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Or >>> 26) | 0, Or &= 67108863, ht = Math.imul(Xt, zt), Ce = Math.imul(Xt, Vt), Ce = Ce + Math.imul(Zt, zt) | 0, yt = Math.imul(Zt, Vt), ht = ht + Math.imul(Tt, wr) | 0, Ce = Ce + Math.imul(Tt, hr) | 0, Ce = Ce + Math.imul(Rt, wr) | 0, yt = yt + Math.imul(Rt, hr) | 0, ht = ht + Math.imul(Mt, gr) | 0, Ce = Ce + Math.imul(Mt, vr) | 0, Ce = Ce + Math.imul(Lt, gr) | 0, yt = yt + Math.imul(Lt, vr) | 0, ht = ht + Math.imul(jt, Ir) | 0, Ce = Ce + Math.imul(jt, Ut) | 0, Ce = Ce + Math.imul(kt, Ir) | 0, yt = yt + Math.imul(kt, Ut) | 0;
        var Cr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Cr >>> 26) | 0, Cr &= 67108863, ht = Math.imul(fr, zt), Ce = Math.imul(fr, Vt), Ce = Ce + Math.imul(lr, zt) | 0, yt = Math.imul(lr, Vt), ht = ht + Math.imul(Xt, wr) | 0, Ce = Ce + Math.imul(Xt, hr) | 0, Ce = Ce + Math.imul(Zt, wr) | 0, yt = yt + Math.imul(Zt, hr) | 0, ht = ht + Math.imul(Tt, gr) | 0, Ce = Ce + Math.imul(Tt, vr) | 0, Ce = Ce + Math.imul(Rt, gr) | 0, yt = yt + Math.imul(Rt, vr) | 0, ht = ht + Math.imul(Mt, Ir) | 0, Ce = Ce + Math.imul(Mt, Ut) | 0, Ce = Ce + Math.imul(Lt, Ir) | 0, yt = yt + Math.imul(Lt, Ut) | 0, ht = ht + Math.imul(jt, Dt) | 0, Ce = Ce + Math.imul(jt, Ht) | 0, Ce = Ce + Math.imul(kt, Dt) | 0, yt = yt + Math.imul(kt, Ht) | 0;
        var Lr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, ht = Math.imul(_r, zt), Ce = Math.imul(_r, Vt), Ce = Ce + Math.imul(sr, zt) | 0, yt = Math.imul(sr, Vt), ht = ht + Math.imul(fr, wr) | 0, Ce = Ce + Math.imul(fr, hr) | 0, Ce = Ce + Math.imul(lr, wr) | 0, yt = yt + Math.imul(lr, hr) | 0, ht = ht + Math.imul(Xt, gr) | 0, Ce = Ce + Math.imul(Xt, vr) | 0, Ce = Ce + Math.imul(Zt, gr) | 0, yt = yt + Math.imul(Zt, vr) | 0, ht = ht + Math.imul(Tt, Ir) | 0, Ce = Ce + Math.imul(Tt, Ut) | 0, Ce = Ce + Math.imul(Rt, Ir) | 0, yt = yt + Math.imul(Rt, Ut) | 0, ht = ht + Math.imul(Mt, Dt) | 0, Ce = Ce + Math.imul(Mt, Ht) | 0, Ce = Ce + Math.imul(Lt, Dt) | 0, yt = yt + Math.imul(Lt, Ht) | 0, ht = ht + Math.imul(jt, Qt) | 0, Ce = Ce + Math.imul(jt, er) | 0, Ce = Ce + Math.imul(kt, Qt) | 0, yt = yt + Math.imul(kt, er) | 0;
        var Dr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, ht = Math.imul(Sr, zt), Ce = Math.imul(Sr, Vt), Ce = Ce + Math.imul(cr, zt) | 0, yt = Math.imul(cr, Vt), ht = ht + Math.imul(_r, wr) | 0, Ce = Ce + Math.imul(_r, hr) | 0, Ce = Ce + Math.imul(sr, wr) | 0, yt = yt + Math.imul(sr, hr) | 0, ht = ht + Math.imul(fr, gr) | 0, Ce = Ce + Math.imul(fr, vr) | 0, Ce = Ce + Math.imul(lr, gr) | 0, yt = yt + Math.imul(lr, vr) | 0, ht = ht + Math.imul(Xt, Ir) | 0, Ce = Ce + Math.imul(Xt, Ut) | 0, Ce = Ce + Math.imul(Zt, Ir) | 0, yt = yt + Math.imul(Zt, Ut) | 0, ht = ht + Math.imul(Tt, Dt) | 0, Ce = Ce + Math.imul(Tt, Ht) | 0, Ce = Ce + Math.imul(Rt, Dt) | 0, yt = yt + Math.imul(Rt, Ht) | 0, ht = ht + Math.imul(Mt, Qt) | 0, Ce = Ce + Math.imul(Mt, er) | 0, Ce = Ce + Math.imul(Lt, Qt) | 0, yt = yt + Math.imul(Lt, er) | 0, ht = ht + Math.imul(jt, ur) | 0, Ce = Ce + Math.imul(jt, ir) | 0, Ce = Ce + Math.imul(kt, ur) | 0, yt = yt + Math.imul(kt, ir) | 0;
        var Ur = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, ht = Math.imul($r, zt), Ce = Math.imul($r, Vt), Ce = Ce + Math.imul(yr, zt) | 0, yt = Math.imul(yr, Vt), ht = ht + Math.imul(Sr, wr) | 0, Ce = Ce + Math.imul(Sr, hr) | 0, Ce = Ce + Math.imul(cr, wr) | 0, yt = yt + Math.imul(cr, hr) | 0, ht = ht + Math.imul(_r, gr) | 0, Ce = Ce + Math.imul(_r, vr) | 0, Ce = Ce + Math.imul(sr, gr) | 0, yt = yt + Math.imul(sr, vr) | 0, ht = ht + Math.imul(fr, Ir) | 0, Ce = Ce + Math.imul(fr, Ut) | 0, Ce = Ce + Math.imul(lr, Ir) | 0, yt = yt + Math.imul(lr, Ut) | 0, ht = ht + Math.imul(Xt, Dt) | 0, Ce = Ce + Math.imul(Xt, Ht) | 0, Ce = Ce + Math.imul(Zt, Dt) | 0, yt = yt + Math.imul(Zt, Ht) | 0, ht = ht + Math.imul(Tt, Qt) | 0, Ce = Ce + Math.imul(Tt, er) | 0, Ce = Ce + Math.imul(Rt, Qt) | 0, yt = yt + Math.imul(Rt, er) | 0, ht = ht + Math.imul(Mt, ur) | 0, Ce = Ce + Math.imul(Mt, ir) | 0, Ce = Ce + Math.imul(Lt, ur) | 0, yt = yt + Math.imul(Lt, ir) | 0, ht = ht + Math.imul(jt, pr) | 0, Ce = Ce + Math.imul(jt, Ft) | 0, Ce = Ce + Math.imul(kt, pr) | 0, yt = yt + Math.imul(kt, Ft) | 0;
        var Fr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, ht = Math.imul(Tr, zt), Ce = Math.imul(Tr, Vt), Ce = Ce + Math.imul(It, zt) | 0, yt = Math.imul(It, Vt), ht = ht + Math.imul($r, wr) | 0, Ce = Ce + Math.imul($r, hr) | 0, Ce = Ce + Math.imul(yr, wr) | 0, yt = yt + Math.imul(yr, hr) | 0, ht = ht + Math.imul(Sr, gr) | 0, Ce = Ce + Math.imul(Sr, vr) | 0, Ce = Ce + Math.imul(cr, gr) | 0, yt = yt + Math.imul(cr, vr) | 0, ht = ht + Math.imul(_r, Ir) | 0, Ce = Ce + Math.imul(_r, Ut) | 0, Ce = Ce + Math.imul(sr, Ir) | 0, yt = yt + Math.imul(sr, Ut) | 0, ht = ht + Math.imul(fr, Dt) | 0, Ce = Ce + Math.imul(fr, Ht) | 0, Ce = Ce + Math.imul(lr, Dt) | 0, yt = yt + Math.imul(lr, Ht) | 0, ht = ht + Math.imul(Xt, Qt) | 0, Ce = Ce + Math.imul(Xt, er) | 0, Ce = Ce + Math.imul(Zt, Qt) | 0, yt = yt + Math.imul(Zt, er) | 0, ht = ht + Math.imul(Tt, ur) | 0, Ce = Ce + Math.imul(Tt, ir) | 0, Ce = Ce + Math.imul(Rt, ur) | 0, yt = yt + Math.imul(Rt, ir) | 0, ht = ht + Math.imul(Mt, pr) | 0, Ce = Ce + Math.imul(Mt, Ft) | 0, Ce = Ce + Math.imul(Lt, pr) | 0, yt = yt + Math.imul(Lt, Ft) | 0, ht = ht + Math.imul(jt, rr) | 0, Ce = Ce + Math.imul(jt, nr) | 0, Ce = Ce + Math.imul(kt, rr) | 0, yt = yt + Math.imul(kt, nr) | 0;
        var jr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, ht = Math.imul(At, zt), Ce = Math.imul(At, Vt), Ce = Ce + Math.imul(Ot, zt) | 0, yt = Math.imul(Ot, Vt), ht = ht + Math.imul(Tr, wr) | 0, Ce = Ce + Math.imul(Tr, hr) | 0, Ce = Ce + Math.imul(It, wr) | 0, yt = yt + Math.imul(It, hr) | 0, ht = ht + Math.imul($r, gr) | 0, Ce = Ce + Math.imul($r, vr) | 0, Ce = Ce + Math.imul(yr, gr) | 0, yt = yt + Math.imul(yr, vr) | 0, ht = ht + Math.imul(Sr, Ir) | 0, Ce = Ce + Math.imul(Sr, Ut) | 0, Ce = Ce + Math.imul(cr, Ir) | 0, yt = yt + Math.imul(cr, Ut) | 0, ht = ht + Math.imul(_r, Dt) | 0, Ce = Ce + Math.imul(_r, Ht) | 0, Ce = Ce + Math.imul(sr, Dt) | 0, yt = yt + Math.imul(sr, Ht) | 0, ht = ht + Math.imul(fr, Qt) | 0, Ce = Ce + Math.imul(fr, er) | 0, Ce = Ce + Math.imul(lr, Qt) | 0, yt = yt + Math.imul(lr, er) | 0, ht = ht + Math.imul(Xt, ur) | 0, Ce = Ce + Math.imul(Xt, ir) | 0, Ce = Ce + Math.imul(Zt, ur) | 0, yt = yt + Math.imul(Zt, ir) | 0, ht = ht + Math.imul(Tt, pr) | 0, Ce = Ce + Math.imul(Tt, Ft) | 0, Ce = Ce + Math.imul(Rt, pr) | 0, yt = yt + Math.imul(Rt, Ft) | 0, ht = ht + Math.imul(Mt, rr) | 0, Ce = Ce + Math.imul(Mt, nr) | 0, Ce = Ce + Math.imul(Lt, rr) | 0, yt = yt + Math.imul(Lt, nr) | 0, ht = ht + Math.imul(jt, br) | 0, Ce = Ce + Math.imul(jt, dr) | 0, Ce = Ce + Math.imul(kt, br) | 0, yt = yt + Math.imul(kt, dr) | 0;
        var Hr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, ht = Math.imul(At, wr), Ce = Math.imul(At, hr), Ce = Ce + Math.imul(Ot, wr) | 0, yt = Math.imul(Ot, hr), ht = ht + Math.imul(Tr, gr) | 0, Ce = Ce + Math.imul(Tr, vr) | 0, Ce = Ce + Math.imul(It, gr) | 0, yt = yt + Math.imul(It, vr) | 0, ht = ht + Math.imul($r, Ir) | 0, Ce = Ce + Math.imul($r, Ut) | 0, Ce = Ce + Math.imul(yr, Ir) | 0, yt = yt + Math.imul(yr, Ut) | 0, ht = ht + Math.imul(Sr, Dt) | 0, Ce = Ce + Math.imul(Sr, Ht) | 0, Ce = Ce + Math.imul(cr, Dt) | 0, yt = yt + Math.imul(cr, Ht) | 0, ht = ht + Math.imul(_r, Qt) | 0, Ce = Ce + Math.imul(_r, er) | 0, Ce = Ce + Math.imul(sr, Qt) | 0, yt = yt + Math.imul(sr, er) | 0, ht = ht + Math.imul(fr, ur) | 0, Ce = Ce + Math.imul(fr, ir) | 0, Ce = Ce + Math.imul(lr, ur) | 0, yt = yt + Math.imul(lr, ir) | 0, ht = ht + Math.imul(Xt, pr) | 0, Ce = Ce + Math.imul(Xt, Ft) | 0, Ce = Ce + Math.imul(Zt, pr) | 0, yt = yt + Math.imul(Zt, Ft) | 0, ht = ht + Math.imul(Tt, rr) | 0, Ce = Ce + Math.imul(Tt, nr) | 0, Ce = Ce + Math.imul(Rt, rr) | 0, yt = yt + Math.imul(Rt, nr) | 0, ht = ht + Math.imul(Mt, br) | 0, Ce = Ce + Math.imul(Mt, dr) | 0, Ce = Ce + Math.imul(Lt, br) | 0, yt = yt + Math.imul(Lt, dr) | 0;
        var Wr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, ht = Math.imul(At, gr), Ce = Math.imul(At, vr), Ce = Ce + Math.imul(Ot, gr) | 0, yt = Math.imul(Ot, vr), ht = ht + Math.imul(Tr, Ir) | 0, Ce = Ce + Math.imul(Tr, Ut) | 0, Ce = Ce + Math.imul(It, Ir) | 0, yt = yt + Math.imul(It, Ut) | 0, ht = ht + Math.imul($r, Dt) | 0, Ce = Ce + Math.imul($r, Ht) | 0, Ce = Ce + Math.imul(yr, Dt) | 0, yt = yt + Math.imul(yr, Ht) | 0, ht = ht + Math.imul(Sr, Qt) | 0, Ce = Ce + Math.imul(Sr, er) | 0, Ce = Ce + Math.imul(cr, Qt) | 0, yt = yt + Math.imul(cr, er) | 0, ht = ht + Math.imul(_r, ur) | 0, Ce = Ce + Math.imul(_r, ir) | 0, Ce = Ce + Math.imul(sr, ur) | 0, yt = yt + Math.imul(sr, ir) | 0, ht = ht + Math.imul(fr, pr) | 0, Ce = Ce + Math.imul(fr, Ft) | 0, Ce = Ce + Math.imul(lr, pr) | 0, yt = yt + Math.imul(lr, Ft) | 0, ht = ht + Math.imul(Xt, rr) | 0, Ce = Ce + Math.imul(Xt, nr) | 0, Ce = Ce + Math.imul(Zt, rr) | 0, yt = yt + Math.imul(Zt, nr) | 0, ht = ht + Math.imul(Tt, br) | 0, Ce = Ce + Math.imul(Tt, dr) | 0, Ce = Ce + Math.imul(Rt, br) | 0, yt = yt + Math.imul(Rt, dr) | 0;
        var Gr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, ht = Math.imul(At, Ir), Ce = Math.imul(At, Ut), Ce = Ce + Math.imul(Ot, Ir) | 0, yt = Math.imul(Ot, Ut), ht = ht + Math.imul(Tr, Dt) | 0, Ce = Ce + Math.imul(Tr, Ht) | 0, Ce = Ce + Math.imul(It, Dt) | 0, yt = yt + Math.imul(It, Ht) | 0, ht = ht + Math.imul($r, Qt) | 0, Ce = Ce + Math.imul($r, er) | 0, Ce = Ce + Math.imul(yr, Qt) | 0, yt = yt + Math.imul(yr, er) | 0, ht = ht + Math.imul(Sr, ur) | 0, Ce = Ce + Math.imul(Sr, ir) | 0, Ce = Ce + Math.imul(cr, ur) | 0, yt = yt + Math.imul(cr, ir) | 0, ht = ht + Math.imul(_r, pr) | 0, Ce = Ce + Math.imul(_r, Ft) | 0, Ce = Ce + Math.imul(sr, pr) | 0, yt = yt + Math.imul(sr, Ft) | 0, ht = ht + Math.imul(fr, rr) | 0, Ce = Ce + Math.imul(fr, nr) | 0, Ce = Ce + Math.imul(lr, rr) | 0, yt = yt + Math.imul(lr, nr) | 0, ht = ht + Math.imul(Xt, br) | 0, Ce = Ce + Math.imul(Xt, dr) | 0, Ce = Ce + Math.imul(Zt, br) | 0, yt = yt + Math.imul(Zt, dr) | 0;
        var zr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, ht = Math.imul(At, Dt), Ce = Math.imul(At, Ht), Ce = Ce + Math.imul(Ot, Dt) | 0, yt = Math.imul(Ot, Ht), ht = ht + Math.imul(Tr, Qt) | 0, Ce = Ce + Math.imul(Tr, er) | 0, Ce = Ce + Math.imul(It, Qt) | 0, yt = yt + Math.imul(It, er) | 0, ht = ht + Math.imul($r, ur) | 0, Ce = Ce + Math.imul($r, ir) | 0, Ce = Ce + Math.imul(yr, ur) | 0, yt = yt + Math.imul(yr, ir) | 0, ht = ht + Math.imul(Sr, pr) | 0, Ce = Ce + Math.imul(Sr, Ft) | 0, Ce = Ce + Math.imul(cr, pr) | 0, yt = yt + Math.imul(cr, Ft) | 0, ht = ht + Math.imul(_r, rr) | 0, Ce = Ce + Math.imul(_r, nr) | 0, Ce = Ce + Math.imul(sr, rr) | 0, yt = yt + Math.imul(sr, nr) | 0, ht = ht + Math.imul(fr, br) | 0, Ce = Ce + Math.imul(fr, dr) | 0, Ce = Ce + Math.imul(lr, br) | 0, yt = yt + Math.imul(lr, dr) | 0;
        var Vr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, ht = Math.imul(At, Qt), Ce = Math.imul(At, er), Ce = Ce + Math.imul(Ot, Qt) | 0, yt = Math.imul(Ot, er), ht = ht + Math.imul(Tr, ur) | 0, Ce = Ce + Math.imul(Tr, ir) | 0, Ce = Ce + Math.imul(It, ur) | 0, yt = yt + Math.imul(It, ir) | 0, ht = ht + Math.imul($r, pr) | 0, Ce = Ce + Math.imul($r, Ft) | 0, Ce = Ce + Math.imul(yr, pr) | 0, yt = yt + Math.imul(yr, Ft) | 0, ht = ht + Math.imul(Sr, rr) | 0, Ce = Ce + Math.imul(Sr, nr) | 0, Ce = Ce + Math.imul(cr, rr) | 0, yt = yt + Math.imul(cr, nr) | 0, ht = ht + Math.imul(_r, br) | 0, Ce = Ce + Math.imul(_r, dr) | 0, Ce = Ce + Math.imul(sr, br) | 0, yt = yt + Math.imul(sr, dr) | 0;
        var Xr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, ht = Math.imul(At, ur), Ce = Math.imul(At, ir), Ce = Ce + Math.imul(Ot, ur) | 0, yt = Math.imul(Ot, ir), ht = ht + Math.imul(Tr, pr) | 0, Ce = Ce + Math.imul(Tr, Ft) | 0, Ce = Ce + Math.imul(It, pr) | 0, yt = yt + Math.imul(It, Ft) | 0, ht = ht + Math.imul($r, rr) | 0, Ce = Ce + Math.imul($r, nr) | 0, Ce = Ce + Math.imul(yr, rr) | 0, yt = yt + Math.imul(yr, nr) | 0, ht = ht + Math.imul(Sr, br) | 0, Ce = Ce + Math.imul(Sr, dr) | 0, Ce = Ce + Math.imul(cr, br) | 0, yt = yt + Math.imul(cr, dr) | 0;
        var Yr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, ht = Math.imul(At, pr), Ce = Math.imul(At, Ft), Ce = Ce + Math.imul(Ot, pr) | 0, yt = Math.imul(Ot, Ft), ht = ht + Math.imul(Tr, rr) | 0, Ce = Ce + Math.imul(Tr, nr) | 0, Ce = Ce + Math.imul(It, rr) | 0, yt = yt + Math.imul(It, nr) | 0, ht = ht + Math.imul($r, br) | 0, Ce = Ce + Math.imul($r, dr) | 0, Ce = Ce + Math.imul(yr, br) | 0, yt = yt + Math.imul(yr, dr) | 0;
        var Jr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, ht = Math.imul(At, rr), Ce = Math.imul(At, nr), Ce = Ce + Math.imul(Ot, rr) | 0, yt = Math.imul(Ot, nr), ht = ht + Math.imul(Tr, br) | 0, Ce = Ce + Math.imul(Tr, dr) | 0, Ce = Ce + Math.imul(It, br) | 0, yt = yt + Math.imul(It, dr) | 0;
        var Qr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        ct = (yt + (Ce >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, ht = Math.imul(At, br), Ce = Math.imul(At, dr), Ce = Ce + Math.imul(Ot, br) | 0, yt = Math.imul(Ot, dr);
        var Zr = (ct + ht | 0) + ((Ce & 8191) << 13) | 0;
        return ct = (yt + (Ce >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, lt[0] = Rr, lt[1] = Nr, lt[2] = Or, lt[3] = Cr, lt[4] = Lr, lt[5] = Dr, lt[6] = Ur, lt[7] = Fr, lt[8] = jr, lt[9] = Hr, lt[10] = Wr, lt[11] = Gr, lt[12] = zr, lt[13] = Vr, lt[14] = Xr, lt[15] = Yr, lt[16] = Jr, lt[17] = Qr, lt[18] = Zr, ct !== 0 && (lt[19] = ct, it.length++), it;
      };
      Math.imul || (pt = vt);
      function mt(Oe, V, ce) {
        ce.negative = V.negative ^ Oe.negative, ce.length = Oe.length + V.length;
        for (var it = 0, at = 0, ft = 0; ft < ce.length - 1; ft++) {
          var lt = at;
          at = 0;
          for (var ct = it & 67108863, ht = Math.min(ft, V.length - 1), Ce = Math.max(0, ft - Oe.length + 1); Ce <= ht; Ce++) {
            var yt = ft - Ce, qt = Oe.words[yt] | 0, jt = V.words[Ce] | 0, kt = qt * jt, $t = kt & 67108863;
            lt = lt + (kt / 67108864 | 0) | 0, $t = $t + ct | 0, ct = $t & 67108863, lt = lt + ($t >>> 26) | 0, at += lt >>> 26, lt &= 67108863;
          }
          ce.words[ft] = ct, it = lt, lt = at;
        }
        return it !== 0 ? ce.words[ft] = it : ce.length--, ce._strip();
      }
      function gt(Oe, V, ce) {
        return mt(Oe, V, ce);
      }
      L.prototype.mulTo = function(V, ce) {
        var it, at = this.length + V.length;
        return this.length === 10 && V.length === 10 ? it = pt(this, V, ce) : at < 63 ? it = vt(this, V, ce) : at < 1024 ? it = mt(this, V, ce) : it = gt(this, V, ce), it;
      }, L.prototype.mul = function(V) {
        var ce = new L(null);
        return ce.words = new Array(this.length + V.length), this.mulTo(V, ce);
      }, L.prototype.mulf = function(V) {
        var ce = new L(null);
        return ce.words = new Array(this.length + V.length), gt(this, V, ce);
      }, L.prototype.imul = function(V) {
        return this.clone().mulTo(V, this);
      }, L.prototype.imuln = function(V) {
        var ce = V < 0;
        ce && (V = -V), K(typeof V == "number"), K(V < 67108864);
        for (var it = 0, at = 0; at < this.length; at++) {
          var ft = (this.words[at] | 0) * V, lt = (ft & 67108863) + (it & 67108863);
          it >>= 26, it += ft / 67108864 | 0, it += lt >>> 26, this.words[at] = lt & 67108863;
        }
        return it !== 0 && (this.words[at] = it, this.length++), ce ? this.ineg() : this;
      }, L.prototype.muln = function(V) {
        return this.clone().imuln(V);
      }, L.prototype.sqr = function() {
        return this.mul(this);
      }, L.prototype.isqr = function() {
        return this.imul(this.clone());
      }, L.prototype.pow = function(V) {
        var ce = dt(V);
        if (ce.length === 0) return new L(1);
        for (var it = this, at = 0; at < ce.length && ce[at] === 0; at++, it = it.sqr())
          ;
        if (++at < ce.length)
          for (var ft = it.sqr(); at < ce.length; at++, ft = ft.sqr())
            ce[at] !== 0 && (it = it.mul(ft));
        return it;
      }, L.prototype.iushln = function(V) {
        K(typeof V == "number" && V >= 0);
        var ce = V % 26, it = (V - ce) / 26, at = 67108863 >>> 26 - ce << 26 - ce, ft;
        if (ce !== 0) {
          var lt = 0;
          for (ft = 0; ft < this.length; ft++) {
            var ct = this.words[ft] & at, ht = (this.words[ft] | 0) - ct << ce;
            this.words[ft] = ht | lt, lt = ct >>> 26 - ce;
          }
          lt && (this.words[ft] = lt, this.length++);
        }
        if (it !== 0) {
          for (ft = this.length - 1; ft >= 0; ft--)
            this.words[ft + it] = this.words[ft];
          for (ft = 0; ft < it; ft++)
            this.words[ft] = 0;
          this.length += it;
        }
        return this._strip();
      }, L.prototype.ishln = function(V) {
        return K(this.negative === 0), this.iushln(V);
      }, L.prototype.iushrn = function(V, ce, it) {
        K(typeof V == "number" && V >= 0);
        var at;
        ce ? at = (ce - ce % 26) / 26 : at = 0;
        var ft = V % 26, lt = Math.min((V - ft) / 26, this.length), ct = 67108863 ^ 67108863 >>> ft << ft, ht = it;
        if (at -= lt, at = Math.max(0, at), ht) {
          for (var Ce = 0; Ce < lt; Ce++)
            ht.words[Ce] = this.words[Ce];
          ht.length = lt;
        }
        if (lt !== 0) if (this.length > lt)
          for (this.length -= lt, Ce = 0; Ce < this.length; Ce++)
            this.words[Ce] = this.words[Ce + lt];
        else
          this.words[0] = 0, this.length = 1;
        var yt = 0;
        for (Ce = this.length - 1; Ce >= 0 && (yt !== 0 || Ce >= at); Ce--) {
          var qt = this.words[Ce] | 0;
          this.words[Ce] = yt << 26 - ft | qt >>> ft, yt = qt & ct;
        }
        return ht && yt !== 0 && (ht.words[ht.length++] = yt), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, L.prototype.ishrn = function(V, ce, it) {
        return K(this.negative === 0), this.iushrn(V, ce, it);
      }, L.prototype.shln = function(V) {
        return this.clone().ishln(V);
      }, L.prototype.ushln = function(V) {
        return this.clone().iushln(V);
      }, L.prototype.shrn = function(V) {
        return this.clone().ishrn(V);
      }, L.prototype.ushrn = function(V) {
        return this.clone().iushrn(V);
      }, L.prototype.testn = function(V) {
        K(typeof V == "number" && V >= 0);
        var ce = V % 26, it = (V - ce) / 26, at = 1 << ce;
        if (this.length <= it) return !1;
        var ft = this.words[it];
        return !!(ft & at);
      }, L.prototype.imaskn = function(V) {
        K(typeof V == "number" && V >= 0);
        var ce = V % 26, it = (V - ce) / 26;
        if (K(this.negative === 0, "imaskn works only with positive numbers"), this.length <= it)
          return this;
        if (ce !== 0 && it++, this.length = Math.min(it, this.length), ce !== 0) {
          var at = 67108863 ^ 67108863 >>> ce << ce;
          this.words[this.length - 1] &= at;
        }
        return this._strip();
      }, L.prototype.maskn = function(V) {
        return this.clone().imaskn(V);
      }, L.prototype.iaddn = function(V) {
        return K(typeof V == "number"), K(V < 67108864), V < 0 ? this.isubn(-V) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= V ? (this.words[0] = V - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(V), this.negative = 1, this) : this._iaddn(V);
      }, L.prototype._iaddn = function(V) {
        this.words[0] += V;
        for (var ce = 0; ce < this.length && this.words[ce] >= 67108864; ce++)
          this.words[ce] -= 67108864, ce === this.length - 1 ? this.words[ce + 1] = 1 : this.words[ce + 1]++;
        return this.length = Math.max(this.length, ce + 1), this;
      }, L.prototype.isubn = function(V) {
        if (K(typeof V == "number"), K(V < 67108864), V < 0) return this.iaddn(-V);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(V), this.negative = 1, this;
        if (this.words[0] -= V, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var ce = 0; ce < this.length && this.words[ce] < 0; ce++)
            this.words[ce] += 67108864, this.words[ce + 1] -= 1;
        return this._strip();
      }, L.prototype.addn = function(V) {
        return this.clone().iaddn(V);
      }, L.prototype.subn = function(V) {
        return this.clone().isubn(V);
      }, L.prototype.iabs = function() {
        return this.negative = 0, this;
      }, L.prototype.abs = function() {
        return this.clone().iabs();
      }, L.prototype._ishlnsubmul = function(V, ce, it) {
        var at = V.length + it, ft;
        this._expand(at);
        var lt, ct = 0;
        for (ft = 0; ft < V.length; ft++) {
          lt = (this.words[ft + it] | 0) + ct;
          var ht = (V.words[ft] | 0) * ce;
          lt -= ht & 67108863, ct = (lt >> 26) - (ht / 67108864 | 0), this.words[ft + it] = lt & 67108863;
        }
        for (; ft < this.length - it; ft++)
          lt = (this.words[ft + it] | 0) + ct, ct = lt >> 26, this.words[ft + it] = lt & 67108863;
        if (ct === 0) return this._strip();
        for (K(ct === -1), ct = 0, ft = 0; ft < this.length; ft++)
          lt = -(this.words[ft] | 0) + ct, ct = lt >> 26, this.words[ft] = lt & 67108863;
        return this.negative = 1, this._strip();
      }, L.prototype._wordDiv = function(V, ce) {
        var it = this.length - V.length, at = this.clone(), ft = V, lt = ft.words[ft.length - 1] | 0, ct = this._countBits(lt);
        it = 26 - ct, it !== 0 && (ft = ft.ushln(it), at.iushln(it), lt = ft.words[ft.length - 1] | 0);
        var ht = at.length - ft.length, Ce;
        if (ce !== "mod") {
          Ce = new L(null), Ce.length = ht + 1, Ce.words = new Array(Ce.length);
          for (var yt = 0; yt < Ce.length; yt++)
            Ce.words[yt] = 0;
        }
        var qt = at.clone()._ishlnsubmul(ft, 1, ht);
        qt.negative === 0 && (at = qt, Ce && (Ce.words[ht] = 1));
        for (var jt = ht - 1; jt >= 0; jt--) {
          var kt = (at.words[ft.length + jt] | 0) * 67108864 + (at.words[ft.length + jt - 1] | 0);
          for (kt = Math.min(kt / lt | 0, 67108863), at._ishlnsubmul(ft, kt, jt); at.negative !== 0; )
            kt--, at.negative = 0, at._ishlnsubmul(ft, 1, jt), at.isZero() || (at.negative ^= 1);
          Ce && (Ce.words[jt] = kt);
        }
        return Ce && Ce._strip(), at._strip(), ce !== "div" && it !== 0 && at.iushrn(it), {
          div: Ce || null,
          mod: at
        };
      }, L.prototype.divmod = function(V, ce, it) {
        if (K(!V.isZero()), this.isZero())
          return {
            div: new L(0),
            mod: new L(0)
          };
        var at, ft, lt;
        return this.negative !== 0 && V.negative === 0 ? (lt = this.neg().divmod(V, ce), ce !== "mod" && (at = lt.div.neg()), ce !== "div" && (ft = lt.mod.neg(), it && ft.negative !== 0 && ft.iadd(V)), {
          div: at,
          mod: ft
        }) : this.negative === 0 && V.negative !== 0 ? (lt = this.divmod(V.neg(), ce), ce !== "mod" && (at = lt.div.neg()), {
          div: at,
          mod: lt.mod
        }) : this.negative & V.negative ? (lt = this.neg().divmod(V.neg(), ce), ce !== "div" && (ft = lt.mod.neg(), it && ft.negative !== 0 && ft.isub(V)), {
          div: lt.div,
          mod: ft
        }) : V.length > this.length || this.cmp(V) < 0 ? {
          div: new L(0),
          mod: this
        } : V.length === 1 ? ce === "div" ? {
          div: this.divn(V.words[0]),
          mod: null
        } : ce === "mod" ? {
          div: null,
          mod: new L(this.modrn(V.words[0]))
        } : {
          div: this.divn(V.words[0]),
          mod: new L(this.modrn(V.words[0]))
        } : this._wordDiv(V, ce);
      }, L.prototype.div = function(V) {
        return this.divmod(V, "div", !1).div;
      }, L.prototype.mod = function(V) {
        return this.divmod(V, "mod", !1).mod;
      }, L.prototype.umod = function(V) {
        return this.divmod(V, "mod", !0).mod;
      }, L.prototype.divRound = function(V) {
        var ce = this.divmod(V);
        if (ce.mod.isZero()) return ce.div;
        var it = ce.div.negative !== 0 ? ce.mod.isub(V) : ce.mod, at = V.ushrn(1), ft = V.andln(1), lt = it.cmp(at);
        return lt < 0 || ft === 1 && lt === 0 ? ce.div : ce.div.negative !== 0 ? ce.div.isubn(1) : ce.div.iaddn(1);
      }, L.prototype.modrn = function(V) {
        var ce = V < 0;
        ce && (V = -V), K(V <= 67108863);
        for (var it = (1 << 26) % V, at = 0, ft = this.length - 1; ft >= 0; ft--)
          at = (it * at + (this.words[ft] | 0)) % V;
        return ce ? -at : at;
      }, L.prototype.modn = function(V) {
        return this.modrn(V);
      }, L.prototype.idivn = function(V) {
        var ce = V < 0;
        ce && (V = -V), K(V <= 67108863);
        for (var it = 0, at = this.length - 1; at >= 0; at--) {
          var ft = (this.words[at] | 0) + it * 67108864;
          this.words[at] = ft / V | 0, it = ft % V;
        }
        return this._strip(), ce ? this.ineg() : this;
      }, L.prototype.divn = function(V) {
        return this.clone().idivn(V);
      }, L.prototype.egcd = function(V) {
        K(V.negative === 0), K(!V.isZero());
        var ce = this, it = V.clone();
        ce.negative !== 0 ? ce = ce.umod(V) : ce = ce.clone();
        for (var at = new L(1), ft = new L(0), lt = new L(0), ct = new L(1), ht = 0; ce.isEven() && it.isEven(); )
          ce.iushrn(1), it.iushrn(1), ++ht;
        for (var Ce = it.clone(), yt = ce.clone(); !ce.isZero(); ) {
          for (var qt = 0, jt = 1; !(ce.words[0] & jt) && qt < 26; ++qt, jt <<= 1) ;
          if (qt > 0)
            for (ce.iushrn(qt); qt-- > 0; )
              (at.isOdd() || ft.isOdd()) && (at.iadd(Ce), ft.isub(yt)), at.iushrn(1), ft.iushrn(1);
          for (var kt = 0, $t = 1; !(it.words[0] & $t) && kt < 26; ++kt, $t <<= 1) ;
          if (kt > 0)
            for (it.iushrn(kt); kt-- > 0; )
              (lt.isOdd() || ct.isOdd()) && (lt.iadd(Ce), ct.isub(yt)), lt.iushrn(1), ct.iushrn(1);
          ce.cmp(it) >= 0 ? (ce.isub(it), at.isub(lt), ft.isub(ct)) : (it.isub(ce), lt.isub(at), ct.isub(ft));
        }
        return {
          a: lt,
          b: ct,
          gcd: it.iushln(ht)
        };
      }, L.prototype._invmp = function(V) {
        K(V.negative === 0), K(!V.isZero());
        var ce = this, it = V.clone();
        ce.negative !== 0 ? ce = ce.umod(V) : ce = ce.clone();
        for (var at = new L(1), ft = new L(0), lt = it.clone(); ce.cmpn(1) > 0 && it.cmpn(1) > 0; ) {
          for (var ct = 0, ht = 1; !(ce.words[0] & ht) && ct < 26; ++ct, ht <<= 1) ;
          if (ct > 0)
            for (ce.iushrn(ct); ct-- > 0; )
              at.isOdd() && at.iadd(lt), at.iushrn(1);
          for (var Ce = 0, yt = 1; !(it.words[0] & yt) && Ce < 26; ++Ce, yt <<= 1) ;
          if (Ce > 0)
            for (it.iushrn(Ce); Ce-- > 0; )
              ft.isOdd() && ft.iadd(lt), ft.iushrn(1);
          ce.cmp(it) >= 0 ? (ce.isub(it), at.isub(ft)) : (it.isub(ce), ft.isub(at));
        }
        var qt;
        return ce.cmpn(1) === 0 ? qt = at : qt = ft, qt.cmpn(0) < 0 && qt.iadd(V), qt;
      }, L.prototype.gcd = function(V) {
        if (this.isZero()) return V.abs();
        if (V.isZero()) return this.abs();
        var ce = this.clone(), it = V.clone();
        ce.negative = 0, it.negative = 0;
        for (var at = 0; ce.isEven() && it.isEven(); at++)
          ce.iushrn(1), it.iushrn(1);
        do {
          for (; ce.isEven(); )
            ce.iushrn(1);
          for (; it.isEven(); )
            it.iushrn(1);
          var ft = ce.cmp(it);
          if (ft < 0) {
            var lt = ce;
            ce = it, it = lt;
          } else if (ft === 0 || it.cmpn(1) === 0)
            break;
          ce.isub(it);
        } while (!0);
        return it.iushln(at);
      }, L.prototype.invm = function(V) {
        return this.egcd(V).a.umod(V);
      }, L.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, L.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, L.prototype.andln = function(V) {
        return this.words[0] & V;
      }, L.prototype.bincn = function(V) {
        K(typeof V == "number");
        var ce = V % 26, it = (V - ce) / 26, at = 1 << ce;
        if (this.length <= it)
          return this._expand(it + 1), this.words[it] |= at, this;
        for (var ft = at, lt = it; ft !== 0 && lt < this.length; lt++) {
          var ct = this.words[lt] | 0;
          ct += ft, ft = ct >>> 26, ct &= 67108863, this.words[lt] = ct;
        }
        return ft !== 0 && (this.words[lt] = ft, this.length++), this;
      }, L.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, L.prototype.cmpn = function(V) {
        var ce = V < 0;
        if (this.negative !== 0 && !ce) return -1;
        if (this.negative === 0 && ce) return 1;
        this._strip();
        var it;
        if (this.length > 1)
          it = 1;
        else {
          ce && (V = -V), K(V <= 67108863, "Number is too big");
          var at = this.words[0] | 0;
          it = at === V ? 0 : at < V ? -1 : 1;
        }
        return this.negative !== 0 ? -it | 0 : it;
      }, L.prototype.cmp = function(V) {
        if (this.negative !== 0 && V.negative === 0) return -1;
        if (this.negative === 0 && V.negative !== 0) return 1;
        var ce = this.ucmp(V);
        return this.negative !== 0 ? -ce | 0 : ce;
      }, L.prototype.ucmp = function(V) {
        if (this.length > V.length) return 1;
        if (this.length < V.length) return -1;
        for (var ce = 0, it = this.length - 1; it >= 0; it--) {
          var at = this.words[it] | 0, ft = V.words[it] | 0;
          if (at !== ft) {
            at < ft ? ce = -1 : at > ft && (ce = 1);
            break;
          }
        }
        return ce;
      }, L.prototype.gtn = function(V) {
        return this.cmpn(V) === 1;
      }, L.prototype.gt = function(V) {
        return this.cmp(V) === 1;
      }, L.prototype.gten = function(V) {
        return this.cmpn(V) >= 0;
      }, L.prototype.gte = function(V) {
        return this.cmp(V) >= 0;
      }, L.prototype.ltn = function(V) {
        return this.cmpn(V) === -1;
      }, L.prototype.lt = function(V) {
        return this.cmp(V) === -1;
      }, L.prototype.lten = function(V) {
        return this.cmpn(V) <= 0;
      }, L.prototype.lte = function(V) {
        return this.cmp(V) <= 0;
      }, L.prototype.eqn = function(V) {
        return this.cmpn(V) === 0;
      }, L.prototype.eq = function(V) {
        return this.cmp(V) === 0;
      }, L.red = function(V) {
        return new wt(V);
      }, L.prototype.toRed = function(V) {
        return K(!this.red, "Already a number in reduction context"), K(this.negative === 0, "red works only with positives"), V.convertTo(this)._forceRed(V);
      }, L.prototype.fromRed = function() {
        return K(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, L.prototype._forceRed = function(V) {
        return this.red = V, this;
      }, L.prototype.forceRed = function(V) {
        return K(!this.red, "Already a number in reduction context"), this._forceRed(V);
      }, L.prototype.redAdd = function(V) {
        return K(this.red, "redAdd works only with red numbers"), this.red.add(this, V);
      }, L.prototype.redIAdd = function(V) {
        return K(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, V);
      }, L.prototype.redSub = function(V) {
        return K(this.red, "redSub works only with red numbers"), this.red.sub(this, V);
      }, L.prototype.redISub = function(V) {
        return K(this.red, "redISub works only with red numbers"), this.red.isub(this, V);
      }, L.prototype.redShl = function(V) {
        return K(this.red, "redShl works only with red numbers"), this.red.shl(this, V);
      }, L.prototype.redMul = function(V) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, V), this.red.mul(this, V);
      }, L.prototype.redIMul = function(V) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, V), this.red.imul(this, V);
      }, L.prototype.redSqr = function() {
        return K(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, L.prototype.redISqr = function() {
        return K(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, L.prototype.redSqrt = function() {
        return K(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, L.prototype.redInvm = function() {
        return K(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, L.prototype.redNeg = function() {
        return K(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, L.prototype.redPow = function(V) {
        return K(this.red && !V.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, V);
      };
      var Pt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function xt(Oe, V) {
        this.name = Oe, this.p = new L(V, 16), this.n = this.p.bitLength(), this.k = new L(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      xt.prototype._tmp = function() {
        var V = new L(null);
        return V.words = new Array(Math.ceil(this.n / 13)), V;
      }, xt.prototype.ireduce = function(V) {
        var ce = V, it;
        do
          this.split(ce, this.tmp), ce = this.imulK(ce), ce = ce.iadd(this.tmp), it = ce.bitLength();
        while (it > this.n);
        var at = it < this.n ? -1 : ce.ucmp(this.p);
        return at === 0 ? (ce.words[0] = 0, ce.length = 1) : at > 0 ? ce.isub(this.p) : ce.strip !== void 0 ? ce.strip() : ce._strip(), ce;
      }, xt.prototype.split = function(V, ce) {
        V.iushrn(this.n, 0, ce);
      }, xt.prototype.imulK = function(V) {
        return V.imul(this.k);
      };
      function Nt() {
        xt.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      J(Nt, xt), Nt.prototype.split = function(V, ce) {
        for (var it = 4194303, at = Math.min(V.length, 9), ft = 0; ft < at; ft++)
          ce.words[ft] = V.words[ft];
        if (ce.length = at, V.length <= 9) {
          V.words[0] = 0, V.length = 1;
          return;
        }
        var lt = V.words[9];
        for (ce.words[ce.length++] = lt & it, ft = 10; ft < V.length; ft++) {
          var ct = V.words[ft] | 0;
          V.words[ft - 10] = (ct & it) << 4 | lt >>> 22, lt = ct;
        }
        lt >>>= 22, V.words[ft - 10] = lt, lt === 0 && V.length > 10 ? V.length -= 10 : V.length -= 9;
      }, Nt.prototype.imulK = function(V) {
        V.words[V.length] = 0, V.words[V.length + 1] = 0, V.length += 2;
        for (var ce = 0, it = 0; it < V.length; it++) {
          var at = V.words[it] | 0;
          ce += at * 977, V.words[it] = ce & 67108863, ce = at * 64 + (ce / 67108864 | 0);
        }
        return V.words[V.length - 1] === 0 && (V.length--, V.words[V.length - 1] === 0 && V.length--), V;
      };
      function Et() {
        xt.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      J(Et, xt);
      function bt() {
        xt.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      J(bt, xt);
      function Bt() {
        xt.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      J(Bt, xt), Bt.prototype.imulK = function(V) {
        for (var ce = 0, it = 0; it < V.length; it++) {
          var at = (V.words[it] | 0) * 19 + ce, ft = at & 67108863;
          at >>>= 26, V.words[it] = ft, ce = at;
        }
        return ce !== 0 && (V.words[V.length++] = ce), V;
      }, L._prime = function(V) {
        if (Pt[V]) return Pt[V];
        var ce;
        if (V === "k256")
          ce = new Nt();
        else if (V === "p224")
          ce = new Et();
        else if (V === "p192")
          ce = new bt();
        else if (V === "p25519")
          ce = new Bt();
        else
          throw new Error("Unknown prime " + V);
        return Pt[V] = ce, ce;
      };
      function wt(Oe) {
        if (typeof Oe == "string") {
          var V = L._prime(Oe);
          this.m = V.p, this.prime = V;
        } else
          K(Oe.gtn(1), "modulus must be greater than 1"), this.m = Oe, this.prime = null;
      }
      wt.prototype._verify1 = function(V) {
        K(V.negative === 0, "red works only with positives"), K(V.red, "red works only with red numbers");
      }, wt.prototype._verify2 = function(V, ce) {
        K((V.negative | ce.negative) === 0, "red works only with positives"), K(
          V.red && V.red === ce.red,
          "red works only with red numbers"
        );
      }, wt.prototype.imod = function(V) {
        return this.prime ? this.prime.ireduce(V)._forceRed(this) : (ne(V, V.umod(this.m)._forceRed(this)), V);
      }, wt.prototype.neg = function(V) {
        return V.isZero() ? V.clone() : this.m.sub(V)._forceRed(this);
      }, wt.prototype.add = function(V, ce) {
        this._verify2(V, ce);
        var it = V.add(ce);
        return it.cmp(this.m) >= 0 && it.isub(this.m), it._forceRed(this);
      }, wt.prototype.iadd = function(V, ce) {
        this._verify2(V, ce);
        var it = V.iadd(ce);
        return it.cmp(this.m) >= 0 && it.isub(this.m), it;
      }, wt.prototype.sub = function(V, ce) {
        this._verify2(V, ce);
        var it = V.sub(ce);
        return it.cmpn(0) < 0 && it.iadd(this.m), it._forceRed(this);
      }, wt.prototype.isub = function(V, ce) {
        this._verify2(V, ce);
        var it = V.isub(ce);
        return it.cmpn(0) < 0 && it.iadd(this.m), it;
      }, wt.prototype.shl = function(V, ce) {
        return this._verify1(V), this.imod(V.ushln(ce));
      }, wt.prototype.imul = function(V, ce) {
        return this._verify2(V, ce), this.imod(V.imul(ce));
      }, wt.prototype.mul = function(V, ce) {
        return this._verify2(V, ce), this.imod(V.mul(ce));
      }, wt.prototype.isqr = function(V) {
        return this.imul(V, V.clone());
      }, wt.prototype.sqr = function(V) {
        return this.mul(V, V);
      }, wt.prototype.sqrt = function(V) {
        if (V.isZero()) return V.clone();
        var ce = this.m.andln(3);
        if (K(ce % 2 === 1), ce === 3) {
          var it = this.m.add(new L(1)).iushrn(2);
          return this.pow(V, it);
        }
        for (var at = this.m.subn(1), ft = 0; !at.isZero() && at.andln(1) === 0; )
          ft++, at.iushrn(1);
        K(!at.isZero());
        var lt = new L(1).toRed(this), ct = lt.redNeg(), ht = this.m.subn(1).iushrn(1), Ce = this.m.bitLength();
        for (Ce = new L(2 * Ce * Ce).toRed(this); this.pow(Ce, ht).cmp(ct) !== 0; )
          Ce.redIAdd(ct);
        for (var yt = this.pow(Ce, at), qt = this.pow(V, at.addn(1).iushrn(1)), jt = this.pow(V, at), kt = ft; jt.cmp(lt) !== 0; ) {
          for (var $t = jt, Mt = 0; $t.cmp(lt) !== 0; Mt++)
            $t = $t.redSqr();
          K(Mt < kt);
          var Lt = this.pow(yt, new L(1).iushln(kt - Mt - 1));
          qt = qt.redMul(Lt), yt = Lt.redSqr(), jt = jt.redMul(yt), kt = Mt;
        }
        return qt;
      }, wt.prototype.invm = function(V) {
        var ce = V._invmp(this.m);
        return ce.negative !== 0 ? (ce.negative = 0, this.imod(ce).redNeg()) : this.imod(ce);
      }, wt.prototype.pow = function(V, ce) {
        if (ce.isZero()) return new L(1).toRed(this);
        if (ce.cmpn(1) === 0) return V.clone();
        var it = 4, at = new Array(1 << it);
        at[0] = new L(1).toRed(this), at[1] = V;
        for (var ft = 2; ft < at.length; ft++)
          at[ft] = this.mul(at[ft - 1], V);
        var lt = at[0], ct = 0, ht = 0, Ce = ce.bitLength() % 26;
        for (Ce === 0 && (Ce = 26), ft = ce.length - 1; ft >= 0; ft--) {
          for (var yt = ce.words[ft], qt = Ce - 1; qt >= 0; qt--) {
            var jt = yt >> qt & 1;
            if (lt !== at[0] && (lt = this.sqr(lt)), jt === 0 && ct === 0) {
              ht = 0;
              continue;
            }
            ct <<= 1, ct |= jt, ht++, !(ht !== it && (ft !== 0 || qt !== 0)) && (lt = this.mul(lt, at[ct]), ht = 0, ct = 0);
          }
          Ce = 26;
        }
        return lt;
      }, wt.prototype.convertTo = function(V) {
        var ce = V.umod(this.m);
        return ce === V ? ce.clone() : ce;
      }, wt.prototype.convertFrom = function(V) {
        var ce = V.clone();
        return ce.red = null, ce;
      }, L.mont = function(V) {
        return new st(V);
      };
      function st(Oe) {
        wt.call(this, Oe), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new L(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      J(st, wt), st.prototype.convertTo = function(V) {
        return this.imod(V.ushln(this.shift));
      }, st.prototype.convertFrom = function(V) {
        var ce = this.imod(V.mul(this.rinv));
        return ce.red = null, ce;
      }, st.prototype.imul = function(V, ce) {
        if (V.isZero() || ce.isZero())
          return V.words[0] = 0, V.length = 1, V;
        var it = V.imul(ce), at = it.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ft = it.isub(at).iushrn(this.shift), lt = ft;
        return ft.cmp(this.m) >= 0 ? lt = ft.isub(this.m) : ft.cmpn(0) < 0 && (lt = ft.iadd(this.m)), lt._forceRed(this);
      }, st.prototype.mul = function(V, ce) {
        if (V.isZero() || ce.isZero()) return new L(0)._forceRed(this);
        var it = V.mul(ce), at = it.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ft = it.isub(at).iushrn(this.shift), lt = ft;
        return ft.cmp(this.m) >= 0 ? lt = ft.isub(this.m) : ft.cmpn(0) < 0 && (lt = ft.iadd(this.m)), lt._forceRed(this);
      }, st.prototype.invm = function(V) {
        var ce = this.imod(V._invmp(this.m).mul(this.r2));
        return ce._forceRed(this);
      };
    })(A, commonjsGlobal);
  }(bn)), bn.exports;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(A, B) {
      if (A.indexOf) return A.indexOf(B);
      for (var W = 0; W < A.length; W++)
        if (A[W] === B) return W;
      return -1;
    }, Object_keys = function(A) {
      if (Object.keys) return Object.keys(A);
      var B = [];
      for (var W in A) B.push(W);
      return B;
    }, forEach = function(A, B) {
      if (A.forEach) return A.forEach(B);
      for (var W = 0; W < A.length; W++)
        B(A[W], W, A);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(A, B, W) {
          Object.defineProperty(A, B, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: W
          });
        };
      } catch {
        return function(B, W, K) {
          B[W] = K;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(B) {
      if (!(this instanceof Script)) return new Script(B);
      this.code = B;
    };
    Script.prototype.runInContext = function(A) {
      if (!(A instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var B = document.createElement("iframe");
      B.style || (B.style = {}), B.style.display = "none", document.body.appendChild(B);
      var W = B.contentWindow, K = W.eval, J = W.execScript;
      !K && J && (J.call(W, "null"), K = W.eval), forEach(Object_keys(A), function(ie) {
        W[ie] = A[ie];
      }), forEach(globals, function(ie) {
        A[ie] && (W[ie] = A[ie]);
      });
      var L = Object_keys(W), re = K.call(W, this.code);
      return forEach(Object_keys(W), function(ie) {
        (ie in A || indexOf(L, ie) === -1) && (A[ie] = W[ie]);
      }), forEach(globals, function(ie) {
        ie in A || defineProp(A, ie, W[ie]);
      }), document.body.removeChild(B), re;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(A) {
      var B = Script.createContext(A), W = this.runInContext(B);
      return A && forEach(Object_keys(B), function(K) {
        A[K] = B[K];
      }), W;
    }, forEach(Object_keys(Script.prototype), function(A) {
      exports[A] = Script[A] = function(B) {
        var W = Script(B);
        return W[A].apply(W, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(A) {
      return A instanceof Context;
    }, exports.createScript = function(A) {
      return exports.Script(A);
    }, exports.createContext = Script.createContext = function(A) {
      var B = new Context();
      return typeof A == "object" && forEach(Object_keys(A), function(W) {
        B[W] = A[W];
      }), B;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(A) {
    var B = requireAsn1$1(), W = requireInherits_browser(), K = A;
    K.define = function(re, ie) {
      return new J(re, ie);
    };
    function J(L, re) {
      this.name = L, this.body = re, this.decoders = {}, this.encoders = {};
    }
    J.prototype._createNamed = function(re) {
      var ie;
      try {
        ie = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        ie = function(ke) {
          this._initNamed(ke);
        };
      }
      return W(ie, re), ie.prototype._initNamed = function(ke) {
        re.call(this, ke);
      }, new ie(this);
    }, J.prototype._getDecoder = function(re) {
      return re = re || "der", this.decoders.hasOwnProperty(re) || (this.decoders[re] = this._createNamed(B.decoders[re])), this.decoders[re];
    }, J.prototype.decode = function(re, ie, oe) {
      return this._getDecoder(ie).decode(re, oe);
    }, J.prototype._getEncoder = function(re) {
      return re = re || "der", this.encoders.hasOwnProperty(re) || (this.encoders[re] = this._createNamed(B.encoders[re])), this.encoders[re];
    }, J.prototype.encode = function(re, ie, oe) {
      return this._getEncoder(ie).encode(re, oe);
    };
  }(api)), api;
}
var base$2 = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var A = requireInherits_browser();
  function B(K) {
    this._reporterState = {
      obj: null,
      path: [],
      options: K || {},
      errors: []
    };
  }
  reporter.Reporter = B, B.prototype.isError = function(J) {
    return J instanceof W;
  }, B.prototype.save = function() {
    var J = this._reporterState;
    return { obj: J.obj, pathLen: J.path.length };
  }, B.prototype.restore = function(J) {
    var L = this._reporterState;
    L.obj = J.obj, L.path = L.path.slice(0, J.pathLen);
  }, B.prototype.enterKey = function(J) {
    return this._reporterState.path.push(J);
  }, B.prototype.exitKey = function(J) {
    var L = this._reporterState;
    L.path = L.path.slice(0, J - 1);
  }, B.prototype.leaveKey = function(J, L, re) {
    var ie = this._reporterState;
    this.exitKey(J), ie.obj !== null && (ie.obj[L] = re);
  }, B.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, B.prototype.enterObject = function() {
    var J = this._reporterState, L = J.obj;
    return J.obj = {}, L;
  }, B.prototype.leaveObject = function(J) {
    var L = this._reporterState, re = L.obj;
    return L.obj = J, re;
  }, B.prototype.error = function(J) {
    var L, re = this._reporterState, ie = J instanceof W;
    if (ie ? L = J : L = new W(re.path.map(function(oe) {
      return "[" + JSON.stringify(oe) + "]";
    }).join(""), J.message || J, J.stack), !re.options.partial)
      throw L;
    return ie || re.errors.push(L), L;
  }, B.prototype.wrapResult = function(J) {
    var L = this._reporterState;
    return L.options.partial ? {
      result: this.isError(J) ? null : J,
      errors: L.errors
    } : J;
  };
  function W(K, J) {
    this.path = K, this.rethrow(J);
  }
  return A(W, Error), W.prototype.rethrow = function(J) {
    if (this.message = J + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, W), !this.stack)
      try {
        throw new Error(this.message);
      } catch (L) {
        this.stack = L.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var A = requireInherits_browser(), B = requireBase().Reporter, W = require$$0$1.Buffer;
  function K(L, re) {
    if (B.call(this, re), !W.isBuffer(L)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = L, this.offset = 0, this.length = L.length;
  }
  A(K, B), buffer.DecoderBuffer = K, K.prototype.save = function() {
    return { offset: this.offset, reporter: B.prototype.save.call(this) };
  }, K.prototype.restore = function(re) {
    var ie = new K(this.base);
    return ie.offset = re.offset, ie.length = this.offset, this.offset = re.offset, B.prototype.restore.call(this, re.reporter), ie;
  }, K.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, K.prototype.readUInt8 = function(re) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(re || "DecoderBuffer overrun");
  }, K.prototype.skip = function(re, ie) {
    if (!(this.offset + re <= this.length))
      return this.error(ie || "DecoderBuffer overrun");
    var oe = new K(this.base);
    return oe._reporterState = this._reporterState, oe.offset = this.offset, oe.length = this.offset + re, this.offset += re, oe;
  }, K.prototype.raw = function(re) {
    return this.base.slice(re ? re.offset : this.offset, this.length);
  };
  function J(L, re) {
    if (Array.isArray(L))
      this.length = 0, this.value = L.map(function(ie) {
        return ie instanceof J || (ie = new J(ie, re)), this.length += ie.length, ie;
      }, this);
    else if (typeof L == "number") {
      if (!(0 <= L && L <= 255))
        return re.error("non-byte EncoderBuffer value");
      this.value = L, this.length = 1;
    } else if (typeof L == "string")
      this.value = L, this.length = W.byteLength(L);
    else if (W.isBuffer(L))
      this.value = L, this.length = L.length;
    else
      return re.error("Unsupported type: " + typeof L);
  }
  return buffer.EncoderBuffer = J, J.prototype.join = function(re, ie) {
    return re || (re = new W(this.length)), ie || (ie = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(oe) {
      oe.join(re, ie), ie += oe.length;
    }) : (typeof this.value == "number" ? re[ie] = this.value : typeof this.value == "string" ? re.write(this.value, ie) : W.isBuffer(this.value) && this.value.copy(re, ie), ie += this.length)), re;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var A = requireBase().Reporter, B = requireBase().EncoderBuffer, W = requireBase().DecoderBuffer, K = requireMinimalisticAssert(), J = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], L = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(J), re = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function ie(ke, ne) {
    var pe = {};
    this._baseState = pe, pe.enc = ke, pe.parent = ne || null, pe.children = null, pe.tag = null, pe.args = null, pe.reverseArgs = null, pe.choice = null, pe.optional = !1, pe.any = !1, pe.obj = !1, pe.use = null, pe.useDecoder = null, pe.key = null, pe.default = null, pe.explicit = null, pe.implicit = null, pe.contains = null, pe.parent || (pe.children = [], this._wrap());
  }
  node = ie;
  var oe = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return ie.prototype.clone = function() {
    var ne = this._baseState, pe = {};
    oe.forEach(function(nt) {
      pe[nt] = ne[nt];
    });
    var rt = new this.constructor(pe.parent);
    return rt._baseState = pe, rt;
  }, ie.prototype._wrap = function() {
    var ne = this._baseState;
    L.forEach(function(pe) {
      this[pe] = function() {
        var nt = new this.constructor(this);
        return ne.children.push(nt), nt[pe].apply(nt, arguments);
      };
    }, this);
  }, ie.prototype._init = function(ne) {
    var pe = this._baseState;
    K(pe.parent === null), ne.call(this), pe.children = pe.children.filter(function(rt) {
      return rt._baseState.parent === this;
    }, this), K.equal(pe.children.length, 1, "Root node can have only one child");
  }, ie.prototype._useArgs = function(ne) {
    var pe = this._baseState, rt = ne.filter(function(nt) {
      return nt instanceof this.constructor;
    }, this);
    ne = ne.filter(function(nt) {
      return !(nt instanceof this.constructor);
    }, this), rt.length !== 0 && (K(pe.children === null), pe.children = rt, rt.forEach(function(nt) {
      nt._baseState.parent = this;
    }, this)), ne.length !== 0 && (K(pe.args === null), pe.args = ne, pe.reverseArgs = ne.map(function(nt) {
      if (typeof nt != "object" || nt.constructor !== Object)
        return nt;
      var ot = {};
      return Object.keys(nt).forEach(function(ut) {
        ut == (ut | 0) && (ut |= 0);
        var dt = nt[ut];
        ot[dt] = ut;
      }), ot;
    }));
  }, re.forEach(function(ke) {
    ie.prototype[ke] = function() {
      var pe = this._baseState;
      throw new Error(ke + " not implemented for encoding: " + pe.enc);
    };
  }), J.forEach(function(ke) {
    ie.prototype[ke] = function() {
      var pe = this._baseState, rt = Array.prototype.slice.call(arguments);
      return K(pe.tag === null), pe.tag = ke, this._useArgs(rt), this;
    };
  }), ie.prototype.use = function(ne) {
    K(ne);
    var pe = this._baseState;
    return K(pe.use === null), pe.use = ne, this;
  }, ie.prototype.optional = function() {
    var ne = this._baseState;
    return ne.optional = !0, this;
  }, ie.prototype.def = function(ne) {
    var pe = this._baseState;
    return K(pe.default === null), pe.default = ne, pe.optional = !0, this;
  }, ie.prototype.explicit = function(ne) {
    var pe = this._baseState;
    return K(pe.explicit === null && pe.implicit === null), pe.explicit = ne, this;
  }, ie.prototype.implicit = function(ne) {
    var pe = this._baseState;
    return K(pe.explicit === null && pe.implicit === null), pe.implicit = ne, this;
  }, ie.prototype.obj = function() {
    var ne = this._baseState, pe = Array.prototype.slice.call(arguments);
    return ne.obj = !0, pe.length !== 0 && this._useArgs(pe), this;
  }, ie.prototype.key = function(ne) {
    var pe = this._baseState;
    return K(pe.key === null), pe.key = ne, this;
  }, ie.prototype.any = function() {
    var ne = this._baseState;
    return ne.any = !0, this;
  }, ie.prototype.choice = function(ne) {
    var pe = this._baseState;
    return K(pe.choice === null), pe.choice = ne, this._useArgs(Object.keys(ne).map(function(rt) {
      return ne[rt];
    })), this;
  }, ie.prototype.contains = function(ne) {
    var pe = this._baseState;
    return K(pe.use === null), pe.contains = ne, this;
  }, ie.prototype._decode = function(ne, pe) {
    var rt = this._baseState;
    if (rt.parent === null)
      return ne.wrapResult(rt.children[0]._decode(ne, pe));
    var nt = rt.default, ot = !0, ut = null;
    if (rt.key !== null && (ut = ne.enterKey(rt.key)), rt.optional) {
      var dt = null;
      if (rt.explicit !== null ? dt = rt.explicit : rt.implicit !== null ? dt = rt.implicit : rt.tag !== null && (dt = rt.tag), dt === null && !rt.any) {
        var vt = ne.save();
        try {
          rt.choice === null ? this._decodeGeneric(rt.tag, ne, pe) : this._decodeChoice(ne, pe), ot = !0;
        } catch {
          ot = !1;
        }
        ne.restore(vt);
      } else if (ot = this._peekTag(ne, dt, rt.any), ne.isError(ot))
        return ot;
    }
    var pt;
    if (rt.obj && ot && (pt = ne.enterObject()), ot) {
      if (rt.explicit !== null) {
        var mt = this._decodeTag(ne, rt.explicit);
        if (ne.isError(mt))
          return mt;
        ne = mt;
      }
      var gt = ne.offset;
      if (rt.use === null && rt.choice === null) {
        if (rt.any)
          var vt = ne.save();
        var Pt = this._decodeTag(
          ne,
          rt.implicit !== null ? rt.implicit : rt.tag,
          rt.any
        );
        if (ne.isError(Pt))
          return Pt;
        rt.any ? nt = ne.raw(vt) : ne = Pt;
      }
      if (pe && pe.track && rt.tag !== null && pe.track(ne.path(), gt, ne.length, "tagged"), pe && pe.track && rt.tag !== null && pe.track(ne.path(), ne.offset, ne.length, "content"), rt.any ? nt = nt : rt.choice === null ? nt = this._decodeGeneric(rt.tag, ne, pe) : nt = this._decodeChoice(ne, pe), ne.isError(nt))
        return nt;
      if (!rt.any && rt.choice === null && rt.children !== null && rt.children.forEach(function(Et) {
        Et._decode(ne, pe);
      }), rt.contains && (rt.tag === "octstr" || rt.tag === "bitstr")) {
        var xt = new W(nt);
        nt = this._getUse(rt.contains, ne._reporterState.obj)._decode(xt, pe);
      }
    }
    return rt.obj && ot && (nt = ne.leaveObject(pt)), rt.key !== null && (nt !== null || ot === !0) ? ne.leaveKey(ut, rt.key, nt) : ut !== null && ne.exitKey(ut), nt;
  }, ie.prototype._decodeGeneric = function(ne, pe, rt) {
    var nt = this._baseState;
    return ne === "seq" || ne === "set" ? null : ne === "seqof" || ne === "setof" ? this._decodeList(pe, ne, nt.args[0], rt) : /str$/.test(ne) ? this._decodeStr(pe, ne, rt) : ne === "objid" && nt.args ? this._decodeObjid(pe, nt.args[0], nt.args[1], rt) : ne === "objid" ? this._decodeObjid(pe, null, null, rt) : ne === "gentime" || ne === "utctime" ? this._decodeTime(pe, ne, rt) : ne === "null_" ? this._decodeNull(pe, rt) : ne === "bool" ? this._decodeBool(pe, rt) : ne === "objDesc" ? this._decodeStr(pe, ne, rt) : ne === "int" || ne === "enum" ? this._decodeInt(pe, nt.args && nt.args[0], rt) : nt.use !== null ? this._getUse(nt.use, pe._reporterState.obj)._decode(pe, rt) : pe.error("unknown tag: " + ne);
  }, ie.prototype._getUse = function(ne, pe) {
    var rt = this._baseState;
    return rt.useDecoder = this._use(ne, pe), K(rt.useDecoder._baseState.parent === null), rt.useDecoder = rt.useDecoder._baseState.children[0], rt.implicit !== rt.useDecoder._baseState.implicit && (rt.useDecoder = rt.useDecoder.clone(), rt.useDecoder._baseState.implicit = rt.implicit), rt.useDecoder;
  }, ie.prototype._decodeChoice = function(ne, pe) {
    var rt = this._baseState, nt = null, ot = !1;
    return Object.keys(rt.choice).some(function(ut) {
      var dt = ne.save(), vt = rt.choice[ut];
      try {
        var pt = vt._decode(ne, pe);
        if (ne.isError(pt))
          return !1;
        nt = { type: ut, value: pt }, ot = !0;
      } catch {
        return ne.restore(dt), !1;
      }
      return !0;
    }, this), ot ? nt : ne.error("Choice not matched");
  }, ie.prototype._createEncoderBuffer = function(ne) {
    return new B(ne, this.reporter);
  }, ie.prototype._encode = function(ne, pe, rt) {
    var nt = this._baseState;
    if (!(nt.default !== null && nt.default === ne)) {
      var ot = this._encodeValue(ne, pe, rt);
      if (ot !== void 0 && !this._skipDefault(ot, pe, rt))
        return ot;
    }
  }, ie.prototype._encodeValue = function(ne, pe, rt) {
    var nt = this._baseState;
    if (nt.parent === null)
      return nt.children[0]._encode(ne, pe || new A());
    var vt = null;
    if (this.reporter = pe, nt.optional && ne === void 0)
      if (nt.default !== null)
        ne = nt.default;
      else
        return;
    var ot = null, ut = !1;
    if (nt.any)
      vt = this._createEncoderBuffer(ne);
    else if (nt.choice)
      vt = this._encodeChoice(ne, pe);
    else if (nt.contains)
      ot = this._getUse(nt.contains, rt)._encode(ne, pe), ut = !0;
    else if (nt.children)
      ot = nt.children.map(function(gt) {
        if (gt._baseState.tag === "null_")
          return gt._encode(null, pe, ne);
        if (gt._baseState.key === null)
          return pe.error("Child should have a key");
        var Pt = pe.enterKey(gt._baseState.key);
        if (typeof ne != "object")
          return pe.error("Child expected, but input is not object");
        var xt = gt._encode(ne[gt._baseState.key], pe, ne);
        return pe.leaveKey(Pt), xt;
      }, this).filter(function(gt) {
        return gt;
      }), ot = this._createEncoderBuffer(ot);
    else if (nt.tag === "seqof" || nt.tag === "setof") {
      if (!(nt.args && nt.args.length === 1))
        return pe.error("Too many args for : " + nt.tag);
      if (!Array.isArray(ne))
        return pe.error("seqof/setof, but data is not Array");
      var dt = this.clone();
      dt._baseState.implicit = null, ot = this._createEncoderBuffer(ne.map(function(gt) {
        var Pt = this._baseState;
        return this._getUse(Pt.args[0], ne)._encode(gt, pe);
      }, dt));
    } else nt.use !== null ? vt = this._getUse(nt.use, rt)._encode(ne, pe) : (ot = this._encodePrimitive(nt.tag, ne), ut = !0);
    var vt;
    if (!nt.any && nt.choice === null) {
      var pt = nt.implicit !== null ? nt.implicit : nt.tag, mt = nt.implicit === null ? "universal" : "context";
      pt === null ? nt.use === null && pe.error("Tag could be omitted only for .use()") : nt.use === null && (vt = this._encodeComposite(pt, ut, mt, ot));
    }
    return nt.explicit !== null && (vt = this._encodeComposite(nt.explicit, !1, "context", vt)), vt;
  }, ie.prototype._encodeChoice = function(ne, pe) {
    var rt = this._baseState, nt = rt.choice[ne.type];
    return nt || K(
      !1,
      ne.type + " not found in " + JSON.stringify(Object.keys(rt.choice))
    ), nt._encode(ne.value, pe);
  }, ie.prototype._encodePrimitive = function(ne, pe) {
    var rt = this._baseState;
    if (/str$/.test(ne))
      return this._encodeStr(pe, ne);
    if (ne === "objid" && rt.args)
      return this._encodeObjid(pe, rt.reverseArgs[0], rt.args[1]);
    if (ne === "objid")
      return this._encodeObjid(pe, null, null);
    if (ne === "gentime" || ne === "utctime")
      return this._encodeTime(pe, ne);
    if (ne === "null_")
      return this._encodeNull();
    if (ne === "int" || ne === "enum")
      return this._encodeInt(pe, rt.args && rt.reverseArgs[0]);
    if (ne === "bool")
      return this._encodeBool(pe);
    if (ne === "objDesc")
      return this._encodeStr(pe, ne);
    throw new Error("Unsupported tag: " + ne);
  }, ie.prototype._isNumstr = function(ne) {
    return /^[0-9 ]*$/.test(ne);
  }, ie.prototype._isPrintstr = function(ne) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(ne);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(A) {
    var B = A;
    B.Reporter = requireReporter().Reporter, B.DecoderBuffer = requireBuffer().DecoderBuffer, B.EncoderBuffer = requireBuffer().EncoderBuffer, B.Node = requireNode();
  }(base$2)), base$2;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(A) {
    var B = requireConstants();
    A.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, A.tagClassByName = B._reverse(A.tagClass), A.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, A.tagByName = B._reverse(A.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(A) {
    var B = A;
    B._reverse = function(K) {
      var J = {};
      return Object.keys(K).forEach(function(L) {
        (L | 0) == L && (L = L | 0);
        var re = K[L];
        J[re] = L;
      }), J;
    }, B.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var A = requireInherits_browser(), B = requireAsn1$1(), W = B.base, K = B.bignum, J = B.constants.der;
  function L(ke) {
    this.enc = "der", this.name = ke.name, this.entity = ke, this.tree = new re(), this.tree._init(ke.body);
  }
  der_1$1 = L, L.prototype.decode = function(ne, pe) {
    return ne instanceof W.DecoderBuffer || (ne = new W.DecoderBuffer(ne, pe)), this.tree._decode(ne, pe);
  };
  function re(ke) {
    W.Node.call(this, "der", ke);
  }
  A(re, W.Node), re.prototype._peekTag = function(ne, pe, rt) {
    if (ne.isEmpty())
      return !1;
    var nt = ne.save(), ot = ie(ne, 'Failed to peek tag: "' + pe + '"');
    return ne.isError(ot) ? ot : (ne.restore(nt), ot.tag === pe || ot.tagStr === pe || ot.tagStr + "of" === pe || rt);
  }, re.prototype._decodeTag = function(ne, pe, rt) {
    var nt = ie(
      ne,
      'Failed to decode tag of "' + pe + '"'
    );
    if (ne.isError(nt))
      return nt;
    var ot = oe(
      ne,
      nt.primitive,
      'Failed to get length of "' + pe + '"'
    );
    if (ne.isError(ot))
      return ot;
    if (!rt && nt.tag !== pe && nt.tagStr !== pe && nt.tagStr + "of" !== pe)
      return ne.error('Failed to match tag: "' + pe + '"');
    if (nt.primitive || ot !== null)
      return ne.skip(ot, 'Failed to match body of: "' + pe + '"');
    var ut = ne.save(), dt = this._skipUntilEnd(
      ne,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return ne.isError(dt) ? dt : (ot = ne.offset - ut.offset, ne.restore(ut), ne.skip(ot, 'Failed to match body of: "' + pe + '"'));
  }, re.prototype._skipUntilEnd = function(ne, pe) {
    for (; ; ) {
      var rt = ie(ne, pe);
      if (ne.isError(rt))
        return rt;
      var nt = oe(ne, rt.primitive, pe);
      if (ne.isError(nt))
        return nt;
      var ot;
      if (rt.primitive || nt !== null ? ot = ne.skip(nt) : ot = this._skipUntilEnd(ne, pe), ne.isError(ot))
        return ot;
      if (rt.tagStr === "end")
        break;
    }
  }, re.prototype._decodeList = function(ne, pe, rt, nt) {
    for (var ot = []; !ne.isEmpty(); ) {
      var ut = this._peekTag(ne, "end");
      if (ne.isError(ut))
        return ut;
      var dt = rt.decode(ne, "der", nt);
      if (ne.isError(dt) && ut)
        break;
      ot.push(dt);
    }
    return ot;
  }, re.prototype._decodeStr = function(ne, pe) {
    if (pe === "bitstr") {
      var rt = ne.readUInt8();
      return ne.isError(rt) ? rt : { unused: rt, data: ne.raw() };
    } else if (pe === "bmpstr") {
      var nt = ne.raw();
      if (nt.length % 2 === 1)
        return ne.error("Decoding of string type: bmpstr length mismatch");
      for (var ot = "", ut = 0; ut < nt.length / 2; ut++)
        ot += String.fromCharCode(nt.readUInt16BE(ut * 2));
      return ot;
    } else if (pe === "numstr") {
      var dt = ne.raw().toString("ascii");
      return this._isNumstr(dt) ? dt : ne.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (pe === "octstr")
        return ne.raw();
      if (pe === "objDesc")
        return ne.raw();
      if (pe === "printstr") {
        var vt = ne.raw().toString("ascii");
        return this._isPrintstr(vt) ? vt : ne.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(pe) ? ne.raw().toString() : ne.error("Decoding of string type: " + pe + " unsupported");
    }
  }, re.prototype._decodeObjid = function(ne, pe, rt) {
    for (var nt, ot = [], ut = 0; !ne.isEmpty(); ) {
      var dt = ne.readUInt8();
      ut <<= 7, ut |= dt & 127, dt & 128 || (ot.push(ut), ut = 0);
    }
    dt & 128 && ot.push(ut);
    var vt = ot[0] / 40 | 0, pt = ot[0] % 40;
    if (rt ? nt = ot : nt = [vt, pt].concat(ot.slice(1)), pe) {
      var mt = pe[nt.join(" ")];
      mt === void 0 && (mt = pe[nt.join(".")]), mt !== void 0 && (nt = mt);
    }
    return nt;
  }, re.prototype._decodeTime = function(ne, pe) {
    var rt = ne.raw().toString();
    if (pe === "gentime")
      var nt = rt.slice(0, 4) | 0, ot = rt.slice(4, 6) | 0, ut = rt.slice(6, 8) | 0, dt = rt.slice(8, 10) | 0, vt = rt.slice(10, 12) | 0, pt = rt.slice(12, 14) | 0;
    else if (pe === "utctime") {
      var nt = rt.slice(0, 2) | 0, ot = rt.slice(2, 4) | 0, ut = rt.slice(4, 6) | 0, dt = rt.slice(6, 8) | 0, vt = rt.slice(8, 10) | 0, pt = rt.slice(10, 12) | 0;
      nt < 70 ? nt = 2e3 + nt : nt = 1900 + nt;
    } else
      return ne.error("Decoding " + pe + " time is not supported yet");
    return Date.UTC(nt, ot - 1, ut, dt, vt, pt, 0);
  }, re.prototype._decodeNull = function(ne) {
    return null;
  }, re.prototype._decodeBool = function(ne) {
    var pe = ne.readUInt8();
    return ne.isError(pe) ? pe : pe !== 0;
  }, re.prototype._decodeInt = function(ne, pe) {
    var rt = ne.raw(), nt = new K(rt);
    return pe && (nt = pe[nt.toString(10)] || nt), nt;
  }, re.prototype._use = function(ne, pe) {
    return typeof ne == "function" && (ne = ne(pe)), ne._getDecoder("der").tree;
  };
  function ie(ke, ne) {
    var pe = ke.readUInt8(ne);
    if (ke.isError(pe))
      return pe;
    var rt = J.tagClass[pe >> 6], nt = (pe & 32) === 0;
    if ((pe & 31) === 31) {
      var ot = pe;
      for (pe = 0; (ot & 128) === 128; ) {
        if (ot = ke.readUInt8(ne), ke.isError(ot))
          return ot;
        pe <<= 7, pe |= ot & 127;
      }
    } else
      pe &= 31;
    var ut = J.tag[pe];
    return {
      cls: rt,
      primitive: nt,
      tag: pe,
      tagStr: ut
    };
  }
  function oe(ke, ne, pe) {
    var rt = ke.readUInt8(pe);
    if (ke.isError(rt))
      return rt;
    if (!ne && rt === 128)
      return null;
    if (!(rt & 128))
      return rt;
    var nt = rt & 127;
    if (nt > 4)
      return ke.error("length octect is too long");
    rt = 0;
    for (var ot = 0; ot < nt; ot++) {
      rt <<= 8;
      var ut = ke.readUInt8(pe);
      if (ke.isError(ut))
        return ut;
      rt |= ut;
    }
    return rt;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var A = requireInherits_browser(), B = require$$0$1.Buffer, W = requireDer$1();
  function K(J) {
    W.call(this, J), this.enc = "pem";
  }
  return A(K, W), pem$1 = K, K.prototype.decode = function(L, re) {
    for (var ie = L.toString().split(/[\r\n]+/g), oe = re.label.toUpperCase(), ke = /^-----(BEGIN|END) ([^-]+)-----$/, ne = -1, pe = -1, rt = 0; rt < ie.length; rt++) {
      var nt = ie[rt].match(ke);
      if (nt !== null && nt[2] === oe)
        if (ne === -1) {
          if (nt[1] !== "BEGIN")
            break;
          ne = rt;
        } else {
          if (nt[1] !== "END")
            break;
          pe = rt;
          break;
        }
    }
    if (ne === -1 || pe === -1)
      throw new Error("PEM section not found for: " + oe);
    var ot = ie.slice(ne + 1, pe).join("");
    ot.replace(/[^a-z0-9\+\/=]+/gi, "");
    var ut = new B(ot, "base64");
    return W.prototype.decode.call(this, ut, re);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(A) {
    var B = A;
    B.der = requireDer$1(), B.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var A = requireInherits_browser(), B = require$$0$1.Buffer, W = requireAsn1$1(), K = W.base, J = W.constants.der;
  function L(ke) {
    this.enc = "der", this.name = ke.name, this.entity = ke, this.tree = new re(), this.tree._init(ke.body);
  }
  der_1 = L, L.prototype.encode = function(ne, pe) {
    return this.tree._encode(ne, pe).join();
  };
  function re(ke) {
    K.Node.call(this, "der", ke);
  }
  A(re, K.Node), re.prototype._encodeComposite = function(ne, pe, rt, nt) {
    var ot = oe(ne, pe, rt, this.reporter);
    if (nt.length < 128) {
      var vt = new B(2);
      return vt[0] = ot, vt[1] = nt.length, this._createEncoderBuffer([vt, nt]);
    }
    for (var ut = 1, dt = nt.length; dt >= 256; dt >>= 8)
      ut++;
    var vt = new B(2 + ut);
    vt[0] = ot, vt[1] = 128 | ut;
    for (var dt = 1 + ut, pt = nt.length; pt > 0; dt--, pt >>= 8)
      vt[dt] = pt & 255;
    return this._createEncoderBuffer([vt, nt]);
  }, re.prototype._encodeStr = function(ne, pe) {
    if (pe === "bitstr")
      return this._createEncoderBuffer([ne.unused | 0, ne.data]);
    if (pe === "bmpstr") {
      for (var rt = new B(ne.length * 2), nt = 0; nt < ne.length; nt++)
        rt.writeUInt16BE(ne.charCodeAt(nt), nt * 2);
      return this._createEncoderBuffer(rt);
    } else return pe === "numstr" ? this._isNumstr(ne) ? this._createEncoderBuffer(ne) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : pe === "printstr" ? this._isPrintstr(ne) ? this._createEncoderBuffer(ne) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(pe) ? this._createEncoderBuffer(ne) : pe === "objDesc" ? this._createEncoderBuffer(ne) : this.reporter.error("Encoding of string type: " + pe + " unsupported");
  }, re.prototype._encodeObjid = function(ne, pe, rt) {
    if (typeof ne == "string") {
      if (!pe)
        return this.reporter.error("string objid given, but no values map found");
      if (!pe.hasOwnProperty(ne))
        return this.reporter.error("objid not found in values map");
      ne = pe[ne].split(/[\s\.]+/g);
      for (var nt = 0; nt < ne.length; nt++)
        ne[nt] |= 0;
    } else if (Array.isArray(ne)) {
      ne = ne.slice();
      for (var nt = 0; nt < ne.length; nt++)
        ne[nt] |= 0;
    }
    if (!Array.isArray(ne))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(ne));
    if (!rt) {
      if (ne[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      ne.splice(0, 2, ne[0] * 40 + ne[1]);
    }
    for (var ot = 0, nt = 0; nt < ne.length; nt++) {
      var ut = ne[nt];
      for (ot++; ut >= 128; ut >>= 7)
        ot++;
    }
    for (var dt = new B(ot), vt = dt.length - 1, nt = ne.length - 1; nt >= 0; nt--) {
      var ut = ne[nt];
      for (dt[vt--] = ut & 127; (ut >>= 7) > 0; )
        dt[vt--] = 128 | ut & 127;
    }
    return this._createEncoderBuffer(dt);
  };
  function ie(ke) {
    return ke < 10 ? "0" + ke : ke;
  }
  re.prototype._encodeTime = function(ne, pe) {
    var rt, nt = new Date(ne);
    return pe === "gentime" ? rt = [
      ie(nt.getFullYear()),
      ie(nt.getUTCMonth() + 1),
      ie(nt.getUTCDate()),
      ie(nt.getUTCHours()),
      ie(nt.getUTCMinutes()),
      ie(nt.getUTCSeconds()),
      "Z"
    ].join("") : pe === "utctime" ? rt = [
      ie(nt.getFullYear() % 100),
      ie(nt.getUTCMonth() + 1),
      ie(nt.getUTCDate()),
      ie(nt.getUTCHours()),
      ie(nt.getUTCMinutes()),
      ie(nt.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + pe + " time is not supported yet"), this._encodeStr(rt, "octstr");
  }, re.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, re.prototype._encodeInt = function(ne, pe) {
    if (typeof ne == "string") {
      if (!pe)
        return this.reporter.error("String int or enum given, but no values map");
      if (!pe.hasOwnProperty(ne))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(ne));
      ne = pe[ne];
    }
    if (typeof ne != "number" && !B.isBuffer(ne)) {
      var rt = ne.toArray();
      !ne.sign && rt[0] & 128 && rt.unshift(0), ne = new B(rt);
    }
    if (B.isBuffer(ne)) {
      var nt = ne.length;
      ne.length === 0 && nt++;
      var ut = new B(nt);
      return ne.copy(ut), ne.length === 0 && (ut[0] = 0), this._createEncoderBuffer(ut);
    }
    if (ne < 128)
      return this._createEncoderBuffer(ne);
    if (ne < 256)
      return this._createEncoderBuffer([0, ne]);
    for (var nt = 1, ot = ne; ot >= 256; ot >>= 8)
      nt++;
    for (var ut = new Array(nt), ot = ut.length - 1; ot >= 0; ot--)
      ut[ot] = ne & 255, ne >>= 8;
    return ut[0] & 128 && ut.unshift(0), this._createEncoderBuffer(new B(ut));
  }, re.prototype._encodeBool = function(ne) {
    return this._createEncoderBuffer(ne ? 255 : 0);
  }, re.prototype._use = function(ne, pe) {
    return typeof ne == "function" && (ne = ne(pe)), ne._getEncoder("der").tree;
  }, re.prototype._skipDefault = function(ne, pe, rt) {
    var nt = this._baseState, ot;
    if (nt.default === null)
      return !1;
    var ut = ne.join();
    if (nt.defaultBuffer === void 0 && (nt.defaultBuffer = this._encodeValue(nt.default, pe, rt).join()), ut.length !== nt.defaultBuffer.length)
      return !1;
    for (ot = 0; ot < ut.length; ot++)
      if (ut[ot] !== nt.defaultBuffer[ot])
        return !1;
    return !0;
  };
  function oe(ke, ne, pe, rt) {
    var nt;
    if (ke === "seqof" ? ke = "seq" : ke === "setof" && (ke = "set"), J.tagByName.hasOwnProperty(ke))
      nt = J.tagByName[ke];
    else if (typeof ke == "number" && (ke | 0) === ke)
      nt = ke;
    else
      return rt.error("Unknown tag: " + ke);
    return nt >= 31 ? rt.error("Multi-octet tag encoding unsupported") : (ne || (nt |= 32), nt |= J.tagClassByName[pe || "universal"] << 6, nt);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var A = requireInherits_browser(), B = requireDer();
  function W(K) {
    B.call(this, K), this.enc = "pem";
  }
  return A(W, B), pem = W, W.prototype.encode = function(J, L) {
    for (var re = B.prototype.encode.call(this, J), ie = re.toString("base64"), oe = ["-----BEGIN " + L.label + "-----"], ke = 0; ke < ie.length; ke += 64)
      oe.push(ie.slice(ke, ke + 64));
    return oe.push("-----END " + L.label + "-----"), oe.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(A) {
    var B = A;
    B.der = requireDer(), B.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(A) {
    var B = A;
    B.bignum = requireBn$2(), B.define = requireApi().define, B.base = requireBase(), B.constants = requireConstants(), B.decoders = requireDecoders(), B.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var A = requireAsn1$1(), B = A.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), W = A.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), K = A.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), J = A.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(K),
      this.key("subjectPublicKey").bitstr()
    );
  }), L = A.define("RelativeDistinguishedName", function() {
    this.setof(W);
  }), re = A.define("RDNSequence", function() {
    this.seqof(L);
  }), ie = A.define("Name", function() {
    this.choice({
      rdnSequence: this.use(re)
    });
  }), oe = A.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(B),
      this.key("notAfter").use(B)
    );
  }), ke = A.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), ne = A.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(K),
      this.key("issuer").use(ie),
      this.key("validity").use(oe),
      this.key("subject").use(ie),
      this.key("subjectPublicKeyInfo").use(J),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(ke).optional()
    );
  }), pe = A.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(ne),
      this.key("signatureAlgorithm").use(K),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = pe, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var A = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var B = A.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = B;
  var W = A.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = W;
  var K = A.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), J = A.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(K),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = J;
  var L = A.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(K),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = L;
  var re = A.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = re;
  var ie = A.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = ie, asn1$1.DSAparam = A.define("DSAparam", function() {
    this.int();
  });
  var oe = A.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), ke = A.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(oe),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = ke, asn1$1.signature = A.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var A = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, B = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, W = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, K = requireEvp_bytestokey(), J = requireBrowser$6(), L = safeBufferExports.Buffer;
  return fixProc = function(re, ie) {
    var oe = re.toString(), ke = oe.match(A), ne;
    if (ke) {
      var rt = "aes" + ke[1], nt = L.from(ke[2], "hex"), ot = L.from(ke[3].replace(/[\r\n]/g, ""), "base64"), ut = K(ie, nt.slice(0, 8), parseInt(ke[1], 10)).key, dt = [], vt = J.createDecipheriv(rt, ut, nt);
      dt.push(vt.update(ot)), dt.push(vt.final()), ne = L.concat(dt);
    } else {
      var pe = oe.match(W);
      ne = L.from(pe[2].replace(/[\r\n]/g, ""), "base64");
    }
    var pt = oe.match(B)[1];
    return {
      tag: pt,
      data: ne
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var A = requireAsn1(), B = require$$1, W = requireFixProc(), K = requireBrowser$6(), J = requireBrowser$7(), L = safeBufferExports.Buffer;
  function re(oe, ke) {
    var ne = oe.algorithm.decrypt.kde.kdeparams.salt, pe = parseInt(oe.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), rt = B[oe.algorithm.decrypt.cipher.algo.join(".")], nt = oe.algorithm.decrypt.cipher.iv, ot = oe.subjectPrivateKey, ut = parseInt(rt.split("-")[1], 10) / 8, dt = J.pbkdf2Sync(ke, ne, pe, ut, "sha1"), vt = K.createDecipheriv(rt, dt, nt), pt = [];
    return pt.push(vt.update(ot)), pt.push(vt.final()), L.concat(pt);
  }
  function ie(oe) {
    var ke;
    typeof oe == "object" && !L.isBuffer(oe) && (ke = oe.passphrase, oe = oe.key), typeof oe == "string" && (oe = L.from(oe));
    var ne = W(oe, ke), pe = ne.tag, rt = ne.data, nt, ot;
    switch (pe) {
      case "CERTIFICATE":
        ot = A.certificate.decode(rt, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (ot || (ot = A.PublicKey.decode(rt, "der")), nt = ot.algorithm.algorithm.join("."), nt) {
          case "1.2.840.113549.1.1.1":
            return A.RSAPublicKey.decode(ot.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return ot.subjectPrivateKey = ot.subjectPublicKey, {
              type: "ec",
              data: ot
            };
          case "1.2.840.10040.4.1":
            return ot.algorithm.params.pub_key = A.DSAparam.decode(ot.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: ot.algorithm.params
            };
          default:
            throw new Error("unknown key id " + nt);
        }
      case "ENCRYPTED PRIVATE KEY":
        rt = A.EncryptedPrivateKey.decode(rt, "der"), rt = re(rt, ke);
      case "PRIVATE KEY":
        switch (ot = A.PrivateKey.decode(rt, "der"), nt = ot.algorithm.algorithm.join("."), nt) {
          case "1.2.840.113549.1.1.1":
            return A.RSAPrivateKey.decode(ot.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: ot.algorithm.curve,
              privateKey: A.ECPrivateKey.decode(ot.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return ot.algorithm.params.priv_key = A.DSAparam.decode(ot.subjectPrivateKey, "der"), {
              type: "dsa",
              params: ot.algorithm.params
            };
          default:
            throw new Error("unknown key id " + nt);
        }
      case "RSA PUBLIC KEY":
        return A.RSAPublicKey.decode(rt, "der");
      case "RSA PRIVATE KEY":
        return A.RSAPrivateKey.decode(rt, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: A.DSAPrivateKey.decode(rt, "der")
        };
      case "EC PRIVATE KEY":
        return rt = A.ECPrivateKey.decode(rt, "der"), {
          curve: rt.parameters.value,
          privateKey: rt.privateKey
        };
      default:
        throw new Error("unknown key type " + pe);
    }
  }
  return ie.signature = A.signature, parseAsn1 = ie, parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var A = safeBufferExports.Buffer, B = requireBrowser$8(), W = requireBrowserifyRsa(), K = requireElliptic().ec, J = requireBn(), L = requireParseAsn1(), re = require$$4, ie = 1;
  function oe(vt, pt, mt, gt, Pt) {
    var xt = L(pt);
    if (xt.curve) {
      if (gt !== "ecdsa" && gt !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return ke(vt, xt);
    } else if (xt.type === "dsa") {
      if (gt !== "dsa")
        throw new Error("wrong private key type");
      return ne(vt, xt, mt);
    }
    if (gt !== "rsa" && gt !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (pt.padding !== void 0 && pt.padding !== ie)
      throw new Error("illegal or unsupported padding mode");
    vt = A.concat([Pt, vt]);
    for (var Nt = xt.modulus.byteLength(), Et = [0, 1]; vt.length + Et.length + 1 < Nt; )
      Et.push(255);
    Et.push(0);
    for (var bt = -1; ++bt < vt.length; )
      Et.push(vt[bt]);
    var Bt = W(Et, xt);
    return Bt;
  }
  function ke(vt, pt) {
    var mt = re[pt.curve.join(".")];
    if (!mt)
      throw new Error("unknown curve " + pt.curve.join("."));
    var gt = new K(mt), Pt = gt.keyFromPrivate(pt.privateKey), xt = Pt.sign(vt);
    return A.from(xt.toDER());
  }
  function ne(vt, pt, mt) {
    for (var gt = pt.params.priv_key, Pt = pt.params.p, xt = pt.params.q, Nt = pt.params.g, Et = new J(0), bt, Bt = nt(vt, xt).mod(xt), wt = !1, st = rt(gt, xt, vt, mt); wt === !1; )
      bt = ut(xt, st, mt), Et = dt(Nt, bt, Pt, xt), wt = bt.invm(xt).imul(Bt.add(gt.mul(Et))).mod(xt), wt.cmpn(0) === 0 && (wt = !1, Et = new J(0));
    return pe(Et, wt);
  }
  function pe(vt, pt) {
    vt = vt.toArray(), pt = pt.toArray(), vt[0] & 128 && (vt = [0].concat(vt)), pt[0] & 128 && (pt = [0].concat(pt));
    var mt = vt.length + pt.length + 4, gt = [
      48,
      mt,
      2,
      vt.length
    ];
    return gt = gt.concat(vt, [2, pt.length], pt), A.from(gt);
  }
  function rt(vt, pt, mt, gt) {
    if (vt = A.from(vt.toArray()), vt.length < pt.byteLength()) {
      var Pt = A.alloc(pt.byteLength() - vt.length);
      vt = A.concat([Pt, vt]);
    }
    var xt = mt.length, Nt = ot(mt, pt), Et = A.alloc(xt);
    Et.fill(1);
    var bt = A.alloc(xt);
    return bt = B(gt, bt).update(Et).update(A.from([0])).update(vt).update(Nt).digest(), Et = B(gt, bt).update(Et).digest(), bt = B(gt, bt).update(Et).update(A.from([1])).update(vt).update(Nt).digest(), Et = B(gt, bt).update(Et).digest(), { k: bt, v: Et };
  }
  function nt(vt, pt) {
    var mt = new J(vt), gt = (vt.length << 3) - pt.bitLength();
    return gt > 0 && mt.ishrn(gt), mt;
  }
  function ot(vt, pt) {
    vt = nt(vt, pt), vt = vt.mod(pt);
    var mt = A.from(vt.toArray());
    if (mt.length < pt.byteLength()) {
      var gt = A.alloc(pt.byteLength() - mt.length);
      mt = A.concat([gt, mt]);
    }
    return mt;
  }
  function ut(vt, pt, mt) {
    var gt, Pt;
    do {
      for (gt = A.alloc(0); gt.length * 8 < vt.bitLength(); )
        pt.v = B(mt, pt.k).update(pt.v).digest(), gt = A.concat([gt, pt.v]);
      Pt = nt(gt, vt), pt.k = B(mt, pt.k).update(pt.v).update(A.from([0])).digest(), pt.v = B(mt, pt.k).update(pt.v).digest();
    } while (Pt.cmp(vt) !== -1);
    return Pt;
  }
  function dt(vt, pt, mt, gt) {
    return vt.toRed(J.mont(mt)).redPow(pt).fromRed().mod(gt);
  }
  return sign.exports = oe, sign.exports.getKey = rt, sign.exports.makeKey = ut, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var A = safeBufferExports.Buffer, B = requireBn(), W = requireElliptic().ec, K = requireParseAsn1(), J = require$$4;
  function L(ke, ne, pe, rt, nt) {
    var ot = K(pe);
    if (ot.type === "ec") {
      if (rt !== "ecdsa" && rt !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return re(ke, ne, ot);
    } else if (ot.type === "dsa") {
      if (rt !== "dsa")
        throw new Error("wrong public key type");
      return ie(ke, ne, ot);
    }
    if (rt !== "rsa" && rt !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    ne = A.concat([nt, ne]);
    for (var ut = ot.modulus.byteLength(), dt = [1], vt = 0; ne.length + dt.length + 2 < ut; )
      dt.push(255), vt += 1;
    dt.push(0);
    for (var pt = -1; ++pt < ne.length; )
      dt.push(ne[pt]);
    dt = A.from(dt);
    var mt = B.mont(ot.modulus);
    ke = new B(ke).toRed(mt), ke = ke.redPow(new B(ot.publicExponent)), ke = A.from(ke.fromRed().toArray());
    var gt = vt < 8 ? 1 : 0;
    for (ut = Math.min(ke.length, dt.length), ke.length !== dt.length && (gt = 1), pt = -1; ++pt < ut; )
      gt |= ke[pt] ^ dt[pt];
    return gt === 0;
  }
  function re(ke, ne, pe) {
    var rt = J[pe.data.algorithm.curve.join(".")];
    if (!rt)
      throw new Error("unknown curve " + pe.data.algorithm.curve.join("."));
    var nt = new W(rt), ot = pe.data.subjectPrivateKey.data;
    return nt.verify(ne, ke, ot);
  }
  function ie(ke, ne, pe) {
    var rt = pe.data.p, nt = pe.data.q, ot = pe.data.g, ut = pe.data.pub_key, dt = K.signature.decode(ke, "der"), vt = dt.s, pt = dt.r;
    oe(vt, nt), oe(pt, nt);
    var mt = B.mont(rt), gt = vt.invm(nt), Pt = ot.toRed(mt).redPow(new B(ne).mul(gt).mod(nt)).fromRed().mul(ut.toRed(mt).redPow(pt.mul(gt).mod(nt)).fromRed()).mod(rt).mod(nt);
    return Pt.cmp(pt) === 0;
  }
  function oe(ke, ne) {
    if (ke.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (ke.cmp(ne) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = L, verify_1;
}
var browser$3, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$3;
  hasRequiredBrowser$3 = 1;
  var A = safeBufferExports.Buffer, B = requireBrowser$9(), W = requireReadableBrowser(), K = requireInherits_browser(), J = requireSign(), L = requireVerify(), re = require$$6;
  Object.keys(re).forEach(function(pe) {
    re[pe].id = A.from(re[pe].id, "hex"), re[pe.toLowerCase()] = re[pe];
  });
  function ie(pe) {
    W.Writable.call(this);
    var rt = re[pe];
    if (!rt)
      throw new Error("Unknown message digest");
    this._hashType = rt.hash, this._hash = B(rt.hash), this._tag = rt.id, this._signType = rt.sign;
  }
  K(ie, W.Writable), ie.prototype._write = function(rt, nt, ot) {
    this._hash.update(rt), ot();
  }, ie.prototype.update = function(rt, nt) {
    return this._hash.update(typeof rt == "string" ? A.from(rt, nt) : rt), this;
  }, ie.prototype.sign = function(rt, nt) {
    this.end();
    var ot = this._hash.digest(), ut = J(ot, rt, this._hashType, this._signType, this._tag);
    return nt ? ut.toString(nt) : ut;
  };
  function oe(pe) {
    W.Writable.call(this);
    var rt = re[pe];
    if (!rt)
      throw new Error("Unknown message digest");
    this._hash = B(rt.hash), this._tag = rt.id, this._signType = rt.sign;
  }
  K(oe, W.Writable), oe.prototype._write = function(rt, nt, ot) {
    this._hash.update(rt), ot();
  }, oe.prototype.update = function(rt, nt) {
    return this._hash.update(typeof rt == "string" ? A.from(rt, nt) : rt), this;
  }, oe.prototype.verify = function(rt, nt, ot) {
    var ut = typeof nt == "string" ? A.from(nt, ot) : nt;
    this.end();
    var dt = this._hash.digest();
    return L(ut, dt, rt, this._signType, this._tag);
  };
  function ke(pe) {
    return new ie(pe);
  }
  function ne(pe) {
    return new oe(pe);
  }
  return browser$3 = {
    Sign: ke,
    Verify: ne,
    createSign: ke,
    createVerify: ne
  }, browser$3;
}
var browser$2, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2;
  hasRequiredBrowser$2 = 1;
  var A = requireElliptic(), B = requireBn$2();
  browser$2 = function(re) {
    return new K(re);
  };
  var W = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  W.p224 = W.secp224r1, W.p256 = W.secp256r1 = W.prime256v1, W.p192 = W.secp192r1 = W.prime192v1, W.p384 = W.secp384r1, W.p521 = W.secp521r1;
  function K(L) {
    this.curveType = W[L], this.curveType || (this.curveType = {
      name: L
    }), this.curve = new A.ec(this.curveType.name), this.keys = void 0;
  }
  K.prototype.generateKeys = function(L, re) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(L, re);
  }, K.prototype.computeSecret = function(L, re, ie) {
    re = re || "utf8", Buffer$1.isBuffer(L) || (L = new Buffer$1(L, re));
    var oe = this.curve.keyFromPublic(L).getPublic(), ke = oe.mul(this.keys.getPrivate()).getX();
    return J(ke, ie, this.curveType.byteLength);
  }, K.prototype.getPublicKey = function(L, re) {
    var ie = this.keys.getPublic(re === "compressed", !0);
    return re === "hybrid" && (ie[ie.length - 1] % 2 ? ie[0] = 7 : ie[0] = 6), J(ie, L);
  }, K.prototype.getPrivateKey = function(L) {
    return J(this.keys.getPrivate(), L);
  }, K.prototype.setPublicKey = function(L, re) {
    return re = re || "utf8", Buffer$1.isBuffer(L) || (L = new Buffer$1(L, re)), this.keys._importPublic(L), this;
  }, K.prototype.setPrivateKey = function(L, re) {
    re = re || "utf8", Buffer$1.isBuffer(L) || (L = new Buffer$1(L, re));
    var ie = new B(L);
    return ie = ie.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(ie), this;
  };
  function J(L, re, ie) {
    Array.isArray(L) || (L = L.toArray());
    var oe = new Buffer$1(L);
    if (ie && oe.length < ie) {
      var ke = new Buffer$1(ie - oe.length);
      ke.fill(0), oe = Buffer$1.concat([ke, oe]);
    }
    return re ? oe.toString(re) : oe;
  }
  return browser$2;
}
var browser$1 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var A = requireBrowser$9(), B = safeBufferExports.Buffer;
  mgf = function(K, J) {
    for (var L = B.alloc(0), re = 0, ie; L.length < J; )
      ie = W(re++), L = B.concat([L, A("sha1").update(K).update(ie).digest()]);
    return L.slice(0, J);
  };
  function W(K) {
    var J = B.allocUnsafe(4);
    return J.writeUInt32BE(K, 0), J;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(B, W) {
    for (var K = B.length, J = -1; ++J < K; )
      B[J] ^= W[J];
    return B;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var A = requireBn$2(), B = safeBufferExports.Buffer;
  function W(K, J) {
    return B.from(K.toRed(A.mont(J.modulus)).redPow(new A(J.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = W, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var A = requireParseAsn1(), B = requireBrowser$b(), W = requireBrowser$9(), K = requireMgf(), J = requireXor(), L = requireBn$2(), re = requireWithPublic(), ie = requireBrowserifyRsa(), oe = safeBufferExports.Buffer;
  publicEncrypt = function(nt, ot, ut) {
    var dt;
    nt.padding ? dt = nt.padding : ut ? dt = 1 : dt = 4;
    var vt = A(nt), pt;
    if (dt === 4)
      pt = ke(vt, ot);
    else if (dt === 1)
      pt = ne(vt, ot, ut);
    else if (dt === 3) {
      if (pt = new L(ot), pt.cmp(vt.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return ut ? ie(pt, vt) : re(pt, vt);
  };
  function ke(rt, nt) {
    var ot = rt.modulus.byteLength(), ut = nt.length, dt = W("sha1").update(oe.alloc(0)).digest(), vt = dt.length, pt = 2 * vt;
    if (ut > ot - pt - 2)
      throw new Error("message too long");
    var mt = oe.alloc(ot - ut - pt - 2), gt = ot - vt - 1, Pt = B(vt), xt = J(oe.concat([dt, mt, oe.alloc(1, 1), nt], gt), K(Pt, gt)), Nt = J(Pt, K(xt, vt));
    return new L(oe.concat([oe.alloc(1), Nt, xt], ot));
  }
  function ne(rt, nt, ot) {
    var ut = nt.length, dt = rt.modulus.byteLength();
    if (ut > dt - 11)
      throw new Error("message too long");
    var vt;
    return ot ? vt = oe.alloc(dt - ut - 3, 255) : vt = pe(dt - ut - 3), new L(oe.concat([oe.from([0, ot ? 1 : 2]), vt, oe.alloc(1), nt], dt));
  }
  function pe(rt) {
    for (var nt = oe.allocUnsafe(rt), ot = 0, ut = B(rt * 2), dt = 0, vt; ot < rt; )
      dt === ut.length && (ut = B(rt * 2), dt = 0), vt = ut[dt++], vt && (nt[ot++] = vt);
    return nt;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var A = requireParseAsn1(), B = requireMgf(), W = requireXor(), K = requireBn$2(), J = requireBrowserifyRsa(), L = requireBrowser$9(), re = requireWithPublic(), ie = safeBufferExports.Buffer;
  privateDecrypt = function(rt, nt, ot) {
    var ut;
    rt.padding ? ut = rt.padding : ot ? ut = 1 : ut = 4;
    var dt = A(rt), vt = dt.modulus.byteLength();
    if (nt.length > vt || new K(nt).cmp(dt.modulus) >= 0)
      throw new Error("decryption error");
    var pt;
    ot ? pt = re(new K(nt), dt) : pt = J(nt, dt);
    var mt = ie.alloc(vt - pt.length);
    if (pt = ie.concat([mt, pt], vt), ut === 4)
      return oe(dt, pt);
    if (ut === 1)
      return ke(dt, pt, ot);
    if (ut === 3)
      return pt;
    throw new Error("unknown padding");
  };
  function oe(pe, rt) {
    var nt = pe.modulus.byteLength(), ot = L("sha1").update(ie.alloc(0)).digest(), ut = ot.length;
    if (rt[0] !== 0)
      throw new Error("decryption error");
    var dt = rt.slice(1, ut + 1), vt = rt.slice(ut + 1), pt = W(dt, B(vt, ut)), mt = W(vt, B(pt, nt - ut - 1));
    if (ne(ot, mt.slice(0, ut)))
      throw new Error("decryption error");
    for (var gt = ut; mt[gt] === 0; )
      gt++;
    if (mt[gt++] !== 1)
      throw new Error("decryption error");
    return mt.slice(gt);
  }
  function ke(pe, rt, nt) {
    for (var ot = rt.slice(0, 2), ut = 2, dt = 0; rt[ut++] !== 0; )
      if (ut >= rt.length) {
        dt++;
        break;
      }
    var vt = rt.slice(2, ut - 1);
    if ((ot.toString("hex") !== "0002" && !nt || ot.toString("hex") !== "0001" && nt) && dt++, vt.length < 8 && dt++, dt)
      throw new Error("decryption error");
    return rt.slice(ut);
  }
  function ne(pe, rt) {
    pe = ie.from(pe), rt = ie.from(rt);
    var nt = 0, ot = pe.length;
    pe.length !== rt.length && (nt++, ot = Math.min(pe.length, rt.length));
    for (var ut = -1; ++ut < ot; )
      nt += pe[ut] ^ rt[ut];
    return nt;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(A) {
    A.publicEncrypt = requirePublicEncrypt(), A.privateDecrypt = requirePrivateDecrypt(), A.privateEncrypt = function(W, K) {
      return A.publicEncrypt(W, K, !0);
    }, A.publicDecrypt = function(W, K) {
      return A.privateDecrypt(W, K, !0);
    };
  }(browser$1)), browser$1;
}
var browser = {}, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  function A() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var B = safeBufferExports, W = requireBrowser$b(), K = B.Buffer, J = B.kMaxLength, L = commonjsGlobal.crypto || commonjsGlobal.msCrypto, re = Math.pow(2, 32) - 1;
  function ie(rt, nt) {
    if (typeof rt != "number" || rt !== rt)
      throw new TypeError("offset must be a number");
    if (rt > re || rt < 0)
      throw new TypeError("offset must be a uint32");
    if (rt > J || rt > nt)
      throw new RangeError("offset out of range");
  }
  function oe(rt, nt, ot) {
    if (typeof rt != "number" || rt !== rt)
      throw new TypeError("size must be a number");
    if (rt > re || rt < 0)
      throw new TypeError("size must be a uint32");
    if (rt + nt > ot || rt > J)
      throw new RangeError("buffer too small");
  }
  L && L.getRandomValues || !process$1.browser ? (browser.randomFill = ke, browser.randomFillSync = pe) : (browser.randomFill = A, browser.randomFillSync = A);
  function ke(rt, nt, ot, ut) {
    if (!K.isBuffer(rt) && !(rt instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof nt == "function")
      ut = nt, nt = 0, ot = rt.length;
    else if (typeof ot == "function")
      ut = ot, ot = rt.length - nt;
    else if (typeof ut != "function")
      throw new TypeError('"cb" argument must be a function');
    return ie(nt, rt.length), oe(ot, nt, rt.length), ne(rt, nt, ot, ut);
  }
  function ne(rt, nt, ot, ut) {
    if (process$1.browser) {
      var dt = rt.buffer, vt = new Uint8Array(dt, nt, ot);
      if (L.getRandomValues(vt), ut) {
        process$1.nextTick(function() {
          ut(null, rt);
        });
        return;
      }
      return rt;
    }
    if (ut) {
      W(ot, function(mt, gt) {
        if (mt)
          return ut(mt);
        gt.copy(rt, nt), ut(null, rt);
      });
      return;
    }
    var pt = W(ot);
    return pt.copy(rt, nt), rt;
  }
  function pe(rt, nt, ot) {
    if (typeof nt > "u" && (nt = 0), !K.isBuffer(rt) && !(rt instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return ie(nt, rt.length), ot === void 0 && (ot = rt.length - nt), oe(ot, nt, rt.length), ne(rt, nt, ot);
  }
  return browser;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var A = requireAlgos(), B = Object.keys(A), W = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(B);
  cryptoBrowserify.getHashes = function() {
    return W;
  };
  var K = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = K.pbkdf2, cryptoBrowserify.pbkdf2Sync = K.pbkdf2Sync;
  var J = requireBrowser$5();
  cryptoBrowserify.Cipher = J.Cipher, cryptoBrowserify.createCipher = J.createCipher, cryptoBrowserify.Cipheriv = J.Cipheriv, cryptoBrowserify.createCipheriv = J.createCipheriv, cryptoBrowserify.Decipher = J.Decipher, cryptoBrowserify.createDecipher = J.createDecipher, cryptoBrowserify.Decipheriv = J.Decipheriv, cryptoBrowserify.createDecipheriv = J.createDecipheriv, cryptoBrowserify.getCiphers = J.getCiphers, cryptoBrowserify.listCiphers = J.listCiphers;
  var L = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = L.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = L.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = L.getDiffieHellman, cryptoBrowserify.createDiffieHellman = L.createDiffieHellman, cryptoBrowserify.DiffieHellman = L.DiffieHellman;
  var re = requireBrowser$3();
  cryptoBrowserify.createSign = re.createSign, cryptoBrowserify.Sign = re.Sign, cryptoBrowserify.createVerify = re.createVerify, cryptoBrowserify.Verify = re.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var ie = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = ie.publicEncrypt, cryptoBrowserify.privateEncrypt = ie.privateEncrypt, cryptoBrowserify.publicDecrypt = ie.publicDecrypt, cryptoBrowserify.privateDecrypt = ie.privateDecrypt;
  var oe = requireBrowser();
  return cryptoBrowserify.randomFill = oe.randomFill, cryptoBrowserify.randomFillSync = oe.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(A) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(A, "__esModule", { value: !0 }), A.utils = A.schnorr = A.verify = A.signSync = A.sign = A.getSharedSecret = A.recoverPublicKey = A.getPublicKey = A.Signature = A.Point = A.CURVE = void 0;
  const B = requireCryptoBrowserify(), W = BigInt(0), K = BigInt(1), J = BigInt(2), L = BigInt(3), re = BigInt(8), ie = Object.freeze({
    a: W,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: K,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  A.CURVE = ie;
  const oe = (Ut, Ct) => (Ut + Ct / J) / Ct, ke = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(Ut) {
      const { n: Ct } = ie, Dt = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Ht = -K * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), Yt = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Qt = Dt, er = BigInt("0x100000000000000000000000000000000"), or = oe(Qt * Ut, Ct), ur = oe(-Ht * Ut, Ct);
      let ir = yt(Ut - or * Dt - ur * Yt, Ct), Ar = yt(-or * Ht - ur * Qt, Ct);
      const pr = ir > er, Ft = Ar > er;
      if (pr && (ir = Ct - ir), Ft && (Ar = Ct - Ar), ir > er || Ar > er)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + Ut);
      return { k1neg: pr, k1: ir, k2neg: Ft, k2: Ar };
    }
  }, ne = 32, pe = 32, rt = 32, nt = ne + 1, ot = 2 * ne + 1;
  function ut(Ut) {
    const { a: Ct, b: Dt } = ie, Ht = yt(Ut * Ut), Yt = yt(Ht * Ut);
    return yt(Yt + Ct * Ut + Dt);
  }
  const dt = ie.a === W;
  class vt extends Error {
    constructor(Ct) {
      super(Ct);
    }
  }
  function pt(Ut) {
    if (!(Ut instanceof mt))
      throw new TypeError("JacobianPoint expected");
  }
  class mt {
    constructor(Ct, Dt, Ht) {
      this.x = Ct, this.y = Dt, this.z = Ht;
    }
    static fromAffine(Ct) {
      if (!(Ct instanceof xt))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return Ct.equals(xt.ZERO) ? mt.ZERO : new mt(Ct.x, Ct.y, K);
    }
    static toAffineBatch(Ct) {
      const Dt = $t(Ct.map((Ht) => Ht.z));
      return Ct.map((Ht, Yt) => Ht.toAffine(Dt[Yt]));
    }
    static normalizeZ(Ct) {
      return mt.toAffineBatch(Ct).map(mt.fromAffine);
    }
    equals(Ct) {
      pt(Ct);
      const { x: Dt, y: Ht, z: Yt } = this, { x: Qt, y: er, z: or } = Ct, ur = yt(Yt * Yt), ir = yt(or * or), Ar = yt(Dt * ir), pr = yt(Qt * ur), Ft = yt(yt(Ht * or) * ir), tr = yt(yt(er * Yt) * ur);
      return Ar === pr && Ft === tr;
    }
    negate() {
      return new mt(this.x, yt(-this.y), this.z);
    }
    double() {
      const { x: Ct, y: Dt, z: Ht } = this, Yt = yt(Ct * Ct), Qt = yt(Dt * Dt), er = yt(Qt * Qt), or = Ct + Qt, ur = yt(J * (yt(or * or) - Yt - er)), ir = yt(L * Yt), Ar = yt(ir * ir), pr = yt(Ar - J * ur), Ft = yt(ir * (ur - pr) - re * er), tr = yt(J * Dt * Ht);
      return new mt(pr, Ft, tr);
    }
    add(Ct) {
      pt(Ct);
      const { x: Dt, y: Ht, z: Yt } = this, { x: Qt, y: er, z: or } = Ct;
      if (Qt === W || er === W)
        return this;
      if (Dt === W || Ht === W)
        return Ct;
      const ur = yt(Yt * Yt), ir = yt(or * or), Ar = yt(Dt * ir), pr = yt(Qt * ur), Ft = yt(yt(Ht * or) * ir), tr = yt(yt(er * Yt) * ur), rr = yt(pr - Ar), nr = yt(tr - Ft);
      if (rr === W)
        return nr === W ? this.double() : mt.ZERO;
      const xr = yt(rr * rr), br = yt(rr * xr), dr = yt(Ar * xr), Rr = yt(nr * nr - br - J * dr), Nr = yt(nr * (dr - Rr) - Ft * br), Or = yt(Yt * or * rr);
      return new mt(Rr, Nr, Or);
    }
    subtract(Ct) {
      return this.add(Ct.negate());
    }
    multiplyUnsafe(Ct) {
      const Dt = mt.ZERO;
      if (typeof Ct == "bigint" && Ct === W)
        return Dt;
      let Ht = Ce(Ct);
      if (Ht === K)
        return this;
      if (!dt) {
        let pr = Dt, Ft = this;
        for (; Ht > W; )
          Ht & K && (pr = pr.add(Ft)), Ft = Ft.double(), Ht >>= K;
        return pr;
      }
      let { k1neg: Yt, k1: Qt, k2neg: er, k2: or } = ke.splitScalar(Ht), ur = Dt, ir = Dt, Ar = this;
      for (; Qt > W || or > W; )
        Qt & K && (ur = ur.add(Ar)), or & K && (ir = ir.add(Ar)), Ar = Ar.double(), Qt >>= K, or >>= K;
      return Yt && (ur = ur.negate()), er && (ir = ir.negate()), ir = new mt(yt(ir.x * ke.beta), ir.y, ir.z), ur.add(ir);
    }
    precomputeWindow(Ct) {
      const Dt = dt ? 128 / Ct + 1 : 256 / Ct + 1, Ht = [];
      let Yt = this, Qt = Yt;
      for (let er = 0; er < Dt; er++) {
        Qt = Yt, Ht.push(Qt);
        for (let or = 1; or < 2 ** (Ct - 1); or++)
          Qt = Qt.add(Yt), Ht.push(Qt);
        Yt = Qt.double();
      }
      return Ht;
    }
    wNAF(Ct, Dt) {
      !Dt && this.equals(mt.BASE) && (Dt = xt.BASE);
      const Ht = Dt && Dt._WINDOW_SIZE || 1;
      if (256 % Ht)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let Yt = Dt && Pt.get(Dt);
      Yt || (Yt = this.precomputeWindow(Ht), Dt && Ht !== 1 && (Yt = mt.normalizeZ(Yt), Pt.set(Dt, Yt)));
      let Qt = mt.ZERO, er = mt.BASE;
      const or = 1 + (dt ? 128 / Ht : 256 / Ht), ur = 2 ** (Ht - 1), ir = BigInt(2 ** Ht - 1), Ar = 2 ** Ht, pr = BigInt(Ht);
      for (let Ft = 0; Ft < or; Ft++) {
        const tr = Ft * ur;
        let rr = Number(Ct & ir);
        Ct >>= pr, rr > ur && (rr -= Ar, Ct += K);
        const nr = tr, xr = tr + Math.abs(rr) - 1, br = Ft % 2 !== 0, dr = rr < 0;
        rr === 0 ? er = er.add(gt(br, Yt[nr])) : Qt = Qt.add(gt(dr, Yt[xr]));
      }
      return { p: Qt, f: er };
    }
    multiply(Ct, Dt) {
      let Ht = Ce(Ct), Yt, Qt;
      if (dt) {
        const { k1neg: er, k1: or, k2neg: ur, k2: ir } = ke.splitScalar(Ht);
        let { p: Ar, f: pr } = this.wNAF(or, Dt), { p: Ft, f: tr } = this.wNAF(ir, Dt);
        Ar = gt(er, Ar), Ft = gt(ur, Ft), Ft = new mt(yt(Ft.x * ke.beta), Ft.y, Ft.z), Yt = Ar.add(Ft), Qt = pr.add(tr);
      } else {
        const { p: er, f: or } = this.wNAF(Ht, Dt);
        Yt = er, Qt = or;
      }
      return mt.normalizeZ([Yt, Qt])[0];
    }
    toAffine(Ct) {
      const { x: Dt, y: Ht, z: Yt } = this, Qt = this.equals(mt.ZERO);
      Ct == null && (Ct = Qt ? re : kt(Yt));
      const er = Ct, or = yt(er * er), ur = yt(or * er), ir = yt(Dt * or), Ar = yt(Ht * ur), pr = yt(Yt * er);
      if (Qt)
        return xt.ZERO;
      if (pr !== K)
        throw new Error("invZ was invalid");
      return new xt(ir, Ar);
    }
  }
  mt.BASE = new mt(ie.Gx, ie.Gy, K), mt.ZERO = new mt(W, K, W);
  function gt(Ut, Ct) {
    const Dt = Ct.negate();
    return Ut ? Dt : Ct;
  }
  const Pt = /* @__PURE__ */ new WeakMap();
  class xt {
    constructor(Ct, Dt) {
      this.x = Ct, this.y = Dt;
    }
    _setWindowSize(Ct) {
      this._WINDOW_SIZE = Ct, Pt.delete(this);
    }
    hasEvenY() {
      return this.y % J === W;
    }
    static fromCompressedHex(Ct) {
      const Dt = Ct.length === 32, Ht = ct(Dt ? Ct : Ct.subarray(1));
      if (!Xt(Ht))
        throw new Error("Point is not on curve");
      const Yt = ut(Ht);
      let Qt = jt(Yt);
      const er = (Qt & K) === K;
      Dt ? er && (Qt = yt(-Qt)) : (Ct[0] & 1) === 1 !== er && (Qt = yt(-Qt));
      const or = new xt(Ht, Qt);
      return or.assertValidity(), or;
    }
    static fromUncompressedHex(Ct) {
      const Dt = ct(Ct.subarray(1, ne + 1)), Ht = ct(Ct.subarray(ne + 1, ne * 2 + 1)), Yt = new xt(Dt, Ht);
      return Yt.assertValidity(), Yt;
    }
    static fromHex(Ct) {
      const Dt = ht(Ct), Ht = Dt.length, Yt = Dt[0];
      if (Ht === ne)
        return this.fromCompressedHex(Dt);
      if (Ht === nt && (Yt === 2 || Yt === 3))
        return this.fromCompressedHex(Dt);
      if (Ht === ot && Yt === 4)
        return this.fromUncompressedHex(Dt);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${nt} compressed bytes or ${ot} uncompressed bytes, not ${Ht}`);
    }
    static fromPrivateKey(Ct) {
      return xt.BASE.multiply(ar(Ct));
    }
    static fromSignature(Ct, Dt, Ht) {
      const { r: Yt, s: Qt } = lr(Dt);
      if (![0, 1, 2, 3].includes(Ht))
        throw new Error("Cannot recover: invalid recovery bit");
      const er = Lt(ht(Ct)), { n: or } = ie, ur = Ht === 2 || Ht === 3 ? Yt + or : Yt, ir = kt(ur, or), Ar = yt(-er * ir, or), pr = yt(Qt * ir, or), Ft = Ht & 1 ? "03" : "02", tr = xt.fromHex(Ft + ce(ur)), rr = xt.BASE.multiplyAndAddUnsafe(tr, Ar, pr);
      if (!rr)
        throw new Error("Cannot recover signature: point at infinify");
      return rr.assertValidity(), rr;
    }
    toRawBytes(Ct = !1) {
      return lt(this.toHex(Ct));
    }
    toHex(Ct = !1) {
      const Dt = ce(this.x);
      return Ct ? `${this.hasEvenY() ? "02" : "03"}${Dt}` : `04${Dt}${ce(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const Ct = "Point is not on elliptic curve", { x: Dt, y: Ht } = this;
      if (!Xt(Dt) || !Xt(Ht))
        throw new Error(Ct);
      const Yt = yt(Ht * Ht), Qt = ut(Dt);
      if (yt(Yt - Qt) !== W)
        throw new Error(Ct);
    }
    equals(Ct) {
      return this.x === Ct.x && this.y === Ct.y;
    }
    negate() {
      return new xt(this.x, yt(-this.y));
    }
    double() {
      return mt.fromAffine(this).double().toAffine();
    }
    add(Ct) {
      return mt.fromAffine(this).add(mt.fromAffine(Ct)).toAffine();
    }
    subtract(Ct) {
      return this.add(Ct.negate());
    }
    multiply(Ct) {
      return mt.fromAffine(this).multiply(Ct, this).toAffine();
    }
    multiplyAndAddUnsafe(Ct, Dt, Ht) {
      const Yt = mt.fromAffine(this), Qt = Dt === W || Dt === K || this !== xt.BASE ? Yt.multiplyUnsafe(Dt) : Yt.multiply(Dt), er = mt.fromAffine(Ct).multiplyUnsafe(Ht), or = Qt.add(er);
      return or.equals(mt.ZERO) ? void 0 : or.toAffine();
    }
  }
  A.Point = xt, xt.BASE = new xt(ie.Gx, ie.Gy), xt.ZERO = new xt(W, W);
  function Nt(Ut) {
    return Number.parseInt(Ut[0], 16) >= 8 ? "00" + Ut : Ut;
  }
  function Et(Ut) {
    if (Ut.length < 2 || Ut[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${Oe(Ut)}`);
    const Ct = Ut[1], Dt = Ut.subarray(2, Ct + 2);
    if (!Ct || Dt.length !== Ct)
      throw new Error("Invalid signature integer: wrong length");
    if (Dt[0] === 0 && Dt[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: ct(Dt), left: Ut.subarray(Ct + 2) };
  }
  function bt(Ut) {
    if (Ut.length < 2 || Ut[0] != 48)
      throw new Error(`Invalid signature tag: ${Oe(Ut)}`);
    if (Ut[1] !== Ut.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: Ct, left: Dt } = Et(Ut.subarray(2)), { data: Ht, left: Yt } = Et(Dt);
    if (Yt.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${Oe(Yt)}`);
    return { r: Ct, s: Ht };
  }
  class Bt {
    constructor(Ct, Dt) {
      this.r = Ct, this.s = Dt, this.assertValidity();
    }
    static fromCompact(Ct) {
      const Dt = Ct instanceof Uint8Array, Ht = "Signature.fromCompact";
      if (typeof Ct != "string" && !Dt)
        throw new TypeError(`${Ht}: Expected string or Uint8Array`);
      const Yt = Dt ? Oe(Ct) : Ct;
      if (Yt.length !== 128)
        throw new Error(`${Ht}: Expected 64-byte hex`);
      return new Bt(ft(Yt.slice(0, 64)), ft(Yt.slice(64, 128)));
    }
    static fromDER(Ct) {
      const Dt = Ct instanceof Uint8Array;
      if (typeof Ct != "string" && !Dt)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: Ht, s: Yt } = bt(Dt ? Ct : lt(Ct));
      return new Bt(Ht, Yt);
    }
    static fromHex(Ct) {
      return this.fromDER(Ct);
    }
    assertValidity() {
      const { r: Ct, s: Dt } = this;
      if (!Wt(Ct))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!Wt(Dt))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const Ct = ie.n >> K;
      return this.s > Ct;
    }
    normalizeS() {
      return this.hasHighS() ? new Bt(this.r, yt(-this.s, ie.n)) : this;
    }
    toDERRawBytes() {
      return lt(this.toDERHex());
    }
    toDERHex() {
      const Ct = Nt(at(this.s)), Dt = Nt(at(this.r)), Ht = Ct.length / 2, Yt = Dt.length / 2, Qt = at(Ht), er = at(Yt);
      return `30${at(Yt + Ht + 4)}02${er}${Dt}02${Qt}${Ct}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return lt(this.toCompactHex());
    }
    toCompactHex() {
      return ce(this.r) + ce(this.s);
    }
  }
  A.Signature = Bt;
  function wt(...Ut) {
    if (!Ut.every((Ht) => Ht instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (Ut.length === 1)
      return Ut[0];
    const Ct = Ut.reduce((Ht, Yt) => Ht + Yt.length, 0), Dt = new Uint8Array(Ct);
    for (let Ht = 0, Yt = 0; Ht < Ut.length; Ht++) {
      const Qt = Ut[Ht];
      Dt.set(Qt, Yt), Yt += Qt.length;
    }
    return Dt;
  }
  const st = Array.from({ length: 256 }, (Ut, Ct) => Ct.toString(16).padStart(2, "0"));
  function Oe(Ut) {
    if (!(Ut instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let Ct = "";
    for (let Dt = 0; Dt < Ut.length; Dt++)
      Ct += st[Ut[Dt]];
    return Ct;
  }
  const V = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function ce(Ut) {
    if (typeof Ut != "bigint")
      throw new Error("Expected bigint");
    if (!(W <= Ut && Ut < V))
      throw new Error("Expected number 0 <= n < 2^256");
    return Ut.toString(16).padStart(64, "0");
  }
  function it(Ut) {
    const Ct = lt(ce(Ut));
    if (Ct.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return Ct;
  }
  function at(Ut) {
    const Ct = Ut.toString(16);
    return Ct.length & 1 ? `0${Ct}` : Ct;
  }
  function ft(Ut) {
    if (typeof Ut != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof Ut);
    return BigInt(`0x${Ut}`);
  }
  function lt(Ut) {
    if (typeof Ut != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof Ut);
    if (Ut.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + Ut.length);
    const Ct = new Uint8Array(Ut.length / 2);
    for (let Dt = 0; Dt < Ct.length; Dt++) {
      const Ht = Dt * 2, Yt = Ut.slice(Ht, Ht + 2), Qt = Number.parseInt(Yt, 16);
      if (Number.isNaN(Qt) || Qt < 0)
        throw new Error("Invalid byte sequence");
      Ct[Dt] = Qt;
    }
    return Ct;
  }
  function ct(Ut) {
    return ft(Oe(Ut));
  }
  function ht(Ut) {
    return Ut instanceof Uint8Array ? Uint8Array.from(Ut) : lt(Ut);
  }
  function Ce(Ut) {
    if (typeof Ut == "number" && Number.isSafeInteger(Ut) && Ut > 0)
      return BigInt(Ut);
    if (typeof Ut == "bigint" && Wt(Ut))
      return Ut;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function yt(Ut, Ct = ie.P) {
    const Dt = Ut % Ct;
    return Dt >= W ? Dt : Ct + Dt;
  }
  function qt(Ut, Ct) {
    const { P: Dt } = ie;
    let Ht = Ut;
    for (; Ct-- > W; )
      Ht *= Ht, Ht %= Dt;
    return Ht;
  }
  function jt(Ut) {
    const { P: Ct } = ie, Dt = BigInt(6), Ht = BigInt(11), Yt = BigInt(22), Qt = BigInt(23), er = BigInt(44), or = BigInt(88), ur = Ut * Ut * Ut % Ct, ir = ur * ur * Ut % Ct, Ar = qt(ir, L) * ir % Ct, pr = qt(Ar, L) * ir % Ct, Ft = qt(pr, J) * ur % Ct, tr = qt(Ft, Ht) * Ft % Ct, rr = qt(tr, Yt) * tr % Ct, nr = qt(rr, er) * rr % Ct, xr = qt(nr, or) * nr % Ct, br = qt(xr, er) * rr % Ct, dr = qt(br, L) * ir % Ct, Rr = qt(dr, Qt) * tr % Ct, Nr = qt(Rr, Dt) * ur % Ct, Or = qt(Nr, J);
    if (Or * Or % Ct !== Ut)
      throw new Error("Cannot find square root");
    return Or;
  }
  function kt(Ut, Ct = ie.P) {
    if (Ut === W || Ct <= W)
      throw new Error(`invert: expected positive integers, got n=${Ut} mod=${Ct}`);
    let Dt = yt(Ut, Ct), Ht = Ct, Yt = W, Qt = K;
    for (; Dt !== W; ) {
      const or = Ht / Dt, ur = Ht % Dt, ir = Yt - Qt * or;
      Ht = Dt, Dt = ur, Yt = Qt, Qt = ir;
    }
    if (Ht !== K)
      throw new Error("invert: does not exist");
    return yt(Yt, Ct);
  }
  function $t(Ut, Ct = ie.P) {
    const Dt = new Array(Ut.length), Ht = Ut.reduce((Qt, er, or) => er === W ? Qt : (Dt[or] = Qt, yt(Qt * er, Ct)), K), Yt = kt(Ht, Ct);
    return Ut.reduceRight((Qt, er, or) => er === W ? Qt : (Dt[or] = yt(Qt * Dt[or], Ct), yt(Qt * er, Ct)), Yt), Dt;
  }
  function Mt(Ut) {
    const Ct = Ut.length * 8 - pe * 8, Dt = ct(Ut);
    return Ct > 0 ? Dt >> BigInt(Ct) : Dt;
  }
  function Lt(Ut, Ct = !1) {
    const Dt = Mt(Ut);
    if (Ct)
      return Dt;
    const { n: Ht } = ie;
    return Dt >= Ht ? Dt - Ht : Dt;
  }
  let Kt, Tt;
  class Rt {
    constructor(Ct, Dt) {
      if (this.hashLen = Ct, this.qByteLen = Dt, typeof Ct != "number" || Ct < 2)
        throw new Error("hashLen must be a number");
      if (typeof Dt != "number" || Dt < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(Ct).fill(1), this.k = new Uint8Array(Ct).fill(0), this.counter = 0;
    }
    hmac(...Ct) {
      return A.utils.hmacSha256(this.k, ...Ct);
    }
    hmacSync(...Ct) {
      return Tt(this.k, ...Ct);
    }
    checkSync() {
      if (typeof Tt != "function")
        throw new vt("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(Ct = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), Ct), this.v = await this.hmac(this.v), Ct.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), Ct), this.v = await this.hmac(this.v));
    }
    reseedSync(Ct = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), Ct), this.v = this.hmacSync(this.v), Ct.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), Ct), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let Ct = 0;
      const Dt = [];
      for (; Ct < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const Ht = this.v.slice();
        Dt.push(Ht), Ct += this.v.length;
      }
      return wt(...Dt);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let Ct = 0;
      const Dt = [];
      for (; Ct < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const Ht = this.v.slice();
        Dt.push(Ht), Ct += this.v.length;
      }
      return wt(...Dt);
    }
  }
  function Wt(Ut) {
    return W < Ut && Ut < ie.n;
  }
  function Xt(Ut) {
    return W < Ut && Ut < ie.P;
  }
  function Zt(Ut, Ct, Dt, Ht = !0) {
    const { n: Yt } = ie, Qt = Lt(Ut, !0);
    if (!Wt(Qt))
      return;
    const er = kt(Qt, Yt), or = xt.BASE.multiply(Qt), ur = yt(or.x, Yt);
    if (ur === W)
      return;
    const ir = yt(er * yt(Ct + Dt * ur, Yt), Yt);
    if (ir === W)
      return;
    let Ar = new Bt(ur, ir), pr = (or.x === Ar.r ? 0 : 2) | Number(or.y & K);
    return Ht && Ar.hasHighS() && (Ar = Ar.normalizeS(), pr ^= 1), { sig: Ar, recovery: pr };
  }
  function ar(Ut) {
    let Ct;
    if (typeof Ut == "bigint")
      Ct = Ut;
    else if (typeof Ut == "number" && Number.isSafeInteger(Ut) && Ut > 0)
      Ct = BigInt(Ut);
    else if (typeof Ut == "string") {
      if (Ut.length !== 2 * pe)
        throw new Error("Expected 32 bytes of private key");
      Ct = ft(Ut);
    } else if (Ut instanceof Uint8Array) {
      if (Ut.length !== pe)
        throw new Error("Expected 32 bytes of private key");
      Ct = ct(Ut);
    } else
      throw new TypeError("Expected valid private key");
    if (!Wt(Ct))
      throw new Error("Expected private key: 0 < key < n");
    return Ct;
  }
  function fr(Ut) {
    return Ut instanceof xt ? (Ut.assertValidity(), Ut) : xt.fromHex(Ut);
  }
  function lr(Ut) {
    if (Ut instanceof Bt)
      return Ut.assertValidity(), Ut;
    try {
      return Bt.fromDER(Ut);
    } catch {
      return Bt.fromCompact(Ut);
    }
  }
  function Jt(Ut, Ct = !1) {
    return xt.fromPrivateKey(Ut).toRawBytes(Ct);
  }
  A.getPublicKey = Jt;
  function _r(Ut, Ct, Dt, Ht = !1) {
    return xt.fromSignature(Ut, Ct, Dt).toRawBytes(Ht);
  }
  A.recoverPublicKey = _r;
  function sr(Ut) {
    const Ct = Ut instanceof Uint8Array, Dt = typeof Ut == "string", Ht = (Ct || Dt) && Ut.length;
    return Ct ? Ht === nt || Ht === ot : Dt ? Ht === nt * 2 || Ht === ot * 2 : Ut instanceof xt;
  }
  function Mr(Ut, Ct, Dt = !1) {
    if (sr(Ut))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!sr(Ct))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const Ht = fr(Ct);
    return Ht.assertValidity(), Ht.multiply(ar(Ut)).toRawBytes(Dt);
  }
  A.getSharedSecret = Mr;
  function Sr(Ut) {
    const Ct = Ut.length > ne ? Ut.slice(0, ne) : Ut;
    return ct(Ct);
  }
  function cr(Ut) {
    const Ct = Sr(Ut), Dt = yt(Ct, ie.n);
    return Br(Dt < W ? Ct : Dt);
  }
  function Br(Ut) {
    return it(Ut);
  }
  function $r(Ut, Ct, Dt) {
    if (Ut == null)
      throw new Error(`sign: expected valid message hash, not "${Ut}"`);
    const Ht = ht(Ut), Yt = ar(Ct), Qt = [Br(Yt), cr(Ht)];
    if (Dt != null) {
      Dt === !0 && (Dt = A.utils.randomBytes(ne));
      const ur = ht(Dt);
      if (ur.length !== ne)
        throw new Error(`sign: Expected ${ne} bytes of extra data`);
      Qt.push(ur);
    }
    const er = wt(...Qt), or = Sr(Ht);
    return { seed: er, m: or, d: Yt };
  }
  function yr(Ut, Ct) {
    const { sig: Dt, recovery: Ht } = Ut, { der: Yt, recovered: Qt } = Object.assign({ canonical: !0, der: !0 }, Ct), er = Yt ? Dt.toDERRawBytes() : Dt.toCompactRawBytes();
    return Qt ? [er, Ht] : er;
  }
  async function kr(Ut, Ct, Dt = {}) {
    const { seed: Ht, m: Yt, d: Qt } = $r(Ut, Ct, Dt.extraEntropy), er = new Rt(rt, pe);
    await er.reseed(Ht);
    let or;
    for (; !(or = Zt(await er.generate(), Yt, Qt, Dt.canonical)); )
      await er.reseed();
    return yr(or, Dt);
  }
  A.sign = kr;
  function Tr(Ut, Ct, Dt = {}) {
    const { seed: Ht, m: Yt, d: Qt } = $r(Ut, Ct, Dt.extraEntropy), er = new Rt(rt, pe);
    er.reseedSync(Ht);
    let or;
    for (; !(or = Zt(er.generateSync(), Yt, Qt, Dt.canonical)); )
      er.reseedSync();
    return yr(or, Dt);
  }
  A.signSync = Tr;
  const It = { strict: !0 };
  function St(Ut, Ct, Dt, Ht = It) {
    let Yt;
    try {
      Yt = lr(Ut), Ct = ht(Ct);
    } catch {
      return !1;
    }
    const { r: Qt, s: er } = Yt;
    if (Ht.strict && Yt.hasHighS())
      return !1;
    const or = Lt(Ct);
    let ur;
    try {
      ur = fr(Dt);
    } catch {
      return !1;
    }
    const { n: ir } = ie, Ar = kt(er, ir), pr = yt(or * Ar, ir), Ft = yt(Qt * Ar, ir), tr = xt.BASE.multiplyAndAddUnsafe(ur, pr, Ft);
    return tr ? yt(tr.x, ir) === Qt : !1;
  }
  A.verify = St;
  function At(Ut) {
    return yt(ct(Ut), ie.n);
  }
  class Ot {
    constructor(Ct, Dt) {
      this.r = Ct, this.s = Dt, this.assertValidity();
    }
    static fromHex(Ct) {
      const Dt = ht(Ct);
      if (Dt.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${Dt.length}`);
      const Ht = ct(Dt.subarray(0, 32)), Yt = ct(Dt.subarray(32, 64));
      return new Ot(Ht, Yt);
    }
    assertValidity() {
      const { r: Ct, s: Dt } = this;
      if (!Xt(Ct) || !Wt(Dt))
        throw new Error("Invalid signature");
    }
    toHex() {
      return ce(this.r) + ce(this.s);
    }
    toRawBytes() {
      return lt(this.toHex());
    }
  }
  function Gt(Ut) {
    return xt.fromPrivateKey(Ut).toRawX();
  }
  class zt {
    constructor(Ct, Dt, Ht = A.utils.randomBytes()) {
      if (Ct == null)
        throw new TypeError(`sign: Expected valid message, not "${Ct}"`);
      this.m = ht(Ct);
      const { x: Yt, scalar: Qt } = this.getScalar(ar(Dt));
      if (this.px = Yt, this.d = Qt, this.rand = ht(Ht), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(Ct) {
      const Dt = xt.fromPrivateKey(Ct), Ht = Dt.hasEvenY() ? Ct : ie.n - Ct;
      return { point: Dt, scalar: Ht, x: Dt.toRawX() };
    }
    initNonce(Ct, Dt) {
      return it(Ct ^ ct(Dt));
    }
    finalizeNonce(Ct) {
      const Dt = yt(ct(Ct), ie.n);
      if (Dt === W)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: Ht, x: Yt, scalar: Qt } = this.getScalar(Dt);
      return { R: Ht, rx: Yt, k: Qt };
    }
    finalizeSig(Ct, Dt, Ht, Yt) {
      return new Ot(Ct.x, yt(Dt + Ht * Yt, ie.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: Ct, d: Dt, px: Ht, rand: Yt } = this, Qt = A.utils.taggedHash, er = this.initNonce(Dt, await Qt(qr.aux, Yt)), { R: or, rx: ur, k: ir } = this.finalizeNonce(await Qt(qr.nonce, er, Ht, Ct)), Ar = At(await Qt(qr.challenge, ur, Ht, Ct)), pr = this.finalizeSig(or, ir, Ar, Dt);
      return await Pr(pr, Ct, Ht) || this.error(), pr;
    }
    calcSync() {
      const { m: Ct, d: Dt, px: Ht, rand: Yt } = this, Qt = A.utils.taggedHashSync, er = this.initNonce(Dt, Qt(qr.aux, Yt)), { R: or, rx: ur, k: ir } = this.finalizeNonce(Qt(qr.nonce, er, Ht, Ct)), Ar = At(Qt(qr.challenge, ur, Ht, Ct)), pr = this.finalizeSig(or, ir, Ar, Dt);
      return gr(pr, Ct, Ht) || this.error(), pr;
    }
  }
  async function Vt(Ut, Ct, Dt) {
    return new zt(Ut, Ct, Dt).calc();
  }
  function Er(Ut, Ct, Dt) {
    return new zt(Ut, Ct, Dt).calcSync();
  }
  function wr(Ut, Ct, Dt) {
    const Ht = Ut instanceof Ot, Yt = Ht ? Ut : Ot.fromHex(Ut);
    return Ht && Yt.assertValidity(), {
      ...Yt,
      m: ht(Ct),
      P: fr(Dt)
    };
  }
  function hr(Ut, Ct, Dt, Ht) {
    const Yt = xt.BASE.multiplyAndAddUnsafe(Ct, ar(Dt), yt(-Ht, ie.n));
    return !(!Yt || !Yt.hasEvenY() || Yt.x !== Ut);
  }
  async function Pr(Ut, Ct, Dt) {
    try {
      const { r: Ht, s: Yt, m: Qt, P: er } = wr(Ut, Ct, Dt), or = At(await A.utils.taggedHash(qr.challenge, it(Ht), er.toRawX(), Qt));
      return hr(Ht, er, Yt, or);
    } catch {
      return !1;
    }
  }
  function gr(Ut, Ct, Dt) {
    try {
      const { r: Ht, s: Yt, m: Qt, P: er } = wr(Ut, Ct, Dt), or = At(A.utils.taggedHashSync(qr.challenge, it(Ht), er.toRawX(), Qt));
      return hr(Ht, er, Yt, or);
    } catch (Ht) {
      if (Ht instanceof vt)
        throw Ht;
      return !1;
    }
  }
  A.schnorr = {
    Signature: Ot,
    getPublicKey: Gt,
    sign: Vt,
    verify: Pr,
    signSync: Er,
    verifySync: gr
  }, xt.BASE._setWindowSize(8);
  const vr = {
    node: B,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, qr = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, Ir = {};
  A.utils = {
    bytesToHex: Oe,
    hexToBytes: lt,
    concatBytes: wt,
    mod: yt,
    invert: kt,
    isValidPrivateKey(Ut) {
      try {
        return ar(Ut), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: it,
    _normalizePrivateKey: ar,
    hashToPrivateKey: (Ut) => {
      Ut = ht(Ut);
      const Ct = pe + 8;
      if (Ut.length < Ct || Ut.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const Dt = yt(ct(Ut), ie.n - K) + K;
      return it(Dt);
    },
    randomBytes: (Ut = 32) => {
      if (vr.web)
        return vr.web.getRandomValues(new Uint8Array(Ut));
      if (vr.node) {
        const { randomBytes: Ct } = vr.node;
        return Uint8Array.from(Ct(Ut));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => A.utils.hashToPrivateKey(A.utils.randomBytes(pe + 8)),
    precompute(Ut = 8, Ct = xt.BASE) {
      const Dt = Ct === xt.BASE ? Ct : new xt(Ct.x, Ct.y);
      return Dt._setWindowSize(Ut), Dt.multiply(L), Dt;
    },
    sha256: async (...Ut) => {
      if (vr.web) {
        const Ct = await vr.web.subtle.digest("SHA-256", wt(...Ut));
        return new Uint8Array(Ct);
      } else if (vr.node) {
        const { createHash: Ct } = vr.node, Dt = Ct("sha256");
        return Ut.forEach((Ht) => Dt.update(Ht)), Uint8Array.from(Dt.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (Ut, ...Ct) => {
      if (vr.web) {
        const Dt = await vr.web.subtle.importKey("raw", Ut, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), Ht = wt(...Ct), Yt = await vr.web.subtle.sign("HMAC", Dt, Ht);
        return new Uint8Array(Yt);
      } else if (vr.node) {
        const { createHmac: Dt } = vr.node, Ht = Dt("sha256", Ut);
        return Ct.forEach((Yt) => Ht.update(Yt)), Uint8Array.from(Ht.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (Ut, ...Ct) => {
      let Dt = Ir[Ut];
      if (Dt === void 0) {
        const Ht = await A.utils.sha256(Uint8Array.from(Ut, (Yt) => Yt.charCodeAt(0)));
        Dt = wt(Ht, Ht), Ir[Ut] = Dt;
      }
      return A.utils.sha256(Dt, ...Ct);
    },
    taggedHashSync: (Ut, ...Ct) => {
      if (typeof Kt != "function")
        throw new vt("sha256Sync is undefined, you need to set it");
      let Dt = Ir[Ut];
      if (Dt === void 0) {
        const Ht = Kt(Uint8Array.from(Ut, (Yt) => Yt.charCodeAt(0)));
        Dt = wt(Ht, Ht), Ir[Ut] = Dt;
      }
      return Kt(Dt, ...Ct);
    },
    _JacobianPoint: mt
  }, Object.defineProperties(A.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return Kt;
      },
      set(Ut) {
        Kt || (Kt = Ut);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return Tt;
      },
      set(Ut) {
        Tt || (Tt = Ut);
      }
    }
  });
})(lib);
var ecdsaSigFormatter = {};
Object.defineProperty(ecdsaSigFormatter, "__esModule", { value: !0 });
ecdsaSigFormatter.joseToDer = ecdsaSigFormatter.derToJose = void 0;
const base64_js_1 = base64Js, base64Url_1 = base64Url;
function getParamSize(A) {
  return (A / 8 | 0) + (A % 8 === 0 ? 0 : 1);
}
const paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg(A) {
  const B = paramBytesForAlg[A];
  if (B)
    return B;
  throw new Error(`Unknown algorithm "${A}"`);
}
const MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function signatureAsBytes(A) {
  if (A instanceof Uint8Array)
    return A;
  if (typeof A == "string")
    return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(A));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function derToJose(A, B) {
  const W = signatureAsBytes(A), K = getParamBytesForAlg(B), J = K + 1, L = W.length;
  let re = 0;
  if (W[re++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  let ie = W[re++];
  if (ie === (MAX_OCTET | 1) && (ie = W[re++]), L - re < ie)
    throw new Error(`"seq" specified length of "${ie}", only "${L - re}" remaining`);
  if (W[re++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  const oe = W[re++];
  if (L - re - 2 < oe)
    throw new Error(`"r" specified length of "${oe}", only "${L - re - 2}" available`);
  if (J < oe)
    throw new Error(`"r" specified length of "${oe}", max of "${J}" is acceptable`);
  const ke = re;
  if (re += oe, W[re++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  const ne = W[re++];
  if (L - re !== ne)
    throw new Error(`"s" specified length of "${ne}", expected "${L - re}"`);
  if (J < ne)
    throw new Error(`"s" specified length of "${ne}", max of "${J}" is acceptable`);
  const pe = re;
  if (re += ne, re !== L)
    throw new Error(`Expected to consume entire array, but "${L - re}" bytes remain`);
  const rt = K - oe, nt = K - ne, ot = new Uint8Array(rt + oe + nt + ne);
  for (re = 0; re < rt; ++re)
    ot[re] = 0;
  ot.set(W.subarray(ke + Math.max(-rt, 0), ke + oe), re), re = K;
  for (const ut = re; re < ut + nt; ++re)
    ot[re] = 0;
  return ot.set(W.subarray(pe + Math.max(-nt, 0), pe + ne), re), (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(ot));
}
ecdsaSigFormatter.derToJose = derToJose;
function countPadding(A, B, W) {
  let K = 0;
  for (; B + K < W && A[B + K] === 0; )
    ++K;
  return A[B + K] >= MAX_OCTET && --K, K;
}
function joseToDer(A, B) {
  A = signatureAsBytes(A);
  const W = getParamBytesForAlg(B), K = A.length;
  if (K !== W * 2)
    throw new TypeError(`"${B}" signatures must be "${W * 2}" bytes, saw "${K}"`);
  const J = countPadding(A, 0, W), L = countPadding(A, W, A.length), re = W - J, ie = W - L, oe = 2 + re + 1 + 1 + ie, ke = oe < MAX_OCTET, ne = new Uint8Array((ke ? 2 : 3) + oe);
  let pe = 0;
  return ne[pe++] = ENCODED_TAG_SEQ, ke ? ne[pe++] = oe : (ne[pe++] = MAX_OCTET | 1, ne[pe++] = oe & 255), ne[pe++] = ENCODED_TAG_INT, ne[pe++] = re, J < 0 ? (ne[pe++] = 0, ne.set(A.subarray(0, W), pe), pe += W) : (ne.set(A.subarray(J, W), pe), pe += W - J), ne[pe++] = ENCODED_TAG_INT, ne[pe++] = ie, L < 0 ? (ne[pe++] = 0, ne.set(A.subarray(W), pe)) : ne.set(A.subarray(W + L), pe), ne;
}
ecdsaSigFormatter.joseToDer = joseToDer;
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: !0 });
errors$1.InvalidTokenError = errors$1.MissingParametersError = void 0;
class MissingParametersError extends Error {
  constructor(B) {
    super(), this.name = "MissingParametersError", this.message = B || "";
  }
}
errors$1.MissingParametersError = MissingParametersError;
class InvalidTokenError extends Error {
  constructor(B) {
    super(), this.name = "InvalidTokenError", this.message = B || "";
  }
}
errors$1.InvalidTokenError = InvalidTokenError;
Object.defineProperty(secp256k1$1, "__esModule", { value: !0 });
secp256k1$1.SECP256K1Client = void 0;
const hmac_1 = hmac$1, sha256_1$3 = sha256$4, secp = lib, ecdsaSigFormatter_1 = ecdsaSigFormatter, errors_1$2 = errors$1, utils_1$2 = utils$5;
secp.utils.hmacSha256Sync = (A, ...B) => {
  const W = hmac_1.hmac.create(sha256_1$3.sha256, A);
  return B.forEach((K) => W.update(K)), W.digest();
};
class SECP256K1Client {
  static derivePublicKey(B, W = !0) {
    return B.length === 66 && (B = B.slice(0, 64)), B.length < 64 && (B = B.padStart(64, "0")), (0, utils_1$2.bytesToHex)(secp.getPublicKey(B, W));
  }
  static signHash(B, W, K = "jose") {
    if (!B || !W)
      throw new errors_1$2.MissingParametersError("a signing input hash and private key are all required");
    const J = secp.signSync(B, W.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (K === "der")
      return (0, utils_1$2.bytesToHex)(J);
    if (K === "jose")
      return (0, ecdsaSigFormatter_1.derToJose)(J, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(B) {
    return (0, ecdsaSigFormatter_1.joseToDer)(B, "ES256");
  }
  static verifyHash(B, W, K) {
    if (!B || !W || !K)
      throw new errors_1$2.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return secp.verify(W, B, K, { strict: !1 });
  }
}
secp256k1$1.SECP256K1Client = SECP256K1Client;
SECP256K1Client.algorithmName = "ES256K";
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.cryptoClients = A.SECP256K1Client = void 0;
  const B = secp256k1$1;
  Object.defineProperty(A, "SECP256K1Client", { enumerable: !0, get: function() {
    return B.SECP256K1Client;
  } });
  const W = {
    ES256K: B.SECP256K1Client
  };
  A.cryptoClients = W;
})(cryptoClients);
var sha256$1 = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(A, B, W, K) {
  function J(L) {
    return L instanceof W ? L : new W(function(re) {
      re(L);
    });
  }
  return new (W || (W = Promise))(function(L, re) {
    function ie(ne) {
      try {
        ke(K.next(ne));
      } catch (pe) {
        re(pe);
      }
    }
    function oe(ne) {
      try {
        ke(K.throw(ne));
      } catch (pe) {
        re(pe);
      }
    }
    function ke(ne) {
      ne.done ? L(ne.value) : J(ne.value).then(ie, oe);
    }
    ke((K = K.apply(A, B || [])).next());
  });
};
Object.defineProperty(sha256$1, "__esModule", { value: !0 });
sha256$1.hashSha256Async = sha256$1.hashSha256 = void 0;
const sha256_1$2 = sha256$4;
function hashSha256(A) {
  return (0, sha256_1$2.sha256)(A);
}
sha256$1.hashSha256 = hashSha256;
function hashSha256Async(A) {
  return __awaiter$1(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const W = typeof A == "string" ? new TextEncoder().encode(A) : A, K = yield crypto.subtle.digest("SHA-256", W);
        return new Uint8Array(K);
      } else {
        const W = requireCryptoBrowserify();
        if (!W.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(W.createHash("sha256").update(A).digest());
      }
    } catch (B) {
      return console.log(B), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(hashSha256(A));
    }
  });
}
sha256$1.hashSha256Async = hashSha256Async;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(A, B, W, K) {
  function J(L) {
    return L instanceof W ? L : new W(function(re) {
      re(L);
    });
  }
  return new (W || (W = Promise))(function(L, re) {
    function ie(ne) {
      try {
        ke(K.next(ne));
      } catch (pe) {
        re(pe);
      }
    }
    function oe(ne) {
      try {
        ke(K.throw(ne));
      } catch (pe) {
        re(pe);
      }
    }
    function ke(ne) {
      ne.done ? L(ne.value) : J(ne.value).then(ie, oe);
    }
    ke((K = K.apply(A, B || [])).next());
  });
};
Object.defineProperty(signer, "__esModule", { value: !0 });
signer.TokenSigner = signer.createUnsecuredToken = void 0;
const base64url$2 = base64Url, cryptoClients_1$1 = cryptoClients, errors_1$1 = errors$1, sha256_1$1 = sha256$1;
function createSigningInput(A, B) {
  const W = [], K = base64url$2.encode(JSON.stringify(B));
  W.push(K);
  const J = base64url$2.encode(JSON.stringify(A));
  return W.push(J), W.join(".");
}
function createUnsecuredToken(A) {
  return createSigningInput(A, { typ: "JWT", alg: "none" }) + ".";
}
signer.createUnsecuredToken = createUnsecuredToken;
class TokenSigner {
  constructor(B, W) {
    if (!(B && W))
      throw new errors_1$1.MissingParametersError("a signing algorithm and private key are required");
    if (typeof B != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (B = B.toUpperCase(), !cryptoClients_1$1.cryptoClients.hasOwnProperty(B))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1$1.cryptoClients[B], this.rawPrivateKey = W;
  }
  header(B = {}) {
    const W = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, W, B);
  }
  sign(B, W = !1, K = {}) {
    const J = this.header(K), L = createSigningInput(B, J), re = (0, sha256_1$1.hashSha256)(L);
    return this.createWithSignedHash(B, W, J, L, re);
  }
  signAsync(B, W = !1, K = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const J = this.header(K), L = createSigningInput(B, J), re = yield (0, sha256_1$1.hashSha256Async)(L);
      return this.createWithSignedHash(B, W, J, L, re);
    });
  }
  createWithSignedHash(B, W, K, J, L) {
    const re = this.cryptoClient.signHash(L, this.rawPrivateKey);
    return W ? {
      header: [base64url$2.encode(JSON.stringify(K))],
      payload: JSON.stringify(B),
      signature: [re]
    } : [J, re].join(".");
  }
}
signer.TokenSigner = TokenSigner;
var verifier = {};
Object.defineProperty(verifier, "__esModule", { value: !0 });
verifier.TokenVerifier = void 0;
const base64url$1 = base64Url, cryptoClients_1 = cryptoClients, errors_1 = errors$1, sha256_1 = sha256$1;
class TokenVerifier {
  constructor(B, W) {
    if (!(B && W))
      throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
    if (typeof B != "string")
      throw "signing algorithm parameter must be a string";
    if (B = B.toUpperCase(), !cryptoClients_1.cryptoClients.hasOwnProperty(B))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1.cryptoClients[B], this.rawPublicKey = W;
  }
  verify(B) {
    return typeof B == "string" ? this.verifyCompact(B, !1) : typeof B == "object" ? this.verifyExpanded(B, !1) : !1;
  }
  verifyAsync(B) {
    return typeof B == "string" ? this.verifyCompact(B, !0) : typeof B == "object" ? this.verifyExpanded(B, !0) : Promise.resolve(!1);
  }
  verifyCompact(B, W) {
    const K = B.split("."), J = K[0] + "." + K[1], L = (re) => {
      const ie = this.cryptoClient.loadSignature(K[2]);
      return this.cryptoClient.verifyHash(re, ie, this.rawPublicKey);
    };
    if (W)
      return (0, sha256_1.hashSha256Async)(J).then((re) => L(re));
    {
      const re = (0, sha256_1.hashSha256)(J);
      return L(re);
    }
  }
  verifyExpanded(B, W) {
    const K = [B.header.join("."), base64url$1.encode(B.payload)].join(".");
    let J = !0;
    const L = (re) => (B.signature.map((ie) => {
      const oe = this.cryptoClient.loadSignature(ie);
      this.cryptoClient.verifyHash(re, oe, this.rawPublicKey) || (J = !1);
    }), J);
    if (W)
      return (0, sha256_1.hashSha256Async)(K).then((re) => L(re));
    {
      const re = (0, sha256_1.hashSha256)(K);
      return L(re);
    }
  }
}
verifier.TokenVerifier = TokenVerifier;
var decode$i = {};
Object.defineProperty(decode$i, "__esModule", { value: !0 });
decode$i.decodeToken = void 0;
const base64url = base64Url;
function decodeToken(A) {
  if (typeof A == "string") {
    const B = A.split("."), W = JSON.parse(base64url.decode(B[0])), K = JSON.parse(base64url.decode(B[1])), J = B[2];
    return {
      header: W,
      payload: K,
      signature: J
    };
  } else if (typeof A == "object") {
    if (typeof A.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let B = A.payload;
    A.payload[0] !== "{" && (B = base64url.decode(B));
    const W = [];
    return A.header.map((K) => {
      const J = JSON.parse(base64url.decode(K));
      W.push(J);
    }), {
      header: W,
      payload: JSON.parse(B),
      signature: A.signature
    };
  }
}
decode$i.decodeToken = decodeToken;
(function(A) {
  var B = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(K, J, L, re) {
    re === void 0 && (re = L);
    var ie = Object.getOwnPropertyDescriptor(J, L);
    (!ie || ("get" in ie ? !J.__esModule : ie.writable || ie.configurable)) && (ie = { enumerable: !0, get: function() {
      return J[L];
    } }), Object.defineProperty(K, re, ie);
  } : function(K, J, L, re) {
    re === void 0 && (re = L), K[re] = J[L];
  }), W = commonjsGlobal && commonjsGlobal.__exportStar || function(K, J) {
    for (var L in K) L !== "default" && !Object.prototype.hasOwnProperty.call(J, L) && B(J, K, L);
  };
  Object.defineProperty(A, "__esModule", { value: !0 }), W(signer, A), W(verifier, A), W(decode$i, A), W(errors$1, A), W(cryptoClients, A);
})(lib$1);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const A = Array(256).fill(-1);
  for (let B = 0; B < r.length; ++B) A[r.charCodeAt(B)] = B;
})();
var s, i, o, h$1 = (s = function(A, B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.bech32m = B.bech32 = void 0;
  const W = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", K = {};
  for (let pe = 0; pe < 32; pe++) {
    const rt = W.charAt(pe);
    K[rt] = pe;
  }
  function J(pe) {
    const rt = pe >> 25;
    return (33554431 & pe) << 5 ^ 996825010 & -(rt >> 0 & 1) ^ 642813549 & -(rt >> 1 & 1) ^ 513874426 & -(rt >> 2 & 1) ^ 1027748829 & -(rt >> 3 & 1) ^ 705979059 & -(rt >> 4 & 1);
  }
  function L(pe) {
    let rt = 1;
    for (let nt = 0; nt < pe.length; ++nt) {
      const ot = pe.charCodeAt(nt);
      if (ot < 33 || ot > 126) return "Invalid prefix (" + pe + ")";
      rt = J(rt) ^ ot >> 5;
    }
    rt = J(rt);
    for (let nt = 0; nt < pe.length; ++nt) {
      const ot = pe.charCodeAt(nt);
      rt = J(rt) ^ 31 & ot;
    }
    return rt;
  }
  function re(pe, rt, nt, ot) {
    let ut = 0, dt = 0;
    const vt = (1 << nt) - 1, pt = [];
    for (let mt = 0; mt < pe.length; ++mt) for (ut = ut << rt | pe[mt], dt += rt; dt >= nt; ) dt -= nt, pt.push(ut >> dt & vt);
    if (ot) dt > 0 && pt.push(ut << nt - dt & vt);
    else {
      if (dt >= rt) return "Excess padding";
      if (ut << nt - dt & vt) return "Non-zero padding";
    }
    return pt;
  }
  function ie(pe) {
    return re(pe, 8, 5, !0);
  }
  function oe(pe) {
    const rt = re(pe, 5, 8, !1);
    if (Array.isArray(rt)) return rt;
  }
  function ke(pe) {
    const rt = re(pe, 5, 8, !1);
    if (Array.isArray(rt)) return rt;
    throw new Error(rt);
  }
  function ne(pe) {
    let rt;
    function nt(ot, ut) {
      if (ut = ut || 90, ot.length < 8) return ot + " too short";
      if (ot.length > ut) return "Exceeds length limit";
      const dt = ot.toLowerCase(), vt = ot.toUpperCase();
      if (ot !== dt && ot !== vt) return "Mixed-case string " + ot;
      const pt = (ot = dt).lastIndexOf("1");
      if (pt === -1) return "No separator character for " + ot;
      if (pt === 0) return "Missing prefix for " + ot;
      const mt = ot.slice(0, pt), gt = ot.slice(pt + 1);
      if (gt.length < 6) return "Data too short";
      let Pt = L(mt);
      if (typeof Pt == "string") return Pt;
      const xt = [];
      for (let Nt = 0; Nt < gt.length; ++Nt) {
        const Et = gt.charAt(Nt), bt = K[Et];
        if (bt === void 0) return "Unknown character " + Et;
        Pt = J(Pt) ^ bt, Nt + 6 >= gt.length || xt.push(bt);
      }
      return Pt !== rt ? "Invalid checksum for " + ot : { prefix: mt, words: xt };
    }
    return rt = pe === "bech32" ? 1 : 734539939, { decodeUnsafe: function(ot, ut) {
      const dt = nt(ot, ut);
      if (typeof dt == "object") return dt;
    }, decode: function(ot, ut) {
      const dt = nt(ot, ut);
      if (typeof dt == "object") return dt;
      throw new Error(dt);
    }, encode: function(ot, ut, dt) {
      if (dt = dt || 90, ot.length + 7 + ut.length > dt) throw new TypeError("Exceeds length limit");
      let vt = L(ot = ot.toLowerCase());
      if (typeof vt == "string") throw new Error(vt);
      let pt = ot + "1";
      for (let mt = 0; mt < ut.length; ++mt) {
        const gt = ut[mt];
        if (gt >> 5) throw new Error("Non 5-bit word");
        vt = J(vt) ^ gt, pt += W.charAt(gt);
      }
      for (let mt = 0; mt < 6; ++mt) vt = J(vt);
      vt ^= rt;
      for (let mt = 0; mt < 6; ++mt) pt += W.charAt(vt >> 5 * (5 - mt) & 31);
      return pt;
    }, toWords: ie, fromWordsUnsafe: oe, fromWords: ke };
  }
  B.bech32 = ne("bech32"), B.bech32m = ne("bech32m");
}, s(i = { exports: {} }, i.exports), i.exports);
(o = h$1) && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") && o.default;
h$1.bech32m;
h$1.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var x, k;
(function(A) {
  A.mainnet = "mainnet", A.testnet = "testnet", A.regtest = "regtest";
})(x || (x = {})), function(A) {
  A.p2pkh = "p2pkh", A.p2sh = "p2sh", A.p2wpkh = "p2wpkh", A.p2wsh = "p2wsh", A.p2tr = "p2tr";
}(k || (k = {}));
k.p2pkh, x.mainnet, k.p2pkh, x.testnet, k.p2sh, x.mainnet, k.p2sh, x.testnet;
var accountChangeEventName = "accountChange";
object({
  type: literal(accountChangeEventName)
});
var networkChangeEventName = "networkChange", networkType = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  type: literal(networkChangeEventName),
  bitcoin: object({
    name: picklist(networkType)
  }),
  stacks: object({
    name: string()
  })
});
var disconnectEventName = "disconnect";
object({
  type: literal(disconnectEventName)
});
async function getProviderOrThrow(A) {
  var W;
  const B = await (A == null ? void 0 : A()) || ((W = window.XverseProviders) == null ? void 0 : W.BitcoinProvider) || window.BitcoinProvider;
  if (!B)
    throw new Error("No Bitcoin wallet installed");
  return B;
}
var BitcoinNetworkType = /* @__PURE__ */ ((A) => (A.Mainnet = "Mainnet", A.Testnet = "Testnet", A.Testnet4 = "Testnet4", A.Signet = "Signet", A.Regtest = "Regtest", A))(BitcoinNetworkType || {}), RpcIdSchema = optional(union([string(), number(), null_()])), rpcRequestMessageSchema = object({
  jsonrpc: literal("2.0"),
  method: string(),
  params: optional(
    union([
      array(unknown()),
      looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      null_()
    ])
  ),
  id: unwrap(RpcIdSchema)
}), rpcSuccessResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  result: nonOptional(unknown()),
  id: RpcIdSchema
}), rpcErrorResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  error: nonOptional(unknown()),
  id: RpcIdSchema
});
union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);
var stxCallContractMethodName = "stx_callContract", stxCallContractParamsSchema = object({
  /**
   * The contract principal.
   *
   * E.g. `"SPKE...GD5C.my-contract"`
   */
  contract: string(),
  /**
   * The name of the function to call.
   *
   * Note: spec changes ongoing,
   * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
   */
  functionName: string(),
  /**
   * The function's arguments. The arguments are expected to be hex-encoded
   * strings of Clarity values.
   *
   * To convert Clarity values to their hex representation, the `cvToHex`
   * helper from the `@stacks/transactions` package may be helpful.
   *
   * ```js
   * import { cvToHex } from '@stacks/transactions';
   *
   * const functionArgs = [someClarityValue1, someClarityValue2];
   * const hexArgs = functionArgs.map(cvToHex);
   * ```
   */
  arguments: optional(array(string()))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxCallContractMethodName),
    params: stxCallContractParamsSchema,
    id: string()
  }).entries
});
var stxDeployContractMethodName = "stx_deployContract", stxDeployContractParamsSchema = object({
  /**
   * Name of the contract.
   */
  name: string(),
  /**
   * The source code of the Clarity contract.
   */
  clarityCode: string(),
  /**
   * The version of the Clarity contract.
   */
  clarityVersion: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxDeployContractMethodName),
    params: stxDeployContractParamsSchema,
    id: string()
  }).entries
});
var stxGetAccountsMethodName = "stx_getAccounts", stxGetAccountsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAccountsMethodName),
    params: stxGetAccountsParamsSchema,
    id: string()
  }).entries
});
var AddressPurpose = /* @__PURE__ */ ((A) => (A.Ordinals = "ordinals", A.Payment = "payment", A.Stacks = "stacks", A))(AddressPurpose || {}), AddressType = /* @__PURE__ */ ((A) => (A.p2pkh = "p2pkh", A.p2sh = "p2sh", A.p2wpkh = "p2wpkh", A.p2wsh = "p2wsh", A.p2tr = "p2tr", A.stacks = "stacks", A))(AddressType || {}), addressSchema = object({
  address: string(),
  publicKey: string(),
  purpose: enum_(AddressPurpose),
  addressType: enum_(AddressType),
  walletType: walletTypeSchema
}), getAddress = async (A) => {
  var K, J;
  const B = await getProviderOrThrow(A.getProvider), { purposes: W } = A.payload;
  if (!W)
    throw new Error("Address purposes are required");
  try {
    const L = lib$1.createUnsecuredToken(A.payload), re = await B.connect(L);
    (K = A.onFinish) == null || K.call(A, re);
  } catch (L) {
    console.error("[Connect] Error during address request", L), (J = A.onCancel) == null || J.call(A);
  }
}, stxGetAddressesMethodName = "stx_getAddresses", stxGetAddressesParamsSchema = nullish(
  object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: optional(string())
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: string()
  }).entries
});
var stxSignMessageMethodName = "stx_signMessage", stxSignMessageParamsSchema = object({
  /**
   * The message to sign.
   */
  message: string(),
  /**
   * The public key to sign the message with.
   */
  publicKey: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignMessageMethodName),
    params: stxSignMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignStructuredMessageMethodName = "stx_signStructuredMessage", stxSignStructuredMessageParamsSchema = object({
  /**
   * The domain to be signed.
   */
  domain: string(),
  /**
   * Message payload to be signed.
   */
  message: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number()),
  /**
   * The public key to sign the message with.
   */
  publicKey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignStructuredMessageMethodName),
    params: stxSignStructuredMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionMethodName = "stx_signTransaction", stxSignTransactionParamsSchema = object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionsMethodName = "stx_signTransactions", stxSignTransactionsParamsSchema = object({
  /**
   * The transactions to sign as hex-encoded strings.
   */
  transactions: pipe(
    array(
      pipe(
        string(),
        check$e((A) => !0, "Invalid hex-encoded Stacks transaction.")
      )
    ),
    minLength(1)
  ),
  /**
   * Whether the signed transactions should be broadcast after signing. Defaults
   * to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionsMethodName),
    params: stxSignTransactionsParamsSchema,
    id: string()
  }).entries
});
var stxTransferStxMethodName = "stx_transferStx", stxTransferStxParamsSchema = object({
  /**
   * Amount of STX tokens to transfer in microstacks as a string. Anything
   * parseable by `BigInt` is acceptable.
   *
   * Example,
   *
   * ```js
   * const amount1 = 1234;
   * const amount2 = 1234n;
   * const amount3 = '1234';
   * ```
   */
  amount: union([number(), string()]),
  /**
   * The recipeint's principal.
   */
  recipient: string(),
  /**
   * A string representing the memo.
   */
  memo: optional(string()),
  /**
   * Version of parameter format.
   */
  version: optional(string()),
  /**
   * The mode of the post conditions.
   */
  postConditionMode: optional(number()),
  /**
   * A hex-encoded string representing the post conditions.
   *
   * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
   *
   * ```js
   * import { serializePostCondition } from '@stacks/transactions';
   *
   * const postCondition = somePostCondition;
   * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
   * ```
   */
  postConditions: optional(array(string())),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxTransferStxMethodName),
    params: stxTransferStxParamsSchema,
    id: string()
  }).entries
});
var walletTypes = ["software", "ledger", "keystone"], walletTypeSchema = picklist(walletTypes), getInfoMethodName = "getInfo", getInfoParamsSchema = nullish(null_());
object({
  /**
   * Version of the wallet.
   */
  version: string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: optional(array(string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: array(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: string()
  }).entries
});
var getAddressesMethodName = "getAddresses", getAddressesParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: string()
  }).entries
});
var signMessageMethodName = "signMessage", MessageSigningProtocols = /* @__PURE__ */ ((A) => (A.ECDSA = "ECDSA", A.BIP322 = "BIP322", A))(MessageSigningProtocols || {}), signMessageParamsSchema = object({
  /**
   * The address used for signing.
   **/
  address: string(),
  /**
   * The message to sign.
   **/
  message: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: optional(enum_(MessageSigningProtocols))
});
object({
  /**
   * The signature of the message.
   */
  signature: string(),
  /**
   * hash of the message.
   */
  messageHash: string(),
  /**
   * The address used for signing.
   */
  address: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: enum_(MessageSigningProtocols)
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: string()
  }).entries
});
var sendTransferMethodName = "sendTransfer", sendTransferParamsSchema = object({
  /**
   * Array of recipients to send to.
   * The amount to send to each recipient is in satoshis.
   */
  recipients: array(
    object({
      address: string(),
      amount: number()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendTransferMethodName),
    params: sendTransferParamsSchema,
    id: string()
  }).entries
});
var signPsbtMethodName = "signPsbt", signPsbtParamsSchema = object({
  /**
   * The base64 encoded PSBT to sign.
   */
  psbt: string(),
  /**
   * The inputs to sign.
   * The key is the address and the value is an array of indexes of the inputs to sign.
   */
  signInputs: record(string(), array(number())),
  /**
   * Whether to broadcast the transaction after signing.
   **/
  broadcast: optional(boolean())
});
object({
  /**
   * The base64 encoded PSBT after signing.
   */
  psbt: string(),
  /**
   * The transaction id as a hex-encoded string.
   * This is only returned if the transaction was broadcast.
   **/
  txid: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signPsbtMethodName),
    params: signPsbtParamsSchema,
    id: string()
  }).entries
});
var getAccountsMethodName = "getAccounts", getAccountsParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
array(
  object({
    ...addressSchema.entries,
    ...object({
      walletType: walletTypeSchema
    }).entries
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: string()
  }).entries
});
var getBalanceMethodName = "getBalance";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getBalanceMethodName),
    id: string()
  }).entries
});
var accountActionsSchema = object({
  read: optional(boolean())
}), walletActionsSchema = object({
  readNetwork: optional(boolean())
}), accountPermissionSchema = object({
  type: literal("account"),
  resourceId: string(),
  clientId: string(),
  actions: accountActionsSchema
}), walletPermissionSchema = object({
  type: literal("wallet"),
  resourceId: string(),
  clientId: string(),
  actions: walletActionsSchema
}), PermissionRequestParams = variant("type", [
  object({
    ...omit(accountPermissionSchema, ["clientId"]).entries
  }),
  object({
    ...omit(walletPermissionSchema, ["clientId"]).entries
  })
]), requestPermissionsMethodName = "wallet_requestPermissions", requestPermissionsParamsSchema = nullish(array(PermissionRequestParams));
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions", renouncePermissionsParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: string()
  }).entries
});
var disconnectMethodName = "wallet_disconnect", disconnectParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(disconnectMethodName),
    params: disconnectParamsSchema,
    id: string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType", getWalletTypeParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getWalletTypeMethodName),
    params: getWalletTypeParamsSchema,
    id: string()
  }).entries
});
var getCurrentPermissionsMethodName = "wallet_getCurrentPermissions", getCurrentPermissionsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getCurrentPermissionsMethodName),
    params: getCurrentPermissionsParamsSchema,
    id: string()
  }).entries
});
var getAccountMethodName = "wallet_getAccount", getAccountParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountMethodName),
    params: getAccountParamsSchema,
    id: string()
  }).entries
});
var getNetworkMethodName = "wallet_getNetwork", getNetworkParamsSchema = nullish(null_()), networkType2 = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  bitcoin: object({
    name: picklist(networkType2)
  }),
  stacks: object({
    name: string()
  })
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getNetworkMethodName),
    params: getNetworkParamsSchema,
    id: string()
  }).entries
});
var connectMethodName = "wallet_connect", connectParamsSchema = nullish(
  object({
    permissions: optional(array(PermissionRequestParams)),
    addresses: optional(array(enum_(AddressPurpose))),
    message: optional(
      pipe(string(), maxLength(80, "The message must not exceed 80 characters."))
    )
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(connectMethodName),
    params: connectParamsSchema,
    id: string()
  }).entries
});
var runesEtchMethodName = "runes_etch", etchTermsSchema = object({
  amount: string(),
  cap: string(),
  heightStart: optional(string()),
  heightEnd: optional(string()),
  offsetStart: optional(string()),
  offsetEnd: optional(string())
}), inscriptionDetailsSchema = object({
  contentType: string(),
  contentBase64: string()
}), runesEtchParamsSchema = object({
  runeName: string(),
  divisibility: optional(number()),
  symbol: optional(string()),
  premine: optional(string()),
  isMintable: boolean(),
  delegateInscriptionId: optional(string()),
  destinationAddress: string(),
  refundAddress: string(),
  feeRate: number(),
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  terms: optional(etchTermsSchema),
  inscriptionDetails: optional(inscriptionDetailsSchema),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesEtchMethodName),
    params: runesEtchParamsSchema,
    id: string()
  }).entries
});
var runesGetBalanceMethodName = "runes_getBalance", runesGetBalanceParamsSchema = nullish(null_());
object({
  balances: array(
    object({
      runeName: string(),
      amount: string(),
      divisibility: number(),
      symbol: string(),
      inscriptionId: nullish(string())
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesGetBalanceMethodName),
    params: runesGetBalanceParamsSchema,
    id: string()
  }).entries
});
var runesMintMethodName = "runes_mint", runesMintParamsSchema = object({
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  destinationAddress: string(),
  feeRate: number(),
  refundAddress: string(),
  repeats: number(),
  runeName: string(),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesMintMethodName),
    params: runesMintParamsSchema,
    id: string()
  }).entries
});
var runesTransferMethodName = "runes_transfer", runesTransferParamsSchema = object({
  recipients: array(
    object({
      runeName: string(),
      amount: string(),
      address: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesTransferMethodName),
    params: runesTransferParamsSchema,
    id: string()
  }).entries
});
var getInscriptionsMethodName = "ord_getInscriptions", getInscriptionsParamsSchema = object({
  offset: number(),
  limit: number()
});
object({
  total: number(),
  limit: number(),
  offset: number(),
  inscriptions: array(
    object({
      inscriptionId: string(),
      inscriptionNumber: string(),
      address: string(),
      collectionName: optional(string()),
      postage: string(),
      contentLength: string(),
      contentType: string(),
      timestamp: number(),
      offset: number(),
      genesisTransaction: string(),
      output: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions", sendInscriptionsParamsSchema = object({
  transfers: array(
    object({
      address: string(),
      inscriptionId: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: string()
  }).entries
});
async function waitForUnisatExtensionReady() {
  let A = 0;
  const B = 20;
  for (; A < B; ) {
    if (typeof window < "u" && window.unisat)
      try {
        const W = await window.unisat.getAccounts();
        if (W && W.length > 0)
          return !0;
      } catch {
        break;
      }
    A += 1, await new Promise((W) => {
      setTimeout(W, 100);
    });
  }
  return !1;
}
const NETWORK_TO_BITCOIN_NETWORK_TYPE = {
  mainnet: BitcoinNetworkType.Mainnet,
  testnet: BitcoinNetworkType.Testnet,
  signet: BitcoinNetworkType.Signet
}, getXverseAddresses = async (A) => {
  var L;
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  if (!(typeof ((L = window.XverseProviders) == null ? void 0 : L.BitcoinProvider) < "u"))
    throw new BrowserWalletNotInstalledError("Xverse not installed");
  const W = async () => window.XverseProviders.BitcoinProvider, K = [], J = {
    payload: {
      purposes: ["ordinals", "payment"],
      message: "Provide access to Payment address and Ordinals address",
      network: {
        type: A === Network.TESTNET ? BitcoinNetworkType.Testnet4 : NETWORK_TO_BITCOIN_NETWORK_TYPE[A]
      }
    },
    getProvider: W,
    onFinish: (re) => {
      if (!re || !re.addresses || re.addresses.length !== 2)
        throw new BrowserWalletSigningError(
          "Failed to retrieve addresses using selected wallet"
        );
      re.addresses.forEach((ie) => {
        const oe = getAddressFormat(ie.address, A);
        let ke = ie.publicKey;
        oe === "taproot" && (ke = Buffer$1.from(ie.publicKey, "hex").length === 33 ? ke : `02${ke}`), K.push({
          publicKey: ke,
          address: ie.address,
          format: oe
        });
      });
    },
    onCancel: () => {
      throw new BrowserWalletRequestCancelledByUserError();
    }
  };
  return await getAddress(J), K;
}, WALLET_CHROME_EXTENSION_URL = {
  [Wallet.OKX]: "https://www.okx.com/web3",
  [Wallet.MAGICEDEN]: "https://wallet.magiceden.io/",
  [Wallet.UNISAT]: "https://unisat.io/download",
  // their www subdomain doesn't work
  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.LEATHER]: "https://leather.io/install-extension"
}, connectWallet = async ({
  network: A,
  wallet: B,
  chain: W = Chain.BITCOIN
}, { readOnly: K = !1 } = {}) => {
  switch (B) {
    case Wallet.UNISAT: {
      const J = await getAddresses$3(A, W, { readOnly: K });
      if (!J || J.length < 1)
        throw new Error("Unisat via Ordit returned no addresses");
      const L = J[0];
      return {
        address: {
          ordinals: L.address,
          payments: L.address
        },
        publicKey: {
          ordinals: L.publicKey,
          payments: L.publicKey
        },
        format: {
          ordinals: L.format,
          payments: L.format
        }
      };
    }
    case Wallet.XVERSE: {
      const J = await getXverseAddresses(A);
      if (!J || J.length < 1)
        throw new Error("Xverse via Ordit returned no addresses");
      const L = J.find(
        (ie) => ie.format === "p2sh-p2wpkh" || ie.format === "segwit"
      );
      if (!L)
        throw new Error(
          "Xverse via Ordit did not return a P2SH or Segwit address"
        );
      const re = J.find(
        (ie) => ie.format === "taproot"
      );
      if (!re)
        throw new Error("Xverse via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: re.address,
          payments: L.address
        },
        publicKey: {
          ordinals: re.publicKey,
          payments: L.publicKey
        },
        format: {
          ordinals: re.format,
          payments: L.format
        }
      };
    }
    case Wallet.MAGICEDEN: {
      const J = await getAddresses$2(A);
      if (!J || J.length < 1)
        throw new Error("Magic Eden via Ordit returned no addresses");
      const L = J.find(
        (ie) => ie.format === "segwit" || ie.format === "p2sh-p2wpkh"
      );
      if (!L)
        throw new Error(
          "Magic Eden via Ordit did not return a P2SH or Segwit address"
        );
      const re = J.find(
        (ie) => ie.format === "taproot"
      );
      if (!re)
        throw new Error(
          "Magic Eden via Ordit did not return a Taproot address"
        );
      return {
        address: {
          ordinals: re.address,
          payments: L.address
        },
        publicKey: {
          ordinals: re.publicKey,
          payments: L.publicKey
        },
        format: {
          ordinals: re.format,
          payments: L.format
        }
      };
    }
    case Wallet.LEATHER: {
      const J = await getAddresses$1(A);
      if (!J || J.length < 1)
        throw new Error("Leather via Ordit returned no addresses");
      const L = J.find(
        (ie) => ie.format === "segwit"
      );
      if (!L)
        throw new Error("Leather via Ordit did not return a Segwit address");
      const re = J.find(
        (ie) => ie.format === "taproot"
      );
      if (!re)
        throw new Error("Leather via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: re.address,
          payments: L.address
        },
        publicKey: {
          ordinals: re.publicKey,
          payments: L.publicKey
        },
        format: {
          ordinals: re.format,
          payments: L.format
        }
      };
    }
    case Wallet.OKX: {
      const J = await getAddresses(A);
      if (!J || J.length < 1)
        throw new Error("OKX via Ordit returned no addresses");
      const L = J[0];
      return {
        address: {
          ordinals: L.address,
          payments: L.address
        },
        publicKey: {
          ordinals: L.publicKey,
          payments: L.publicKey
        },
        format: {
          ordinals: L.format,
          payments: L.format
        }
      };
    }
    default:
      throw new Error("Invalid wallet");
  }
};
function useConnect({
  onClose: A,
  onError: B
}) {
  const {
    updateAddress: W,
    network: K,
    updateWallet: J,
    updatePublicKey: L,
    updateFormat: re,
    disconnectWallet: ie,
    address: oe,
    publicKey: ke,
    format: ne,
    wallet: pe,
    chain: rt
  } = useOrdConnect(), nt = (ut, dt) => {
    B(dt.message ?? dt.toString()), console.error(`Error while connecting to ${ut} wallet`, dt), ie(), dt instanceof BrowserWalletNotInstalledError && window.open(
      WALLET_CHROME_EXTENSION_URL[ut],
      "_blank",
      "noopener,noreferrer"
    );
  }, ot = async (ut, { readOnly: dt = !1 } = {}) => {
    try {
      const { address: vt, publicKey: pt, format: mt } = await connectWallet(
        { network: K, wallet: ut, chain: rt },
        { readOnly: dt }
      );
      return W({
        ordinals: vt.ordinals,
        payments: vt.payments
      }), L({
        ordinals: pt.ordinals,
        payments: pt.payments
      }), J(ut), re({
        ordinals: mt.ordinals,
        payments: mt.payments
      }), A(), !0;
    } catch (vt) {
      return nt(ut, vt), !1;
    }
  };
  return useEffect(() => {
    if (pe !== Wallet.UNISAT)
      return;
    let ut = !0, dt = !1;
    const vt = () => ot(Wallet.UNISAT);
    return oe && ke && ne && (async () => {
      const mt = await waitForUnisatExtensionReady();
      if (ut) {
        if (!mt) {
          ie();
          return;
        }
        dt = await ot(Wallet.UNISAT, {
          readOnly: !0
        }), ut && dt && window.unisat.addListener("accountsChanged", vt);
      }
    })(), () => {
      ut = !1, dt && window.unisat.removeListener("accountsChanged", vt);
    };
  }, [pe]), { connectWallet: ot };
}
const ChevronRightIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9%2018L15%2012L9%206'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LoadingIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='44'%20height='44'%20viewBox='0%200%2044%2044'%20stroke='%23fff'%3e%3cg%20fill='none'%20fill-rule='evenodd'%20stroke-width='2'%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='0s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='0s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='-0.9s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='-0.9s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3c/g%3e%3c/svg%3e", WALLET_TO_NAME = {
  [Wallet.MAGICEDEN]: "Magic Eden",
  [Wallet.UNISAT]: "UniSat",
  [Wallet.XVERSE]: "Xverse",
  [Wallet.LEATHER]: "Leather",
  [Wallet.OKX]: "OKX"
};
function WalletButton({
  wallet: A,
  onConnect: B,
  icon: W,
  renderAvatar: K,
  isPreferred: J
}) {
  const L = isMobileUserAgent(), { wallet: re, address: ie } = useOrdConnect(), [oe, ke] = useState(!1), ne = WALLET_TO_NAME[A], pe = async () => {
    ke(!0);
    try {
      await B();
    } catch {
    }
    ke(!1);
  }, rt = re === A && ie.ordinals;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      className: "wallet-option-button",
      onClick: pe,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "option-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "wallet-icon", src: W, alt: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-label", children: ne }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-subtitle", children: L ? "Available on app" : "" })
        ] }),
        re === A && ie.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option-connected-address", children: [
          K ? K(ie.ordinals, "small") : /* @__PURE__ */ jsxRuntimeExports.jsx(
            Avatar,
            {
              size: L ? 12 : 16,
              variant: "beam",
              name: ie.ordinals,
              colors: ["#1C2DCB", "#F226B8"]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: truncateMiddle(ie.ordinals) })
        ] }) : null,
        !rt && J ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "preferred-label", children: "Preferred" }) : null,
        oe ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: LoadingIcon,
            width: L ? 20 : 24,
            height: L ? 20 : 24,
            alt: `${ne} extension is loading`
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: ChevronRightIcon,
            alt: "",
            width: L ? 20 : 24,
            height: L ? 20 : 24,
            className: "chevron-btn"
          }
        )
      ] })
    }
  );
}
const CHAIN_TO_NAME = {
  [Chain.BITCOIN]: "Bitcoin",
  [Chain.FRACTAL_BITCOIN]: "Fractal Bitcoin"
};
function SelectWalletModal({
  isOpen: A,
  closeModal: B,
  renderAvatar: W,
  preferredWallet: K,
  walletsOrder: J,
  visibleWallets: L
}) {
  const [re, ie] = useState(""), { connectWallet: oe } = useConnect({
    onClose: B,
    onError: (nt) => ie(nt)
  }), { network: ke, chain: ne } = useOrdConnect(), pe = isMobileUserAgent(), rt = useMemo(() => {
    const ot = [
      {
        wallet: Wallet.OKX,
        onConnect: () => oe(Wallet.OKX),
        icon: OKXWalletIcon,
        hidden: pe && ke !== Network.MAINNET,
        order: 20,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.UNISAT,
        onConnect: () => oe(Wallet.UNISAT),
        icon: UnisatWalletIcon,
        hidden: pe,
        order: 21,
        chains: [Chain.BITCOIN, Chain.FRACTAL_BITCOIN]
      },
      {
        wallet: Wallet.XVERSE,
        onConnect: () => oe(Wallet.XVERSE),
        icon: XverseWalletIcon,
        order: 22,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.MAGICEDEN,
        onConnect: () => oe(Wallet.MAGICEDEN),
        icon: MagicEdenWalletIcon,
        order: 23,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.LEATHER,
        onConnect: () => oe(Wallet.LEATHER),
        icon: LeatherWalletIcon,
        hidden: pe,
        order: 24,
        chains: [Chain.BITCOIN]
      }
    ].filter((dt) => (L || []).includes(dt.wallet)).filter(
      (dt) => dt.chains.includes(ne) && !dt.hidden
    );
    return J ? ot.map((dt) => {
      const vt = J.findIndex(
        (pt) => pt === dt.wallet
      );
      return vt >= 0 ? { ...dt, order: vt } : dt;
    }).sort((dt, vt) => dt.order - vt.order) : ot;
  }, [pe, ke, J, oe, ne]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(qe, { appear: !0, show: A, as: Fragment, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    _t,
    {
      as: "div",
      className: "ord-connect-font ord-connect-wallet-modal",
      onClose: B,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0",
            enterTo: "opacity-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100",
            leaveTo: "opacity-0",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "backdrop" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "outer-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inner-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0 scale-95",
            enterTo: "opacity-100 scale-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100 scale-100",
            leaveTo: "opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(_t.Panel, { className: "panel", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-title-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(_t.Title, { as: "h3", className: "panel-title", children: [
                  "Choose ",
                  CHAIN_TO_NAME[ne],
                  " wallet to connect"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: B,
                    className: "close-button",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: CloseModalIcon, alt: "Close" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-content-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "panel-content-inner-container", children: rt.map((nt, ot) => {
                  const ut = ot === rt.length - 1;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      WalletButton,
                      {
                        wallet: nt.wallet,
                        onConnect: async () => {
                          ie("");
                          const dt = nt.onConnect().then((pt) => (pt && ie(""), pt)), vt = await Promise.race([
                            dt,
                            new Promise((pt) => {
                              setTimeout(() => pt("timeout"), 5e3);
                            })
                          ]);
                          return typeof vt == "string" ? (ie(
                            "No wallet pop-up? The extension is not responding. Try reloading your browser."
                          ), dt) : vt;
                        },
                        icon: nt.icon,
                        renderAvatar: W,
                        isPreferred: K === nt.wallet
                      }
                    ),
                    !ut && /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" })
                  ] }, nt.wallet);
                }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "error-message", children: re })
              ] })
            ] })
          }
        ) }) })
      ]
    }
  ) });
}
function OrdConnectKit({
  hideConnectButton: A,
  onViewProfile: B,
  onChangeWalletClick: W,
  onDisconnectWalletClick: K,
  renderAvatar: J,
  preferredWallet: L,
  walletsOrder: re
}) {
  const {
    address: ie,
    disconnectWallet: oe,
    network: ke,
    isModalOpen: ne,
    openModal: pe,
    closeModal: rt,
    visibleWallets: nt
  } = useOrdConnect(), ot = useHasMounted(), ut = () => A ? null : ie != null && ie.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    PostConnectButton,
    {
      address: ie.ordinals,
      network: ke,
      onViewProfile: B,
      onChangeWallet: () => {
        pe(), W == null || W();
      },
      onDisconnectWallet: () => {
        oe(), K == null || K();
      },
      renderAvatar: J
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(PreConnectButton, { disabled: !ot, openModal: pe });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    ut(),
    ot ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectWalletModal,
      {
        isOpen: ne,
        closeModal: rt,
        renderAvatar: J,
        preferredWallet: L,
        walletsOrder: re,
        visibleWallets: nt
      }
    ) : null
  ] });
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER$2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(A) {
  var B, W, K, J = pt.prototype = { constructor: pt, toString: null, valueOf: null }, L = new pt(1), re = 20, ie = 4, oe = -7, ke = 21, ne = -1e7, pe = 1e7, rt = !1, nt = 1, ot = 0, ut = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, dt = "0123456789abcdefghijklmnopqrstuvwxyz", vt = !0;
  function pt(Et, bt) {
    var Bt, wt, st, Oe, V, ce, it, at, ft = this;
    if (!(ft instanceof pt)) return new pt(Et, bt);
    if (bt == null) {
      if (Et && Et._isBigNumber === !0) {
        ft.s = Et.s, !Et.c || Et.e > pe ? ft.c = ft.e = null : Et.e < ne ? ft.c = [ft.e = 0] : (ft.e = Et.e, ft.c = Et.c.slice());
        return;
      }
      if ((ce = typeof Et == "number") && Et * 0 == 0) {
        if (ft.s = 1 / Et < 0 ? (Et = -Et, -1) : 1, Et === ~~Et) {
          for (Oe = 0, V = Et; V >= 10; V /= 10, Oe++) ;
          Oe > pe ? ft.c = ft.e = null : (ft.e = Oe, ft.c = [Et]);
          return;
        }
        at = String(Et);
      } else {
        if (!isNumeric.test(at = String(Et))) return K(ft, at, ce);
        ft.s = at.charCodeAt(0) == 45 ? (at = at.slice(1), -1) : 1;
      }
      (Oe = at.indexOf(".")) > -1 && (at = at.replace(".", "")), (V = at.search(/e/i)) > 0 ? (Oe < 0 && (Oe = V), Oe += +at.slice(V + 1), at = at.substring(0, V)) : Oe < 0 && (Oe = at.length);
    } else {
      if (intCheck(bt, 2, dt.length, "Base"), bt == 10 && vt)
        return ft = new pt(Et), xt(ft, re + ft.e + 1, ie);
      if (at = String(Et), ce = typeof Et == "number") {
        if (Et * 0 != 0) return K(ft, at, ce, bt);
        if (ft.s = 1 / Et < 0 ? (at = at.slice(1), -1) : 1, pt.DEBUG && at.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + Et);
      } else
        ft.s = at.charCodeAt(0) === 45 ? (at = at.slice(1), -1) : 1;
      for (Bt = dt.slice(0, bt), Oe = V = 0, it = at.length; V < it; V++)
        if (Bt.indexOf(wt = at.charAt(V)) < 0) {
          if (wt == ".") {
            if (V > Oe) {
              Oe = it;
              continue;
            }
          } else if (!st && (at == at.toUpperCase() && (at = at.toLowerCase()) || at == at.toLowerCase() && (at = at.toUpperCase()))) {
            st = !0, V = -1, Oe = 0;
            continue;
          }
          return K(ft, String(Et), ce, bt);
        }
      ce = !1, at = W(at, bt, 10, ft.s), (Oe = at.indexOf(".")) > -1 ? at = at.replace(".", "") : Oe = at.length;
    }
    for (V = 0; at.charCodeAt(V) === 48; V++) ;
    for (it = at.length; at.charCodeAt(--it) === 48; ) ;
    if (at = at.slice(V, ++it)) {
      if (it -= V, ce && pt.DEBUG && it > 15 && (Et > MAX_SAFE_INTEGER$2 || Et !== mathfloor(Et)))
        throw Error(tooManyDigits + ft.s * Et);
      if ((Oe = Oe - V - 1) > pe)
        ft.c = ft.e = null;
      else if (Oe < ne)
        ft.c = [ft.e = 0];
      else {
        if (ft.e = Oe, ft.c = [], V = (Oe + 1) % LOG_BASE, Oe < 0 && (V += LOG_BASE), V < it) {
          for (V && ft.c.push(+at.slice(0, V)), it -= LOG_BASE; V < it; )
            ft.c.push(+at.slice(V, V += LOG_BASE));
          V = LOG_BASE - (at = at.slice(V)).length;
        } else
          V -= it;
        for (; V--; at += "0") ;
        ft.c.push(+at);
      }
    } else
      ft.c = [ft.e = 0];
  }
  pt.clone = clone, pt.ROUND_UP = 0, pt.ROUND_DOWN = 1, pt.ROUND_CEIL = 2, pt.ROUND_FLOOR = 3, pt.ROUND_HALF_UP = 4, pt.ROUND_HALF_DOWN = 5, pt.ROUND_HALF_EVEN = 6, pt.ROUND_HALF_CEIL = 7, pt.ROUND_HALF_FLOOR = 8, pt.EUCLID = 9, pt.config = pt.set = function(Et) {
    var bt, Bt;
    if (Et != null)
      if (typeof Et == "object") {
        if (Et.hasOwnProperty(bt = "DECIMAL_PLACES") && (Bt = Et[bt], intCheck(Bt, 0, MAX, bt), re = Bt), Et.hasOwnProperty(bt = "ROUNDING_MODE") && (Bt = Et[bt], intCheck(Bt, 0, 8, bt), ie = Bt), Et.hasOwnProperty(bt = "EXPONENTIAL_AT") && (Bt = Et[bt], Bt && Bt.pop ? (intCheck(Bt[0], -1e9, 0, bt), intCheck(Bt[1], 0, MAX, bt), oe = Bt[0], ke = Bt[1]) : (intCheck(Bt, -1e9, MAX, bt), oe = -(ke = Bt < 0 ? -Bt : Bt))), Et.hasOwnProperty(bt = "RANGE"))
          if (Bt = Et[bt], Bt && Bt.pop)
            intCheck(Bt[0], -1e9, -1, bt), intCheck(Bt[1], 1, MAX, bt), ne = Bt[0], pe = Bt[1];
          else if (intCheck(Bt, -1e9, MAX, bt), Bt)
            ne = -(pe = Bt < 0 ? -Bt : Bt);
          else
            throw Error(bignumberError + bt + " cannot be zero: " + Bt);
        if (Et.hasOwnProperty(bt = "CRYPTO"))
          if (Bt = Et[bt], Bt === !!Bt)
            if (Bt)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                rt = Bt;
              else
                throw rt = !Bt, Error(bignumberError + "crypto unavailable");
            else
              rt = Bt;
          else
            throw Error(bignumberError + bt + " not true or false: " + Bt);
        if (Et.hasOwnProperty(bt = "MODULO_MODE") && (Bt = Et[bt], intCheck(Bt, 0, 9, bt), nt = Bt), Et.hasOwnProperty(bt = "POW_PRECISION") && (Bt = Et[bt], intCheck(Bt, 0, MAX, bt), ot = Bt), Et.hasOwnProperty(bt = "FORMAT"))
          if (Bt = Et[bt], typeof Bt == "object") ut = Bt;
          else throw Error(bignumberError + bt + " not an object: " + Bt);
        if (Et.hasOwnProperty(bt = "ALPHABET"))
          if (Bt = Et[bt], typeof Bt == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(Bt))
            vt = Bt.slice(0, 10) == "0123456789", dt = Bt;
          else
            throw Error(bignumberError + bt + " invalid: " + Bt);
      } else
        throw Error(bignumberError + "Object expected: " + Et);
    return {
      DECIMAL_PLACES: re,
      ROUNDING_MODE: ie,
      EXPONENTIAL_AT: [oe, ke],
      RANGE: [ne, pe],
      CRYPTO: rt,
      MODULO_MODE: nt,
      POW_PRECISION: ot,
      FORMAT: ut,
      ALPHABET: dt
    };
  }, pt.isBigNumber = function(Et) {
    if (!Et || Et._isBigNumber !== !0) return !1;
    if (!pt.DEBUG) return !0;
    var bt, Bt, wt = Et.c, st = Et.e, Oe = Et.s;
    e: if ({}.toString.call(wt) == "[object Array]") {
      if ((Oe === 1 || Oe === -1) && st >= -1e9 && st <= MAX && st === mathfloor(st)) {
        if (wt[0] === 0) {
          if (st === 0 && wt.length === 1) return !0;
          break e;
        }
        if (bt = (st + 1) % LOG_BASE, bt < 1 && (bt += LOG_BASE), String(wt[0]).length == bt) {
          for (bt = 0; bt < wt.length; bt++)
            if (Bt = wt[bt], Bt < 0 || Bt >= BASE || Bt !== mathfloor(Bt)) break e;
          if (Bt !== 0) return !0;
        }
      }
    } else if (wt === null && st === null && (Oe === null || Oe === 1 || Oe === -1))
      return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + Et);
  }, pt.maximum = pt.max = function() {
    return gt(arguments, -1);
  }, pt.minimum = pt.min = function() {
    return gt(arguments, 1);
  }, pt.random = function() {
    var Et = 9007199254740992, bt = Math.random() * Et & 2097151 ? function() {
      return mathfloor(Math.random() * Et);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(Bt) {
      var wt, st, Oe, V, ce, it = 0, at = [], ft = new pt(L);
      if (Bt == null ? Bt = re : intCheck(Bt, 0, MAX), V = mathceil(Bt / LOG_BASE), rt)
        if (crypto.getRandomValues) {
          for (wt = crypto.getRandomValues(new Uint32Array(V *= 2)); it < V; )
            ce = wt[it] * 131072 + (wt[it + 1] >>> 11), ce >= 9e15 ? (st = crypto.getRandomValues(new Uint32Array(2)), wt[it] = st[0], wt[it + 1] = st[1]) : (at.push(ce % 1e14), it += 2);
          it = V / 2;
        } else if (crypto.randomBytes) {
          for (wt = crypto.randomBytes(V *= 7); it < V; )
            ce = (wt[it] & 31) * 281474976710656 + wt[it + 1] * 1099511627776 + wt[it + 2] * 4294967296 + wt[it + 3] * 16777216 + (wt[it + 4] << 16) + (wt[it + 5] << 8) + wt[it + 6], ce >= 9e15 ? crypto.randomBytes(7).copy(wt, it) : (at.push(ce % 1e14), it += 7);
          it = V / 7;
        } else
          throw rt = !1, Error(bignumberError + "crypto unavailable");
      if (!rt)
        for (; it < V; )
          ce = bt(), ce < 9e15 && (at[it++] = ce % 1e14);
      for (V = at[--it], Bt %= LOG_BASE, V && Bt && (ce = POWS_TEN[LOG_BASE - Bt], at[it] = mathfloor(V / ce) * ce); at[it] === 0; at.pop(), it--) ;
      if (it < 0)
        at = [Oe = 0];
      else {
        for (Oe = -1; at[0] === 0; at.splice(0, 1), Oe -= LOG_BASE) ;
        for (it = 1, ce = at[0]; ce >= 10; ce /= 10, it++) ;
        it < LOG_BASE && (Oe -= LOG_BASE - it);
      }
      return ft.e = Oe, ft.c = at, ft;
    };
  }(), pt.sum = function() {
    for (var Et = 1, bt = arguments, Bt = new pt(bt[0]); Et < bt.length; ) Bt = Bt.plus(bt[Et++]);
    return Bt;
  }, W = /* @__PURE__ */ function() {
    var Et = "0123456789";
    function bt(Bt, wt, st, Oe) {
      for (var V, ce = [0], it, at = 0, ft = Bt.length; at < ft; ) {
        for (it = ce.length; it--; ce[it] *= wt) ;
        for (ce[0] += Oe.indexOf(Bt.charAt(at++)), V = 0; V < ce.length; V++)
          ce[V] > st - 1 && (ce[V + 1] == null && (ce[V + 1] = 0), ce[V + 1] += ce[V] / st | 0, ce[V] %= st);
      }
      return ce.reverse();
    }
    return function(Bt, wt, st, Oe, V) {
      var ce, it, at, ft, lt, ct, ht, Ce, yt = Bt.indexOf("."), qt = re, jt = ie;
      for (yt >= 0 && (ft = ot, ot = 0, Bt = Bt.replace(".", ""), Ce = new pt(wt), ct = Ce.pow(Bt.length - yt), ot = ft, Ce.c = bt(
        toFixedPoint(coeffToString(ct.c), ct.e, "0"),
        10,
        st,
        Et
      ), Ce.e = Ce.c.length), ht = bt(Bt, wt, st, V ? (ce = dt, Et) : (ce = Et, dt)), at = ft = ht.length; ht[--ft] == 0; ht.pop()) ;
      if (!ht[0]) return ce.charAt(0);
      if (yt < 0 ? --at : (ct.c = ht, ct.e = at, ct.s = Oe, ct = B(ct, Ce, qt, jt, st), ht = ct.c, lt = ct.r, at = ct.e), it = at + qt + 1, yt = ht[it], ft = st / 2, lt = lt || it < 0 || ht[it + 1] != null, lt = jt < 4 ? (yt != null || lt) && (jt == 0 || jt == (ct.s < 0 ? 3 : 2)) : yt > ft || yt == ft && (jt == 4 || lt || jt == 6 && ht[it - 1] & 1 || jt == (ct.s < 0 ? 8 : 7)), it < 1 || !ht[0])
        Bt = lt ? toFixedPoint(ce.charAt(1), -qt, ce.charAt(0)) : ce.charAt(0);
      else {
        if (ht.length = it, lt)
          for (--st; ++ht[--it] > st; )
            ht[it] = 0, it || (++at, ht = [1].concat(ht));
        for (ft = ht.length; !ht[--ft]; ) ;
        for (yt = 0, Bt = ""; yt <= ft; Bt += ce.charAt(ht[yt++])) ;
        Bt = toFixedPoint(Bt, at, ce.charAt(0));
      }
      return Bt;
    };
  }(), B = /* @__PURE__ */ function() {
    function Et(wt, st, Oe) {
      var V, ce, it, at, ft = 0, lt = wt.length, ct = st % SQRT_BASE, ht = st / SQRT_BASE | 0;
      for (wt = wt.slice(); lt--; )
        it = wt[lt] % SQRT_BASE, at = wt[lt] / SQRT_BASE | 0, V = ht * it + at * ct, ce = ct * it + V % SQRT_BASE * SQRT_BASE + ft, ft = (ce / Oe | 0) + (V / SQRT_BASE | 0) + ht * at, wt[lt] = ce % Oe;
      return ft && (wt = [ft].concat(wt)), wt;
    }
    function bt(wt, st, Oe, V) {
      var ce, it;
      if (Oe != V)
        it = Oe > V ? 1 : -1;
      else
        for (ce = it = 0; ce < Oe; ce++)
          if (wt[ce] != st[ce]) {
            it = wt[ce] > st[ce] ? 1 : -1;
            break;
          }
      return it;
    }
    function Bt(wt, st, Oe, V) {
      for (var ce = 0; Oe--; )
        wt[Oe] -= ce, ce = wt[Oe] < st[Oe] ? 1 : 0, wt[Oe] = ce * V + wt[Oe] - st[Oe];
      for (; !wt[0] && wt.length > 1; wt.splice(0, 1)) ;
    }
    return function(wt, st, Oe, V, ce) {
      var it, at, ft, lt, ct, ht, Ce, yt, qt, jt, kt, $t, Mt, Lt, Kt, Tt, Rt, Wt = wt.s == st.s ? 1 : -1, Xt = wt.c, Zt = st.c;
      if (!Xt || !Xt[0] || !Zt || !Zt[0])
        return new pt(
          // Return NaN if either NaN, or both Infinity or 0.
          !wt.s || !st.s || (Xt ? Zt && Xt[0] == Zt[0] : !Zt) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            Xt && Xt[0] == 0 || !Zt ? Wt * 0 : Wt / 0
          )
        );
      for (yt = new pt(Wt), qt = yt.c = [], at = wt.e - st.e, Wt = Oe + at + 1, ce || (ce = BASE, at = bitFloor(wt.e / LOG_BASE) - bitFloor(st.e / LOG_BASE), Wt = Wt / LOG_BASE | 0), ft = 0; Zt[ft] == (Xt[ft] || 0); ft++) ;
      if (Zt[ft] > (Xt[ft] || 0) && at--, Wt < 0)
        qt.push(1), lt = !0;
      else {
        for (Lt = Xt.length, Tt = Zt.length, ft = 0, Wt += 2, ct = mathfloor(ce / (Zt[0] + 1)), ct > 1 && (Zt = Et(Zt, ct, ce), Xt = Et(Xt, ct, ce), Tt = Zt.length, Lt = Xt.length), Mt = Tt, jt = Xt.slice(0, Tt), kt = jt.length; kt < Tt; jt[kt++] = 0) ;
        Rt = Zt.slice(), Rt = [0].concat(Rt), Kt = Zt[0], Zt[1] >= ce / 2 && Kt++;
        do {
          if (ct = 0, it = bt(Zt, jt, Tt, kt), it < 0) {
            if ($t = jt[0], Tt != kt && ($t = $t * ce + (jt[1] || 0)), ct = mathfloor($t / Kt), ct > 1)
              for (ct >= ce && (ct = ce - 1), ht = Et(Zt, ct, ce), Ce = ht.length, kt = jt.length; bt(ht, jt, Ce, kt) == 1; )
                ct--, Bt(ht, Tt < Ce ? Rt : Zt, Ce, ce), Ce = ht.length, it = 1;
            else
              ct == 0 && (it = ct = 1), ht = Zt.slice(), Ce = ht.length;
            if (Ce < kt && (ht = [0].concat(ht)), Bt(jt, ht, kt, ce), kt = jt.length, it == -1)
              for (; bt(Zt, jt, Tt, kt) < 1; )
                ct++, Bt(jt, Tt < kt ? Rt : Zt, kt, ce), kt = jt.length;
          } else it === 0 && (ct++, jt = [0]);
          qt[ft++] = ct, jt[0] ? jt[kt++] = Xt[Mt] || 0 : (jt = [Xt[Mt]], kt = 1);
        } while ((Mt++ < Lt || jt[0] != null) && Wt--);
        lt = jt[0] != null, qt[0] || qt.splice(0, 1);
      }
      if (ce == BASE) {
        for (ft = 1, Wt = qt[0]; Wt >= 10; Wt /= 10, ft++) ;
        xt(yt, Oe + (yt.e = ft + at * LOG_BASE - 1) + 1, V, lt);
      } else
        yt.e = at, yt.r = +lt;
      return yt;
    };
  }();
  function mt(Et, bt, Bt, wt) {
    var st, Oe, V, ce, it;
    if (Bt == null ? Bt = ie : intCheck(Bt, 0, 8), !Et.c) return Et.toString();
    if (st = Et.c[0], V = Et.e, bt == null)
      it = coeffToString(Et.c), it = wt == 1 || wt == 2 && (V <= oe || V >= ke) ? toExponential(it, V) : toFixedPoint(it, V, "0");
    else if (Et = xt(new pt(Et), bt, Bt), Oe = Et.e, it = coeffToString(Et.c), ce = it.length, wt == 1 || wt == 2 && (bt <= Oe || Oe <= oe)) {
      for (; ce < bt; it += "0", ce++) ;
      it = toExponential(it, Oe);
    } else if (bt -= V, it = toFixedPoint(it, Oe, "0"), Oe + 1 > ce) {
      if (--bt > 0) for (it += "."; bt--; it += "0") ;
    } else if (bt += Oe - ce, bt > 0)
      for (Oe + 1 == ce && (it += "."); bt--; it += "0") ;
    return Et.s < 0 && st ? "-" + it : it;
  }
  function gt(Et, bt) {
    for (var Bt, wt, st = 1, Oe = new pt(Et[0]); st < Et.length; st++)
      wt = new pt(Et[st]), (!wt.s || (Bt = compare(Oe, wt)) === bt || Bt === 0 && Oe.s === bt) && (Oe = wt);
    return Oe;
  }
  function Pt(Et, bt, Bt) {
    for (var wt = 1, st = bt.length; !bt[--st]; bt.pop()) ;
    for (st = bt[0]; st >= 10; st /= 10, wt++) ;
    return (Bt = wt + Bt * LOG_BASE - 1) > pe ? Et.c = Et.e = null : Bt < ne ? Et.c = [Et.e = 0] : (Et.e = Bt, Et.c = bt), Et;
  }
  K = /* @__PURE__ */ function() {
    var Et = /^(-?)0([xbo])(?=\w[\w.]*$)/i, bt = /^([^.]+)\.$/, Bt = /^\.([^.]+)$/, wt = /^-?(Infinity|NaN)$/, st = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(Oe, V, ce, it) {
      var at, ft = ce ? V : V.replace(st, "");
      if (wt.test(ft))
        Oe.s = isNaN(ft) ? null : ft < 0 ? -1 : 1;
      else {
        if (!ce && (ft = ft.replace(Et, function(lt, ct, ht) {
          return at = (ht = ht.toLowerCase()) == "x" ? 16 : ht == "b" ? 2 : 8, !it || it == at ? ct : lt;
        }), it && (at = it, ft = ft.replace(bt, "$1").replace(Bt, "0.$1")), V != ft))
          return new pt(ft, at);
        if (pt.DEBUG)
          throw Error(bignumberError + "Not a" + (it ? " base " + it : "") + " number: " + V);
        Oe.s = null;
      }
      Oe.c = Oe.e = null;
    };
  }();
  function xt(Et, bt, Bt, wt) {
    var st, Oe, V, ce, it, at, ft, lt = Et.c, ct = POWS_TEN;
    if (lt) {
      e: {
        for (st = 1, ce = lt[0]; ce >= 10; ce /= 10, st++) ;
        if (Oe = bt - st, Oe < 0)
          Oe += LOG_BASE, V = bt, it = lt[at = 0], ft = mathfloor(it / ct[st - V - 1] % 10);
        else if (at = mathceil((Oe + 1) / LOG_BASE), at >= lt.length)
          if (wt) {
            for (; lt.length <= at; lt.push(0)) ;
            it = ft = 0, st = 1, Oe %= LOG_BASE, V = Oe - LOG_BASE + 1;
          } else
            break e;
        else {
          for (it = ce = lt[at], st = 1; ce >= 10; ce /= 10, st++) ;
          Oe %= LOG_BASE, V = Oe - LOG_BASE + st, ft = V < 0 ? 0 : mathfloor(it / ct[st - V - 1] % 10);
        }
        if (wt = wt || bt < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        lt[at + 1] != null || (V < 0 ? it : it % ct[st - V - 1]), wt = Bt < 4 ? (ft || wt) && (Bt == 0 || Bt == (Et.s < 0 ? 3 : 2)) : ft > 5 || ft == 5 && (Bt == 4 || wt || Bt == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (Oe > 0 ? V > 0 ? it / ct[st - V] : 0 : lt[at - 1]) % 10 & 1 || Bt == (Et.s < 0 ? 8 : 7)), bt < 1 || !lt[0])
          return lt.length = 0, wt ? (bt -= Et.e + 1, lt[0] = ct[(LOG_BASE - bt % LOG_BASE) % LOG_BASE], Et.e = -bt || 0) : lt[0] = Et.e = 0, Et;
        if (Oe == 0 ? (lt.length = at, ce = 1, at--) : (lt.length = at + 1, ce = ct[LOG_BASE - Oe], lt[at] = V > 0 ? mathfloor(it / ct[st - V] % ct[V]) * ce : 0), wt)
          for (; ; )
            if (at == 0) {
              for (Oe = 1, V = lt[0]; V >= 10; V /= 10, Oe++) ;
              for (V = lt[0] += ce, ce = 1; V >= 10; V /= 10, ce++) ;
              Oe != ce && (Et.e++, lt[0] == BASE && (lt[0] = 1));
              break;
            } else {
              if (lt[at] += ce, lt[at] != BASE) break;
              lt[at--] = 0, ce = 1;
            }
        for (Oe = lt.length; lt[--Oe] === 0; lt.pop()) ;
      }
      Et.e > pe ? Et.c = Et.e = null : Et.e < ne && (Et.c = [Et.e = 0]);
    }
    return Et;
  }
  function Nt(Et) {
    var bt, Bt = Et.e;
    return Bt === null ? Et.toString() : (bt = coeffToString(Et.c), bt = Bt <= oe || Bt >= ke ? toExponential(bt, Bt) : toFixedPoint(bt, Bt, "0"), Et.s < 0 ? "-" + bt : bt);
  }
  return J.absoluteValue = J.abs = function() {
    var Et = new pt(this);
    return Et.s < 0 && (Et.s = 1), Et;
  }, J.comparedTo = function(Et, bt) {
    return compare(this, new pt(Et, bt));
  }, J.decimalPlaces = J.dp = function(Et, bt) {
    var Bt, wt, st, Oe = this;
    if (Et != null)
      return intCheck(Et, 0, MAX), bt == null ? bt = ie : intCheck(bt, 0, 8), xt(new pt(Oe), Et + Oe.e + 1, bt);
    if (!(Bt = Oe.c)) return null;
    if (wt = ((st = Bt.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, st = Bt[st]) for (; st % 10 == 0; st /= 10, wt--) ;
    return wt < 0 && (wt = 0), wt;
  }, J.dividedBy = J.div = function(Et, bt) {
    return B(this, new pt(Et, bt), re, ie);
  }, J.dividedToIntegerBy = J.idiv = function(Et, bt) {
    return B(this, new pt(Et, bt), 0, 1);
  }, J.exponentiatedBy = J.pow = function(Et, bt) {
    var Bt, wt, st, Oe, V, ce, it, at, ft, lt = this;
    if (Et = new pt(Et), Et.c && !Et.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + Nt(Et));
    if (bt != null && (bt = new pt(bt)), ce = Et.e > 14, !lt.c || !lt.c[0] || lt.c[0] == 1 && !lt.e && lt.c.length == 1 || !Et.c || !Et.c[0])
      return ft = new pt(Math.pow(+Nt(lt), ce ? Et.s * (2 - isOdd(Et)) : +Nt(Et))), bt ? ft.mod(bt) : ft;
    if (it = Et.s < 0, bt) {
      if (bt.c ? !bt.c[0] : !bt.s) return new pt(NaN);
      wt = !it && lt.isInteger() && bt.isInteger(), wt && (lt = lt.mod(bt));
    } else {
      if (Et.e > 9 && (lt.e > 0 || lt.e < -1 || (lt.e == 0 ? lt.c[0] > 1 || ce && lt.c[1] >= 24e7 : lt.c[0] < 8e13 || ce && lt.c[0] <= 9999975e7)))
        return Oe = lt.s < 0 && isOdd(Et) ? -0 : 0, lt.e > -1 && (Oe = 1 / Oe), new pt(it ? 1 / Oe : Oe);
      ot && (Oe = mathceil(ot / LOG_BASE + 2));
    }
    for (ce ? (Bt = new pt(0.5), it && (Et.s = 1), at = isOdd(Et)) : (st = Math.abs(+Nt(Et)), at = st % 2), ft = new pt(L); ; ) {
      if (at) {
        if (ft = ft.times(lt), !ft.c) break;
        Oe ? ft.c.length > Oe && (ft.c.length = Oe) : wt && (ft = ft.mod(bt));
      }
      if (st) {
        if (st = mathfloor(st / 2), st === 0) break;
        at = st % 2;
      } else if (Et = Et.times(Bt), xt(Et, Et.e + 1, 1), Et.e > 14)
        at = isOdd(Et);
      else {
        if (st = +Nt(Et), st === 0) break;
        at = st % 2;
      }
      lt = lt.times(lt), Oe ? lt.c && lt.c.length > Oe && (lt.c.length = Oe) : wt && (lt = lt.mod(bt));
    }
    return wt ? ft : (it && (ft = L.div(ft)), bt ? ft.mod(bt) : Oe ? xt(ft, ot, ie, V) : ft);
  }, J.integerValue = function(Et) {
    var bt = new pt(this);
    return Et == null ? Et = ie : intCheck(Et, 0, 8), xt(bt, bt.e + 1, Et);
  }, J.isEqualTo = J.eq = function(Et, bt) {
    return compare(this, new pt(Et, bt)) === 0;
  }, J.isFinite = function() {
    return !!this.c;
  }, J.isGreaterThan = J.gt = function(Et, bt) {
    return compare(this, new pt(Et, bt)) > 0;
  }, J.isGreaterThanOrEqualTo = J.gte = function(Et, bt) {
    return (bt = compare(this, new pt(Et, bt))) === 1 || bt === 0;
  }, J.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, J.isLessThan = J.lt = function(Et, bt) {
    return compare(this, new pt(Et, bt)) < 0;
  }, J.isLessThanOrEqualTo = J.lte = function(Et, bt) {
    return (bt = compare(this, new pt(Et, bt))) === -1 || bt === 0;
  }, J.isNaN = function() {
    return !this.s;
  }, J.isNegative = function() {
    return this.s < 0;
  }, J.isPositive = function() {
    return this.s > 0;
  }, J.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, J.minus = function(Et, bt) {
    var Bt, wt, st, Oe, V = this, ce = V.s;
    if (Et = new pt(Et, bt), bt = Et.s, !ce || !bt) return new pt(NaN);
    if (ce != bt)
      return Et.s = -bt, V.plus(Et);
    var it = V.e / LOG_BASE, at = Et.e / LOG_BASE, ft = V.c, lt = Et.c;
    if (!it || !at) {
      if (!ft || !lt) return ft ? (Et.s = -bt, Et) : new pt(lt ? V : NaN);
      if (!ft[0] || !lt[0])
        return lt[0] ? (Et.s = -bt, Et) : new pt(ft[0] ? V : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ie == 3 ? -0 : 0
        ));
    }
    if (it = bitFloor(it), at = bitFloor(at), ft = ft.slice(), ce = it - at) {
      for ((Oe = ce < 0) ? (ce = -ce, st = ft) : (at = it, st = lt), st.reverse(), bt = ce; bt--; st.push(0)) ;
      st.reverse();
    } else
      for (wt = (Oe = (ce = ft.length) < (bt = lt.length)) ? ce : bt, ce = bt = 0; bt < wt; bt++)
        if (ft[bt] != lt[bt]) {
          Oe = ft[bt] < lt[bt];
          break;
        }
    if (Oe && (st = ft, ft = lt, lt = st, Et.s = -Et.s), bt = (wt = lt.length) - (Bt = ft.length), bt > 0) for (; bt--; ft[Bt++] = 0) ;
    for (bt = BASE - 1; wt > ce; ) {
      if (ft[--wt] < lt[wt]) {
        for (Bt = wt; Bt && !ft[--Bt]; ft[Bt] = bt) ;
        --ft[Bt], ft[wt] += BASE;
      }
      ft[wt] -= lt[wt];
    }
    for (; ft[0] == 0; ft.splice(0, 1), --at) ;
    return ft[0] ? Pt(Et, ft, at) : (Et.s = ie == 3 ? -1 : 1, Et.c = [Et.e = 0], Et);
  }, J.modulo = J.mod = function(Et, bt) {
    var Bt, wt, st = this;
    return Et = new pt(Et, bt), !st.c || !Et.s || Et.c && !Et.c[0] ? new pt(NaN) : !Et.c || st.c && !st.c[0] ? new pt(st) : (nt == 9 ? (wt = Et.s, Et.s = 1, Bt = B(st, Et, 0, 3), Et.s = wt, Bt.s *= wt) : Bt = B(st, Et, 0, nt), Et = st.minus(Bt.times(Et)), !Et.c[0] && nt == 1 && (Et.s = st.s), Et);
  }, J.multipliedBy = J.times = function(Et, bt) {
    var Bt, wt, st, Oe, V, ce, it, at, ft, lt, ct, ht, Ce, yt, qt, jt = this, kt = jt.c, $t = (Et = new pt(Et, bt)).c;
    if (!kt || !$t || !kt[0] || !$t[0])
      return !jt.s || !Et.s || kt && !kt[0] && !$t || $t && !$t[0] && !kt ? Et.c = Et.e = Et.s = null : (Et.s *= jt.s, !kt || !$t ? Et.c = Et.e = null : (Et.c = [0], Et.e = 0)), Et;
    for (wt = bitFloor(jt.e / LOG_BASE) + bitFloor(Et.e / LOG_BASE), Et.s *= jt.s, it = kt.length, lt = $t.length, it < lt && (Ce = kt, kt = $t, $t = Ce, st = it, it = lt, lt = st), st = it + lt, Ce = []; st--; Ce.push(0)) ;
    for (yt = BASE, qt = SQRT_BASE, st = lt; --st >= 0; ) {
      for (Bt = 0, ct = $t[st] % qt, ht = $t[st] / qt | 0, V = it, Oe = st + V; Oe > st; )
        at = kt[--V] % qt, ft = kt[V] / qt | 0, ce = ht * at + ft * ct, at = ct * at + ce % qt * qt + Ce[Oe] + Bt, Bt = (at / yt | 0) + (ce / qt | 0) + ht * ft, Ce[Oe--] = at % yt;
      Ce[Oe] = Bt;
    }
    return Bt ? ++wt : Ce.splice(0, 1), Pt(Et, Ce, wt);
  }, J.negated = function() {
    var Et = new pt(this);
    return Et.s = -Et.s || null, Et;
  }, J.plus = function(Et, bt) {
    var Bt, wt = this, st = wt.s;
    if (Et = new pt(Et, bt), bt = Et.s, !st || !bt) return new pt(NaN);
    if (st != bt)
      return Et.s = -bt, wt.minus(Et);
    var Oe = wt.e / LOG_BASE, V = Et.e / LOG_BASE, ce = wt.c, it = Et.c;
    if (!Oe || !V) {
      if (!ce || !it) return new pt(st / 0);
      if (!ce[0] || !it[0]) return it[0] ? Et : new pt(ce[0] ? wt : st * 0);
    }
    if (Oe = bitFloor(Oe), V = bitFloor(V), ce = ce.slice(), st = Oe - V) {
      for (st > 0 ? (V = Oe, Bt = it) : (st = -st, Bt = ce), Bt.reverse(); st--; Bt.push(0)) ;
      Bt.reverse();
    }
    for (st = ce.length, bt = it.length, st - bt < 0 && (Bt = it, it = ce, ce = Bt, bt = st), st = 0; bt; )
      st = (ce[--bt] = ce[bt] + it[bt] + st) / BASE | 0, ce[bt] = BASE === ce[bt] ? 0 : ce[bt] % BASE;
    return st && (ce = [st].concat(ce), ++V), Pt(Et, ce, V);
  }, J.precision = J.sd = function(Et, bt) {
    var Bt, wt, st, Oe = this;
    if (Et != null && Et !== !!Et)
      return intCheck(Et, 1, MAX), bt == null ? bt = ie : intCheck(bt, 0, 8), xt(new pt(Oe), Et, bt);
    if (!(Bt = Oe.c)) return null;
    if (st = Bt.length - 1, wt = st * LOG_BASE + 1, st = Bt[st]) {
      for (; st % 10 == 0; st /= 10, wt--) ;
      for (st = Bt[0]; st >= 10; st /= 10, wt++) ;
    }
    return Et && Oe.e + 1 > wt && (wt = Oe.e + 1), wt;
  }, J.shiftedBy = function(Et) {
    return intCheck(Et, -9007199254740991, MAX_SAFE_INTEGER$2), this.times("1e" + Et);
  }, J.squareRoot = J.sqrt = function() {
    var Et, bt, Bt, wt, st, Oe = this, V = Oe.c, ce = Oe.s, it = Oe.e, at = re + 4, ft = new pt("0.5");
    if (ce !== 1 || !V || !V[0])
      return new pt(!ce || ce < 0 && (!V || V[0]) ? NaN : V ? Oe : 1 / 0);
    if (ce = Math.sqrt(+Nt(Oe)), ce == 0 || ce == 1 / 0 ? (bt = coeffToString(V), (bt.length + it) % 2 == 0 && (bt += "0"), ce = Math.sqrt(+bt), it = bitFloor((it + 1) / 2) - (it < 0 || it % 2), ce == 1 / 0 ? bt = "5e" + it : (bt = ce.toExponential(), bt = bt.slice(0, bt.indexOf("e") + 1) + it), Bt = new pt(bt)) : Bt = new pt(ce + ""), Bt.c[0]) {
      for (it = Bt.e, ce = it + at, ce < 3 && (ce = 0); ; )
        if (st = Bt, Bt = ft.times(st.plus(B(Oe, st, at, 1))), coeffToString(st.c).slice(0, ce) === (bt = coeffToString(Bt.c)).slice(0, ce))
          if (Bt.e < it && --ce, bt = bt.slice(ce - 3, ce + 1), bt == "9999" || !wt && bt == "4999") {
            if (!wt && (xt(st, st.e + re + 2, 0), st.times(st).eq(Oe))) {
              Bt = st;
              break;
            }
            at += 4, ce += 4, wt = 1;
          } else {
            (!+bt || !+bt.slice(1) && bt.charAt(0) == "5") && (xt(Bt, Bt.e + re + 2, 1), Et = !Bt.times(Bt).eq(Oe));
            break;
          }
    }
    return xt(Bt, Bt.e + re + 1, ie, Et);
  }, J.toExponential = function(Et, bt) {
    return Et != null && (intCheck(Et, 0, MAX), Et++), mt(this, Et, bt, 1);
  }, J.toFixed = function(Et, bt) {
    return Et != null && (intCheck(Et, 0, MAX), Et = Et + this.e + 1), mt(this, Et, bt);
  }, J.toFormat = function(Et, bt, Bt) {
    var wt, st = this;
    if (Bt == null)
      Et != null && bt && typeof bt == "object" ? (Bt = bt, bt = null) : Et && typeof Et == "object" ? (Bt = Et, Et = bt = null) : Bt = ut;
    else if (typeof Bt != "object")
      throw Error(bignumberError + "Argument not an object: " + Bt);
    if (wt = st.toFixed(Et, bt), st.c) {
      var Oe, V = wt.split("."), ce = +Bt.groupSize, it = +Bt.secondaryGroupSize, at = Bt.groupSeparator || "", ft = V[0], lt = V[1], ct = st.s < 0, ht = ct ? ft.slice(1) : ft, Ce = ht.length;
      if (it && (Oe = ce, ce = it, it = Oe, Ce -= Oe), ce > 0 && Ce > 0) {
        for (Oe = Ce % ce || ce, ft = ht.substr(0, Oe); Oe < Ce; Oe += ce) ft += at + ht.substr(Oe, ce);
        it > 0 && (ft += at + ht.slice(Oe)), ct && (ft = "-" + ft);
      }
      wt = lt ? ft + (Bt.decimalSeparator || "") + ((it = +Bt.fractionGroupSize) ? lt.replace(
        new RegExp("\\d{" + it + "}\\B", "g"),
        "$&" + (Bt.fractionGroupSeparator || "")
      ) : lt) : ft;
    }
    return (Bt.prefix || "") + wt + (Bt.suffix || "");
  }, J.toFraction = function(Et) {
    var bt, Bt, wt, st, Oe, V, ce, it, at, ft, lt, ct, ht = this, Ce = ht.c;
    if (Et != null && (ce = new pt(Et), !ce.isInteger() && (ce.c || ce.s !== 1) || ce.lt(L)))
      throw Error(bignumberError + "Argument " + (ce.isInteger() ? "out of range: " : "not an integer: ") + Nt(ce));
    if (!Ce) return new pt(ht);
    for (bt = new pt(L), at = Bt = new pt(L), wt = it = new pt(L), ct = coeffToString(Ce), Oe = bt.e = ct.length - ht.e - 1, bt.c[0] = POWS_TEN[(V = Oe % LOG_BASE) < 0 ? LOG_BASE + V : V], Et = !Et || ce.comparedTo(bt) > 0 ? Oe > 0 ? bt : at : ce, V = pe, pe = 1 / 0, ce = new pt(ct), it.c[0] = 0; ft = B(ce, bt, 0, 1), st = Bt.plus(ft.times(wt)), st.comparedTo(Et) != 1; )
      Bt = wt, wt = st, at = it.plus(ft.times(st = at)), it = st, bt = ce.minus(ft.times(st = bt)), ce = st;
    return st = B(Et.minus(Bt), wt, 0, 1), it = it.plus(st.times(at)), Bt = Bt.plus(st.times(wt)), it.s = at.s = ht.s, Oe = Oe * 2, lt = B(at, wt, Oe, ie).minus(ht).abs().comparedTo(
      B(it, Bt, Oe, ie).minus(ht).abs()
    ) < 1 ? [at, wt] : [it, Bt], pe = V, lt;
  }, J.toNumber = function() {
    return +Nt(this);
  }, J.toPrecision = function(Et, bt) {
    return Et != null && intCheck(Et, 1, MAX), mt(this, Et, bt, 2);
  }, J.toString = function(Et) {
    var bt, Bt = this, wt = Bt.s, st = Bt.e;
    return st === null ? wt ? (bt = "Infinity", wt < 0 && (bt = "-" + bt)) : bt = "NaN" : (Et == null ? bt = st <= oe || st >= ke ? toExponential(coeffToString(Bt.c), st) : toFixedPoint(coeffToString(Bt.c), st, "0") : Et === 10 && vt ? (Bt = xt(new pt(Bt), re + st + 1, ie), bt = toFixedPoint(coeffToString(Bt.c), Bt.e, "0")) : (intCheck(Et, 2, dt.length, "Base"), bt = W(toFixedPoint(coeffToString(Bt.c), st, "0"), 10, Et, wt, !0)), wt < 0 && Bt.c[0] && (bt = "-" + bt)), bt;
  }, J.valueOf = J.toJSON = function() {
    return Nt(this);
  }, J._isBigNumber = !0, J[Symbol.toStringTag] = "BigNumber", J[Symbol.for("nodejs.util.inspect.custom")] = J.valueOf, A != null && pt.set(A), pt;
}
function bitFloor(A) {
  var B = A | 0;
  return A > 0 || A === B ? B : B - 1;
}
function coeffToString(A) {
  for (var B, W, K = 1, J = A.length, L = A[0] + ""; K < J; ) {
    for (B = A[K++] + "", W = LOG_BASE - B.length; W--; B = "0" + B) ;
    L += B;
  }
  for (J = L.length; L.charCodeAt(--J) === 48; ) ;
  return L.slice(0, J + 1 || 1);
}
function compare(A, B) {
  var W, K, J = A.c, L = B.c, re = A.s, ie = B.s, oe = A.e, ke = B.e;
  if (!re || !ie) return null;
  if (W = J && !J[0], K = L && !L[0], W || K) return W ? K ? 0 : -ie : re;
  if (re != ie) return re;
  if (W = re < 0, K = oe == ke, !J || !L) return K ? 0 : !J ^ W ? 1 : -1;
  if (!K) return oe > ke ^ W ? 1 : -1;
  for (ie = (oe = J.length) < (ke = L.length) ? oe : ke, re = 0; re < ie; re++) if (J[re] != L[re]) return J[re] > L[re] ^ W ? 1 : -1;
  return oe == ke ? 0 : oe > ke ^ W ? 1 : -1;
}
function intCheck(A, B, W, K) {
  if (A < B || A > W || A !== mathfloor(A))
    throw Error(bignumberError + (K || "Argument") + (typeof A == "number" ? A < B || A > W ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(A));
}
function isOdd(A) {
  var B = A.c.length - 1;
  return bitFloor(A.e / LOG_BASE) == B && A.c[B] % 2 != 0;
}
function toExponential(A, B) {
  return (A.length > 1 ? A.charAt(0) + "." + A.slice(1) : A) + (B < 0 ? "e" : "e+") + B;
}
function toFixedPoint(A, B, W) {
  var K, J;
  if (B < 0) {
    for (J = W + "."; ++B; J += W) ;
    A = J + A;
  } else if (K = A.length, ++B > K) {
    for (J = W, B -= K; --B; J += W) ;
    A += J;
  } else B < K && (A = A.slice(0, B) + "." + A.slice(B));
  return A;
}
var BigNumber = clone();
function useBalance() {
  const { network: A, publicKey: B, format: W } = useOrdConnect(), [K, J] = useState(null), [L, re] = useState(!1);
  return { getBalance: useCallback(async () => {
    re(!0);
    try {
      if (J(null), !W || !W.payments || !B || !B.payments)
        throw new Error("No wallet is connected");
      const { address: oe } = getAddressesFromPublicKey(
        B.payments,
        A,
        ADDRESS_FORMAT_TO_TYPE[W.payments]
      )[0], ne = await new JsonRpcDatasource({ network: A }).getBalance({ address: oe }), pe = Number(
        new BigNumber(ne).multipliedBy(1e8).toFixed(0, BigNumber.ROUND_HALF_DOWN)
      );
      return re(!1), pe;
    } catch (oe) {
      throw J(oe.message), re(!1), oe;
    }
  }, [W, A, B]), error: K, loading: L };
}
async function signPsbt({
  address: A,
  wallet: B,
  network: W,
  psbt: K,
  options: J
}) {
  var oe, ke;
  if ((oe = J == null ? void 0 : J.signingIndexes) != null && oe.length && ((ke = J == null ? void 0 : J.inputsToSign) != null && ke.length))
    throw new Error("Cannot have both indexes and inputs to sign together");
  const L = (J == null ? void 0 : J.finalize) ?? !0, re = (J == null ? void 0 : J.extractTx) ?? !0, ie = () => K.data.inputs.map((ne, pe) => pe);
  if (B === Wallet.MAGICEDEN)
    return await signPsbt$1(K, {
      network: W,
      inputsToSign: (J == null ? void 0 : J.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (J == null ? void 0 : J.signingIndexes) ?? ie(),
          sigHash: J == null ? void 0 : J.sigHash
        }
      ],
      finalize: L,
      extractTx: re
    });
  if (B === Wallet.UNISAT)
    return await signPsbt$2(K, {
      finalize: L,
      extractTx: re
    });
  if (B === Wallet.XVERSE)
    return await signPsbt$3(K, {
      network: W,
      inputsToSign: (J == null ? void 0 : J.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (J == null ? void 0 : J.signingIndexes) ?? ie(),
          // If signingIndexes is not provided, just sign everything
          sigHash: J == null ? void 0 : J.sigHash
        }
      ],
      finalize: L,
      extractTx: re
    });
  if (B === Wallet.LEATHER)
    return await signPsbt$4(K, {
      network: W,
      finalize: L,
      extractTx: re,
      allowedSighash: J != null && J.sigHash ? [J == null ? void 0 : J.sigHash] : [],
      signAtIndexes: (J == null ? void 0 : J.signingIndexes) ?? ie()
      // If signingIndexes is not provided, just sign everything
    });
  if (B === Wallet.OKX)
    return await signPsbt$5(K, {
      finalize: L,
      extractTx: re,
      network: W,
      inputsToSign: (J == null ? void 0 : J.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (J == null ? void 0 : J.signingIndexes) ?? ie(),
          // If signingIndexes is not provided, just sign everything
          sigHash: J == null ? void 0 : J.sigHash
        }
      ]
    });
  throw new Error("Invalid wallet selected");
}
function useSend() {
  const { wallet: A, network: B, address: W, publicKey: K } = useOrdConnect(), [J, L] = useState(null), [re, ie] = useState(!1);
  return { send: useCallback(
    async (ke, ne, pe, rt = !0) => {
      ie(!0);
      try {
        if (L(null), !W || !W.payments || !K || !K.payments || !A)
          throw new Error("No wallet is connected");
        const nt = new PSBTBuilder({
          address: W.payments,
          feeRate: pe,
          network: B,
          publicKey: K.payments,
          outputs: [
            {
              address: ke,
              value: ne
            }
          ]
        });
        await nt.prepare();
        const ot = await signPsbt({
          address: W.payments,
          wallet: A,
          network: B,
          psbt: nt.toPSBT()
        });
        if (rt) {
          const dt = await new JsonRpcDatasource({ network: B }).relay({ hex: ot.hex });
          return ie(!1), dt;
        }
        return ie(!1), ot.hex;
      } catch (nt) {
        return L(nt.message), ie(!1), null;
      }
    },
    [W, B, K, A]
  ), error: J, loading: re };
}
function useSendV2() {
  const { wallet: A, network: B, address: W, publicKey: K } = useOrdConnect(), [J, L] = useState(!1);
  return { send: useCallback(
    async ({
      toAddress: ie,
      satoshis: oe,
      feeRate: ke,
      relay: ne = !0,
      rbf: pe = !1
    }) => {
      L(!0);
      try {
        if (!W || !W.payments || !K || !K.payments || !A)
          throw new Error("No wallet is connected");
        const rt = new PSBTBuilder({
          address: W.payments,
          feeRate: ke,
          network: B,
          publicKey: K.payments,
          outputs: [
            {
              address: ie,
              value: oe
            }
          ]
        });
        rt.setRBF(pe), await rt.prepare();
        const nt = await signPsbt({
          address: W.payments,
          wallet: A,
          network: B,
          psbt: rt.toPSBT()
        });
        if (ne) {
          const ut = await new JsonRpcDatasource({ network: B }).relay({ hex: nt.hex });
          return L(!1), {
            txId: ut
          };
        }
        return L(!1), {
          signedPsbtHex: nt.hex
        };
      } catch (rt) {
        return L(!1), {
          error: rt.message
        };
      }
    },
    [W, B, K, A]
  ), isLoading: J };
}
var src$1 = {}, address = {}, networks = {};
Object.defineProperty(networks, "__esModule", { value: !0 });
networks.testnet = networks.regtest = networks.bitcoin = void 0;
networks.bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
networks.regtest = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
networks.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var payments$2 = {}, embed = {}, script = {}, bip66 = {};
Object.defineProperty(bip66, "__esModule", { value: !0 });
bip66.encode = bip66.decode = bip66.check = void 0;
function check$d(A) {
  if (A.length < 8 || A.length > 72 || A[0] !== 48 || A[1] !== A.length - 2 || A[2] !== 2) return !1;
  const B = A[3];
  if (B === 0 || 5 + B >= A.length || A[4 + B] !== 2) return !1;
  const W = A[5 + B];
  return !(W === 0 || 6 + B + W !== A.length || A[4] & 128 || B > 1 && A[4] === 0 && !(A[5] & 128) || A[B + 6] & 128 || W > 1 && A[B + 6] === 0 && !(A[B + 7] & 128));
}
bip66.check = check$d;
function decode$h(A) {
  if (A.length < 8) throw new Error("DER sequence length is too short");
  if (A.length > 72) throw new Error("DER sequence length is too long");
  if (A[0] !== 48) throw new Error("Expected DER sequence");
  if (A[1] !== A.length - 2)
    throw new Error("DER sequence length is invalid");
  if (A[2] !== 2) throw new Error("Expected DER integer");
  const B = A[3];
  if (B === 0) throw new Error("R length is zero");
  if (5 + B >= A.length) throw new Error("R length is too long");
  if (A[4 + B] !== 2) throw new Error("Expected DER integer (2)");
  const W = A[5 + B];
  if (W === 0) throw new Error("S length is zero");
  if (6 + B + W !== A.length) throw new Error("S length is invalid");
  if (A[4] & 128) throw new Error("R value is negative");
  if (B > 1 && A[4] === 0 && !(A[5] & 128))
    throw new Error("R value excessively padded");
  if (A[B + 6] & 128) throw new Error("S value is negative");
  if (W > 1 && A[B + 6] === 0 && !(A[B + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: A.slice(4, 4 + B),
    s: A.slice(6 + B)
  };
}
bip66.decode = decode$h;
function encode$i(A, B) {
  const W = A.length, K = B.length;
  if (W === 0) throw new Error("R length is zero");
  if (K === 0) throw new Error("S length is zero");
  if (W > 33) throw new Error("R length is too long");
  if (K > 33) throw new Error("S length is too long");
  if (A[0] & 128) throw new Error("R value is negative");
  if (B[0] & 128) throw new Error("S value is negative");
  if (W > 1 && A[0] === 0 && !(A[1] & 128))
    throw new Error("R value excessively padded");
  if (K > 1 && B[0] === 0 && !(B[1] & 128))
    throw new Error("S value excessively padded");
  const J = Buffer$1.allocUnsafe(6 + W + K);
  return J[0] = 48, J[1] = J.length - 2, J[2] = 2, J[3] = A.length, A.copy(J, 4), J[4 + W] = 2, J[5 + W] = B.length, B.copy(J, 6 + W), J;
}
bip66.encode = encode$i;
var ops = {};
Object.defineProperty(ops, "__esModule", { value: !0 });
ops.REVERSE_OPS = ops.OPS = void 0;
const OPS$7 = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
ops.OPS = OPS$7;
const REVERSE_OPS = {};
ops.REVERSE_OPS = REVERSE_OPS;
for (const A of Object.keys(OPS$7)) {
  const B = OPS$7[A];
  REVERSE_OPS[B] = A;
}
var push_data = {};
Object.defineProperty(push_data, "__esModule", { value: !0 });
push_data.decode = push_data.encode = push_data.encodingLength = void 0;
const ops_1 = ops;
function encodingLength$2(A) {
  return A < ops_1.OPS.OP_PUSHDATA1 ? 1 : A <= 255 ? 2 : A <= 65535 ? 3 : 5;
}
push_data.encodingLength = encodingLength$2;
function encode$h(A, B, W) {
  const K = encodingLength$2(B);
  return K === 1 ? A.writeUInt8(B, W) : K === 2 ? (A.writeUInt8(ops_1.OPS.OP_PUSHDATA1, W), A.writeUInt8(B, W + 1)) : K === 3 ? (A.writeUInt8(ops_1.OPS.OP_PUSHDATA2, W), A.writeUInt16LE(B, W + 1)) : (A.writeUInt8(ops_1.OPS.OP_PUSHDATA4, W), A.writeUInt32LE(B, W + 1)), K;
}
push_data.encode = encode$h;
function decode$g(A, B) {
  const W = A.readUInt8(B);
  let K, J;
  if (W < ops_1.OPS.OP_PUSHDATA1)
    K = W, J = 1;
  else if (W === ops_1.OPS.OP_PUSHDATA1) {
    if (B + 2 > A.length) return null;
    K = A.readUInt8(B + 1), J = 2;
  } else if (W === ops_1.OPS.OP_PUSHDATA2) {
    if (B + 3 > A.length) return null;
    K = A.readUInt16LE(B + 1), J = 3;
  } else {
    if (B + 5 > A.length) return null;
    if (W !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    K = A.readUInt32LE(B + 1), J = 5;
  }
  return {
    opcode: W,
    number: K,
    size: J
  };
}
push_data.decode = decode$g;
var script_number = {};
Object.defineProperty(script_number, "__esModule", { value: !0 });
script_number.encode = script_number.decode = void 0;
function decode$f(A, B, W) {
  B = B || 4, W = W === void 0 ? !0 : W;
  const K = A.length;
  if (K === 0) return 0;
  if (K > B) throw new TypeError("Script number overflow");
  if (W && !(A[K - 1] & 127) && (K <= 1 || !(A[K - 2] & 128)))
    throw new Error("Non-minimally encoded script number");
  if (K === 5) {
    const L = A.readUInt32LE(0), re = A.readUInt8(4);
    return re & 128 ? -((re & -129) * 4294967296 + L) : re * 4294967296 + L;
  }
  let J = 0;
  for (let L = 0; L < K; ++L)
    J |= A[L] << 8 * L;
  return A[K - 1] & 128 ? -(J & ~(128 << 8 * (K - 1))) : J;
}
script_number.decode = decode$f;
function scriptNumSize(A) {
  return A > 2147483647 ? 5 : A > 8388607 ? 4 : A > 32767 ? 3 : A > 127 ? 2 : A > 0 ? 1 : 0;
}
function encode$g(A) {
  let B = Math.abs(A);
  const W = scriptNumSize(B), K = Buffer$1.allocUnsafe(W), J = A < 0;
  for (let L = 0; L < W; ++L)
    K.writeUInt8(B & 255, L), B >>= 8;
  return K[W - 1] & 128 ? K.writeUInt8(J ? 128 : 0, W - 1) : J && (K[W - 1] |= 128), K;
}
script_number.encode = encode$g;
var script_signature = {}, types$4 = {}, types$3 = {
  Array: function(A) {
    return A != null && A.constructor === Array;
  },
  Boolean: function(A) {
    return typeof A == "boolean";
  },
  Function: function(A) {
    return typeof A == "function";
  },
  Nil: function(A) {
    return A == null;
  },
  Number: function(A) {
    return typeof A == "number";
  },
  Object: function(A) {
    return typeof A == "object";
  },
  String: function(A) {
    return typeof A == "string";
  },
  "": function() {
    return !0;
  }
};
types$3.Null = types$3.Nil;
for (var typeName$1 in types$3)
  types$3[typeName$1].toJSON = (function(A) {
    return A;
  }).bind(null, typeName$1);
var native$1 = types$3, native = native$1;
function getTypeName(A) {
  return A.name || A.toString().match(/function (.*?)\s*\(/)[1];
}
function getValueTypeName$1(A) {
  return native.Nil(A) ? "" : getTypeName(A.constructor);
}
function getValue(A) {
  return native.Function(A) ? "" : native.String(A) ? JSON.stringify(A) : A && native.Object(A) ? "" : A;
}
function captureStackTrace(A, B) {
  Error.captureStackTrace && Error.captureStackTrace(A, B);
}
function tfJSON$1(A) {
  return native.Function(A) ? A.toJSON ? A.toJSON() : getTypeName(A) : native.Array(A) ? "Array" : A && native.Object(A) ? "Object" : A !== void 0 ? A : "";
}
function tfErrorString(A, B, W) {
  var K = getValue(B);
  return "Expected " + tfJSON$1(A) + ", got" + (W !== "" ? " " + W : "") + (K !== "" ? " " + K : "");
}
function TfTypeError$1(A, B, W) {
  W = W || getValueTypeName$1(B), this.message = tfErrorString(A, B, W), captureStackTrace(this, TfTypeError$1), this.__type = A, this.__value = B, this.__valueTypeName = W;
}
TfTypeError$1.prototype = Object.create(Error.prototype);
TfTypeError$1.prototype.constructor = TfTypeError$1;
function tfPropertyErrorString(A, B, W, K, J) {
  var L = '" of type ';
  return B === "key" && (L = '" with key type '), tfErrorString('property "' + tfJSON$1(W) + L + tfJSON$1(A), K, J);
}
function TfPropertyTypeError$1(A, B, W, K, J) {
  A ? (J = J || getValueTypeName$1(K), this.message = tfPropertyErrorString(A, W, B, K, J)) : this.message = 'Unexpected property "' + B + '"', captureStackTrace(this, TfTypeError$1), this.__label = W, this.__property = B, this.__type = A, this.__value = K, this.__valueTypeName = J;
}
TfPropertyTypeError$1.prototype = Object.create(Error.prototype);
TfPropertyTypeError$1.prototype.constructor = TfTypeError$1;
function tfCustomError(A, B) {
  return new TfTypeError$1(A, {}, B);
}
function tfSubError$1(A, B, W) {
  return A instanceof TfPropertyTypeError$1 ? (B = B + "." + A.__property, A = new TfPropertyTypeError$1(
    A.__type,
    B,
    A.__label,
    A.__value,
    A.__valueTypeName
  )) : A instanceof TfTypeError$1 && (A = new TfPropertyTypeError$1(
    A.__type,
    B,
    W,
    A.__value,
    A.__valueTypeName
  )), captureStackTrace(A), A;
}
var errors = {
  TfTypeError: TfTypeError$1,
  TfPropertyTypeError: TfPropertyTypeError$1,
  tfCustomError,
  tfSubError: tfSubError$1,
  tfJSON: tfJSON$1,
  getValueTypeName: getValueTypeName$1
}, extra, hasRequiredExtra;
function requireExtra() {
  if (hasRequiredExtra) return extra;
  hasRequiredExtra = 1;
  var A = native$1, B = errors;
  function W(xt) {
    return Buffer$1.isBuffer(xt);
  }
  function K(xt) {
    return typeof xt == "string" && /^([0-9a-f]{2})+$/i.test(xt);
  }
  function J(xt, Nt) {
    var Et = xt.toJSON();
    function bt(Bt) {
      if (!xt(Bt)) return !1;
      if (Bt.length === Nt) return !0;
      throw B.tfCustomError(Et + "(Length: " + Nt + ")", Et + "(Length: " + Bt.length + ")");
    }
    return bt.toJSON = function() {
      return Et;
    }, bt;
  }
  var L = J.bind(null, A.Array), re = J.bind(null, W), ie = J.bind(null, K), oe = J.bind(null, A.String);
  function ke(xt, Nt, Et) {
    Et = Et || A.Number;
    function bt(Bt, wt) {
      return Et(Bt, wt) && Bt > xt && Bt < Nt;
    }
    return bt.toJSON = function() {
      return `${Et.toJSON()} between [${xt}, ${Nt}]`;
    }, bt;
  }
  var ne = Math.pow(2, 53) - 1;
  function pe(xt) {
    return typeof xt == "number" && isFinite(xt);
  }
  function rt(xt) {
    return xt << 24 >> 24 === xt;
  }
  function nt(xt) {
    return xt << 16 >> 16 === xt;
  }
  function ot(xt) {
    return (xt | 0) === xt;
  }
  function ut(xt) {
    return typeof xt == "number" && xt >= -ne && xt <= ne && Math.floor(xt) === xt;
  }
  function dt(xt) {
    return (xt & 255) === xt;
  }
  function vt(xt) {
    return (xt & 65535) === xt;
  }
  function pt(xt) {
    return xt >>> 0 === xt;
  }
  function mt(xt) {
    return typeof xt == "number" && xt >= 0 && xt <= ne && Math.floor(xt) === xt;
  }
  var gt = {
    ArrayN: L,
    Buffer: W,
    BufferN: re,
    Finite: pe,
    Hex: K,
    HexN: ie,
    Int8: rt,
    Int16: nt,
    Int32: ot,
    Int53: ut,
    Range: ke,
    StringN: oe,
    UInt8: dt,
    UInt16: vt,
    UInt32: pt,
    UInt53: mt
  };
  for (var Pt in gt)
    gt[Pt].toJSON = (function(xt) {
      return xt;
    }).bind(null, Pt);
  return extra = gt, extra;
}
var ERRORS = errors, NATIVE = native$1, tfJSON = ERRORS.tfJSON, TfTypeError = ERRORS.TfTypeError, TfPropertyTypeError = ERRORS.TfPropertyTypeError, tfSubError = ERRORS.tfSubError, getValueTypeName = ERRORS.getValueTypeName, TYPES = {
  arrayOf: function A(B, W) {
    B = compile(B), W = W || {};
    function K(J, L) {
      return !NATIVE.Array(J) || NATIVE.Nil(J) || W.minLength !== void 0 && J.length < W.minLength || W.maxLength !== void 0 && J.length > W.maxLength || W.length !== void 0 && J.length !== W.length ? !1 : J.every(function(re, ie) {
        try {
          return typeforce$3(B, re, L);
        } catch (oe) {
          throw tfSubError(oe, ie);
        }
      });
    }
    return K.toJSON = function() {
      var J = "[" + tfJSON(B) + "]";
      return W.length !== void 0 ? J += "{" + W.length + "}" : (W.minLength !== void 0 || W.maxLength !== void 0) && (J += "{" + (W.minLength === void 0 ? 0 : W.minLength) + "," + (W.maxLength === void 0 ? 1 / 0 : W.maxLength) + "}"), J;
    }, K;
  },
  maybe: function A(B) {
    B = compile(B);
    function W(K, J) {
      return NATIVE.Nil(K) || B(K, J, A);
    }
    return W.toJSON = function() {
      return "?" + tfJSON(B);
    }, W;
  },
  map: function A(B, W) {
    B = compile(B), W && (W = compile(W));
    function K(J, L) {
      if (!NATIVE.Object(J) || NATIVE.Nil(J)) return !1;
      for (var re in J) {
        try {
          W && typeforce$3(W, re, L);
        } catch (oe) {
          throw tfSubError(oe, re, "key");
        }
        try {
          var ie = J[re];
          typeforce$3(B, ie, L);
        } catch (oe) {
          throw tfSubError(oe, re);
        }
      }
      return !0;
    }
    return W ? K.toJSON = function() {
      return "{" + tfJSON(W) + ": " + tfJSON(B) + "}";
    } : K.toJSON = function() {
      return "{" + tfJSON(B) + "}";
    }, K;
  },
  object: function A(B) {
    var W = {};
    for (var K in B)
      W[K] = compile(B[K]);
    function J(L, re) {
      if (!NATIVE.Object(L) || NATIVE.Nil(L)) return !1;
      var ie;
      try {
        for (ie in W) {
          var oe = W[ie], ke = L[ie];
          typeforce$3(oe, ke, re);
        }
      } catch (ne) {
        throw tfSubError(ne, ie);
      }
      if (re) {
        for (ie in L)
          if (!W[ie])
            throw new TfPropertyTypeError(void 0, ie);
      }
      return !0;
    }
    return J.toJSON = function() {
      return tfJSON(W);
    }, J;
  },
  anyOf: function A() {
    var B = [].slice.call(arguments).map(compile);
    function W(K, J) {
      return B.some(function(L) {
        try {
          return typeforce$3(L, K, J);
        } catch {
          return !1;
        }
      });
    }
    return W.toJSON = function() {
      return B.map(tfJSON).join("|");
    }, W;
  },
  allOf: function A() {
    var B = [].slice.call(arguments).map(compile);
    function W(K, J) {
      return B.every(function(L) {
        try {
          return typeforce$3(L, K, J);
        } catch {
          return !1;
        }
      });
    }
    return W.toJSON = function() {
      return B.map(tfJSON).join(" & ");
    }, W;
  },
  quacksLike: function A(B) {
    function W(K) {
      return B === getValueTypeName(K);
    }
    return W.toJSON = function() {
      return B;
    }, W;
  },
  tuple: function A() {
    var B = [].slice.call(arguments).map(compile);
    function W(K, J) {
      return NATIVE.Nil(K) || NATIVE.Nil(K.length) || J && K.length !== B.length ? !1 : B.every(function(L, re) {
        try {
          return typeforce$3(L, K[re], J);
        } catch (ie) {
          throw tfSubError(ie, re);
        }
      });
    }
    return W.toJSON = function() {
      return "(" + B.map(tfJSON).join(", ") + ")";
    }, W;
  },
  value: function A(B) {
    function W(K) {
      return K === B;
    }
    return W.toJSON = function() {
      return B;
    }, W;
  }
};
TYPES.oneOf = TYPES.anyOf;
function compile(A) {
  if (NATIVE.String(A))
    return A[0] === "?" ? TYPES.maybe(A.slice(1)) : NATIVE[A] || TYPES.quacksLike(A);
  if (A && NATIVE.Object(A)) {
    if (NATIVE.Array(A)) {
      if (A.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return TYPES.arrayOf(A[0]);
    }
    return TYPES.object(A);
  } else if (NATIVE.Function(A))
    return A;
  return TYPES.value(A);
}
function typeforce$3(A, B, W, K) {
  if (NATIVE.Function(A)) {
    if (A(B, W)) return !0;
    throw new TfTypeError(K || A, B);
  }
  return typeforce$3(compile(A), B, W);
}
for (var typeName in NATIVE)
  typeforce$3[typeName] = NATIVE[typeName];
for (typeName in TYPES)
  typeforce$3[typeName] = TYPES[typeName];
var EXTRA = requireExtra();
for (typeName in EXTRA)
  typeforce$3[typeName] = EXTRA[typeName];
typeforce$3.compile = compile;
typeforce$3.TfTypeError = TfTypeError;
typeforce$3.TfPropertyTypeError = TfPropertyTypeError;
var typeforce_1 = typeforce$3;
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.oneOf = A.Null = A.BufferN = A.Function = A.UInt32 = A.UInt8 = A.tuple = A.maybe = A.Hex = A.Buffer = A.String = A.Boolean = A.Array = A.Number = A.Hash256bit = A.Hash160bit = A.Buffer256bit = A.isTaptree = A.isTapleaf = A.TAPLEAF_VERSION_MASK = A.Satoshi = A.isPoint = A.stacksEqual = A.typeforce = void 0;
  const B = require$$0$1;
  A.typeforce = typeforce_1;
  const W = B.Buffer.alloc(32, 0), K = B.Buffer.from(
    "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "hex"
  );
  function J(ne, pe) {
    return ne.length !== pe.length ? !1 : ne.every((rt, nt) => rt.equals(pe[nt]));
  }
  A.stacksEqual = J;
  function L(ne) {
    if (!B.Buffer.isBuffer(ne) || ne.length < 33) return !1;
    const pe = ne[0], rt = ne.slice(1, 33);
    if (rt.compare(W) === 0 || rt.compare(K) >= 0) return !1;
    if ((pe === 2 || pe === 3) && ne.length === 33)
      return !0;
    const nt = ne.slice(33);
    return nt.compare(W) === 0 || nt.compare(K) >= 0 ? !1 : pe === 4 && ne.length === 65;
  }
  A.isPoint = L;
  const re = 21 * 1e14;
  function ie(ne) {
    return A.typeforce.UInt53(ne) && ne <= re;
  }
  A.Satoshi = ie, A.TAPLEAF_VERSION_MASK = 254;
  function oe(ne) {
    return !ne || !("output" in ne) || !B.Buffer.isBuffer(ne.output) ? !1 : ne.version !== void 0 ? (ne.version & A.TAPLEAF_VERSION_MASK) === ne.version : !0;
  }
  A.isTapleaf = oe;
  function ke(ne) {
    return (0, A.Array)(ne) ? ne.length !== 2 ? !1 : ne.every((pe) => ke(pe)) : oe(ne);
  }
  A.isTaptree = ke, A.Buffer256bit = A.typeforce.BufferN(32), A.Hash160bit = A.typeforce.BufferN(20), A.Hash256bit = A.typeforce.BufferN(32), A.Number = A.typeforce.Number, A.Array = A.typeforce.Array, A.Boolean = A.typeforce.Boolean, A.String = A.typeforce.String, A.Buffer = A.typeforce.Buffer, A.Hex = A.typeforce.Hex, A.maybe = A.typeforce.maybe, A.tuple = A.typeforce.tuple, A.UInt8 = A.typeforce.UInt8, A.UInt32 = A.typeforce.UInt32, A.Function = A.typeforce.Function, A.BufferN = A.typeforce.BufferN, A.Null = A.typeforce.Null, A.oneOf = A.typeforce.oneOf;
})(types$4);
var hasRequiredScript_signature;
function requireScript_signature() {
  if (hasRequiredScript_signature) return script_signature;
  hasRequiredScript_signature = 1, Object.defineProperty(script_signature, "__esModule", { value: !0 }), script_signature.encode = script_signature.decode = void 0;
  const A = bip66, B = requireScript(), W = types$4, { typeforce: K } = W, J = Buffer$1.alloc(1, 0);
  function L(ke) {
    let ne = 0;
    for (; ke[ne] === 0; ) ++ne;
    return ne === ke.length ? J : (ke = ke.slice(ne), ke[0] & 128 ? Buffer$1.concat([J, ke], 1 + ke.length) : ke);
  }
  function re(ke) {
    ke[0] === 0 && (ke = ke.slice(1));
    const ne = Buffer$1.alloc(32, 0), pe = Math.max(0, 32 - ke.length);
    return ke.copy(ne, pe), ne;
  }
  function ie(ke) {
    const ne = ke.readUInt8(ke.length - 1);
    if (!(0, B.isDefinedHashType)(ne))
      throw new Error("Invalid hashType " + ne);
    const pe = A.decode(ke.slice(0, -1)), rt = re(pe.r), nt = re(pe.s);
    return { signature: Buffer$1.concat([rt, nt], 64), hashType: ne };
  }
  script_signature.decode = ie;
  function oe(ke, ne) {
    if (K(
      {
        signature: W.BufferN(64),
        hashType: W.UInt8
      },
      { signature: ke, hashType: ne }
    ), !(0, B.isDefinedHashType)(ne))
      throw new Error("Invalid hashType " + ne);
    const pe = Buffer$1.allocUnsafe(1);
    pe.writeUInt8(ne, 0);
    const rt = L(ke.slice(0, 32)), nt = L(ke.slice(32, 64));
    return Buffer$1.concat([A.encode(rt, nt), pe]);
  }
  return script_signature.encode = oe, script_signature;
}
var hasRequiredScript;
function requireScript() {
  return hasRequiredScript || (hasRequiredScript = 1, function(A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.signature = A.number = A.isCanonicalScriptSignature = A.isDefinedHashType = A.isCanonicalPubKey = A.toStack = A.fromASM = A.toASM = A.decompile = A.compile = A.countNonPushOnlyOPs = A.isPushOnly = A.OPS = void 0;
    const B = bip66, W = ops;
    Object.defineProperty(A, "OPS", {
      enumerable: !0,
      get: function() {
        return W.OPS;
      }
    });
    const K = push_data, J = script_number, L = requireScript_signature(), re = types$4, { typeforce: ie } = re, oe = W.OPS.OP_RESERVED;
    function ke(bt) {
      return re.Number(bt) && (bt === W.OPS.OP_0 || bt >= W.OPS.OP_1 && bt <= W.OPS.OP_16 || bt === W.OPS.OP_1NEGATE);
    }
    function ne(bt) {
      return re.Buffer(bt) || ke(bt);
    }
    function pe(bt) {
      return re.Array(bt) && bt.every(ne);
    }
    A.isPushOnly = pe;
    function rt(bt) {
      return bt.length - bt.filter(ne).length;
    }
    A.countNonPushOnlyOPs = rt;
    function nt(bt) {
      if (bt.length === 0) return W.OPS.OP_0;
      if (bt.length === 1) {
        if (bt[0] >= 1 && bt[0] <= 16) return oe + bt[0];
        if (bt[0] === 129) return W.OPS.OP_1NEGATE;
      }
    }
    function ot(bt) {
      return Buffer$1.isBuffer(bt);
    }
    function ut(bt) {
      return re.Array(bt);
    }
    function dt(bt) {
      return Buffer$1.isBuffer(bt);
    }
    function vt(bt) {
      if (ot(bt)) return bt;
      ie(re.Array, bt);
      const Bt = bt.reduce((Oe, V) => dt(V) ? V.length === 1 && nt(V) !== void 0 ? Oe + 1 : Oe + K.encodingLength(V.length) + V.length : Oe + 1, 0), wt = Buffer$1.allocUnsafe(Bt);
      let st = 0;
      if (bt.forEach((Oe) => {
        if (dt(Oe)) {
          const V = nt(Oe);
          if (V !== void 0) {
            wt.writeUInt8(V, st), st += 1;
            return;
          }
          st += K.encode(wt, Oe.length, st), Oe.copy(wt, st), st += Oe.length;
        } else
          wt.writeUInt8(Oe, st), st += 1;
      }), st !== wt.length) throw new Error("Could not decode chunks");
      return wt;
    }
    A.compile = vt;
    function pt(bt) {
      if (ut(bt)) return bt;
      ie(re.Buffer, bt);
      const Bt = [];
      let wt = 0;
      for (; wt < bt.length; ) {
        const st = bt[wt];
        if (st > W.OPS.OP_0 && st <= W.OPS.OP_PUSHDATA4) {
          const Oe = K.decode(bt, wt);
          if (Oe === null || (wt += Oe.size, wt + Oe.number > bt.length)) return null;
          const V = bt.slice(wt, wt + Oe.number);
          wt += Oe.number;
          const ce = nt(V);
          ce !== void 0 ? Bt.push(ce) : Bt.push(V);
        } else
          Bt.push(st), wt += 1;
      }
      return Bt;
    }
    A.decompile = pt;
    function mt(bt) {
      if (ot(bt) && (bt = pt(bt)), !bt)
        throw new Error("Could not convert invalid chunks to ASM");
      return bt.map((Bt) => {
        if (dt(Bt)) {
          const wt = nt(Bt);
          if (wt === void 0) return Bt.toString("hex");
          Bt = wt;
        }
        return W.REVERSE_OPS[Bt];
      }).join(" ");
    }
    A.toASM = mt;
    function gt(bt) {
      return ie(re.String, bt), vt(
        bt.split(" ").map((Bt) => W.OPS[Bt] !== void 0 ? W.OPS[Bt] : (ie(re.Hex, Bt), Buffer$1.from(Bt, "hex")))
      );
    }
    A.fromASM = gt;
    function Pt(bt) {
      return bt = pt(bt), ie(pe, bt), bt.map((Bt) => dt(Bt) ? Bt : Bt === W.OPS.OP_0 ? Buffer$1.allocUnsafe(0) : J.encode(Bt - oe));
    }
    A.toStack = Pt;
    function xt(bt) {
      return re.isPoint(bt);
    }
    A.isCanonicalPubKey = xt;
    function Nt(bt) {
      const Bt = bt & -129;
      return Bt > 0 && Bt < 4;
    }
    A.isDefinedHashType = Nt;
    function Et(bt) {
      return !Buffer$1.isBuffer(bt) || !Nt(bt[bt.length - 1]) ? !1 : B.check(bt.slice(0, -1));
    }
    A.isCanonicalScriptSignature = Et, A.number = J, A.signature = L;
  }(script)), script;
}
var lazy$7 = {};
Object.defineProperty(lazy$7, "__esModule", { value: !0 });
lazy$7.value = lazy$7.prop = void 0;
function prop(A, B, W) {
  Object.defineProperty(A, B, {
    configurable: !0,
    enumerable: !0,
    get() {
      const K = W.call(this);
      return this[B] = K, K;
    },
    set(K) {
      Object.defineProperty(this, B, {
        configurable: !0,
        enumerable: !0,
        value: K,
        writable: !0
      });
    }
  });
}
lazy$7.prop = prop;
function value(A) {
  let B;
  return () => (B !== void 0 || (B = A()), B);
}
lazy$7.value = value;
Object.defineProperty(embed, "__esModule", { value: !0 });
embed.p2data = void 0;
const networks_1$7 = networks, bscript$9 = requireScript(), types_1$7 = types$4, lazy$6 = lazy$7, OPS$6 = bscript$9.OPS;
function p2data(A, B) {
  if (!A.data && !A.output) throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$7.typeforce)(
    {
      network: types_1$7.typeforce.maybe(types_1$7.typeforce.Object),
      output: types_1$7.typeforce.maybe(types_1$7.typeforce.Buffer),
      data: types_1$7.typeforce.maybe(
        types_1$7.typeforce.arrayOf(types_1$7.typeforce.Buffer)
      )
    },
    A
  );
  const K = { name: "embed", network: A.network || networks_1$7.bitcoin };
  if (lazy$6.prop(K, "output", () => {
    if (A.data)
      return bscript$9.compile([OPS$6.OP_RETURN].concat(A.data));
  }), lazy$6.prop(K, "data", () => {
    if (A.output)
      return bscript$9.decompile(A.output).slice(1);
  }), B.validate && A.output) {
    const J = bscript$9.decompile(A.output);
    if (J[0] !== OPS$6.OP_RETURN) throw new TypeError("Output is invalid");
    if (!J.slice(1).every(types_1$7.typeforce.Buffer))
      throw new TypeError("Output is invalid");
    if (A.data && !(0, types_1$7.stacksEqual)(A.data, K.data))
      throw new TypeError("Data mismatch");
  }
  return Object.assign(K, A);
}
embed.p2data = p2data;
var p2ms$1 = {};
Object.defineProperty(p2ms$1, "__esModule", { value: !0 });
p2ms$1.p2ms = void 0;
const networks_1$6 = networks, bscript$8 = requireScript(), types_1$6 = types$4, lazy$5 = lazy$7, OPS$5 = bscript$8.OPS, OP_INT_BASE = OPS$5.OP_RESERVED;
function p2ms(A, B) {
  if (!A.input && !A.output && !(A.pubkeys && A.m !== void 0) && !A.signatures)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {});
  function W(oe) {
    return bscript$8.isCanonicalScriptSignature(oe) || (B.allowIncomplete && oe === OPS$5.OP_0) !== void 0;
  }
  (0, types_1$6.typeforce)(
    {
      network: types_1$6.typeforce.maybe(types_1$6.typeforce.Object),
      m: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      n: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      output: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer),
      pubkeys: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(types_1$6.isPoint)
      ),
      signatures: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(W)
      ),
      input: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer)
    },
    A
  );
  const J = { network: A.network || networks_1$6.bitcoin };
  let L = [], re = !1;
  function ie(oe) {
    re || (re = !0, L = bscript$8.decompile(oe), J.m = L[0] - OP_INT_BASE, J.n = L[L.length - 2] - OP_INT_BASE, J.pubkeys = L.slice(1, -2));
  }
  if (lazy$5.prop(J, "output", () => {
    if (A.m && J.n && A.pubkeys)
      return bscript$8.compile(
        [].concat(
          OP_INT_BASE + A.m,
          A.pubkeys,
          OP_INT_BASE + J.n,
          OPS$5.OP_CHECKMULTISIG
        )
      );
  }), lazy$5.prop(J, "m", () => {
    if (J.output)
      return ie(J.output), J.m;
  }), lazy$5.prop(J, "n", () => {
    if (J.pubkeys)
      return J.pubkeys.length;
  }), lazy$5.prop(J, "pubkeys", () => {
    if (A.output)
      return ie(A.output), J.pubkeys;
  }), lazy$5.prop(J, "signatures", () => {
    if (A.input)
      return bscript$8.decompile(A.input).slice(1);
  }), lazy$5.prop(J, "input", () => {
    if (A.signatures)
      return bscript$8.compile([OPS$5.OP_0].concat(A.signatures));
  }), lazy$5.prop(J, "witness", () => {
    if (J.input)
      return [];
  }), lazy$5.prop(J, "name", () => {
    if (!(!J.m || !J.n))
      return `p2ms(${J.m} of ${J.n})`;
  }), B.validate) {
    if (A.output) {
      if (ie(A.output), !types_1$6.typeforce.Number(L[0]))
        throw new TypeError("Output is invalid");
      if (!types_1$6.typeforce.Number(L[L.length - 2]))
        throw new TypeError("Output is invalid");
      if (L[L.length - 1] !== OPS$5.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (J.m <= 0 || J.n > 16 || J.m > J.n || J.n !== L.length - 3)
        throw new TypeError("Output is invalid");
      if (!J.pubkeys.every((oe) => (0, types_1$6.isPoint)(oe)))
        throw new TypeError("Output is invalid");
      if (A.m !== void 0 && A.m !== J.m) throw new TypeError("m mismatch");
      if (A.n !== void 0 && A.n !== J.n) throw new TypeError("n mismatch");
      if (A.pubkeys && !(0, types_1$6.stacksEqual)(A.pubkeys, J.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (A.pubkeys) {
      if (A.n !== void 0 && A.n !== A.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (J.n = A.pubkeys.length, J.n < J.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (A.signatures) {
      if (A.signatures.length < J.m)
        throw new TypeError("Not enough signatures provided");
      if (A.signatures.length > J.m)
        throw new TypeError("Too many signatures provided");
    }
    if (A.input) {
      if (A.input[0] !== OPS$5.OP_0) throw new TypeError("Input is invalid");
      if (J.signatures.length === 0 || !J.signatures.every(W))
        throw new TypeError("Input has invalid signature(s)");
      if (A.signatures && !(0, types_1$6.stacksEqual)(A.signatures, J.signatures))
        throw new TypeError("Signature mismatch");
      if (A.m !== void 0 && A.m !== A.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(J, A);
}
p2ms$1.p2ms = p2ms;
var p2pk$1 = {};
Object.defineProperty(p2pk$1, "__esModule", { value: !0 });
p2pk$1.p2pk = void 0;
const networks_1$5 = networks, bscript$7 = requireScript(), types_1$5 = types$4, lazy$4 = lazy$7, OPS$4 = bscript$7.OPS;
function p2pk(A, B) {
  if (!A.input && !A.output && !A.pubkey && !A.input && !A.signature)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$5.typeforce)(
    {
      network: types_1$5.typeforce.maybe(types_1$5.typeforce.Object),
      output: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer),
      pubkey: types_1$5.typeforce.maybe(types_1$5.isPoint),
      signature: types_1$5.typeforce.maybe(bscript$7.isCanonicalScriptSignature),
      input: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer)
    },
    A
  );
  const W = lazy$4.value(() => bscript$7.decompile(A.input)), J = { name: "p2pk", network: A.network || networks_1$5.bitcoin };
  if (lazy$4.prop(J, "output", () => {
    if (A.pubkey)
      return bscript$7.compile([A.pubkey, OPS$4.OP_CHECKSIG]);
  }), lazy$4.prop(J, "pubkey", () => {
    if (A.output)
      return A.output.slice(1, -1);
  }), lazy$4.prop(J, "signature", () => {
    if (A.input)
      return W()[0];
  }), lazy$4.prop(J, "input", () => {
    if (A.signature)
      return bscript$7.compile([A.signature]);
  }), lazy$4.prop(J, "witness", () => {
    if (J.input)
      return [];
  }), B.validate) {
    if (A.output) {
      if (A.output[A.output.length - 1] !== OPS$4.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!(0, types_1$5.isPoint)(J.pubkey))
        throw new TypeError("Output pubkey is invalid");
      if (A.pubkey && !A.pubkey.equals(J.pubkey))
        throw new TypeError("Pubkey mismatch");
    }
    if (A.signature && A.input && !A.input.equals(J.input))
      throw new TypeError("Signature mismatch");
    if (A.input) {
      if (W().length !== 1) throw new TypeError("Input is invalid");
      if (!bscript$7.isCanonicalScriptSignature(J.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(J, A);
}
p2pk$1.p2pk = p2pk;
var p2pkh$1 = {}, crypto$1 = {}, ripemd160 = {};
Object.defineProperty(ripemd160, "__esModule", { value: !0 });
ripemd160.ripemd160 = ripemd160.RIPEMD160 = void 0;
const _md_js_1$1 = _md, utils_js_1$1 = utils$5, Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((A, B) => B)), Pi = /* @__PURE__ */ Id.map((A) => (9 * A + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let A = 0; A < 4; A++)
  for (let B of [idxL, idxR])
    B.push(B[A].map((W) => Rho[W]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((A) => new Uint8Array(A)), shiftsL = /* @__PURE__ */ idxL.map((A, B) => A.map((W) => shifts[B][W])), shiftsR = /* @__PURE__ */ idxR.map((A, B) => A.map((W) => shifts[B][W])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f(A, B, W, K) {
  return A === 0 ? B ^ W ^ K : A === 1 ? B & W | ~B & K : A === 2 ? (B | ~W) ^ K : A === 3 ? B & K | W & ~K : B ^ (W | ~K);
}
const R_BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_js_1$1.HashMD {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: B, h1: W, h2: K, h3: J, h4: L } = this;
    return [B, W, K, J, L];
  }
  set(B, W, K, J, L) {
    this.h0 = B | 0, this.h1 = W | 0, this.h2 = K | 0, this.h3 = J | 0, this.h4 = L | 0;
  }
  process(B, W) {
    for (let nt = 0; nt < 16; nt++, W += 4)
      R_BUF[nt] = B.getUint32(W, !0);
    let K = this.h0 | 0, J = K, L = this.h1 | 0, re = L, ie = this.h2 | 0, oe = ie, ke = this.h3 | 0, ne = ke, pe = this.h4 | 0, rt = pe;
    for (let nt = 0; nt < 5; nt++) {
      const ot = 4 - nt, ut = Kl[nt], dt = Kr[nt], vt = idxL[nt], pt = idxR[nt], mt = shiftsL[nt], gt = shiftsR[nt];
      for (let Pt = 0; Pt < 16; Pt++) {
        const xt = (0, utils_js_1$1.rotl)(K + f(nt, L, ie, ke) + R_BUF[vt[Pt]] + ut, mt[Pt]) + pe | 0;
        K = pe, pe = ke, ke = (0, utils_js_1$1.rotl)(ie, 10) | 0, ie = L, L = xt;
      }
      for (let Pt = 0; Pt < 16; Pt++) {
        const xt = (0, utils_js_1$1.rotl)(J + f(ot, re, oe, ne) + R_BUF[pt[Pt]] + dt, gt[Pt]) + rt | 0;
        J = rt, rt = ne, ne = (0, utils_js_1$1.rotl)(oe, 10) | 0, oe = re, re = xt;
      }
    }
    this.set(this.h1 + ie + ne | 0, this.h2 + ke + rt | 0, this.h3 + pe + J | 0, this.h4 + K + re | 0, this.h0 + L + oe | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
ripemd160.RIPEMD160 = RIPEMD160;
ripemd160.ripemd160 = (0, utils_js_1$1.wrapConstructor)(() => new RIPEMD160());
var sha1 = {};
Object.defineProperty(sha1, "__esModule", { value: !0 });
sha1.sha1 = sha1.SHA1 = void 0;
const _md_js_1 = _md, utils_js_1 = utils$5, SHA1_IV = /* @__PURE__ */ new Uint32Array([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), SHA1_W = /* @__PURE__ */ new Uint32Array(80);
class SHA1 extends _md_js_1.HashMD {
  constructor() {
    super(64, 20, 8, !1), this.A = SHA1_IV[0] | 0, this.B = SHA1_IV[1] | 0, this.C = SHA1_IV[2] | 0, this.D = SHA1_IV[3] | 0, this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: B, B: W, C: K, D: J, E: L } = this;
    return [B, W, K, J, L];
  }
  set(B, W, K, J, L) {
    this.A = B | 0, this.B = W | 0, this.C = K | 0, this.D = J | 0, this.E = L | 0;
  }
  process(B, W) {
    for (let oe = 0; oe < 16; oe++, W += 4)
      SHA1_W[oe] = B.getUint32(W, !1);
    for (let oe = 16; oe < 80; oe++)
      SHA1_W[oe] = (0, utils_js_1.rotl)(SHA1_W[oe - 3] ^ SHA1_W[oe - 8] ^ SHA1_W[oe - 14] ^ SHA1_W[oe - 16], 1);
    let { A: K, B: J, C: L, D: re, E: ie } = this;
    for (let oe = 0; oe < 80; oe++) {
      let ke, ne;
      oe < 20 ? (ke = (0, _md_js_1.Chi)(J, L, re), ne = 1518500249) : oe < 40 ? (ke = J ^ L ^ re, ne = 1859775393) : oe < 60 ? (ke = (0, _md_js_1.Maj)(J, L, re), ne = 2400959708) : (ke = J ^ L ^ re, ne = 3395469782);
      const pe = (0, utils_js_1.rotl)(K, 5) + ke + ie + ne + SHA1_W[oe] | 0;
      ie = re, re = L, L = (0, utils_js_1.rotl)(J, 30), J = K, K = pe;
    }
    K = K + this.A | 0, J = J + this.B | 0, L = L + this.C | 0, re = re + this.D | 0, ie = ie + this.E | 0, this.set(K, J, L, re, ie);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha1.SHA1 = SHA1;
sha1.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.taggedHash = A.TAGGED_HASH_PREFIXES = A.TAGS = A.hash256 = A.hash160 = A.sha256 = A.sha1 = A.ripemd160 = void 0;
  const B = ripemd160, W = sha1, K = sha256$4;
  function J(ne) {
    return Buffer$1.from((0, B.ripemd160)(Uint8Array.from(ne)));
  }
  A.ripemd160 = J;
  function L(ne) {
    return Buffer$1.from((0, W.sha1)(Uint8Array.from(ne)));
  }
  A.sha1 = L;
  function re(ne) {
    return Buffer$1.from((0, K.sha256)(Uint8Array.from(ne)));
  }
  A.sha256 = re;
  function ie(ne) {
    return Buffer$1.from(
      (0, B.ripemd160)((0, K.sha256)(Uint8Array.from(ne)))
    );
  }
  A.hash160 = ie;
  function oe(ne) {
    return Buffer$1.from(
      (0, K.sha256)((0, K.sha256)(Uint8Array.from(ne)))
    );
  }
  A.hash256 = oe, A.TAGS = [
    "BIP0340/challenge",
    "BIP0340/aux",
    "BIP0340/nonce",
    "TapLeaf",
    "TapBranch",
    "TapSighash",
    "TapTweak",
    "KeyAgg list",
    "KeyAgg coefficient"
  ], A.TAGGED_HASH_PREFIXES = {
    "BIP0340/challenge": Buffer$1.from([
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124,
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124
    ]),
    "BIP0340/aux": Buffer$1.from([
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144,
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144
    ]),
    "BIP0340/nonce": Buffer$1.from([
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47,
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47
    ]),
    TapLeaf: Buffer$1.from([
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238,
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238
    ]),
    TapBranch: Buffer$1.from([
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21,
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21
    ]),
    TapSighash: Buffer$1.from([
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49,
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49
    ]),
    TapTweak: Buffer$1.from([
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233,
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233
    ]),
    "KeyAgg list": Buffer$1.from([
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240,
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240
    ]),
    "KeyAgg coefficient": Buffer$1.from([
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129,
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129
    ])
  };
  function ke(ne, pe) {
    return re(Buffer$1.concat([A.TAGGED_HASH_PREFIXES[ne], pe]));
  }
  A.taggedHash = ke;
})(crypto$1);
function base$1(A) {
  if (A.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var B = new Uint8Array(256), W = 0; W < B.length; W++)
    B[W] = 255;
  for (var K = 0; K < A.length; K++) {
    var J = A.charAt(K), L = J.charCodeAt(0);
    if (B[L] !== 255)
      throw new TypeError(J + " is ambiguous");
    B[L] = K;
  }
  var re = A.length, ie = A.charAt(0), oe = Math.log(re) / Math.log(256), ke = Math.log(256) / Math.log(re);
  function ne(nt) {
    if (nt instanceof Uint8Array || (ArrayBuffer.isView(nt) ? nt = new Uint8Array(nt.buffer, nt.byteOffset, nt.byteLength) : Array.isArray(nt) && (nt = Uint8Array.from(nt))), !(nt instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (nt.length === 0)
      return "";
    for (var ot = 0, ut = 0, dt = 0, vt = nt.length; dt !== vt && nt[dt] === 0; )
      dt++, ot++;
    for (var pt = (vt - dt) * ke + 1 >>> 0, mt = new Uint8Array(pt); dt !== vt; ) {
      for (var gt = nt[dt], Pt = 0, xt = pt - 1; (gt !== 0 || Pt < ut) && xt !== -1; xt--, Pt++)
        gt += 256 * mt[xt] >>> 0, mt[xt] = gt % re >>> 0, gt = gt / re >>> 0;
      if (gt !== 0)
        throw new Error("Non-zero carry");
      ut = Pt, dt++;
    }
    for (var Nt = pt - ut; Nt !== pt && mt[Nt] === 0; )
      Nt++;
    for (var Et = ie.repeat(ot); Nt < pt; ++Nt)
      Et += A.charAt(mt[Nt]);
    return Et;
  }
  function pe(nt) {
    if (typeof nt != "string")
      throw new TypeError("Expected String");
    if (nt.length === 0)
      return new Uint8Array();
    for (var ot = 0, ut = 0, dt = 0; nt[ot] === ie; )
      ut++, ot++;
    for (var vt = (nt.length - ot) * oe + 1 >>> 0, pt = new Uint8Array(vt); nt[ot]; ) {
      var mt = B[nt.charCodeAt(ot)];
      if (mt === 255)
        return;
      for (var gt = 0, Pt = vt - 1; (mt !== 0 || gt < dt) && Pt !== -1; Pt--, gt++)
        mt += re * pt[Pt] >>> 0, pt[Pt] = mt % 256 >>> 0, mt = mt / 256 >>> 0;
      if (mt !== 0)
        throw new Error("Non-zero carry");
      dt = gt, ot++;
    }
    for (var xt = vt - dt; xt !== vt && pt[xt] === 0; )
      xt++;
    for (var Nt = new Uint8Array(ut + (vt - xt)), Et = ut; xt !== vt; )
      Nt[Et++] = pt[xt++];
    return Nt;
  }
  function rt(nt) {
    var ot = pe(nt);
    if (ot)
      return ot;
    throw new Error("Non-base" + re + " character");
  }
  return {
    encode: ne,
    decodeUnsafe: pe,
    decode: rt
  };
}
var src = base$1;
const basex = src, ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET$1), base58 = bs58, base = function(A) {
  function B(L) {
    var re = Uint8Array.from(L), ie = A(re), oe = re.length + 4, ke = new Uint8Array(oe);
    return ke.set(re, 0), ke.set(ie.subarray(0, 4), re.length), base58.encode(ke, oe);
  }
  function W(L) {
    var re = L.slice(0, -4), ie = L.slice(-4), oe = A(re);
    if (!(ie[0] ^ oe[0] | ie[1] ^ oe[1] | ie[2] ^ oe[2] | ie[3] ^ oe[3]))
      return re;
  }
  function K(L) {
    var re = base58.decodeUnsafe(L);
    if (re)
      return W(re);
  }
  function J(L) {
    var re = base58.decode(L), ie = W(re);
    if (!ie) throw new Error("Invalid checksum");
    return ie;
  }
  return {
    encode: B,
    decode: J,
    decodeUnsafe: K
  };
}, { sha256 } = sha256$4, bs58checkBase = base;
function sha256x2(A) {
  return sha256(sha256(A));
}
var bs58check$2 = bs58checkBase(sha256x2);
Object.defineProperty(p2pkh$1, "__esModule", { value: !0 });
p2pkh$1.p2pkh = void 0;
const bcrypto$5 = crypto$1, networks_1$4 = networks, bscript$6 = requireScript(), types_1$4 = types$4, lazy$3 = lazy$7, bs58check$1 = bs58check$2, OPS$3 = bscript$6.OPS;
function p2pkh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.pubkey && !A.input)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$4.typeforce)(
    {
      network: types_1$4.typeforce.maybe(types_1$4.typeforce.Object),
      address: types_1$4.typeforce.maybe(types_1$4.typeforce.String),
      hash: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(20)),
      output: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(25)),
      pubkey: types_1$4.typeforce.maybe(types_1$4.isPoint),
      signature: types_1$4.typeforce.maybe(bscript$6.isCanonicalScriptSignature),
      input: types_1$4.typeforce.maybe(types_1$4.typeforce.Buffer)
    },
    A
  );
  const W = lazy$3.value(() => {
    const re = Buffer$1.from(bs58check$1.decode(A.address)), ie = re.readUInt8(0), oe = re.slice(1);
    return { version: ie, hash: oe };
  }), K = lazy$3.value(() => bscript$6.decompile(A.input)), J = A.network || networks_1$4.bitcoin, L = { name: "p2pkh", network: J };
  if (lazy$3.prop(L, "address", () => {
    if (!L.hash) return;
    const re = Buffer$1.allocUnsafe(21);
    return re.writeUInt8(J.pubKeyHash, 0), L.hash.copy(re, 1), bs58check$1.encode(re);
  }), lazy$3.prop(L, "hash", () => {
    if (A.output) return A.output.slice(3, 23);
    if (A.address) return W().hash;
    if (A.pubkey || L.pubkey) return bcrypto$5.hash160(A.pubkey || L.pubkey);
  }), lazy$3.prop(L, "output", () => {
    if (L.hash)
      return bscript$6.compile([
        OPS$3.OP_DUP,
        OPS$3.OP_HASH160,
        L.hash,
        OPS$3.OP_EQUALVERIFY,
        OPS$3.OP_CHECKSIG
      ]);
  }), lazy$3.prop(L, "pubkey", () => {
    if (A.input)
      return K()[1];
  }), lazy$3.prop(L, "signature", () => {
    if (A.input)
      return K()[0];
  }), lazy$3.prop(L, "input", () => {
    if (A.pubkey && A.signature)
      return bscript$6.compile([A.signature, A.pubkey]);
  }), lazy$3.prop(L, "witness", () => {
    if (L.input)
      return [];
  }), B.validate) {
    let re = Buffer$1.from([]);
    if (A.address) {
      if (W().version !== J.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (W().hash.length !== 20) throw new TypeError("Invalid address");
      re = W().hash;
    }
    if (A.hash) {
      if (re.length > 0 && !re.equals(A.hash))
        throw new TypeError("Hash mismatch");
      re = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 25 || A.output[0] !== OPS$3.OP_DUP || A.output[1] !== OPS$3.OP_HASH160 || A.output[2] !== 20 || A.output[23] !== OPS$3.OP_EQUALVERIFY || A.output[24] !== OPS$3.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const ie = A.output.slice(3, 23);
      if (re.length > 0 && !re.equals(ie))
        throw new TypeError("Hash mismatch");
      re = ie;
    }
    if (A.pubkey) {
      const ie = bcrypto$5.hash160(A.pubkey);
      if (re.length > 0 && !re.equals(ie))
        throw new TypeError("Hash mismatch");
      re = ie;
    }
    if (A.input) {
      const ie = K();
      if (ie.length !== 2) throw new TypeError("Input is invalid");
      if (!bscript$6.isCanonicalScriptSignature(ie[0]))
        throw new TypeError("Input has invalid signature");
      if (!(0, types_1$4.isPoint)(ie[1]))
        throw new TypeError("Input has invalid pubkey");
      if (A.signature && !A.signature.equals(ie[0]))
        throw new TypeError("Signature mismatch");
      if (A.pubkey && !A.pubkey.equals(ie[1]))
        throw new TypeError("Pubkey mismatch");
      const oe = bcrypto$5.hash160(ie[1]);
      if (re.length > 0 && !re.equals(oe))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(L, A);
}
p2pkh$1.p2pkh = p2pkh;
var p2sh$1 = {};
Object.defineProperty(p2sh$1, "__esModule", { value: !0 });
p2sh$1.p2sh = void 0;
const bcrypto$4 = crypto$1, networks_1$3 = networks, bscript$5 = requireScript(), types_1$3 = types$4, lazy$2 = lazy$7, bs58check = bs58check$2, OPS$2 = bscript$5.OPS;
function p2sh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.redeem && !A.input)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$3.typeforce)(
    {
      network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
      address: types_1$3.typeforce.maybe(types_1$3.typeforce.String),
      hash: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(20)),
      output: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(23)),
      redeem: types_1$3.typeforce.maybe({
        network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
        output: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        witness: types_1$3.typeforce.maybe(
          types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
        )
      }),
      input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
      witness: types_1$3.typeforce.maybe(
        types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
      )
    },
    A
  );
  let W = A.network;
  W || (W = A.redeem && A.redeem.network || networks_1$3.bitcoin);
  const K = { network: W }, J = lazy$2.value(() => {
    const ie = Buffer$1.from(bs58check.decode(A.address)), oe = ie.readUInt8(0), ke = ie.slice(1);
    return { version: oe, hash: ke };
  }), L = lazy$2.value(() => bscript$5.decompile(A.input)), re = lazy$2.value(() => {
    const ie = L(), oe = ie[ie.length - 1];
    return {
      network: W,
      output: oe === OPS$2.OP_FALSE ? Buffer$1.from([]) : oe,
      input: bscript$5.compile(ie.slice(0, -1)),
      witness: A.witness || []
    };
  });
  if (lazy$2.prop(K, "address", () => {
    if (!K.hash) return;
    const ie = Buffer$1.allocUnsafe(21);
    return ie.writeUInt8(K.network.scriptHash, 0), K.hash.copy(ie, 1), bs58check.encode(ie);
  }), lazy$2.prop(K, "hash", () => {
    if (A.output) return A.output.slice(2, 22);
    if (A.address) return J().hash;
    if (K.redeem && K.redeem.output) return bcrypto$4.hash160(K.redeem.output);
  }), lazy$2.prop(K, "output", () => {
    if (K.hash)
      return bscript$5.compile([OPS$2.OP_HASH160, K.hash, OPS$2.OP_EQUAL]);
  }), lazy$2.prop(K, "redeem", () => {
    if (A.input)
      return re();
  }), lazy$2.prop(K, "input", () => {
    if (!(!A.redeem || !A.redeem.input || !A.redeem.output))
      return bscript$5.compile(
        [].concat(bscript$5.decompile(A.redeem.input), A.redeem.output)
      );
  }), lazy$2.prop(K, "witness", () => {
    if (K.redeem && K.redeem.witness) return K.redeem.witness;
    if (K.input) return [];
  }), lazy$2.prop(K, "name", () => {
    const ie = ["p2sh"];
    return K.redeem !== void 0 && K.redeem.name !== void 0 && ie.push(K.redeem.name), ie.join("-");
  }), B.validate) {
    let ie = Buffer$1.from([]);
    if (A.address) {
      if (J().version !== W.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (J().hash.length !== 20) throw new TypeError("Invalid address");
      ie = J().hash;
    }
    if (A.hash) {
      if (ie.length > 0 && !ie.equals(A.hash))
        throw new TypeError("Hash mismatch");
      ie = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 23 || A.output[0] !== OPS$2.OP_HASH160 || A.output[1] !== 20 || A.output[22] !== OPS$2.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const ke = A.output.slice(2, 22);
      if (ie.length > 0 && !ie.equals(ke))
        throw new TypeError("Hash mismatch");
      ie = ke;
    }
    const oe = (ke) => {
      if (ke.output) {
        const ne = bscript$5.decompile(ke.output);
        if (!ne || ne.length < 1)
          throw new TypeError("Redeem.output too short");
        if (ke.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (bscript$5.countNonPushOnlyOPs(ne) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const pe = bcrypto$4.hash160(ke.output);
        if (ie.length > 0 && !ie.equals(pe))
          throw new TypeError("Hash mismatch");
        ie = pe;
      }
      if (ke.input) {
        const ne = ke.input.length > 0, pe = ke.witness && ke.witness.length > 0;
        if (!ne && !pe) throw new TypeError("Empty input");
        if (ne && pe)
          throw new TypeError("Input and witness provided");
        if (ne) {
          const rt = bscript$5.decompile(ke.input);
          if (!bscript$5.isPushOnly(rt))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (A.input) {
      const ke = L();
      if (!ke || ke.length < 1) throw new TypeError("Input too short");
      if (!Buffer$1.isBuffer(re().output))
        throw new TypeError("Input is invalid");
      oe(re());
    }
    if (A.redeem) {
      if (A.redeem.network && A.redeem.network !== W)
        throw new TypeError("Network mismatch");
      if (A.input) {
        const ke = re();
        if (A.redeem.output && !A.redeem.output.equals(ke.output))
          throw new TypeError("Redeem.output mismatch");
        if (A.redeem.input && !A.redeem.input.equals(ke.input))
          throw new TypeError("Redeem.input mismatch");
      }
      oe(A.redeem);
    }
    if (A.witness && A.redeem && A.redeem.witness && !(0, types_1$3.stacksEqual)(A.redeem.witness, A.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(K, A);
}
p2sh$1.p2sh = p2sh;
var p2wpkh$1 = {}, dist = {};
Object.defineProperty(dist, "__esModule", { value: !0 });
dist.bech32m = dist.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let A = 0; A < ALPHABET.length; A++) {
  const B = ALPHABET.charAt(A);
  ALPHABET_MAP[B] = A;
}
function polymodStep(A) {
  const B = A >> 25;
  return (A & 33554431) << 5 ^ -(B >> 0 & 1) & 996825010 ^ -(B >> 1 & 1) & 642813549 ^ -(B >> 2 & 1) & 513874426 ^ -(B >> 3 & 1) & 1027748829 ^ -(B >> 4 & 1) & 705979059;
}
function prefixChk(A) {
  let B = 1;
  for (let W = 0; W < A.length; ++W) {
    const K = A.charCodeAt(W);
    if (K < 33 || K > 126)
      return "Invalid prefix (" + A + ")";
    B = polymodStep(B) ^ K >> 5;
  }
  B = polymodStep(B);
  for (let W = 0; W < A.length; ++W) {
    const K = A.charCodeAt(W);
    B = polymodStep(B) ^ K & 31;
  }
  return B;
}
function convert$2(A, B, W, K) {
  let J = 0, L = 0;
  const re = (1 << W) - 1, ie = [];
  for (let oe = 0; oe < A.length; ++oe)
    for (J = J << B | A[oe], L += B; L >= W; )
      L -= W, ie.push(J >> L & re);
  if (K)
    L > 0 && ie.push(J << W - L & re);
  else {
    if (L >= B)
      return "Excess padding";
    if (J << W - L & re)
      return "Non-zero padding";
  }
  return ie;
}
function toWords(A) {
  return convert$2(A, 8, 5, !0);
}
function fromWordsUnsafe(A) {
  const B = convert$2(A, 5, 8, !1);
  if (Array.isArray(B))
    return B;
}
function fromWords(A) {
  const B = convert$2(A, 5, 8, !1);
  if (Array.isArray(B))
    return B;
  throw new Error(B);
}
function getLibraryFromEncoding(A) {
  let B;
  A === "bech32" ? B = 1 : B = 734539939;
  function W(re, ie, oe) {
    if (oe = oe || 90, re.length + 7 + ie.length > oe)
      throw new TypeError("Exceeds length limit");
    re = re.toLowerCase();
    let ke = prefixChk(re);
    if (typeof ke == "string")
      throw new Error(ke);
    let ne = re + "1";
    for (let pe = 0; pe < ie.length; ++pe) {
      const rt = ie[pe];
      if (rt >> 5)
        throw new Error("Non 5-bit word");
      ke = polymodStep(ke) ^ rt, ne += ALPHABET.charAt(rt);
    }
    for (let pe = 0; pe < 6; ++pe)
      ke = polymodStep(ke);
    ke ^= B;
    for (let pe = 0; pe < 6; ++pe) {
      const rt = ke >> (5 - pe) * 5 & 31;
      ne += ALPHABET.charAt(rt);
    }
    return ne;
  }
  function K(re, ie) {
    if (ie = ie || 90, re.length < 8)
      return re + " too short";
    if (re.length > ie)
      return "Exceeds length limit";
    const oe = re.toLowerCase(), ke = re.toUpperCase();
    if (re !== oe && re !== ke)
      return "Mixed-case string " + re;
    re = oe;
    const ne = re.lastIndexOf("1");
    if (ne === -1)
      return "No separator character for " + re;
    if (ne === 0)
      return "Missing prefix for " + re;
    const pe = re.slice(0, ne), rt = re.slice(ne + 1);
    if (rt.length < 6)
      return "Data too short";
    let nt = prefixChk(pe);
    if (typeof nt == "string")
      return nt;
    const ot = [];
    for (let ut = 0; ut < rt.length; ++ut) {
      const dt = rt.charAt(ut), vt = ALPHABET_MAP[dt];
      if (vt === void 0)
        return "Unknown character " + dt;
      nt = polymodStep(nt) ^ vt, !(ut + 6 >= rt.length) && ot.push(vt);
    }
    return nt !== B ? "Invalid checksum for " + re : { prefix: pe, words: ot };
  }
  function J(re, ie) {
    const oe = K(re, ie);
    if (typeof oe == "object")
      return oe;
  }
  function L(re, ie) {
    const oe = K(re, ie);
    if (typeof oe == "object")
      return oe;
    throw new Error(oe);
  }
  return {
    decodeUnsafe: J,
    decode: L,
    encode: W,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
dist.bech32 = getLibraryFromEncoding("bech32");
dist.bech32m = getLibraryFromEncoding("bech32m");
Object.defineProperty(p2wpkh$1, "__esModule", { value: !0 });
p2wpkh$1.p2wpkh = void 0;
const bcrypto$3 = crypto$1, networks_1$2 = networks, bscript$4 = requireScript(), types_1$2 = types$4, lazy$1 = lazy$7, bech32_1$1 = dist, OPS$1 = bscript$4.OPS, EMPTY_BUFFER$2 = Buffer$1.alloc(0);
function p2wpkh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.pubkey && !A.witness)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$2.typeforce)(
    {
      address: types_1$2.typeforce.maybe(types_1$2.typeforce.String),
      hash: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(20)),
      input: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(0)),
      network: types_1$2.typeforce.maybe(types_1$2.typeforce.Object),
      output: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(22)),
      pubkey: types_1$2.typeforce.maybe(types_1$2.isPoint),
      signature: types_1$2.typeforce.maybe(bscript$4.isCanonicalScriptSignature),
      witness: types_1$2.typeforce.maybe(
        types_1$2.typeforce.arrayOf(types_1$2.typeforce.Buffer)
      )
    },
    A
  );
  const W = lazy$1.value(() => {
    const L = bech32_1$1.bech32.decode(A.address), re = L.words.shift(), ie = bech32_1$1.bech32.fromWords(L.words);
    return {
      version: re,
      prefix: L.prefix,
      data: Buffer$1.from(ie)
    };
  }), K = A.network || networks_1$2.bitcoin, J = { name: "p2wpkh", network: K };
  if (lazy$1.prop(J, "address", () => {
    if (!J.hash) return;
    const L = bech32_1$1.bech32.toWords(J.hash);
    return L.unshift(0), bech32_1$1.bech32.encode(K.bech32, L);
  }), lazy$1.prop(J, "hash", () => {
    if (A.output) return A.output.slice(2, 22);
    if (A.address) return W().data;
    if (A.pubkey || J.pubkey) return bcrypto$3.hash160(A.pubkey || J.pubkey);
  }), lazy$1.prop(J, "output", () => {
    if (J.hash)
      return bscript$4.compile([OPS$1.OP_0, J.hash]);
  }), lazy$1.prop(J, "pubkey", () => {
    if (A.pubkey) return A.pubkey;
    if (A.witness)
      return A.witness[1];
  }), lazy$1.prop(J, "signature", () => {
    if (A.witness)
      return A.witness[0];
  }), lazy$1.prop(J, "input", () => {
    if (J.witness)
      return EMPTY_BUFFER$2;
  }), lazy$1.prop(J, "witness", () => {
    if (A.pubkey && A.signature)
      return [A.signature, A.pubkey];
  }), B.validate) {
    let L = Buffer$1.from([]);
    if (A.address) {
      if (K && K.bech32 !== W().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (W().version !== 0)
        throw new TypeError("Invalid address version");
      if (W().data.length !== 20)
        throw new TypeError("Invalid address data");
      L = W().data;
    }
    if (A.hash) {
      if (L.length > 0 && !L.equals(A.hash))
        throw new TypeError("Hash mismatch");
      L = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 22 || A.output[0] !== OPS$1.OP_0 || A.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (L.length > 0 && !L.equals(A.output.slice(2)))
        throw new TypeError("Hash mismatch");
      L = A.output.slice(2);
    }
    if (A.pubkey) {
      const re = bcrypto$3.hash160(A.pubkey);
      if (L.length > 0 && !L.equals(re))
        throw new TypeError("Hash mismatch");
      if (L = re, !(0, types_1$2.isPoint)(A.pubkey) || A.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (A.witness) {
      if (A.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!bscript$4.isCanonicalScriptSignature(A.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!(0, types_1$2.isPoint)(A.witness[1]) || A.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (A.signature && !A.signature.equals(A.witness[0]))
        throw new TypeError("Signature mismatch");
      if (A.pubkey && !A.pubkey.equals(A.witness[1]))
        throw new TypeError("Pubkey mismatch");
      const re = bcrypto$3.hash160(A.witness[1]);
      if (L.length > 0 && !L.equals(re))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(J, A);
}
p2wpkh$1.p2wpkh = p2wpkh;
var p2wsh$1 = {};
Object.defineProperty(p2wsh$1, "__esModule", { value: !0 });
p2wsh$1.p2wsh = void 0;
const bcrypto$2 = crypto$1, networks_1$1 = networks, bscript$3 = requireScript(), types_1$1 = types$4, lazy = lazy$7, bech32_1 = dist, OPS = bscript$3.OPS, EMPTY_BUFFER$1 = Buffer$1.alloc(0);
function chunkHasUncompressedPubkey(A) {
  return !!(Buffer$1.isBuffer(A) && A.length === 65 && A[0] === 4 && (0, types_1$1.isPoint)(A));
}
function p2wsh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.redeem && !A.witness)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$1.typeforce)(
    {
      network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
      address: types_1$1.typeforce.maybe(types_1$1.typeforce.String),
      hash: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(32)),
      output: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(34)),
      redeem: types_1$1.typeforce.maybe({
        input: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
        output: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        witness: types_1$1.typeforce.maybe(
          types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
        )
      }),
      input: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(0)),
      witness: types_1$1.typeforce.maybe(
        types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
      )
    },
    A
  );
  const W = lazy.value(() => {
    const re = bech32_1.bech32.decode(A.address), ie = re.words.shift(), oe = bech32_1.bech32.fromWords(re.words);
    return {
      version: ie,
      prefix: re.prefix,
      data: Buffer$1.from(oe)
    };
  }), K = lazy.value(() => bscript$3.decompile(A.redeem.input));
  let J = A.network;
  J || (J = A.redeem && A.redeem.network || networks_1$1.bitcoin);
  const L = { network: J };
  if (lazy.prop(L, "address", () => {
    if (!L.hash) return;
    const re = bech32_1.bech32.toWords(L.hash);
    return re.unshift(0), bech32_1.bech32.encode(J.bech32, re);
  }), lazy.prop(L, "hash", () => {
    if (A.output) return A.output.slice(2);
    if (A.address) return W().data;
    if (L.redeem && L.redeem.output) return bcrypto$2.sha256(L.redeem.output);
  }), lazy.prop(L, "output", () => {
    if (L.hash)
      return bscript$3.compile([OPS.OP_0, L.hash]);
  }), lazy.prop(L, "redeem", () => {
    if (A.witness)
      return {
        output: A.witness[A.witness.length - 1],
        input: EMPTY_BUFFER$1,
        witness: A.witness.slice(0, -1)
      };
  }), lazy.prop(L, "input", () => {
    if (L.witness)
      return EMPTY_BUFFER$1;
  }), lazy.prop(L, "witness", () => {
    if (A.redeem && A.redeem.input && A.redeem.input.length > 0 && A.redeem.output && A.redeem.output.length > 0) {
      const re = bscript$3.toStack(K());
      return L.redeem = Object.assign({ witness: re }, A.redeem), L.redeem.input = EMPTY_BUFFER$1, [].concat(re, A.redeem.output);
    }
    if (A.redeem && A.redeem.output && A.redeem.witness)
      return [].concat(A.redeem.witness, A.redeem.output);
  }), lazy.prop(L, "name", () => {
    const re = ["p2wsh"];
    return L.redeem !== void 0 && L.redeem.name !== void 0 && re.push(L.redeem.name), re.join("-");
  }), B.validate) {
    let re = Buffer$1.from([]);
    if (A.address) {
      if (W().prefix !== J.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (W().version !== 0)
        throw new TypeError("Invalid address version");
      if (W().data.length !== 32)
        throw new TypeError("Invalid address data");
      re = W().data;
    }
    if (A.hash) {
      if (re.length > 0 && !re.equals(A.hash))
        throw new TypeError("Hash mismatch");
      re = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 34 || A.output[0] !== OPS.OP_0 || A.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const ie = A.output.slice(2);
      if (re.length > 0 && !re.equals(ie))
        throw new TypeError("Hash mismatch");
      re = ie;
    }
    if (A.redeem) {
      if (A.redeem.network && A.redeem.network !== J)
        throw new TypeError("Network mismatch");
      if (A.redeem.input && A.redeem.input.length > 0 && A.redeem.witness && A.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (A.redeem.output) {
        const ie = bscript$3.decompile(A.redeem.output);
        if (!ie || ie.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (A.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (bscript$3.countNonPushOnlyOPs(ie) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const oe = bcrypto$2.sha256(A.redeem.output);
        if (re.length > 0 && !re.equals(oe))
          throw new TypeError("Hash mismatch");
        re = oe;
      }
      if (A.redeem.input && !bscript$3.isPushOnly(K()))
        throw new TypeError("Non push-only scriptSig");
      if (A.witness && A.redeem.witness && !(0, types_1$1.stacksEqual)(A.witness, A.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (A.redeem.input && K().some(chunkHasUncompressedPubkey) || A.redeem.output && (bscript$3.decompile(A.redeem.output) || []).some(
        chunkHasUncompressedPubkey
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (A.witness && A.witness.length > 0) {
      const ie = A.witness[A.witness.length - 1];
      if (A.redeem && A.redeem.output && !A.redeem.output.equals(ie))
        throw new TypeError("Witness and redeem.output mismatch");
      if (A.witness.some(chunkHasUncompressedPubkey) || (bscript$3.decompile(ie) || []).some(chunkHasUncompressedPubkey))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(L, A);
}
p2wsh$1.p2wsh = p2wsh;
var p2tr = {}, ecc_lib = {};
Object.defineProperty(ecc_lib, "__esModule", { value: !0 });
ecc_lib.getEccLib = ecc_lib.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(A) {
  A ? A !== _ECCLIB_CACHE.eccLib && (verifyEcc(A), _ECCLIB_CACHE.eccLib = A) : _ECCLIB_CACHE.eccLib = A;
}
ecc_lib.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return _ECCLIB_CACHE.eccLib;
}
ecc_lib.getEccLib = getEccLib;
const h = (A) => Buffer$1.from(A, "hex");
function verifyEcc(A) {
  assert(typeof A.isXOnlyPoint == "function"), assert(
    A.isXOnlyPoint(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    A.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), assert(
    A.isXOnlyPoint(
      h("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), assert(
    A.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), assert(
    !A.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), assert(
    !A.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), assert(typeof A.xOnlyPointAddTweak == "function"), tweakAddVectors.forEach((B) => {
    const W = A.xOnlyPointAddTweak(h(B.pubkey), h(B.tweak));
    B.result === null ? assert(W === null) : (assert(W !== null), assert(W.parity === B.parity), assert(Buffer$1.from(W.xOnlyPubkey).equals(h(B.result))));
  });
}
function assert(A) {
  if (!A) throw new Error("ecc library invalid");
}
const tweakAddVectors = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];
var bip341 = {}, bufferutils = {}, Buffer = safeBufferExports.Buffer, MAX_SAFE_INTEGER$1 = 9007199254740991;
function checkUInt53$1(A) {
  if (A < 0 || A > MAX_SAFE_INTEGER$1 || A % 1 !== 0) throw new RangeError("value out of range");
}
function encode$f(A, B, W) {
  if (checkUInt53$1(A), B || (B = Buffer.allocUnsafe(encodingLength$1(A))), !Buffer.isBuffer(B)) throw new TypeError("buffer must be a Buffer instance");
  return W || (W = 0), A < 253 ? (B.writeUInt8(A, W), encode$f.bytes = 1) : A <= 65535 ? (B.writeUInt8(253, W), B.writeUInt16LE(A, W + 1), encode$f.bytes = 3) : A <= 4294967295 ? (B.writeUInt8(254, W), B.writeUInt32LE(A, W + 1), encode$f.bytes = 5) : (B.writeUInt8(255, W), B.writeUInt32LE(A >>> 0, W + 1), B.writeUInt32LE(A / 4294967296 | 0, W + 5), encode$f.bytes = 9), B;
}
function decode$e(A, B) {
  if (!Buffer.isBuffer(A)) throw new TypeError("buffer must be a Buffer instance");
  B || (B = 0);
  var W = A.readUInt8(B);
  if (W < 253)
    return decode$e.bytes = 1, W;
  if (W === 253)
    return decode$e.bytes = 3, A.readUInt16LE(B + 1);
  if (W === 254)
    return decode$e.bytes = 5, A.readUInt32LE(B + 1);
  decode$e.bytes = 9;
  var K = A.readUInt32LE(B + 1), J = A.readUInt32LE(B + 5), L = J * 4294967296 + K;
  return checkUInt53$1(L), L;
}
function encodingLength$1(A) {
  return checkUInt53$1(A), A < 253 ? 1 : A <= 65535 ? 3 : A <= 4294967295 ? 5 : 9;
}
var varuintBitcoin = { encode: encode$f, decode: decode$e, encodingLength: encodingLength$1 };
Object.defineProperty(bufferutils, "__esModule", { value: !0 });
bufferutils.BufferReader = bufferutils.BufferWriter = bufferutils.cloneBuffer = bufferutils.reverseBuffer = bufferutils.writeUInt64LE = bufferutils.readUInt64LE = bufferutils.varuint = void 0;
const types$2 = types$4, { typeforce: typeforce$2 } = types$2, varuint$7 = varuintBitcoin;
bufferutils.varuint = varuint$7;
function verifuint$1(A, B) {
  if (typeof A != "number")
    throw new Error("cannot write a non-number as a number");
  if (A < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (A > B) throw new Error("RangeError: value out of range");
  if (Math.floor(A) !== A)
    throw new Error("value has a fractional component");
}
function readUInt64LE$1(A, B) {
  const W = A.readUInt32LE(B);
  let K = A.readUInt32LE(B + 4);
  return K *= 4294967296, verifuint$1(K + W, 9007199254740991), K + W;
}
bufferutils.readUInt64LE = readUInt64LE$1;
function writeUInt64LE$1(A, B, W) {
  return verifuint$1(B, 9007199254740991), A.writeInt32LE(B & -1, W), A.writeUInt32LE(Math.floor(B / 4294967296), W + 4), W + 8;
}
bufferutils.writeUInt64LE = writeUInt64LE$1;
function reverseBuffer$1(A) {
  if (A.length < 1) return A;
  let B = A.length - 1, W = 0;
  for (let K = 0; K < A.length / 2; K++)
    W = A[K], A[K] = A[B], A[B] = W, B--;
  return A;
}
bufferutils.reverseBuffer = reverseBuffer$1;
function cloneBuffer(A) {
  const B = Buffer$1.allocUnsafe(A.length);
  return A.copy(B), B;
}
bufferutils.cloneBuffer = cloneBuffer;
class BufferWriter {
  static withCapacity(B) {
    return new BufferWriter(Buffer$1.alloc(B));
  }
  constructor(B, W = 0) {
    this.buffer = B, this.offset = W, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [B, W]);
  }
  writeUInt8(B) {
    this.offset = this.buffer.writeUInt8(B, this.offset);
  }
  writeInt32(B) {
    this.offset = this.buffer.writeInt32LE(B, this.offset);
  }
  writeUInt32(B) {
    this.offset = this.buffer.writeUInt32LE(B, this.offset);
  }
  writeUInt64(B) {
    this.offset = writeUInt64LE$1(this.buffer, B, this.offset);
  }
  writeVarInt(B) {
    varuint$7.encode(B, this.buffer, this.offset), this.offset += varuint$7.encode.bytes;
  }
  writeSlice(B) {
    if (this.buffer.length < this.offset + B.length)
      throw new Error("Cannot write slice out of bounds");
    this.offset += B.copy(this.buffer, this.offset);
  }
  writeVarSlice(B) {
    this.writeVarInt(B.length), this.writeSlice(B);
  }
  writeVector(B) {
    this.writeVarInt(B.length), B.forEach((W) => this.writeVarSlice(W));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
bufferutils.BufferWriter = BufferWriter;
class BufferReader {
  constructor(B, W = 0) {
    this.buffer = B, this.offset = W, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [B, W]);
  }
  readUInt8() {
    const B = this.buffer.readUInt8(this.offset);
    return this.offset++, B;
  }
  readInt32() {
    const B = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, B;
  }
  readUInt32() {
    const B = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, B;
  }
  readUInt64() {
    const B = readUInt64LE$1(this.buffer, this.offset);
    return this.offset += 8, B;
  }
  readVarInt() {
    const B = varuint$7.decode(this.buffer, this.offset);
    return this.offset += varuint$7.decode.bytes, B;
  }
  readSlice(B) {
    if (this.buffer.length < this.offset + B)
      throw new Error("Cannot read slice out of bounds");
    const W = this.buffer.slice(this.offset, this.offset + B);
    return this.offset += B, W;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const B = this.readVarInt(), W = [];
    for (let K = 0; K < B; K++) W.push(this.readVarSlice());
    return W;
  }
}
bufferutils.BufferReader = BufferReader;
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.tweakKey = A.tapTweakHash = A.tapleafHash = A.findScriptPath = A.toHashTree = A.rootHashFromPath = A.MAX_TAPTREE_DEPTH = A.LEAF_VERSION_TAPSCRIPT = void 0;
  const B = require$$0$1, W = ecc_lib, K = crypto$1, J = bufferutils, L = types$4;
  A.LEAF_VERSION_TAPSCRIPT = 192, A.MAX_TAPTREE_DEPTH = 128;
  const re = (ut) => "left" in ut && "right" in ut;
  function ie(ut, dt) {
    if (ut.length < 33)
      throw new TypeError(
        `The control-block length is too small. Got ${ut.length}, expected min 33.`
      );
    const vt = (ut.length - 33) / 32;
    let pt = dt;
    for (let mt = 0; mt < vt; mt++) {
      const gt = ut.slice(33 + 32 * mt, 65 + 32 * mt);
      pt.compare(gt) < 0 ? pt = nt(pt, gt) : pt = nt(gt, pt);
    }
    return pt;
  }
  A.rootHashFromPath = ie;
  function oe(ut) {
    if ((0, L.isTapleaf)(ut))
      return { hash: ne(ut) };
    const dt = [oe(ut[0]), oe(ut[1])];
    dt.sort((mt, gt) => mt.hash.compare(gt.hash));
    const [vt, pt] = dt;
    return {
      hash: nt(vt.hash, pt.hash),
      left: vt,
      right: pt
    };
  }
  A.toHashTree = oe;
  function ke(ut, dt) {
    if (re(ut)) {
      const vt = ke(ut.left, dt);
      if (vt !== void 0) return [...vt, ut.right.hash];
      const pt = ke(ut.right, dt);
      if (pt !== void 0) return [...pt, ut.left.hash];
    } else if (ut.hash.equals(dt))
      return [];
  }
  A.findScriptPath = ke;
  function ne(ut) {
    const dt = ut.version || A.LEAF_VERSION_TAPSCRIPT;
    return K.taggedHash(
      "TapLeaf",
      B.Buffer.concat([
        B.Buffer.from([dt]),
        ot(ut.output)
      ])
    );
  }
  A.tapleafHash = ne;
  function pe(ut, dt) {
    return K.taggedHash(
      "TapTweak",
      B.Buffer.concat(dt ? [ut, dt] : [ut])
    );
  }
  A.tapTweakHash = pe;
  function rt(ut, dt) {
    if (!B.Buffer.isBuffer(ut) || ut.length !== 32 || dt && dt.length !== 32) return null;
    const vt = pe(ut, dt), pt = (0, W.getEccLib)().xOnlyPointAddTweak(ut, vt);
    return !pt || pt.xOnlyPubkey === null ? null : {
      parity: pt.parity,
      x: B.Buffer.from(pt.xOnlyPubkey)
    };
  }
  A.tweakKey = rt;
  function nt(ut, dt) {
    return K.taggedHash("TapBranch", B.Buffer.concat([ut, dt]));
  }
  function ot(ut) {
    const dt = J.varuint.encodingLength(ut.length), vt = B.Buffer.allocUnsafe(dt);
    return J.varuint.encode(ut.length, vt), B.Buffer.concat([vt, ut]);
  }
})(bip341);
var hasRequiredP2tr;
function requireP2tr() {
  if (hasRequiredP2tr) return p2tr;
  hasRequiredP2tr = 1, Object.defineProperty(p2tr, "__esModule", { value: !0 }), p2tr.p2tr = void 0;
  const A = require$$0$1, B = networks, W = requireScript(), K = types$4, J = ecc_lib, L = bip341, re = lazy$7, ie = dist, oe = requireAddress(), ke = W.OPS, ne = 1, pe = 80;
  function rt(nt, ot) {
    if (!nt.address && !nt.output && !nt.pubkey && !nt.internalPubkey && !(nt.witness && nt.witness.length > 1))
      throw new TypeError("Not enough data");
    ot = Object.assign({ validate: !0 }, ot || {}), (0, K.typeforce)(
      {
        address: K.typeforce.maybe(K.typeforce.String),
        input: K.typeforce.maybe(K.typeforce.BufferN(0)),
        network: K.typeforce.maybe(K.typeforce.Object),
        output: K.typeforce.maybe(K.typeforce.BufferN(34)),
        internalPubkey: K.typeforce.maybe(K.typeforce.BufferN(32)),
        hash: K.typeforce.maybe(K.typeforce.BufferN(32)),
        pubkey: K.typeforce.maybe(K.typeforce.BufferN(32)),
        signature: K.typeforce.maybe(
          K.typeforce.anyOf(
            K.typeforce.BufferN(64),
            K.typeforce.BufferN(65)
          )
        ),
        witness: K.typeforce.maybe(
          K.typeforce.arrayOf(K.typeforce.Buffer)
        ),
        scriptTree: K.typeforce.maybe(K.isTaptree),
        redeem: K.typeforce.maybe({
          output: K.typeforce.maybe(K.typeforce.Buffer),
          redeemVersion: K.typeforce.maybe(K.typeforce.Number),
          witness: K.typeforce.maybe(
            K.typeforce.arrayOf(K.typeforce.Buffer)
          )
        }),
        redeemVersion: K.typeforce.maybe(K.typeforce.Number)
      },
      nt
    );
    const ut = re.value(() => (0, oe.fromBech32)(nt.address)), dt = re.value(() => {
      if (!(!nt.witness || !nt.witness.length))
        return nt.witness.length >= 2 && nt.witness[nt.witness.length - 1][0] === pe ? nt.witness.slice(0, -1) : nt.witness.slice();
    }), vt = re.value(() => {
      if (nt.scriptTree) return (0, L.toHashTree)(nt.scriptTree);
      if (nt.hash) return { hash: nt.hash };
    }), pt = nt.network || B.bitcoin, mt = { name: "p2tr", network: pt };
    if (re.prop(mt, "address", () => {
      if (!mt.pubkey) return;
      const gt = ie.bech32m.toWords(mt.pubkey);
      return gt.unshift(ne), ie.bech32m.encode(pt.bech32, gt);
    }), re.prop(mt, "hash", () => {
      const gt = vt();
      if (gt) return gt.hash;
      const Pt = dt();
      if (Pt && Pt.length > 1) {
        const xt = Pt[Pt.length - 1], Nt = xt[0] & K.TAPLEAF_VERSION_MASK, Et = Pt[Pt.length - 2], bt = (0, L.tapleafHash)({
          output: Et,
          version: Nt
        });
        return (0, L.rootHashFromPath)(xt, bt);
      }
      return null;
    }), re.prop(mt, "output", () => {
      if (mt.pubkey)
        return W.compile([ke.OP_1, mt.pubkey]);
    }), re.prop(mt, "redeemVersion", () => nt.redeemVersion ? nt.redeemVersion : nt.redeem && nt.redeem.redeemVersion !== void 0 && nt.redeem.redeemVersion !== null ? nt.redeem.redeemVersion : L.LEAF_VERSION_TAPSCRIPT), re.prop(mt, "redeem", () => {
      const gt = dt();
      if (!(!gt || gt.length < 2))
        return {
          output: gt[gt.length - 2],
          witness: gt.slice(0, -2),
          redeemVersion: gt[gt.length - 1][0] & K.TAPLEAF_VERSION_MASK
        };
    }), re.prop(mt, "pubkey", () => {
      if (nt.pubkey) return nt.pubkey;
      if (nt.output) return nt.output.slice(2);
      if (nt.address) return ut().data;
      if (mt.internalPubkey) {
        const gt = (0, L.tweakKey)(mt.internalPubkey, mt.hash);
        if (gt) return gt.x;
      }
    }), re.prop(mt, "internalPubkey", () => {
      if (nt.internalPubkey) return nt.internalPubkey;
      const gt = dt();
      if (gt && gt.length > 1)
        return gt[gt.length - 1].slice(1, 33);
    }), re.prop(mt, "signature", () => {
      if (nt.signature) return nt.signature;
      const gt = dt();
      if (!(!gt || gt.length !== 1))
        return gt[0];
    }), re.prop(mt, "witness", () => {
      if (nt.witness) return nt.witness;
      const gt = vt();
      if (gt && nt.redeem && nt.redeem.output && nt.internalPubkey) {
        const Pt = (0, L.tapleafHash)({
          output: nt.redeem.output,
          version: mt.redeemVersion
        }), xt = (0, L.findScriptPath)(gt, Pt);
        if (!xt) return;
        const Nt = (0, L.tweakKey)(nt.internalPubkey, gt.hash);
        if (!Nt) return;
        const Et = A.Buffer.concat(
          [
            A.Buffer.from([mt.redeemVersion | Nt.parity]),
            nt.internalPubkey
          ].concat(xt)
        );
        return [nt.redeem.output, Et];
      }
      if (nt.signature) return [nt.signature];
    }), ot.validate) {
      let gt = A.Buffer.from([]);
      if (nt.address) {
        if (pt && pt.bech32 !== ut().prefix)
          throw new TypeError("Invalid prefix or Network mismatch");
        if (ut().version !== ne)
          throw new TypeError("Invalid address version");
        if (ut().data.length !== 32)
          throw new TypeError("Invalid address data");
        gt = ut().data;
      }
      if (nt.pubkey) {
        if (gt.length > 0 && !gt.equals(nt.pubkey))
          throw new TypeError("Pubkey mismatch");
        gt = nt.pubkey;
      }
      if (nt.output) {
        if (nt.output.length !== 34 || nt.output[0] !== ke.OP_1 || nt.output[1] !== 32)
          throw new TypeError("Output is invalid");
        if (gt.length > 0 && !gt.equals(nt.output.slice(2)))
          throw new TypeError("Pubkey mismatch");
        gt = nt.output.slice(2);
      }
      if (nt.internalPubkey) {
        const Nt = (0, L.tweakKey)(nt.internalPubkey, mt.hash);
        if (gt.length > 0 && !gt.equals(Nt.x))
          throw new TypeError("Pubkey mismatch");
        gt = Nt.x;
      }
      if (gt && gt.length && !(0, J.getEccLib)().isXOnlyPoint(gt))
        throw new TypeError("Invalid pubkey for p2tr");
      const Pt = vt();
      if (nt.hash && Pt && !nt.hash.equals(Pt.hash))
        throw new TypeError("Hash mismatch");
      if (nt.redeem && nt.redeem.output && Pt) {
        const Nt = (0, L.tapleafHash)({
          output: nt.redeem.output,
          version: mt.redeemVersion
        });
        if (!(0, L.findScriptPath)(Pt, Nt))
          throw new TypeError("Redeem script not in tree");
      }
      const xt = dt();
      if (nt.redeem && mt.redeem) {
        if (nt.redeem.redeemVersion && nt.redeem.redeemVersion !== mt.redeem.redeemVersion)
          throw new TypeError("Redeem.redeemVersion and witness mismatch");
        if (nt.redeem.output) {
          if (W.decompile(nt.redeem.output).length === 0)
            throw new TypeError("Redeem.output is invalid");
          if (mt.redeem.output && !nt.redeem.output.equals(mt.redeem.output))
            throw new TypeError("Redeem.output and witness mismatch");
        }
        if (nt.redeem.witness && mt.redeem.witness && !(0, K.stacksEqual)(nt.redeem.witness, mt.redeem.witness))
          throw new TypeError("Redeem.witness and witness mismatch");
      }
      if (xt && xt.length)
        if (xt.length === 1) {
          if (nt.signature && !nt.signature.equals(xt[0]))
            throw new TypeError("Signature mismatch");
        } else {
          const Nt = xt[xt.length - 1];
          if (Nt.length < 33)
            throw new TypeError(
              `The control-block length is too small. Got ${Nt.length}, expected min 33.`
            );
          if ((Nt.length - 33) % 32 !== 0)
            throw new TypeError(
              `The control-block length of ${Nt.length} is incorrect!`
            );
          const Et = (Nt.length - 33) / 32;
          if (Et > 128)
            throw new TypeError(
              `The script path is too long. Got ${Et}, expected max 128.`
            );
          const bt = Nt.slice(1, 33);
          if (nt.internalPubkey && !nt.internalPubkey.equals(bt))
            throw new TypeError("Internal pubkey mismatch");
          if (!(0, J.getEccLib)().isXOnlyPoint(bt))
            throw new TypeError("Invalid internalPubkey for p2tr witness");
          const Bt = Nt[0] & K.TAPLEAF_VERSION_MASK, wt = xt[xt.length - 2], st = (0, L.tapleafHash)({
            output: wt,
            version: Bt
          }), Oe = (0, L.rootHashFromPath)(Nt, st), V = (0, L.tweakKey)(bt, Oe);
          if (!V)
            throw new TypeError("Invalid outputKey for p2tr witness");
          if (gt.length && !gt.equals(V.x))
            throw new TypeError("Pubkey mismatch for p2tr witness");
          if (V.parity !== (Nt[0] & 1))
            throw new Error("Incorrect parity");
        }
    }
    return Object.assign(mt, nt);
  }
  return p2tr.p2tr = rt, p2tr;
}
var hasRequiredPayments;
function requirePayments() {
  return hasRequiredPayments || (hasRequiredPayments = 1, function(A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.p2tr = A.p2wsh = A.p2wpkh = A.p2sh = A.p2pkh = A.p2pk = A.p2ms = A.embed = void 0;
    const B = embed;
    Object.defineProperty(A, "embed", {
      enumerable: !0,
      get: function() {
        return B.p2data;
      }
    });
    const W = p2ms$1;
    Object.defineProperty(A, "p2ms", {
      enumerable: !0,
      get: function() {
        return W.p2ms;
      }
    });
    const K = p2pk$1;
    Object.defineProperty(A, "p2pk", {
      enumerable: !0,
      get: function() {
        return K.p2pk;
      }
    });
    const J = p2pkh$1;
    Object.defineProperty(A, "p2pkh", {
      enumerable: !0,
      get: function() {
        return J.p2pkh;
      }
    });
    const L = p2sh$1;
    Object.defineProperty(A, "p2sh", {
      enumerable: !0,
      get: function() {
        return L.p2sh;
      }
    });
    const re = p2wpkh$1;
    Object.defineProperty(A, "p2wpkh", {
      enumerable: !0,
      get: function() {
        return re.p2wpkh;
      }
    });
    const ie = p2wsh$1;
    Object.defineProperty(A, "p2wsh", {
      enumerable: !0,
      get: function() {
        return ie.p2wsh;
      }
    });
    const oe = requireP2tr();
    Object.defineProperty(A, "p2tr", {
      enumerable: !0,
      get: function() {
        return oe.p2tr;
      }
    });
  }(payments$2)), payments$2;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return address;
  hasRequiredAddress = 1, Object.defineProperty(address, "__esModule", { value: !0 }), address.toOutputScript = address.fromOutputScript = address.toBech32 = address.toBase58Check = address.fromBech32 = address.fromBase58Check = void 0;
  const A = networks, B = requirePayments(), W = requireScript(), K = types$4, J = dist, L = bs58check$2, re = 40, ie = 2, oe = 16, ke = 2, ne = 80, pe = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
  function rt(mt, gt) {
    const Pt = mt.slice(2);
    if (Pt.length < ie || Pt.length > re)
      throw new TypeError("Invalid program length for segwit address");
    const xt = mt[0] - ne;
    if (xt < ke || xt > oe)
      throw new TypeError("Invalid version for segwit address");
    if (mt[1] !== Pt.length)
      throw new TypeError("Invalid script for segwit address");
    return console.warn(pe), dt(Pt, xt, gt.bech32);
  }
  function nt(mt) {
    const gt = Buffer$1.from(L.decode(mt));
    if (gt.length < 21) throw new TypeError(mt + " is too short");
    if (gt.length > 21) throw new TypeError(mt + " is too long");
    const Pt = gt.readUInt8(0), xt = gt.slice(1);
    return { version: Pt, hash: xt };
  }
  address.fromBase58Check = nt;
  function ot(mt) {
    let gt, Pt;
    try {
      gt = J.bech32.decode(mt);
    } catch {
    }
    if (gt) {
      if (Pt = gt.words[0], Pt !== 0) throw new TypeError(mt + " uses wrong encoding");
    } else if (gt = J.bech32m.decode(mt), Pt = gt.words[0], Pt === 0) throw new TypeError(mt + " uses wrong encoding");
    const xt = J.bech32.fromWords(gt.words.slice(1));
    return {
      version: Pt,
      prefix: gt.prefix,
      data: Buffer$1.from(xt)
    };
  }
  address.fromBech32 = ot;
  function ut(mt, gt) {
    (0, K.typeforce)(
      (0, K.tuple)(K.Hash160bit, K.UInt8),
      arguments
    );
    const Pt = Buffer$1.allocUnsafe(21);
    return Pt.writeUInt8(gt, 0), mt.copy(Pt, 1), L.encode(Pt);
  }
  address.toBase58Check = ut;
  function dt(mt, gt, Pt) {
    const xt = J.bech32.toWords(mt);
    return xt.unshift(gt), gt === 0 ? J.bech32.encode(Pt, xt) : J.bech32m.encode(Pt, xt);
  }
  address.toBech32 = dt;
  function vt(mt, gt) {
    gt = gt || A.bitcoin;
    try {
      return B.p2pkh({ output: mt, network: gt }).address;
    } catch {
    }
    try {
      return B.p2sh({ output: mt, network: gt }).address;
    } catch {
    }
    try {
      return B.p2wpkh({ output: mt, network: gt }).address;
    } catch {
    }
    try {
      return B.p2wsh({ output: mt, network: gt }).address;
    } catch {
    }
    try {
      return B.p2tr({ output: mt, network: gt }).address;
    } catch {
    }
    try {
      return rt(mt, gt);
    } catch {
    }
    throw new Error(W.toASM(mt) + " has no matching Address");
  }
  address.fromOutputScript = vt;
  function pt(mt, gt) {
    gt = gt || A.bitcoin;
    let Pt, xt;
    try {
      Pt = nt(mt);
    } catch {
    }
    if (Pt) {
      if (Pt.version === gt.pubKeyHash)
        return B.p2pkh({ hash: Pt.hash }).output;
      if (Pt.version === gt.scriptHash)
        return B.p2sh({ hash: Pt.hash }).output;
    } else {
      try {
        xt = ot(mt);
      } catch {
      }
      if (xt) {
        if (xt.prefix !== gt.bech32)
          throw new Error(mt + " has an invalid prefix");
        if (xt.version === 0) {
          if (xt.data.length === 20)
            return B.p2wpkh({ hash: xt.data }).output;
          if (xt.data.length === 32)
            return B.p2wsh({ hash: xt.data }).output;
        } else if (xt.version === 1) {
          if (xt.data.length === 32)
            return B.p2tr({ pubkey: xt.data }).output;
        } else if (xt.version >= ke && xt.version <= oe && xt.data.length >= ie && xt.data.length <= re)
          return console.warn(pe), W.compile([
            xt.version + ne,
            xt.data
          ]);
      }
    }
    throw new Error(mt + " has no matching Script");
  }
  return address.toOutputScript = pt, address;
}
var block = {}, merkle = {};
Object.defineProperty(merkle, "__esModule", { value: !0 });
merkle.fastMerkleRoot = void 0;
function fastMerkleRoot(A, B) {
  if (!Array.isArray(A)) throw TypeError("Expected values Array");
  if (typeof B != "function")
    throw TypeError("Expected digest Function");
  let W = A.length;
  const K = A.concat();
  for (; W > 1; ) {
    let J = 0;
    for (let L = 0; L < W; L += 2, ++J) {
      const re = K[L], ie = L + 1 === W ? re : K[L + 1], oe = Buffer$1.concat([re, ie]);
      K[J] = B(oe);
    }
    W = J;
  }
  return K[0];
}
merkle.fastMerkleRoot = fastMerkleRoot;
var transaction = {};
Object.defineProperty(transaction, "__esModule", { value: !0 });
transaction.Transaction = void 0;
const bufferutils_1$2 = bufferutils, bcrypto$1 = crypto$1, bscript$2 = requireScript(), script_1 = requireScript(), types$1 = types$4, { typeforce: typeforce$1 } = types$1;
function varSliceSize(A) {
  const B = A.length;
  return bufferutils_1$2.varuint.encodingLength(B) + B;
}
function vectorSize(A) {
  const B = A.length;
  return bufferutils_1$2.varuint.encodingLength(B) + A.reduce((W, K) => W + varSliceSize(K), 0);
}
const EMPTY_BUFFER = Buffer$1.allocUnsafe(0), EMPTY_WITNESS = [], ZERO = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000000",
  "hex"
), ONE = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000001",
  "hex"
), VALUE_UINT64_MAX = Buffer$1.from("ffffffffffffffff", "hex"), BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX
};
function isOutput(A) {
  return A.value !== void 0;
}
class Transaction {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static fromBuffer(B, W) {
    const K = new bufferutils_1$2.BufferReader(B), J = new Transaction();
    J.version = K.readInt32();
    const L = K.readUInt8(), re = K.readUInt8();
    let ie = !1;
    L === Transaction.ADVANCED_TRANSACTION_MARKER && re === Transaction.ADVANCED_TRANSACTION_FLAG ? ie = !0 : K.offset -= 2;
    const oe = K.readVarInt();
    for (let ne = 0; ne < oe; ++ne)
      J.ins.push({
        hash: K.readSlice(32),
        index: K.readUInt32(),
        script: K.readVarSlice(),
        sequence: K.readUInt32(),
        witness: EMPTY_WITNESS
      });
    const ke = K.readVarInt();
    for (let ne = 0; ne < ke; ++ne)
      J.outs.push({
        value: K.readUInt64(),
        script: K.readVarSlice()
      });
    if (ie) {
      for (let ne = 0; ne < oe; ++ne)
        J.ins[ne].witness = K.readVector();
      if (!J.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (J.locktime = K.readUInt32(), W) return J;
    if (K.offset !== B.length)
      throw new Error("Transaction has unexpected data");
    return J;
  }
  static fromHex(B) {
    return Transaction.fromBuffer(Buffer$1.from(B, "hex"), !1);
  }
  static isCoinbaseHash(B) {
    typeforce$1(types$1.Hash256bit, B);
    for (let W = 0; W < 32; ++W)
      if (B[W] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(B, W, K, J) {
    return typeforce$1(
      types$1.tuple(
        types$1.Hash256bit,
        types$1.UInt32,
        types$1.maybe(types$1.UInt32),
        types$1.maybe(types$1.Buffer)
      ),
      arguments
    ), types$1.Null(K) && (K = Transaction.DEFAULT_SEQUENCE), this.ins.push({
      hash: B,
      index: W,
      script: J || EMPTY_BUFFER,
      sequence: K,
      witness: EMPTY_WITNESS
    }) - 1;
  }
  addOutput(B, W) {
    return typeforce$1(types$1.tuple(types$1.Buffer, types$1.Satoshi), arguments), this.outs.push({
      script: B,
      value: W
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((B) => B.witness.length !== 0);
  }
  weight() {
    const B = this.byteLength(!1), W = this.byteLength(!0);
    return B * 3 + W;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(B = !0) {
    const W = B && this.hasWitnesses();
    return (W ? 10 : 8) + bufferutils_1$2.varuint.encodingLength(this.ins.length) + bufferutils_1$2.varuint.encodingLength(this.outs.length) + this.ins.reduce((K, J) => K + 40 + varSliceSize(J.script), 0) + this.outs.reduce((K, J) => K + 8 + varSliceSize(J.script), 0) + (W ? this.ins.reduce((K, J) => K + vectorSize(J.witness), 0) : 0);
  }
  clone() {
    const B = new Transaction();
    return B.version = this.version, B.locktime = this.locktime, B.ins = this.ins.map((W) => ({
      hash: W.hash,
      index: W.index,
      script: W.script,
      sequence: W.sequence,
      witness: W.witness
    })), B.outs = this.outs.map((W) => ({
      script: W.script,
      value: W.value
    })), B;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(B, W, K) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        types$1.Buffer,
        /* types.UInt8 */
        types$1.Number
      ),
      arguments
    ), B >= this.ins.length) return ONE;
    const J = bscript$2.compile(
      bscript$2.decompile(W).filter((ie) => ie !== script_1.OPS.OP_CODESEPARATOR)
    ), L = this.clone();
    if ((K & 31) === Transaction.SIGHASH_NONE)
      L.outs = [], L.ins.forEach((ie, oe) => {
        oe !== B && (ie.sequence = 0);
      });
    else if ((K & 31) === Transaction.SIGHASH_SINGLE) {
      if (B >= this.outs.length) return ONE;
      L.outs.length = B + 1;
      for (let ie = 0; ie < B; ie++)
        L.outs[ie] = BLANK_OUTPUT;
      L.ins.forEach((ie, oe) => {
        oe !== B && (ie.sequence = 0);
      });
    }
    K & Transaction.SIGHASH_ANYONECANPAY ? (L.ins = [L.ins[B]], L.ins[0].script = J) : (L.ins.forEach((ie) => {
      ie.script = EMPTY_BUFFER;
    }), L.ins[B].script = J);
    const re = Buffer$1.allocUnsafe(L.byteLength(!1) + 4);
    return re.writeInt32LE(K, re.length - 4), L.__toBuffer(re, 0, !1), bcrypto$1.hash256(re);
  }
  hashForWitnessV1(B, W, K, J, L, re) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        typeforce$1.arrayOf(types$1.Buffer),
        typeforce$1.arrayOf(types$1.Satoshi),
        types$1.UInt32
      ),
      arguments
    ), K.length !== this.ins.length || W.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const ie = J === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : J & Transaction.SIGHASH_OUTPUT_MASK, ke = (J & Transaction.SIGHASH_INPUT_MASK) === Transaction.SIGHASH_ANYONECANPAY, ne = ie === Transaction.SIGHASH_NONE, pe = ie === Transaction.SIGHASH_SINGLE;
    let rt = EMPTY_BUFFER, nt = EMPTY_BUFFER, ot = EMPTY_BUFFER, ut = EMPTY_BUFFER, dt = EMPTY_BUFFER;
    if (!ke) {
      let gt = bufferutils_1$2.BufferWriter.withCapacity(
        36 * this.ins.length
      );
      this.ins.forEach((Pt) => {
        gt.writeSlice(Pt.hash), gt.writeUInt32(Pt.index);
      }), rt = bcrypto$1.sha256(gt.end()), gt = bufferutils_1$2.BufferWriter.withCapacity(
        8 * this.ins.length
      ), K.forEach((Pt) => gt.writeUInt64(Pt)), nt = bcrypto$1.sha256(gt.end()), gt = bufferutils_1$2.BufferWriter.withCapacity(
        W.map(varSliceSize).reduce((Pt, xt) => Pt + xt)
      ), W.forEach(
        (Pt) => gt.writeVarSlice(Pt)
      ), ot = bcrypto$1.sha256(gt.end()), gt = bufferutils_1$2.BufferWriter.withCapacity(
        4 * this.ins.length
      ), this.ins.forEach((Pt) => gt.writeUInt32(Pt.sequence)), ut = bcrypto$1.sha256(gt.end());
    }
    if (ne || pe) {
      if (pe && B < this.outs.length) {
        const gt = this.outs[B], Pt = bufferutils_1$2.BufferWriter.withCapacity(
          8 + varSliceSize(gt.script)
        );
        Pt.writeUInt64(gt.value), Pt.writeVarSlice(gt.script), dt = bcrypto$1.sha256(Pt.end());
      }
    } else {
      const gt = this.outs.map((xt) => 8 + varSliceSize(xt.script)).reduce((xt, Nt) => xt + Nt), Pt = bufferutils_1$2.BufferWriter.withCapacity(gt);
      this.outs.forEach((xt) => {
        Pt.writeUInt64(xt.value), Pt.writeVarSlice(xt.script);
      }), dt = bcrypto$1.sha256(Pt.end());
    }
    const vt = (L ? 2 : 0) + (re ? 1 : 0), pt = 174 - (ke ? 49 : 0) - (ne ? 32 : 0) + (re ? 32 : 0) + (L ? 37 : 0), mt = bufferutils_1$2.BufferWriter.withCapacity(pt);
    if (mt.writeUInt8(J), mt.writeInt32(this.version), mt.writeUInt32(this.locktime), mt.writeSlice(rt), mt.writeSlice(nt), mt.writeSlice(ot), mt.writeSlice(ut), ne || pe || mt.writeSlice(dt), mt.writeUInt8(vt), ke) {
      const gt = this.ins[B];
      mt.writeSlice(gt.hash), mt.writeUInt32(gt.index), mt.writeUInt64(K[B]), mt.writeVarSlice(W[B]), mt.writeUInt32(gt.sequence);
    } else
      mt.writeUInt32(B);
    if (re) {
      const gt = bufferutils_1$2.BufferWriter.withCapacity(
        varSliceSize(re)
      );
      gt.writeVarSlice(re), mt.writeSlice(bcrypto$1.sha256(gt.end()));
    }
    return pe && mt.writeSlice(dt), L && (mt.writeSlice(L), mt.writeUInt8(0), mt.writeUInt32(4294967295)), bcrypto$1.taggedHash(
      "TapSighash",
      Buffer$1.concat([Buffer$1.from([0]), mt.end()])
    );
  }
  hashForWitnessV0(B, W, K, J) {
    typeforce$1(
      types$1.tuple(types$1.UInt32, types$1.Buffer, types$1.Satoshi, types$1.UInt32),
      arguments
    );
    let L = Buffer$1.from([]), re, ie = ZERO, oe = ZERO, ke = ZERO;
    if (J & Transaction.SIGHASH_ANYONECANPAY || (L = Buffer$1.allocUnsafe(36 * this.ins.length), re = new bufferutils_1$2.BufferWriter(L, 0), this.ins.forEach((pe) => {
      re.writeSlice(pe.hash), re.writeUInt32(pe.index);
    }), oe = bcrypto$1.hash256(L)), !(J & Transaction.SIGHASH_ANYONECANPAY) && (J & 31) !== Transaction.SIGHASH_SINGLE && (J & 31) !== Transaction.SIGHASH_NONE && (L = Buffer$1.allocUnsafe(4 * this.ins.length), re = new bufferutils_1$2.BufferWriter(L, 0), this.ins.forEach((pe) => {
      re.writeUInt32(pe.sequence);
    }), ke = bcrypto$1.hash256(L)), (J & 31) !== Transaction.SIGHASH_SINGLE && (J & 31) !== Transaction.SIGHASH_NONE) {
      const pe = this.outs.reduce((rt, nt) => rt + 8 + varSliceSize(nt.script), 0);
      L = Buffer$1.allocUnsafe(pe), re = new bufferutils_1$2.BufferWriter(L, 0), this.outs.forEach((rt) => {
        re.writeUInt64(rt.value), re.writeVarSlice(rt.script);
      }), ie = bcrypto$1.hash256(L);
    } else if ((J & 31) === Transaction.SIGHASH_SINGLE && B < this.outs.length) {
      const pe = this.outs[B];
      L = Buffer$1.allocUnsafe(8 + varSliceSize(pe.script)), re = new bufferutils_1$2.BufferWriter(L, 0), re.writeUInt64(pe.value), re.writeVarSlice(pe.script), ie = bcrypto$1.hash256(L);
    }
    L = Buffer$1.allocUnsafe(156 + varSliceSize(W)), re = new bufferutils_1$2.BufferWriter(L, 0);
    const ne = this.ins[B];
    return re.writeInt32(this.version), re.writeSlice(oe), re.writeSlice(ke), re.writeSlice(ne.hash), re.writeUInt32(ne.index), re.writeVarSlice(W), re.writeUInt64(K), re.writeUInt32(ne.sequence), re.writeSlice(ie), re.writeUInt32(this.locktime), re.writeUInt32(J), bcrypto$1.hash256(L);
  }
  getHash(B) {
    return B && this.isCoinbase() ? Buffer$1.alloc(32, 0) : bcrypto$1.hash256(this.__toBuffer(void 0, void 0, B));
  }
  getId() {
    return (0, bufferutils_1$2.reverseBuffer)(this.getHash(!1)).toString(
      "hex"
    );
  }
  toBuffer(B, W) {
    return this.__toBuffer(B, W, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(B, W) {
    typeforce$1(types$1.tuple(types$1.Number, types$1.Buffer), arguments), this.ins[B].script = W;
  }
  setWitness(B, W) {
    typeforce$1(types$1.tuple(types$1.Number, [types$1.Buffer]), arguments), this.ins[B].witness = W;
  }
  __toBuffer(B, W, K = !1) {
    B || (B = Buffer$1.allocUnsafe(this.byteLength(K)));
    const J = new bufferutils_1$2.BufferWriter(
      B,
      W || 0
    );
    J.writeInt32(this.version);
    const L = K && this.hasWitnesses();
    return L && (J.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER), J.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)), J.writeVarInt(this.ins.length), this.ins.forEach((re) => {
      J.writeSlice(re.hash), J.writeUInt32(re.index), J.writeVarSlice(re.script), J.writeUInt32(re.sequence);
    }), J.writeVarInt(this.outs.length), this.outs.forEach((re) => {
      isOutput(re) ? J.writeUInt64(re.value) : J.writeSlice(re.valueBuffer), J.writeVarSlice(re.script);
    }), L && this.ins.forEach((re) => {
      J.writeVector(re.witness);
    }), J.writeUInt32(this.locktime), W !== void 0 ? B.slice(W, J.offset) : B;
  }
}
transaction.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 4294967295;
Transaction.SIGHASH_DEFAULT = 0;
Transaction.SIGHASH_ALL = 1;
Transaction.SIGHASH_NONE = 2;
Transaction.SIGHASH_SINGLE = 3;
Transaction.SIGHASH_ANYONECANPAY = 128;
Transaction.SIGHASH_OUTPUT_MASK = 3;
Transaction.SIGHASH_INPUT_MASK = 128;
Transaction.ADVANCED_TRANSACTION_MARKER = 0;
Transaction.ADVANCED_TRANSACTION_FLAG = 1;
Object.defineProperty(block, "__esModule", { value: !0 });
block.Block = void 0;
const bufferutils_1$1 = bufferutils, bcrypto = crypto$1, merkle_1 = merkle, transaction_1$3 = transaction, types = types$4, { typeforce } = types, errorMerkleNoTxes = new TypeError(
  "Cannot compute merkle root for zero transactions"
), errorWitnessNotSegwit = new TypeError(
  "Cannot compute witness commit for non-segwit block"
);
class Block {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(B) {
    if (B.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const W = new bufferutils_1$1.BufferReader(B), K = new Block();
    if (K.version = W.readInt32(), K.prevHash = W.readSlice(32), K.merkleRoot = W.readSlice(32), K.timestamp = W.readUInt32(), K.bits = W.readUInt32(), K.nonce = W.readUInt32(), B.length === 80) return K;
    const J = () => {
      const ie = transaction_1$3.Transaction.fromBuffer(
        W.buffer.slice(W.offset),
        !0
      );
      return W.offset += ie.byteLength(), ie;
    }, L = W.readVarInt();
    K.transactions = [];
    for (let ie = 0; ie < L; ++ie) {
      const oe = J();
      K.transactions.push(oe);
    }
    const re = K.getWitnessCommit();
    return re && (K.witnessCommit = re), K;
  }
  static fromHex(B) {
    return Block.fromBuffer(Buffer$1.from(B, "hex"));
  }
  static calculateTarget(B) {
    const W = ((B & 4278190080) >> 24) - 3, K = B & 8388607, J = Buffer$1.alloc(32, 0);
    return J.writeUIntBE(K, 29 - W, 3), J;
  }
  static calculateMerkleRoot(B, W) {
    if (typeforce([{ getHash: types.Function }], B), B.length === 0) throw errorMerkleNoTxes;
    if (W && !txesHaveWitnessCommit(B))
      throw errorWitnessNotSegwit;
    const K = B.map(
      (L) => L.getHash(W)
    ), J = (0, merkle_1.fastMerkleRoot)(K, bcrypto.hash256);
    return W ? bcrypto.hash256(
      Buffer$1.concat([J, B[0].ins[0].witness[0]])
    ) : J;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    const B = this.transactions[0].outs.filter(
      (K) => K.script.slice(0, 6).equals(Buffer$1.from("6a24aa21a9ed", "hex"))
    ).map((K) => K.script.slice(6, 38));
    if (B.length === 0) return null;
    const W = B[B.length - 1];
    return W instanceof Buffer$1 && W.length === 32 ? W : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof Buffer$1 && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const B = this.byteLength(!1, !1), W = this.byteLength(!1, !0);
    return B * 3 + W;
  }
  byteLength(B, W = !0) {
    return B || !this.transactions ? 80 : 80 + bufferutils_1$1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((K, J) => K + J.byteLength(W), 0);
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(!0));
  }
  getId() {
    return (0, bufferutils_1$1.reverseBuffer)(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const B = /* @__PURE__ */ new Date(0);
    return B.setUTCSeconds(this.timestamp), B;
  }
  // TODO: buffer, offset compatibility
  toBuffer(B) {
    const W = Buffer$1.allocUnsafe(this.byteLength(B)), K = new bufferutils_1$1.BufferWriter(W);
    return K.writeInt32(this.version), K.writeSlice(this.prevHash), K.writeSlice(this.merkleRoot), K.writeUInt32(this.timestamp), K.writeUInt32(this.bits), K.writeUInt32(this.nonce), B || !this.transactions || (bufferutils_1$1.varuint.encode(
      this.transactions.length,
      W,
      K.offset
    ), K.offset += bufferutils_1$1.varuint.encode.bytes, this.transactions.forEach((J) => {
      const L = J.byteLength();
      J.toBuffer(W, K.offset), K.offset += L;
    })), W;
  }
  toHex(B) {
    return this.toBuffer(B).toString("hex");
  }
  checkTxRoots() {
    const B = this.hasWitnessCommit();
    return !B && this.hasWitness() ? !1 : this.__checkMerkleRoot() && (B ? this.__checkWitnessCommit() : !0);
  }
  checkProofOfWork() {
    const B = (0, bufferutils_1$1.reverseBuffer)(this.getHash()), W = Block.calculateTarget(this.bits);
    return B.compare(W) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const B = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(B) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const B = Block.calculateMerkleRoot(
      this.transactions,
      !0
    );
    return this.witnessCommit.compare(B) === 0;
  }
}
block.Block = Block;
function txesHaveWitnessCommit(A) {
  return A instanceof Array && A[0] && A[0].ins && A[0].ins instanceof Array && A[0].ins[0] && A[0].ins[0].witness && A[0].ins[0].witness instanceof Array && A[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(A) {
  return A instanceof Array && A.some(
    (B) => typeof B == "object" && B.ins instanceof Array && B.ins.some(
      (W) => typeof W == "object" && W.witness instanceof Array && W.witness.length > 0
    )
  );
}
var psbt$1 = {}, psbt = {}, combiner = {}, parser = {}, fromBuffer = {}, converter = {}, typeFields = {};
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), function(B) {
    B[B.UNSIGNED_TX = 0] = "UNSIGNED_TX", B[B.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
  }(A.GlobalTypes || (A.GlobalTypes = {})), A.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], function(B) {
    B[B.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", B[B.WITNESS_UTXO = 1] = "WITNESS_UTXO", B[B.PARTIAL_SIG = 2] = "PARTIAL_SIG", B[B.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", B[B.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", B[B.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", B[B.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", B[B.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", B[B.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", B[B.POR_COMMITMENT = 9] = "POR_COMMITMENT", B[B.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", B[B.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", B[B.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", B[B.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", B[B.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", B[B.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
  }(A.InputTypes || (A.InputTypes = {})), A.INPUT_TYPE_NAMES = [
    "nonWitnessUtxo",
    "witnessUtxo",
    "partialSig",
    "sighashType",
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "finalScriptSig",
    "finalScriptWitness",
    "porCommitment",
    "tapKeySig",
    "tapScriptSig",
    "tapLeafScript",
    "tapBip32Derivation",
    "tapInternalKey",
    "tapMerkleRoot"
  ], function(B) {
    B[B.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", B[B.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", B[B.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", B[B.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", B[B.TAP_TREE = 6] = "TAP_TREE", B[B.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
  }(A.OutputTypes || (A.OutputTypes = {})), A.OUTPUT_TYPE_NAMES = [
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "tapInternalKey",
    "tapTree",
    "tapBip32Derivation"
  ];
})(typeFields);
var globalXpub$1 = {};
Object.defineProperty(globalXpub$1, "__esModule", { value: !0 });
const typeFields_1$g = typeFields, range$2 = (A) => [...Array(A).keys()];
function decode$d(A) {
  if (A.key[0] !== typeFields_1$g.GlobalTypes.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + A.key.toString("hex")
    );
  if (A.key.length !== 79 || ![2, 3].includes(A.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + A.key.toString("hex")
    );
  if (A.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const B = A.key.slice(1), W = {
    masterFingerprint: A.value.slice(0, 4),
    extendedPubkey: B,
    path: "m"
  };
  for (const K of range$2(A.value.length / 4 - 1)) {
    const J = A.value.readUInt32LE(K * 4 + 4), L = !!(J & 2147483648), re = J & 2147483647;
    W.path += "/" + re.toString(10) + (L ? "'" : "");
  }
  return W;
}
globalXpub$1.decode = decode$d;
function encode$e(A) {
  const B = Buffer$1.from([typeFields_1$g.GlobalTypes.GLOBAL_XPUB]), W = Buffer$1.concat([B, A.extendedPubkey]), K = A.path.split("/"), J = Buffer$1.allocUnsafe(K.length * 4);
  A.masterFingerprint.copy(J, 0);
  let L = 4;
  return K.slice(1).forEach((re) => {
    const ie = re.slice(-1) === "'";
    let oe = 2147483647 & parseInt(ie ? re.slice(0, -1) : re, 10);
    ie && (oe += 2147483648), J.writeUInt32LE(oe, L), L += 4;
  }), {
    key: W,
    value: J
  };
}
globalXpub$1.encode = encode$e;
globalXpub$1.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
function check$c(A) {
  const B = A.extendedPubkey, W = A.masterFingerprint, K = A.path;
  return Buffer$1.isBuffer(B) && B.length === 78 && [2, 3].indexOf(B[45]) > -1 && Buffer$1.isBuffer(W) && W.length === 4 && typeof K == "string" && !!K.match(/^m(\/\d+'?)*$/);
}
globalXpub$1.check = check$c;
function canAddToArray$3(A, B, W) {
  const K = B.extendedPubkey.toString("hex");
  return W.has(K) ? !1 : (W.add(K), A.filter((J) => J.extendedPubkey.equals(B.extendedPubkey)).length === 0);
}
globalXpub$1.canAddToArray = canAddToArray$3;
var unsignedTx$1 = {};
Object.defineProperty(unsignedTx$1, "__esModule", { value: !0 });
const typeFields_1$f = typeFields;
function encode$d(A) {
  return {
    key: Buffer$1.from([typeFields_1$f.GlobalTypes.UNSIGNED_TX]),
    value: A.toBuffer()
  };
}
unsignedTx$1.encode = encode$d;
var finalScriptSig$1 = {};
Object.defineProperty(finalScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$e = typeFields;
function decode$c(A) {
  if (A.key[0] !== typeFields_1$e.InputTypes.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
finalScriptSig$1.decode = decode$c;
function encode$c(A) {
  return {
    key: Buffer$1.from([typeFields_1$e.InputTypes.FINAL_SCRIPTSIG]),
    value: A
  };
}
finalScriptSig$1.encode = encode$c;
finalScriptSig$1.expected = "Buffer";
function check$b(A) {
  return Buffer$1.isBuffer(A);
}
finalScriptSig$1.check = check$b;
function canAdd$8(A, B) {
  return !!A && !!B && A.finalScriptSig === void 0;
}
finalScriptSig$1.canAdd = canAdd$8;
var finalScriptWitness$1 = {};
Object.defineProperty(finalScriptWitness$1, "__esModule", { value: !0 });
const typeFields_1$d = typeFields;
function decode$b(A) {
  if (A.key[0] !== typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
finalScriptWitness$1.decode = decode$b;
function encode$b(A) {
  return {
    key: Buffer$1.from([typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS]),
    value: A
  };
}
finalScriptWitness$1.encode = encode$b;
finalScriptWitness$1.expected = "Buffer";
function check$a(A) {
  return Buffer$1.isBuffer(A);
}
finalScriptWitness$1.check = check$a;
function canAdd$7(A, B) {
  return !!A && !!B && A.finalScriptWitness === void 0;
}
finalScriptWitness$1.canAdd = canAdd$7;
var nonWitnessUtxo$1 = {};
Object.defineProperty(nonWitnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$c = typeFields;
function decode$a(A) {
  if (A.key[0] !== typeFields_1$c.InputTypes.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
nonWitnessUtxo$1.decode = decode$a;
function encode$a(A) {
  return {
    key: Buffer$1.from([typeFields_1$c.InputTypes.NON_WITNESS_UTXO]),
    value: A
  };
}
nonWitnessUtxo$1.encode = encode$a;
nonWitnessUtxo$1.expected = "Buffer";
function check$9(A) {
  return Buffer$1.isBuffer(A);
}
nonWitnessUtxo$1.check = check$9;
function canAdd$6(A, B) {
  return !!A && !!B && A.nonWitnessUtxo === void 0;
}
nonWitnessUtxo$1.canAdd = canAdd$6;
var partialSig$1 = {};
Object.defineProperty(partialSig$1, "__esModule", { value: !0 });
const typeFields_1$b = typeFields;
function decode$9(A) {
  if (A.key[0] !== typeFields_1$b.InputTypes.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + A.key.toString("hex")
    );
  if (!(A.key.length === 34 || A.key.length === 66) || ![2, 3, 4].includes(A.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + A.key.toString("hex")
    );
  return {
    pubkey: A.key.slice(1),
    signature: A.value
  };
}
partialSig$1.decode = decode$9;
function encode$9(A) {
  const B = Buffer$1.from([typeFields_1$b.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer$1.concat([B, A.pubkey]),
    value: A.signature
  };
}
partialSig$1.encode = encode$9;
partialSig$1.expected = "{ pubkey: Buffer; signature: Buffer; }";
function check$8(A) {
  return Buffer$1.isBuffer(A.pubkey) && Buffer$1.isBuffer(A.signature) && [33, 65].includes(A.pubkey.length) && [2, 3, 4].includes(A.pubkey[0]) && isDerSigWithSighash(A.signature);
}
partialSig$1.check = check$8;
function isDerSigWithSighash(A) {
  if (!Buffer$1.isBuffer(A) || A.length < 9 || A[0] !== 48 || A.length !== A[1] + 3 || A[2] !== 2) return !1;
  const B = A[3];
  if (B > 33 || B < 1 || A[3 + B + 1] !== 2) return !1;
  const W = A[3 + B + 2];
  return !(W > 33 || W < 1 || A.length !== 3 + B + 2 + W + 2);
}
function canAddToArray$2(A, B, W) {
  const K = B.pubkey.toString("hex");
  return W.has(K) ? !1 : (W.add(K), A.filter((J) => J.pubkey.equals(B.pubkey)).length === 0);
}
partialSig$1.canAddToArray = canAddToArray$2;
var porCommitment$1 = {};
Object.defineProperty(porCommitment$1, "__esModule", { value: !0 });
const typeFields_1$a = typeFields;
function decode$8(A) {
  if (A.key[0] !== typeFields_1$a.InputTypes.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + A.key.toString("hex")
    );
  return A.value.toString("utf8");
}
porCommitment$1.decode = decode$8;
function encode$8(A) {
  return {
    key: Buffer$1.from([typeFields_1$a.InputTypes.POR_COMMITMENT]),
    value: Buffer$1.from(A, "utf8")
  };
}
porCommitment$1.encode = encode$8;
porCommitment$1.expected = "string";
function check$7(A) {
  return typeof A == "string";
}
porCommitment$1.check = check$7;
function canAdd$5(A, B) {
  return !!A && !!B && A.porCommitment === void 0;
}
porCommitment$1.canAdd = canAdd$5;
var sighashType$1 = {};
Object.defineProperty(sighashType$1, "__esModule", { value: !0 });
const typeFields_1$9 = typeFields;
function decode$7(A) {
  if (A.key[0] !== typeFields_1$9.InputTypes.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + A.key.toString("hex")
    );
  return A.value.readUInt32LE(0);
}
sighashType$1.decode = decode$7;
function encode$7(A) {
  const B = Buffer$1.from([typeFields_1$9.InputTypes.SIGHASH_TYPE]), W = Buffer$1.allocUnsafe(4);
  return W.writeUInt32LE(A, 0), {
    key: B,
    value: W
  };
}
sighashType$1.encode = encode$7;
sighashType$1.expected = "number";
function check$6(A) {
  return typeof A == "number";
}
sighashType$1.check = check$6;
function canAdd$4(A, B) {
  return !!A && !!B && A.sighashType === void 0;
}
sighashType$1.canAdd = canAdd$4;
var tapKeySig$1 = {};
Object.defineProperty(tapKeySig$1, "__esModule", { value: !0 });
const typeFields_1$8 = typeFields;
function decode$6(A) {
  if (A.key[0] !== typeFields_1$8.InputTypes.TAP_KEY_SIG || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + A.key.toString("hex")
    );
  if (!check$5(A.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return A.value;
}
tapKeySig$1.decode = decode$6;
function encode$6(A) {
  return { key: Buffer$1.from([typeFields_1$8.InputTypes.TAP_KEY_SIG]), value: A };
}
tapKeySig$1.encode = encode$6;
tapKeySig$1.expected = "Buffer";
function check$5(A) {
  return Buffer$1.isBuffer(A) && (A.length === 64 || A.length === 65);
}
tapKeySig$1.check = check$5;
function canAdd$3(A, B) {
  return !!A && !!B && A.tapKeySig === void 0;
}
tapKeySig$1.canAdd = canAdd$3;
var tapLeafScript$1 = {};
Object.defineProperty(tapLeafScript$1, "__esModule", { value: !0 });
const typeFields_1$7 = typeFields;
function decode$5(A) {
  if (A.key[0] !== typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + A.key.toString("hex")
    );
  if ((A.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + A.key.toString("hex")
    );
  const B = A.value[A.value.length - 1];
  if ((A.key[1] & 254) !== B)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + A.key.toString("hex")
    );
  const W = A.value.slice(0, -1);
  return { controlBlock: A.key.slice(1), script: W, leafVersion: B };
}
tapLeafScript$1.decode = decode$5;
function encode$5(A) {
  const B = Buffer$1.from([typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT]), W = Buffer$1.from([A.leafVersion]);
  return {
    key: Buffer$1.concat([B, A.controlBlock]),
    value: Buffer$1.concat([A.script, W])
  };
}
tapLeafScript$1.encode = encode$5;
tapLeafScript$1.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
function check$4(A) {
  return Buffer$1.isBuffer(A.controlBlock) && (A.controlBlock.length - 1) % 32 === 0 && (A.controlBlock[0] & 254) === A.leafVersion && Buffer$1.isBuffer(A.script);
}
tapLeafScript$1.check = check$4;
function canAddToArray$1(A, B, W) {
  const K = B.controlBlock.toString("hex");
  return W.has(K) ? !1 : (W.add(K), A.filter((J) => J.controlBlock.equals(B.controlBlock)).length === 0);
}
tapLeafScript$1.canAddToArray = canAddToArray$1;
var tapMerkleRoot$1 = {};
Object.defineProperty(tapMerkleRoot$1, "__esModule", { value: !0 });
const typeFields_1$6 = typeFields;
function decode$4(A) {
  if (A.key[0] !== typeFields_1$6.InputTypes.TAP_MERKLE_ROOT || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + A.key.toString("hex")
    );
  if (!check$3(A.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return A.value;
}
tapMerkleRoot$1.decode = decode$4;
function encode$4(A) {
  return { key: Buffer$1.from([typeFields_1$6.InputTypes.TAP_MERKLE_ROOT]), value: A };
}
tapMerkleRoot$1.encode = encode$4;
tapMerkleRoot$1.expected = "Buffer";
function check$3(A) {
  return Buffer$1.isBuffer(A) && A.length === 32;
}
tapMerkleRoot$1.check = check$3;
function canAdd$2(A, B) {
  return !!A && !!B && A.tapMerkleRoot === void 0;
}
tapMerkleRoot$1.canAdd = canAdd$2;
var tapScriptSig$1 = {};
Object.defineProperty(tapScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$5 = typeFields;
function decode$3(A) {
  if (A.key[0] !== typeFields_1$5.InputTypes.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + A.key.toString("hex")
    );
  if (A.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + A.key.toString("hex")
    );
  if (A.value.length !== 64 && A.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + A.key.toString("hex")
    );
  const B = A.key.slice(1, 33), W = A.key.slice(33);
  return {
    pubkey: B,
    leafHash: W,
    signature: A.value
  };
}
tapScriptSig$1.decode = decode$3;
function encode$3(A) {
  const B = Buffer$1.from([typeFields_1$5.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer$1.concat([B, A.pubkey, A.leafHash]),
    value: A.signature
  };
}
tapScriptSig$1.encode = encode$3;
tapScriptSig$1.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
function check$2(A) {
  return Buffer$1.isBuffer(A.pubkey) && Buffer$1.isBuffer(A.leafHash) && Buffer$1.isBuffer(A.signature) && A.pubkey.length === 32 && A.leafHash.length === 32 && (A.signature.length === 64 || A.signature.length === 65);
}
tapScriptSig$1.check = check$2;
function canAddToArray(A, B, W) {
  const K = B.pubkey.toString("hex") + B.leafHash.toString("hex");
  return W.has(K) ? !1 : (W.add(K), A.filter(
    (J) => J.pubkey.equals(B.pubkey) && J.leafHash.equals(B.leafHash)
  ).length === 0);
}
tapScriptSig$1.canAddToArray = canAddToArray;
var witnessUtxo$1 = {}, tools = {}, varint = {};
Object.defineProperty(varint, "__esModule", { value: !0 });
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(A) {
  if (A < 0 || A > MAX_SAFE_INTEGER || A % 1 !== 0)
    throw new RangeError("value out of range");
}
function encode$2(A, B, W) {
  if (checkUInt53(A), B || (B = Buffer$1.allocUnsafe(encodingLength(A))), !Buffer$1.isBuffer(B))
    throw new TypeError("buffer must be a Buffer instance");
  return W || (W = 0), A < 253 ? (B.writeUInt8(A, W), Object.assign(encode$2, { bytes: 1 })) : A <= 65535 ? (B.writeUInt8(253, W), B.writeUInt16LE(A, W + 1), Object.assign(encode$2, { bytes: 3 })) : A <= 4294967295 ? (B.writeUInt8(254, W), B.writeUInt32LE(A, W + 1), Object.assign(encode$2, { bytes: 5 })) : (B.writeUInt8(255, W), B.writeUInt32LE(A >>> 0, W + 1), B.writeUInt32LE(A / 4294967296 | 0, W + 5), Object.assign(encode$2, { bytes: 9 })), B;
}
varint.encode = encode$2;
function decode$2(A, B) {
  if (!Buffer$1.isBuffer(A))
    throw new TypeError("buffer must be a Buffer instance");
  B || (B = 0);
  const W = A.readUInt8(B);
  if (W < 253)
    return Object.assign(decode$2, { bytes: 1 }), W;
  if (W === 253)
    return Object.assign(decode$2, { bytes: 3 }), A.readUInt16LE(B + 1);
  if (W === 254)
    return Object.assign(decode$2, { bytes: 5 }), A.readUInt32LE(B + 1);
  {
    Object.assign(decode$2, { bytes: 9 });
    const K = A.readUInt32LE(B + 1), L = A.readUInt32LE(B + 5) * 4294967296 + K;
    return checkUInt53(L), L;
  }
}
varint.decode = decode$2;
function encodingLength(A) {
  return checkUInt53(A), A < 253 ? 1 : A <= 65535 ? 3 : A <= 4294967295 ? 5 : 9;
}
varint.encodingLength = encodingLength;
Object.defineProperty(tools, "__esModule", { value: !0 });
const varuint$6 = varint;
tools.range = (A) => [...Array(A).keys()];
function reverseBuffer(A) {
  if (A.length < 1) return A;
  let B = A.length - 1, W = 0;
  for (let K = 0; K < A.length / 2; K++)
    W = A[K], A[K] = A[B], A[B] = W, B--;
  return A;
}
tools.reverseBuffer = reverseBuffer;
function keyValsToBuffer(A) {
  const B = A.map(keyValToBuffer);
  return B.push(Buffer$1.from([0])), Buffer$1.concat(B);
}
tools.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(A) {
  const B = A.key.length, W = A.value.length, K = varuint$6.encodingLength(B), J = varuint$6.encodingLength(W), L = Buffer$1.allocUnsafe(
    K + B + J + W
  );
  return varuint$6.encode(B, L, 0), A.key.copy(L, K), varuint$6.encode(W, L, K + B), A.value.copy(L, K + B + J), L;
}
tools.keyValToBuffer = keyValToBuffer;
function verifuint(A, B) {
  if (typeof A != "number")
    throw new Error("cannot write a non-number as a number");
  if (A < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (A > B) throw new Error("RangeError: value out of range");
  if (Math.floor(A) !== A)
    throw new Error("value has a fractional component");
}
function readUInt64LE(A, B) {
  const W = A.readUInt32LE(B);
  let K = A.readUInt32LE(B + 4);
  return K *= 4294967296, verifuint(K + W, 9007199254740991), K + W;
}
tools.readUInt64LE = readUInt64LE;
function writeUInt64LE(A, B, W) {
  return verifuint(B, 9007199254740991), A.writeInt32LE(B & -1, W), A.writeUInt32LE(Math.floor(B / 4294967296), W + 4), W + 8;
}
tools.writeUInt64LE = writeUInt64LE;
Object.defineProperty(witnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$4 = typeFields, tools_1$2 = tools, varuint$5 = varint;
function decode$1(A) {
  if (A.key[0] !== typeFields_1$4.InputTypes.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + A.key.toString("hex")
    );
  const B = tools_1$2.readUInt64LE(A.value, 0);
  let W = 8;
  const K = varuint$5.decode(A.value, W);
  W += varuint$5.encodingLength(K);
  const J = A.value.slice(W);
  if (J.length !== K)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: J,
    value: B
  };
}
witnessUtxo$1.decode = decode$1;
function encode$1(A) {
  const { script: B, value: W } = A, K = varuint$5.encodingLength(B.length), J = Buffer$1.allocUnsafe(8 + K + B.length);
  return tools_1$2.writeUInt64LE(J, W, 0), varuint$5.encode(B.length, J, 8), B.copy(J, 8 + K), {
    key: Buffer$1.from([typeFields_1$4.InputTypes.WITNESS_UTXO]),
    value: J
  };
}
witnessUtxo$1.encode = encode$1;
witnessUtxo$1.expected = "{ script: Buffer; value: number; }";
function check$1(A) {
  return Buffer$1.isBuffer(A.script) && typeof A.value == "number";
}
witnessUtxo$1.check = check$1;
function canAdd$1(A, B) {
  return !!A && !!B && A.witnessUtxo === void 0;
}
witnessUtxo$1.canAdd = canAdd$1;
var tapTree$1 = {};
Object.defineProperty(tapTree$1, "__esModule", { value: !0 });
const typeFields_1$3 = typeFields, varuint$4 = varint;
function decode(A) {
  if (A.key[0] !== typeFields_1$3.OutputTypes.TAP_TREE || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + A.key.toString("hex")
    );
  let B = 0;
  const W = [];
  for (; B < A.value.length; ) {
    const K = A.value[B++], J = A.value[B++], L = varuint$4.decode(A.value, B);
    B += varuint$4.encodingLength(L), W.push({
      depth: K,
      leafVersion: J,
      script: A.value.slice(B, B + L)
    }), B += L;
  }
  return { leaves: W };
}
tapTree$1.decode = decode;
function encode(A) {
  const B = Buffer$1.from([typeFields_1$3.OutputTypes.TAP_TREE]), W = [].concat(
    ...A.leaves.map((K) => [
      Buffer$1.of(K.depth, K.leafVersion),
      varuint$4.encode(K.script.length),
      K.script
    ])
  );
  return {
    key: B,
    value: Buffer$1.concat(W)
  };
}
tapTree$1.encode = encode;
tapTree$1.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
function check(A) {
  return Array.isArray(A.leaves) && A.leaves.every(
    (B) => B.depth >= 0 && B.depth <= 128 && (B.leafVersion & 254) === B.leafVersion && Buffer$1.isBuffer(B.script)
  );
}
tapTree$1.check = check;
function canAdd(A, B) {
  return !!A && !!B && A.tapTree === void 0;
}
tapTree$1.canAdd = canAdd;
var bip32Derivation$2 = {};
Object.defineProperty(bip32Derivation$2, "__esModule", { value: !0 });
const range$1 = (A) => [...Array(A).keys()], isValidDERKey = (A) => A.length === 33 && [2, 3].includes(A[0]) || A.length === 65 && A[0] === 4;
function makeConverter$4(A, B = isValidDERKey) {
  function W(ie) {
    if (ie.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + ie.key.toString("hex")
      );
    const oe = ie.key.slice(1);
    if (!B(oe))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + ie.key.toString("hex")
      );
    if (ie.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const ke = {
      masterFingerprint: ie.value.slice(0, 4),
      pubkey: oe,
      path: "m"
    };
    for (const ne of range$1(ie.value.length / 4 - 1)) {
      const pe = ie.value.readUInt32LE(ne * 4 + 4), rt = !!(pe & 2147483648), nt = pe & 2147483647;
      ke.path += "/" + nt.toString(10) + (rt ? "'" : "");
    }
    return ke;
  }
  function K(ie) {
    const oe = Buffer$1.from([A]), ke = Buffer$1.concat([oe, ie.pubkey]), ne = ie.path.split("/"), pe = Buffer$1.allocUnsafe(ne.length * 4);
    ie.masterFingerprint.copy(pe, 0);
    let rt = 4;
    return ne.slice(1).forEach((nt) => {
      const ot = nt.slice(-1) === "'";
      let ut = 2147483647 & parseInt(ot ? nt.slice(0, -1) : nt, 10);
      ot && (ut += 2147483648), pe.writeUInt32LE(ut, rt), rt += 4;
    }), {
      key: ke,
      value: pe
    };
  }
  const J = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
  function L(ie) {
    return Buffer$1.isBuffer(ie.pubkey) && Buffer$1.isBuffer(ie.masterFingerprint) && typeof ie.path == "string" && B(ie.pubkey) && ie.masterFingerprint.length === 4;
  }
  function re(ie, oe, ke) {
    const ne = oe.pubkey.toString("hex");
    return ke.has(ne) ? !1 : (ke.add(ne), ie.filter((pe) => pe.pubkey.equals(oe.pubkey)).length === 0);
  }
  return {
    decode: W,
    encode: K,
    check: L,
    expected: J,
    canAddToArray: re
  };
}
bip32Derivation$2.makeConverter = makeConverter$4;
var checkPubkey$1 = {};
Object.defineProperty(checkPubkey$1, "__esModule", { value: !0 });
function makeChecker(A) {
  return B;
  function B(W) {
    let K;
    if (A.includes(W.key[0]) && (K = W.key.slice(1), !(K.length === 33 || K.length === 65) || ![2, 3, 4].includes(K[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + W.key.toString("hex")
      );
    return K;
  }
}
checkPubkey$1.makeChecker = makeChecker;
var redeemScript$1 = {};
Object.defineProperty(redeemScript$1, "__esModule", { value: !0 });
function makeConverter$3(A) {
  function B(re) {
    if (re.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + re.key.toString("hex")
      );
    return re.value;
  }
  function W(re) {
    return {
      key: Buffer$1.from([A]),
      value: re
    };
  }
  const K = "Buffer";
  function J(re) {
    return Buffer$1.isBuffer(re);
  }
  function L(re, ie) {
    return !!re && !!ie && re.redeemScript === void 0;
  }
  return {
    decode: B,
    encode: W,
    check: J,
    expected: K,
    canAdd: L
  };
}
redeemScript$1.makeConverter = makeConverter$3;
var tapBip32Derivation$1 = {};
Object.defineProperty(tapBip32Derivation$1, "__esModule", { value: !0 });
const varuint$3 = varint, bip32Derivation$1 = bip32Derivation$2, isValidBIP340Key = (A) => A.length === 32;
function makeConverter$2(A) {
  const B = bip32Derivation$1.makeConverter(A, isValidBIP340Key);
  function W(re) {
    const ie = varuint$3.decode(re.value), oe = varuint$3.encodingLength(ie), ke = B.decode({
      key: re.key,
      value: re.value.slice(oe + ie * 32)
    }), ne = new Array(ie);
    for (let pe = 0, rt = oe; pe < ie; pe++, rt += 32)
      ne[pe] = re.value.slice(rt, rt + 32);
    return Object.assign({}, ke, { leafHashes: ne });
  }
  function K(re) {
    const ie = B.encode(re), oe = varuint$3.encodingLength(re.leafHashes.length), ke = Buffer$1.allocUnsafe(oe);
    varuint$3.encode(re.leafHashes.length, ke);
    const ne = Buffer$1.concat([ke, ...re.leafHashes, ie.value]);
    return Object.assign({}, ie, { value: ne });
  }
  const J = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
  function L(re) {
    return Array.isArray(re.leafHashes) && re.leafHashes.every(
      (ie) => Buffer$1.isBuffer(ie) && ie.length === 32
    ) && B.check(re);
  }
  return {
    decode: W,
    encode: K,
    check: L,
    expected: J,
    canAddToArray: B.canAddToArray
  };
}
tapBip32Derivation$1.makeConverter = makeConverter$2;
var tapInternalKey$1 = {};
Object.defineProperty(tapInternalKey$1, "__esModule", { value: !0 });
function makeConverter$1(A) {
  function B(re) {
    if (re.key[0] !== A || re.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + re.key.toString("hex")
      );
    if (re.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return re.value;
  }
  function W(re) {
    return { key: Buffer$1.from([A]), value: re };
  }
  const K = "Buffer";
  function J(re) {
    return Buffer$1.isBuffer(re) && re.length === 32;
  }
  function L(re, ie) {
    return !!re && !!ie && re.tapInternalKey === void 0;
  }
  return {
    decode: B,
    encode: W,
    check: J,
    expected: K,
    canAdd: L
  };
}
tapInternalKey$1.makeConverter = makeConverter$1;
var witnessScript$1 = {};
Object.defineProperty(witnessScript$1, "__esModule", { value: !0 });
function makeConverter(A) {
  function B(re) {
    if (re.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + re.key.toString("hex")
      );
    return re.value;
  }
  function W(re) {
    return {
      key: Buffer$1.from([A]),
      value: re
    };
  }
  const K = "Buffer";
  function J(re) {
    return Buffer$1.isBuffer(re);
  }
  function L(re, ie) {
    return !!re && !!ie && re.witnessScript === void 0;
  }
  return {
    decode: B,
    encode: W,
    check: J,
    expected: K,
    canAdd: L
  };
}
witnessScript$1.makeConverter = makeConverter;
Object.defineProperty(converter, "__esModule", { value: !0 });
const typeFields_1$2 = typeFields, globalXpub = globalXpub$1, unsignedTx = unsignedTx$1, finalScriptSig = finalScriptSig$1, finalScriptWitness = finalScriptWitness$1, nonWitnessUtxo = nonWitnessUtxo$1, partialSig = partialSig$1, porCommitment = porCommitment$1, sighashType = sighashType$1, tapKeySig = tapKeySig$1, tapLeafScript = tapLeafScript$1, tapMerkleRoot = tapMerkleRoot$1, tapScriptSig = tapScriptSig$1, witnessUtxo = witnessUtxo$1, tapTree = tapTree$1, bip32Derivation = bip32Derivation$2, checkPubkey = checkPubkey$1, redeemScript = redeemScript$1, tapBip32Derivation = tapBip32Derivation$1, tapInternalKey = tapInternalKey$1, witnessScript = witnessScript$1, globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([])
};
converter.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.InputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.InputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.InputTypes.PARTIAL_SIG,
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.InputTypes.TAP_INTERNAL_KEY
  ),
  tapMerkleRoot
};
converter.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.OutputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.OutputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.OutputTypes.TAP_INTERNAL_KEY
  )
};
converter.outputs = outputs;
Object.defineProperty(fromBuffer, "__esModule", { value: !0 });
const convert$1 = converter, tools_1$1 = tools, varuint$2 = varint, typeFields_1$1 = typeFields;
function psbtFromBuffer(A, B) {
  let W = 0;
  function K() {
    const dt = varuint$2.decode(A, W);
    W += varuint$2.encodingLength(dt);
    const vt = A.slice(W, W + dt);
    return W += dt, vt;
  }
  function J() {
    const dt = A.readUInt32BE(W);
    return W += 4, dt;
  }
  function L() {
    const dt = A.readUInt8(W);
    return W += 1, dt;
  }
  function re() {
    const dt = K(), vt = K();
    return {
      key: dt,
      value: vt
    };
  }
  function ie() {
    if (W >= A.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const dt = A.readUInt8(W) === 0;
    return dt && W++, dt;
  }
  if (J() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (L() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const oe = [], ke = {};
  for (; !ie(); ) {
    const dt = re(), vt = dt.key.toString("hex");
    if (ke[vt])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + vt
      );
    ke[vt] = 1, oe.push(dt);
  }
  const ne = oe.filter(
    (dt) => dt.key[0] === typeFields_1$1.GlobalTypes.UNSIGNED_TX
  );
  if (ne.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const pe = B(ne[0].value), { inputCount: rt, outputCount: nt } = pe.getInputOutputCounts(), ot = [], ut = [];
  for (const dt of tools_1$1.range(rt)) {
    const vt = {}, pt = [];
    for (; !ie(); ) {
      const mt = re(), gt = mt.key.toString("hex");
      if (vt[gt])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + dt + " key " + gt
        );
      vt[gt] = 1, pt.push(mt);
    }
    ot.push(pt);
  }
  for (const dt of tools_1$1.range(nt)) {
    const vt = {}, pt = [];
    for (; !ie(); ) {
      const mt = re(), gt = mt.key.toString("hex");
      if (vt[gt])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + dt + " key " + gt
        );
      vt[gt] = 1, pt.push(mt);
    }
    ut.push(pt);
  }
  return psbtFromKeyVals(pe, {
    globalMapKeyVals: oe,
    inputKeyVals: ot,
    outputKeyVals: ut
  });
}
fromBuffer.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(A, B, W) {
  if (!B.equals(Buffer$1.from([W])))
    throw new Error(
      `Format Error: Invalid ${A} key: ${B.toString("hex")}`
    );
}
fromBuffer.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(A, { globalMapKeyVals: B, inputKeyVals: W, outputKeyVals: K }) {
  const J = {
    unsignedTx: A
  };
  let L = 0;
  for (const ne of B)
    switch (ne.key[0]) {
      case typeFields_1$1.GlobalTypes.UNSIGNED_TX:
        if (checkKeyBuffer(
          "global",
          ne.key,
          typeFields_1$1.GlobalTypes.UNSIGNED_TX
        ), L > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        L++;
        break;
      case typeFields_1$1.GlobalTypes.GLOBAL_XPUB:
        J.globalXpub === void 0 && (J.globalXpub = []), J.globalXpub.push(convert$1.globals.globalXpub.decode(ne));
        break;
      default:
        J.unknownKeyVals || (J.unknownKeyVals = []), J.unknownKeyVals.push(ne);
    }
  const re = W.length, ie = K.length, oe = [], ke = [];
  for (const ne of tools_1$1.range(re)) {
    const pe = {};
    for (const rt of W[ne])
      switch (convert$1.inputs.checkPubkey(rt), rt.key[0]) {
        case typeFields_1$1.InputTypes.NON_WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            rt.key,
            typeFields_1$1.InputTypes.NON_WITNESS_UTXO
          ), pe.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          pe.nonWitnessUtxo = convert$1.inputs.nonWitnessUtxo.decode(rt);
          break;
        case typeFields_1$1.InputTypes.WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            rt.key,
            typeFields_1$1.InputTypes.WITNESS_UTXO
          ), pe.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          pe.witnessUtxo = convert$1.inputs.witnessUtxo.decode(rt);
          break;
        case typeFields_1$1.InputTypes.PARTIAL_SIG:
          pe.partialSig === void 0 && (pe.partialSig = []), pe.partialSig.push(convert$1.inputs.partialSig.decode(rt));
          break;
        case typeFields_1$1.InputTypes.SIGHASH_TYPE:
          if (checkKeyBuffer(
            "input",
            rt.key,
            typeFields_1$1.InputTypes.SIGHASH_TYPE
          ), pe.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          pe.sighashType = convert$1.inputs.sighashType.decode(rt);
          break;
        case typeFields_1$1.InputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "input",
            rt.key,
            typeFields_1$1.InputTypes.REDEEM_SCRIPT
          ), pe.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          pe.redeemScript = convert$1.inputs.redeemScript.decode(rt);
          break;
        case typeFields_1$1.InputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "input",
            rt.key,
            typeFields_1$1.InputTypes.WITNESS_SCRIPT
          ), pe.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          pe.witnessScript = convert$1.inputs.witnessScript.decode(rt);
          break;
        case typeFields_1$1.InputTypes.BIP32_DERIVATION:
          pe.bip32Derivation === void 0 && (pe.bip32Derivation = []), pe.bip32Derivation.push(
            convert$1.inputs.bip32Derivation.decode(rt)
          );
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            "input",
            rt.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTSIG
          ), pe.finalScriptSig = convert$1.inputs.finalScriptSig.decode(rt);
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            "input",
            rt.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS
          ), pe.finalScriptWitness = convert$1.inputs.finalScriptWitness.decode(
            rt
          );
          break;
        case typeFields_1$1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            "input",
            rt.key,
            typeFields_1$1.InputTypes.POR_COMMITMENT
          ), pe.porCommitment = convert$1.inputs.porCommitment.decode(rt);
          break;
        case typeFields_1$1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            "input",
            rt.key,
            typeFields_1$1.InputTypes.TAP_KEY_SIG
          ), pe.tapKeySig = convert$1.inputs.tapKeySig.decode(rt);
          break;
        case typeFields_1$1.InputTypes.TAP_SCRIPT_SIG:
          pe.tapScriptSig === void 0 && (pe.tapScriptSig = []), pe.tapScriptSig.push(convert$1.inputs.tapScriptSig.decode(rt));
          break;
        case typeFields_1$1.InputTypes.TAP_LEAF_SCRIPT:
          pe.tapLeafScript === void 0 && (pe.tapLeafScript = []), pe.tapLeafScript.push(convert$1.inputs.tapLeafScript.decode(rt));
          break;
        case typeFields_1$1.InputTypes.TAP_BIP32_DERIVATION:
          pe.tapBip32Derivation === void 0 && (pe.tapBip32Derivation = []), pe.tapBip32Derivation.push(
            convert$1.inputs.tapBip32Derivation.decode(rt)
          );
          break;
        case typeFields_1$1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "input",
            rt.key,
            typeFields_1$1.InputTypes.TAP_INTERNAL_KEY
          ), pe.tapInternalKey = convert$1.inputs.tapInternalKey.decode(rt);
          break;
        case typeFields_1$1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            "input",
            rt.key,
            typeFields_1$1.InputTypes.TAP_MERKLE_ROOT
          ), pe.tapMerkleRoot = convert$1.inputs.tapMerkleRoot.decode(rt);
          break;
        default:
          pe.unknownKeyVals || (pe.unknownKeyVals = []), pe.unknownKeyVals.push(rt);
      }
    oe.push(pe);
  }
  for (const ne of tools_1$1.range(ie)) {
    const pe = {};
    for (const rt of K[ne])
      switch (convert$1.outputs.checkPubkey(rt), rt.key[0]) {
        case typeFields_1$1.OutputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "output",
            rt.key,
            typeFields_1$1.OutputTypes.REDEEM_SCRIPT
          ), pe.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          pe.redeemScript = convert$1.outputs.redeemScript.decode(rt);
          break;
        case typeFields_1$1.OutputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "output",
            rt.key,
            typeFields_1$1.OutputTypes.WITNESS_SCRIPT
          ), pe.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          pe.witnessScript = convert$1.outputs.witnessScript.decode(rt);
          break;
        case typeFields_1$1.OutputTypes.BIP32_DERIVATION:
          pe.bip32Derivation === void 0 && (pe.bip32Derivation = []), pe.bip32Derivation.push(
            convert$1.outputs.bip32Derivation.decode(rt)
          );
          break;
        case typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "output",
            rt.key,
            typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY
          ), pe.tapInternalKey = convert$1.outputs.tapInternalKey.decode(rt);
          break;
        case typeFields_1$1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            "output",
            rt.key,
            typeFields_1$1.OutputTypes.TAP_TREE
          ), pe.tapTree = convert$1.outputs.tapTree.decode(rt);
          break;
        case typeFields_1$1.OutputTypes.TAP_BIP32_DERIVATION:
          pe.tapBip32Derivation === void 0 && (pe.tapBip32Derivation = []), pe.tapBip32Derivation.push(
            convert$1.outputs.tapBip32Derivation.decode(rt)
          );
          break;
        default:
          pe.unknownKeyVals || (pe.unknownKeyVals = []), pe.unknownKeyVals.push(rt);
      }
    ke.push(pe);
  }
  return { globalMap: J, inputs: oe, outputs: ke };
}
fromBuffer.psbtFromKeyVals = psbtFromKeyVals;
var toBuffer = {};
Object.defineProperty(toBuffer, "__esModule", { value: !0 });
const convert = converter, tools_1 = tools;
function psbtToBuffer({ globalMap: A, inputs: B, outputs: W }) {
  const { globalKeyVals: K, inputKeyVals: J, outputKeyVals: L } = psbtToKeyVals({
    globalMap: A,
    inputs: B,
    outputs: W
  }), re = tools_1.keyValsToBuffer(K), ie = (pe) => pe.length === 0 ? [Buffer$1.from([0])] : pe.map(tools_1.keyValsToBuffer), oe = ie(J), ke = ie(L), ne = Buffer$1.allocUnsafe(5);
  return ne.writeUIntBE(482972169471, 0, 5), Buffer$1.concat(
    [ne, re].concat(oe, ke)
  );
}
toBuffer.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (A, B) => A.key.compare(B.key);
function keyValsFromMap(A, B) {
  const W = /* @__PURE__ */ new Set(), K = Object.entries(A).reduce((L, [re, ie]) => {
    if (re === "unknownKeyVals") return L;
    const oe = B[re];
    if (oe === void 0) return L;
    const ke = (Array.isArray(ie) ? ie : [ie]).map(
      oe.encode
    );
    return ke.map((pe) => pe.key.toString("hex")).forEach((pe) => {
      if (W.has(pe))
        throw new Error("Serialize Error: Duplicate key: " + pe);
      W.add(pe);
    }), L.concat(ke);
  }, []), J = A.unknownKeyVals ? A.unknownKeyVals.filter((L) => !W.has(L.key.toString("hex"))) : [];
  return K.concat(J).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap: A, inputs: B, outputs: W }) {
  return {
    globalKeyVals: keyValsFromMap(A, convert.globals),
    inputKeyVals: B.map((K) => keyValsFromMap(K, convert.inputs)),
    outputKeyVals: W.map((K) => keyValsFromMap(K, convert.outputs))
  };
}
toBuffer.psbtToKeyVals = psbtToKeyVals;
(function(A) {
  function B(W) {
    for (var K in W) A.hasOwnProperty(K) || (A[K] = W[K]);
  }
  Object.defineProperty(A, "__esModule", { value: !0 }), B(fromBuffer), B(toBuffer);
})(parser);
Object.defineProperty(combiner, "__esModule", { value: !0 });
const parser_1$1 = parser;
function combine(A) {
  const B = A[0], W = parser_1$1.psbtToKeyVals(B), K = A.slice(1);
  if (K.length === 0) throw new Error("Combine: Nothing to combine");
  const J = getTx(B);
  if (J === void 0)
    throw new Error("Combine: Self missing transaction");
  const L = getKeySet(W.globalKeyVals), re = W.inputKeyVals.map(getKeySet), ie = W.outputKeyVals.map(getKeySet);
  for (const oe of K) {
    const ke = getTx(oe);
    if (ke === void 0 || !ke.toBuffer().equals(J.toBuffer()))
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const ne = parser_1$1.psbtToKeyVals(oe);
    getKeySet(ne.globalKeyVals).forEach(
      keyPusher(
        L,
        W.globalKeyVals,
        ne.globalKeyVals
      )
    ), ne.inputKeyVals.map(getKeySet).forEach(
      (ot, ut) => ot.forEach(
        keyPusher(
          re[ut],
          W.inputKeyVals[ut],
          ne.inputKeyVals[ut]
        )
      )
    ), ne.outputKeyVals.map(getKeySet).forEach(
      (ot, ut) => ot.forEach(
        keyPusher(
          ie[ut],
          W.outputKeyVals[ut],
          ne.outputKeyVals[ut]
        )
      )
    );
  }
  return parser_1$1.psbtFromKeyVals(J, {
    globalMapKeyVals: W.globalKeyVals,
    inputKeyVals: W.inputKeyVals,
    outputKeyVals: W.outputKeyVals
  });
}
combiner.combine = combine;
function keyPusher(A, B, W) {
  return (K) => {
    if (A.has(K)) return;
    const J = W.filter((L) => L.key.toString("hex") === K)[0];
    B.push(J), A.add(K);
  };
}
function getTx(A) {
  return A.globalMap.unsignedTx;
}
function getKeySet(A) {
  const B = /* @__PURE__ */ new Set();
  return A.forEach((W) => {
    const K = W.key.toString("hex");
    if (B.has(K))
      throw new Error("Combine: KeyValue Map keys should be unique");
    B.add(K);
  }), B;
}
var utils = {};
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 });
  const B = converter;
  function W(nt, ot) {
    const ut = nt[ot];
    if (ut === void 0) throw new Error(`No input #${ot}`);
    return ut;
  }
  A.checkForInput = W;
  function K(nt, ot) {
    const ut = nt[ot];
    if (ut === void 0) throw new Error(`No output #${ot}`);
    return ut;
  }
  A.checkForOutput = K;
  function J(nt, ot, ut) {
    if (nt.key[0] < ut)
      throw new Error(
        "Use the method for your specific key instead of addUnknownKeyVal*"
      );
    if (ot && ot.filter((dt) => dt.key.equals(nt.key)).length !== 0)
      throw new Error(`Duplicate Key: ${nt.key.toString("hex")}`);
  }
  A.checkHasKey = J;
  function L(nt) {
    let ot = 0;
    return Object.keys(nt).forEach((ut) => {
      Number(isNaN(Number(ut))) && ot++;
    }), ot;
  }
  A.getEnumLength = L;
  function re(nt, ot) {
    let ut = !1;
    if (ot.nonWitnessUtxo || ot.witnessUtxo) {
      const dt = !!ot.redeemScript, vt = !!ot.witnessScript, pt = !dt || !!ot.finalScriptSig, mt = !vt || !!ot.finalScriptWitness, gt = !!ot.finalScriptSig || !!ot.finalScriptWitness;
      ut = pt && mt && gt;
    }
    if (ut === !1)
      throw new Error(
        `Input #${nt} has too much or too little data to clean`
      );
  }
  A.inputCheckUncleanFinalized = re;
  function ie(nt, ot, ut, dt) {
    throw new Error(
      `Data for ${nt} key ${ot} is incorrect: Expected ${ut} and got ${JSON.stringify(dt)}`
    );
  }
  function oe(nt) {
    return (ot, ut) => {
      for (const dt of Object.keys(ot)) {
        const vt = ot[dt], { canAdd: pt, canAddToArray: mt, check: gt, expected: Pt } = (
          // @ts-ignore
          B[nt + "s"][dt] || {}
        ), xt = !!mt;
        if (gt)
          if (xt) {
            if (!Array.isArray(vt) || // @ts-ignore
            ut[dt] && !Array.isArray(ut[dt]))
              throw new Error(`Key type ${dt} must be an array`);
            vt.every(gt) || ie(nt, dt, Pt, vt);
            const Nt = ut[dt] || [], Et = /* @__PURE__ */ new Set();
            if (!vt.every((bt) => mt(Nt, bt, Et)))
              throw new Error("Can not add duplicate data to array");
            ut[dt] = Nt.concat(vt);
          } else {
            if (gt(vt) || ie(nt, dt, Pt, vt), !pt(ut, vt))
              throw new Error(`Can not add duplicate data to ${nt}`);
            ut[dt] = vt;
          }
      }
    };
  }
  A.updateGlobal = oe("global"), A.updateInput = oe("input"), A.updateOutput = oe("output");
  function ke(nt, ot) {
    const ut = nt.length - 1, dt = W(nt, ut);
    A.updateInput(ot, dt);
  }
  A.addInputAttributes = ke;
  function ne(nt, ot) {
    const ut = nt.length - 1, dt = K(nt, ut);
    A.updateOutput(ot, dt);
  }
  A.addOutputAttributes = ne;
  function pe(nt, ot) {
    if (!Buffer$1.isBuffer(ot) || ot.length < 4)
      throw new Error("Set Version: Invalid Transaction");
    return ot.writeUInt32LE(nt, 0), ot;
  }
  A.defaultVersionSetter = pe;
  function rt(nt, ot) {
    if (!Buffer$1.isBuffer(ot) || ot.length < 4)
      throw new Error("Set Locktime: Invalid Transaction");
    return ot.writeUInt32LE(nt, ot.length - 4), ot;
  }
  A.defaultLocktimeSetter = rt;
})(utils);
Object.defineProperty(psbt, "__esModule", { value: !0 });
const combiner_1 = combiner, parser_1 = parser, typeFields_1 = typeFields, utils_1$1 = utils;
let Psbt$1 = class {
  constructor(B) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: B
    };
  }
  static fromBase64(B, W) {
    const K = Buffer$1.from(B, "base64");
    return this.fromBuffer(K, W);
  }
  static fromHex(B, W) {
    const K = Buffer$1.from(B, "hex");
    return this.fromBuffer(K, W);
  }
  static fromBuffer(B, W) {
    const K = parser_1.psbtFromBuffer(B, W), J = new this(K.globalMap.unsignedTx);
    return Object.assign(J, K), J;
  }
  toBase64() {
    return this.toBuffer().toString("base64");
  }
  toHex() {
    return this.toBuffer().toString("hex");
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(B) {
    return utils_1$1.updateGlobal(B, this.globalMap), this;
  }
  updateInput(B, W) {
    const K = utils_1$1.checkForInput(this.inputs, B);
    return utils_1$1.updateInput(W, K), this;
  }
  updateOutput(B, W) {
    const K = utils_1$1.checkForOutput(this.outputs, B);
    return utils_1$1.updateOutput(W, K), this;
  }
  addUnknownKeyValToGlobal(B) {
    return utils_1$1.checkHasKey(
      B,
      this.globalMap.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.GlobalTypes)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(B), this;
  }
  addUnknownKeyValToInput(B, W) {
    const K = utils_1$1.checkForInput(this.inputs, B);
    return utils_1$1.checkHasKey(
      W,
      K.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.InputTypes)
    ), K.unknownKeyVals || (K.unknownKeyVals = []), K.unknownKeyVals.push(W), this;
  }
  addUnknownKeyValToOutput(B, W) {
    const K = utils_1$1.checkForOutput(this.outputs, B);
    return utils_1$1.checkHasKey(
      W,
      K.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.OutputTypes)
    ), K.unknownKeyVals || (K.unknownKeyVals = []), K.unknownKeyVals.push(W), this;
  }
  addInput(B) {
    this.globalMap.unsignedTx.addInput(B), this.inputs.push({
      unknownKeyVals: []
    });
    const W = B.unknownKeyVals || [], K = this.inputs.length - 1;
    if (!Array.isArray(W))
      throw new Error("unknownKeyVals must be an Array");
    return W.forEach(
      (J) => this.addUnknownKeyValToInput(K, J)
    ), utils_1$1.addInputAttributes(this.inputs, B), this;
  }
  addOutput(B) {
    this.globalMap.unsignedTx.addOutput(B), this.outputs.push({
      unknownKeyVals: []
    });
    const W = B.unknownKeyVals || [], K = this.outputs.length - 1;
    if (!Array.isArray(W))
      throw new Error("unknownKeyVals must be an Array");
    return W.forEach(
      (J) => this.addUnknownKeyValToOutput(K, J)
    ), utils_1$1.addOutputAttributes(this.outputs, B), this;
  }
  clearFinalizedInput(B) {
    const W = utils_1$1.checkForInput(this.inputs, B);
    utils_1$1.inputCheckUncleanFinalized(B, W);
    for (const K of Object.keys(W))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(K) || delete W[K];
    return this;
  }
  combine(...B) {
    const W = combiner_1.combine([this].concat(B));
    return Object.assign(this, W), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
psbt.Psbt = Psbt$1;
var bip371 = {}, psbtutils = {};
Object.defineProperty(psbtutils, "__esModule", { value: !0 });
psbtutils.signatureBlocksAction = psbtutils.checkInputForSig = psbtutils.pubkeyInScript = psbtutils.pubkeyPositionInScript = psbtutils.witnessStackToScriptWitness = psbtutils.isP2TR = psbtutils.isP2SHScript = psbtutils.isP2WSHScript = psbtutils.isP2WPKH = psbtutils.isP2PKH = psbtutils.isP2PK = psbtutils.isP2MS = void 0;
const varuint$1 = varint, bscript$1 = requireScript(), transaction_1$2 = transaction, crypto_1 = crypto$1, payments$1 = requirePayments();
function isPaymentFactory(A) {
  return (B) => {
    try {
      return A({ output: B }), !0;
    } catch {
      return !1;
    }
  };
}
psbtutils.isP2MS = isPaymentFactory(payments$1.p2ms);
psbtutils.isP2PK = isPaymentFactory(payments$1.p2pk);
psbtutils.isP2PKH = isPaymentFactory(payments$1.p2pkh);
psbtutils.isP2WPKH = isPaymentFactory(payments$1.p2wpkh);
psbtutils.isP2WSHScript = isPaymentFactory(payments$1.p2wsh);
psbtutils.isP2SHScript = isPaymentFactory(payments$1.p2sh);
psbtutils.isP2TR = isPaymentFactory(payments$1.p2tr);
function witnessStackToScriptWitness(A) {
  let B = Buffer$1.allocUnsafe(0);
  function W(re) {
    B = Buffer$1.concat([B, Buffer$1.from(re)]);
  }
  function K(re) {
    const ie = B.length, oe = varuint$1.encodingLength(re);
    B = Buffer$1.concat([B, Buffer$1.allocUnsafe(oe)]), varuint$1.encode(re, B, ie);
  }
  function J(re) {
    K(re.length), W(re);
  }
  function L(re) {
    K(re.length), re.forEach(J);
  }
  return L(A), B;
}
psbtutils.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(A, B) {
  const W = (0, crypto_1.hash160)(A), K = A.slice(1, 33), J = bscript$1.decompile(B);
  if (J === null) throw new Error("Unknown script error");
  return J.findIndex((L) => typeof L == "number" ? !1 : L.equals(A) || L.equals(W) || L.equals(K));
}
psbtutils.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(A, B) {
  return pubkeyPositionInScript(A, B) !== -1;
}
psbtutils.pubkeyInScript = pubkeyInScript;
function checkInputForSig(A, B) {
  return extractPartialSigs(A).some(
    (K) => signatureBlocksAction(K, bscript$1.signature.decode, B)
  );
}
psbtutils.checkInputForSig = checkInputForSig;
function signatureBlocksAction(A, B, W) {
  const { hashType: K } = B(A), J = [];
  switch (K & transaction_1$2.Transaction.SIGHASH_ANYONECANPAY && J.push("addInput"), K & 31) {
    case transaction_1$2.Transaction.SIGHASH_ALL:
      break;
    case transaction_1$2.Transaction.SIGHASH_SINGLE:
    case transaction_1$2.Transaction.SIGHASH_NONE:
      J.push("addOutput"), J.push("setInputSequence");
      break;
  }
  return J.indexOf(W) === -1;
}
psbtutils.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(A) {
  let B = [];
  if ((A.partialSig || []).length === 0) {
    if (!A.finalScriptSig && !A.finalScriptWitness) return [];
    B = getPsigsFromInputFinalScripts(A);
  } else
    B = A.partialSig;
  return B.map((W) => W.signature);
}
function getPsigsFromInputFinalScripts(A) {
  const B = A.finalScriptSig ? bscript$1.decompile(A.finalScriptSig) || [] : [], W = A.finalScriptWitness ? bscript$1.decompile(A.finalScriptWitness) || [] : [];
  return B.concat(W).filter((K) => Buffer$1.isBuffer(K) && bscript$1.isCanonicalScriptSignature(K)).map((K) => ({ signature: K }));
}
Object.defineProperty(bip371, "__esModule", { value: !0 });
bip371.checkTaprootInputForSigs = bip371.tapTreeFromList = bip371.tapTreeToList = bip371.tweakInternalPubKey = bip371.checkTaprootOutputFields = bip371.checkTaprootInputFields = bip371.isTaprootOutput = bip371.isTaprootInput = bip371.serializeTaprootSignature = bip371.tapScriptFinalizer = bip371.toXOnly = void 0;
const types_1 = types$4, transaction_1$1 = transaction, psbtutils_1$1 = psbtutils, bip341_1$1 = bip341, payments_1 = requirePayments(), psbtutils_2 = psbtutils, toXOnly = (A) => A.length === 32 ? A : A.slice(1, 33);
bip371.toXOnly = toXOnly;
function tapScriptFinalizer(A, B, W) {
  const K = findTapLeafToFinalize(
    B,
    A,
    W
  );
  try {
    const L = sortSignatures(B, K).concat(K.script).concat(K.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1$1.witnessStackToScriptWitness)(L)
    };
  } catch (J) {
    throw new Error(`Can not finalize taproot input #${A}: ${J}`);
  }
}
bip371.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(A, B) {
  const W = B ? Buffer$1.from([B]) : Buffer$1.from([]);
  return Buffer$1.concat([A, W]);
}
bip371.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(A) {
  return A && !!(A.tapInternalKey || A.tapMerkleRoot || A.tapLeafScript && A.tapLeafScript.length || A.tapBip32Derivation && A.tapBip32Derivation.length || A.witnessUtxo && (0, psbtutils_1$1.isP2TR)(A.witnessUtxo.script));
}
bip371.isTaprootInput = isTaprootInput;
function isTaprootOutput(A, B) {
  return A && !!(A.tapInternalKey || A.tapTree || A.tapBip32Derivation && A.tapBip32Derivation.length || B && (0, psbtutils_1$1.isP2TR)(B));
}
bip371.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(A, B, W) {
  checkMixedTaprootAndNonTaprootInputFields(A, B, W), checkIfTapLeafInTree(A, B, W);
}
bip371.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(A, B, W) {
  checkMixedTaprootAndNonTaprootOutputFields(A, B, W), checkTaprootScriptPubkey(A, B);
}
bip371.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(A, B) {
  if (!B.tapTree && !B.tapInternalKey) return;
  const W = B.tapInternalKey || A.tapInternalKey, K = B.tapTree || A.tapTree;
  if (W) {
    const { script: J } = A, L = getTaprootScripPubkey(W, K);
    if (J && !J.equals(L))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function getTaprootScripPubkey(A, B) {
  const W = B && tapTreeFromList(B.leaves), { output: K } = (0, payments_1.p2tr)({
    internalPubkey: A,
    scriptTree: W
  });
  return K;
}
function tweakInternalPubKey(A, B) {
  const W = B.tapInternalKey, K = W && (0, bip341_1$1.tweakKey)(W, B.tapMerkleRoot);
  if (!K)
    throw new Error(
      `Cannot tweak tap internal key for input #${A}. Public key: ${W && W.toString("hex")}`
    );
  return K.x;
}
bip371.tweakInternalPubKey = tweakInternalPubKey;
function tapTreeToList(A) {
  if (!(0, types_1.isTaptree)(A))
    throw new Error(
      "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
    );
  return _tapTreeToList(A);
}
bip371.tapTreeToList = tapTreeToList;
function tapTreeFromList(A = []) {
  return A.length === 1 && A[0].depth === 0 ? {
    output: A[0].script,
    version: A[0].leafVersion
  } : instertLeavesInTree(A);
}
bip371.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(A, B) {
  return extractTaprootSigs(A).some(
    (K) => (0, psbtutils_2.signatureBlocksAction)(K, decodeSchnorrSignature, B)
  );
}
bip371.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(A) {
  return {
    signature: A.slice(0, 64),
    hashType: A.slice(64)[0] || transaction_1$1.Transaction.SIGHASH_DEFAULT
  };
}
function extractTaprootSigs(A) {
  const B = [];
  if (A.tapKeySig && B.push(A.tapKeySig), A.tapScriptSig && B.push(...A.tapScriptSig.map((W) => W.signature)), !B.length) {
    const W = getTapKeySigFromWithness(A.finalScriptWitness);
    W && B.push(W);
  }
  return B;
}
function getTapKeySigFromWithness(A) {
  if (!A) return;
  const B = A.slice(2);
  if (B.length === 64 || B.length === 65) return B;
}
function _tapTreeToList(A, B = [], W = 0) {
  if (W > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  return A ? (0, types_1.isTapleaf)(A) ? (B.push({
    depth: W,
    leafVersion: A.version || bip341_1$1.LEAF_VERSION_TAPSCRIPT,
    script: A.output
  }), B) : (A[0] && _tapTreeToList(A[0], B, W + 1), A[1] && _tapTreeToList(A[1], B, W + 1), B) : [];
}
function instertLeavesInTree(A) {
  let B;
  for (const W of A)
    if (B = instertLeafInTree(W, B), !B) throw new Error("No room left to insert tapleaf in tree");
  return B;
}
function instertLeafInTree(A, B, W = 0) {
  if (W > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  if (A.depth === W)
    return B ? void 0 : {
      output: A.script,
      version: A.leafVersion
    };
  if ((0, types_1.isTapleaf)(B)) return;
  const K = instertLeafInTree(A, B && B[0], W + 1);
  if (K) return [K, B && B[1]];
  const J = instertLeafInTree(A, B && B[1], W + 1);
  if (J) return [B && B[0], J];
}
function checkMixedTaprootAndNonTaprootInputFields(A, B, W) {
  const K = isTaprootInput(A) && hasNonTaprootFields(B), J = hasNonTaprootFields(A) && isTaprootInput(B), L = A === B && isTaprootInput(B) && hasNonTaprootFields(B);
  if (K || J || L)
    throw new Error(
      `Invalid arguments for Psbt.${W}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(A, B, W) {
  const K = isTaprootOutput(A) && hasNonTaprootFields(B), J = hasNonTaprootFields(A) && isTaprootOutput(B), L = A === B && isTaprootOutput(B) && hasNonTaprootFields(B);
  if (K || J || L)
    throw new Error(
      `Invalid arguments for Psbt.${W}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkIfTapLeafInTree(A, B, W) {
  if (B.tapMerkleRoot) {
    const K = (B.tapLeafScript || []).every(
      (L) => isTapLeafInTree(L, B.tapMerkleRoot)
    ), J = (A.tapLeafScript || []).every(
      (L) => isTapLeafInTree(L, B.tapMerkleRoot)
    );
    if (!K || !J)
      throw new Error(
        `Invalid arguments for Psbt.${W}. Tapleaf not part of taptree.`
      );
  } else if (A.tapMerkleRoot && !(B.tapLeafScript || []).every(
    (J) => isTapLeafInTree(J, A.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${W}. Tapleaf not part of taptree.`
    );
}
function isTapLeafInTree(A, B) {
  if (!B) return !0;
  const W = (0, bip341_1$1.tapleafHash)({
    output: A.script,
    version: A.leafVersion
  });
  return (0, bip341_1$1.rootHashFromPath)(
    A.controlBlock,
    W
  ).equals(B);
}
function sortSignatures(A, B) {
  const W = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (A.tapScriptSig || []).filter((K) => K.leafHash.equals(W)).map((K) => addPubkeyPositionInScript(B.script, K)).sort((K, J) => J.positionInScript - K.positionInScript).map((K) => K.signature);
}
function addPubkeyPositionInScript(A, B) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1$1.pubkeyPositionInScript)(
        B.pubkey,
        A
      )
    },
    B
  );
}
function findTapLeafToFinalize(A, B, W) {
  if (!A.tapScriptSig || !A.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${B}. No tapleaf script signature provided.`
    );
  const K = (A.tapLeafScript || []).sort((J, L) => J.controlBlock.length - L.controlBlock.length).find(
    (J) => canFinalizeLeaf(J, A.tapScriptSig, W)
  );
  if (!K)
    throw new Error(
      `Can not finalize taproot input #${B}. Signature for tapleaf script not found.`
    );
  return K;
}
function canFinalizeLeaf(A, B, W) {
  const K = (0, bip341_1$1.tapleafHash)({
    output: A.script,
    version: A.leafVersion
  });
  return (!W || W.equals(K)) && B.find((L) => L.leafHash.equals(K)) !== void 0;
}
function hasNonTaprootFields(A) {
  return A && !!(A.redeemScript || A.witnessScript || A.bip32Derivation && A.bip32Derivation.length);
}
Object.defineProperty(psbt$1, "__esModule", { value: !0 });
psbt$1.Psbt = void 0;
const bip174_1 = psbt, varuint = varint, utils_1 = utils, address_1 = requireAddress(), bufferutils_1 = bufferutils, networks_1 = networks, payments = requirePayments(), bip341_1 = bip341, bscript = requireScript(), transaction_1 = transaction, bip371_1 = bip371, psbtutils_1 = psbtutils, DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Psbt {
  static fromBase64(B, W = {}) {
    const K = Buffer$1.from(B, "base64");
    return this.fromBuffer(K, W);
  }
  static fromHex(B, W = {}) {
    const K = Buffer$1.from(B, "hex");
    return this.fromBuffer(K, W);
  }
  static fromBuffer(B, W = {}) {
    const K = bip174_1.Psbt.fromBuffer(B, transactionFromBuffer), J = new Psbt(W, K);
    return checkTxForDupeIns(J.__CACHE.__TX, J.__CACHE), J;
  }
  constructor(B = {}, W = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = W, this.opts = Object.assign({}, DEFAULT_OPTS, B), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const K = (J, L, re, ie) => Object.defineProperty(J, L, {
      enumerable: re,
      writable: ie
    });
    K(this, "__CACHE", !1, !0), K(this, "opts", !1, !0);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(B) {
    this.setVersion(B);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(B) {
    this.setLocktime(B);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((B) => ({
      hash: (0, bufferutils_1.cloneBuffer)(B.hash),
      index: B.index,
      sequence: B.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((B) => {
      let W;
      try {
        W = (0, address_1.fromOutputScript)(
          B.script,
          this.opts.network
        );
      } catch {
      }
      return {
        script: (0, bufferutils_1.cloneBuffer)(B.script),
        value: B.value,
        address: W
      };
    });
  }
  combine(...B) {
    return this.data.combine(...B.map((W) => W.data)), this;
  }
  clone() {
    const B = Psbt.fromBuffer(this.data.toBuffer());
    return B.opts = JSON.parse(JSON.stringify(this.opts)), B;
  }
  setMaximumFeeRate(B) {
    check32Bit(B), this.opts.maximumFeeRate = B;
  }
  setVersion(B) {
    check32Bit(B), checkInputsForPartialSig(this.data.inputs, "setVersion");
    const W = this.__CACHE;
    return W.__TX.version = B, W.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(B) {
    check32Bit(B), checkInputsForPartialSig(this.data.inputs, "setLocktime");
    const W = this.__CACHE;
    return W.__TX.locktime = B, W.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(B, W) {
    check32Bit(W), checkInputsForPartialSig(this.data.inputs, "setInputSequence");
    const K = this.__CACHE;
    if (K.__TX.ins.length <= B)
      throw new Error("Input index too high");
    return K.__TX.ins[B].sequence = W, K.__EXTRACTED_TX = void 0, this;
  }
  addInputs(B) {
    return B.forEach((W) => this.addInput(W)), this;
  }
  addInput(B) {
    if (arguments.length > 1 || !B || B.hash === void 0 || B.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    (0, bip371_1.checkTaprootInputFields)(B, B, "addInput"), checkInputsForPartialSig(this.data.inputs, "addInput"), B.witnessScript && checkInvalidP2WSH(B.witnessScript);
    const W = this.__CACHE;
    this.data.addInput(B);
    const K = W.__TX.ins[W.__TX.ins.length - 1];
    checkTxInputCache(W, K);
    const J = this.data.inputs.length - 1, L = this.data.inputs[J];
    return L.nonWitnessUtxo && addNonWitnessTxCache(this.__CACHE, L, J), W.__FEE = void 0, W.__FEE_RATE = void 0, W.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(B) {
    return B.forEach((W) => this.addOutput(W)), this;
  }
  addOutput(B) {
    if (arguments.length > 1 || !B || B.value === void 0 || B.address === void 0 && B.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    checkInputsForPartialSig(this.data.inputs, "addOutput");
    const { address: W } = B;
    if (typeof W == "string") {
      const { network: J } = this.opts, L = (0, address_1.toOutputScript)(W, J);
      B = Object.assign({}, B, { script: L });
    }
    (0, bip371_1.checkTaprootOutputFields)(B, B, "addOutput");
    const K = this.__CACHE;
    return this.data.addOutput(B), K.__FEE = void 0, K.__FEE_RATE = void 0, K.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(B) {
    if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
    const W = this.__CACHE;
    if (B || checkFees(this, W, this.opts), W.__EXTRACTED_TX) return W.__EXTRACTED_TX;
    const K = W.__TX.clone();
    return inputFinalizeGetAmts(this.data.inputs, K, W, !0), K;
  }
  getFeeRate() {
    return getTxCacheValue(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).forEach((B) => this.finalizeInput(B)), this;
  }
  finalizeInput(B, W) {
    const K = (0, utils_1.checkForInput)(this.data.inputs, B);
    return (0, bip371_1.isTaprootInput)(K) ? this._finalizeTaprootInput(
      B,
      K,
      void 0,
      W
    ) : this._finalizeInput(B, K, W);
  }
  finalizeTaprootInput(B, W, K = bip371_1.tapScriptFinalizer) {
    const J = (0, utils_1.checkForInput)(this.data.inputs, B);
    if ((0, bip371_1.isTaprootInput)(J))
      return this._finalizeTaprootInput(
        B,
        J,
        W,
        K
      );
    throw new Error(`Cannot finalize input #${B}. Not Taproot.`);
  }
  _finalizeInput(B, W, K = getFinalScripts) {
    const { script: J, isP2SH: L, isP2WSH: re, isSegwit: ie } = getScriptFromInput(
      B,
      W,
      this.__CACHE
    );
    if (!J) throw new Error(`No script found for input #${B}`);
    checkPartialSigSighashes(W);
    const { finalScriptSig: oe, finalScriptWitness: ke } = K(
      B,
      W,
      J,
      ie,
      L,
      re
    );
    if (oe && this.data.updateInput(B, { finalScriptSig: oe }), ke && this.data.updateInput(B, { finalScriptWitness: ke }), !oe && !ke)
      throw new Error(`Unknown error finalizing input #${B}`);
    return this.data.clearFinalizedInput(B), this;
  }
  _finalizeTaprootInput(B, W, K, J = bip371_1.tapScriptFinalizer) {
    if (!W.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${B}. Missing withness utxo.`
      );
    if (W.tapKeySig) {
      const L = payments.p2tr({
        output: W.witnessUtxo.script,
        signature: W.tapKeySig
      }), re = (0, psbtutils_1.witnessStackToScriptWitness)(
        L.witness
      );
      this.data.updateInput(B, { finalScriptWitness: re });
    } else {
      const { finalScriptWitness: L } = J(
        B,
        W,
        K
      );
      this.data.updateInput(B, { finalScriptWitness: L });
    }
    return this.data.clearFinalizedInput(B), this;
  }
  getInputType(B) {
    const W = (0, utils_1.checkForInput)(this.data.inputs, B), K = getScriptFromUtxo(B, W, this.__CACHE), J = getMeaningfulScript(
      K,
      B,
      "input",
      W.redeemScript || redeemFromFinalScriptSig(W.finalScriptSig),
      W.witnessScript || redeemFromFinalWitnessScript(W.finalScriptWitness)
    ), L = J.type === "raw" ? "" : J.type + "-", re = classifyScript(J.meaningfulScript);
    return L + re;
  }
  inputHasPubkey(B, W) {
    const K = (0, utils_1.checkForInput)(this.data.inputs, B);
    return pubkeyInInput(W, K, B, this.__CACHE);
  }
  inputHasHDKey(B, W) {
    const K = (0, utils_1.checkForInput)(this.data.inputs, B), J = bip32DerivationIsMine(W);
    return !!K.bip32Derivation && K.bip32Derivation.some(J);
  }
  outputHasPubkey(B, W) {
    const K = (0, utils_1.checkForOutput)(this.data.outputs, B);
    return pubkeyInOutput(W, K, B, this.__CACHE);
  }
  outputHasHDKey(B, W) {
    const K = (0, utils_1.checkForOutput)(this.data.outputs, B), J = bip32DerivationIsMine(W);
    return !!K.bip32Derivation && K.bip32Derivation.some(J);
  }
  validateSignaturesOfAllInputs(B) {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).map(
      (K) => this.validateSignaturesOfInput(K, B)
    ).reduce((K, J) => J === !0 && K, !0);
  }
  validateSignaturesOfInput(B, W, K) {
    const J = this.data.inputs[B];
    return (0, bip371_1.isTaprootInput)(J) ? this.validateSignaturesOfTaprootInput(
      B,
      W,
      K
    ) : this._validateSignaturesOfInput(B, W, K);
  }
  _validateSignaturesOfInput(B, W, K) {
    const J = this.data.inputs[B], L = (J || {}).partialSig;
    if (!J || !L || L.length < 1)
      throw new Error("No signatures to validate");
    if (typeof W != "function")
      throw new Error("Need validator function to validate signatures");
    const re = K ? L.filter((pe) => pe.pubkey.equals(K)) : L;
    if (re.length < 1) throw new Error("No signatures for this pubkey");
    const ie = [];
    let oe, ke, ne;
    for (const pe of re) {
      const rt = bscript.signature.decode(pe.signature), { hash: nt, script: ot } = ne !== rt.hashType ? getHashForSig(
        B,
        Object.assign({}, J, { sighashType: rt.hashType }),
        this.__CACHE,
        !0
      ) : { hash: oe, script: ke };
      ne = rt.hashType, oe = nt, ke = ot, checkScriptForPubkey(pe.pubkey, ot, "verify"), ie.push(W(pe.pubkey, nt, rt.signature));
    }
    return ie.every((pe) => pe === !0);
  }
  validateSignaturesOfTaprootInput(B, W, K) {
    const J = this.data.inputs[B], L = (J || {}).tapKeySig, re = (J || {}).tapScriptSig;
    if (!J && !L && !(re && !re.length))
      throw new Error("No signatures to validate");
    if (typeof W != "function")
      throw new Error("Need validator function to validate signatures");
    K = K && (0, bip371_1.toXOnly)(K);
    const ie = K ? getTaprootHashesForSig(
      B,
      J,
      this.data.inputs,
      K,
      this.__CACHE
    ) : getAllTaprootHashesForSig(
      B,
      J,
      this.data.inputs,
      this.__CACHE
    );
    if (!ie.length) throw new Error("No signatures for this pubkey");
    const oe = ie.find((ne) => !ne.leafHash);
    let ke = 0;
    if (L && oe) {
      if (!W(
        oe.pubkey,
        oe.hash,
        trimTaprootSig(L)
      )) return !1;
      ke++;
    }
    if (re)
      for (const ne of re) {
        const pe = ie.find((rt) => ne.pubkey.equals(rt.pubkey));
        if (pe) {
          if (!W(
            ne.pubkey,
            pe.hash,
            trimTaprootSig(ne.signature)
          )) return !1;
          ke++;
        }
      }
    return ke > 0;
  }
  signAllInputsHD(B, W = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!B || !B.publicKey || !B.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const K = [];
    for (const J of range(this.data.inputs.length))
      try {
        this.signInputHD(J, B, W), K.push(!0);
      } catch {
        K.push(!1);
      }
    if (K.every((J) => J === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(B, W = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((K, J) => {
      if (!B || !B.publicKey || !B.fingerprint)
        return J(new Error("Need HDSigner to sign input"));
      const L = [], re = [];
      for (const ie of range(this.data.inputs.length))
        re.push(
          this.signInputHDAsync(ie, B, W).then(
            () => {
              L.push(!0);
            },
            () => {
              L.push(!1);
            }
          )
        );
      return Promise.all(re).then(() => {
        if (L.every((ie) => ie === !1))
          return J(new Error("No inputs were signed"));
        K();
      });
    });
  }
  signInputHD(B, W, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!W || !W.publicKey || !W.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return getSignersFromHD(B, this.data.inputs, W).forEach((L) => this.signInput(B, L, K)), this;
  }
  signInputHDAsync(B, W, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((J, L) => {
      if (!W || !W.publicKey || !W.fingerprint)
        return L(new Error("Need HDSigner to sign input"));
      const ie = getSignersFromHD(B, this.data.inputs, W).map(
        (oe) => this.signInputAsync(B, oe, K)
      );
      return Promise.all(ie).then(() => {
        J();
      }).catch(L);
    });
  }
  signAllInputs(B, W) {
    if (!B || !B.publicKey)
      throw new Error("Need Signer to sign input");
    const K = [];
    for (const J of range(this.data.inputs.length))
      try {
        this.signInput(J, B, W), K.push(!0);
      } catch {
        K.push(!1);
      }
    if (K.every((J) => J === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(B, W) {
    return new Promise((K, J) => {
      if (!B || !B.publicKey)
        return J(new Error("Need Signer to sign input"));
      const L = [], re = [];
      for (const [ie] of this.data.inputs.entries())
        re.push(
          this.signInputAsync(ie, B, W).then(
            () => {
              L.push(!0);
            },
            () => {
              L.push(!1);
            }
          )
        );
      return Promise.all(re).then(() => {
        if (L.every((ie) => ie === !1))
          return J(new Error("No inputs were signed"));
        K();
      });
    });
  }
  signInput(B, W, K) {
    if (!W || !W.publicKey)
      throw new Error("Need Signer to sign input");
    const J = (0, utils_1.checkForInput)(this.data.inputs, B);
    return (0, bip371_1.isTaprootInput)(J) ? this._signTaprootInput(
      B,
      J,
      W,
      void 0,
      K
    ) : this._signInput(B, W, K);
  }
  signTaprootInput(B, W, K, J) {
    if (!W || !W.publicKey)
      throw new Error("Need Signer to sign input");
    const L = (0, utils_1.checkForInput)(this.data.inputs, B);
    if ((0, bip371_1.isTaprootInput)(L))
      return this._signTaprootInput(
        B,
        L,
        W,
        K,
        J
      );
    throw new Error(`Input #${B} is not of type Taproot.`);
  }
  _signInput(B, W, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: J, sighashType: L } = getHashAndSighashType(
      this.data.inputs,
      B,
      W.publicKey,
      this.__CACHE,
      K
    ), re = [
      {
        pubkey: W.publicKey,
        signature: bscript.signature.encode(W.sign(J), L)
      }
    ];
    return this.data.updateInput(B, { partialSig: re }), this;
  }
  _signTaprootInput(B, W, K, J, L = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const re = this.checkTaprootHashesForSig(
      B,
      W,
      K,
      J,
      L
    ), ie = re.filter((ke) => !ke.leafHash).map(
      (ke) => (0, bip371_1.serializeTaprootSignature)(
        K.signSchnorr(ke.hash),
        W.sighashType
      )
    )[0], oe = re.filter((ke) => !!ke.leafHash).map((ke) => ({
      pubkey: (0, bip371_1.toXOnly)(K.publicKey),
      signature: (0, bip371_1.serializeTaprootSignature)(
        K.signSchnorr(ke.hash),
        W.sighashType
      ),
      leafHash: ke.leafHash
    }));
    return ie && this.data.updateInput(B, { tapKeySig: ie }), oe.length && this.data.updateInput(B, { tapScriptSig: oe }), this;
  }
  signInputAsync(B, W, K) {
    return Promise.resolve().then(() => {
      if (!W || !W.publicKey)
        throw new Error("Need Signer to sign input");
      const J = (0, utils_1.checkForInput)(this.data.inputs, B);
      return (0, bip371_1.isTaprootInput)(J) ? this._signTaprootInputAsync(
        B,
        J,
        W,
        void 0,
        K
      ) : this._signInputAsync(B, W, K);
    });
  }
  signTaprootInputAsync(B, W, K, J) {
    return Promise.resolve().then(() => {
      if (!W || !W.publicKey)
        throw new Error("Need Signer to sign input");
      const L = (0, utils_1.checkForInput)(this.data.inputs, B);
      if ((0, bip371_1.isTaprootInput)(L))
        return this._signTaprootInputAsync(
          B,
          L,
          W,
          K,
          J
        );
      throw new Error(`Input #${B} is not of type Taproot.`);
    });
  }
  _signInputAsync(B, W, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: J, sighashType: L } = getHashAndSighashType(
      this.data.inputs,
      B,
      W.publicKey,
      this.__CACHE,
      K
    );
    return Promise.resolve(W.sign(J)).then((re) => {
      const ie = [
        {
          pubkey: W.publicKey,
          signature: bscript.signature.encode(re, L)
        }
      ];
      this.data.updateInput(B, { partialSig: ie });
    });
  }
  async _signTaprootInputAsync(B, W, K, J, L = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const re = this.checkTaprootHashesForSig(
      B,
      W,
      K,
      J,
      L
    ), ie = [], oe = re.filter((ne) => !ne.leafHash)[0];
    if (oe) {
      const ne = Promise.resolve(
        K.signSchnorr(oe.hash)
      ).then((pe) => ({
        tapKeySig: (0, bip371_1.serializeTaprootSignature)(
          pe,
          W.sighashType
        )
      }));
      ie.push(ne);
    }
    const ke = re.filter((ne) => !!ne.leafHash);
    if (ke.length) {
      const ne = ke.map((pe) => Promise.resolve(K.signSchnorr(pe.hash)).then(
        (rt) => ({ tapScriptSig: [
          {
            pubkey: (0, bip371_1.toXOnly)(K.publicKey),
            signature: (0, bip371_1.serializeTaprootSignature)(
              rt,
              W.sighashType
            ),
            leafHash: pe.leafHash
          }
        ] })
      ));
      ie.push(...ne);
    }
    return Promise.all(ie).then((ne) => {
      ne.forEach((pe) => this.data.updateInput(B, pe));
    });
  }
  checkTaprootHashesForSig(B, W, K, J, L) {
    if (typeof K.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${B}.`
      );
    const re = getTaprootHashesForSig(
      B,
      W,
      this.data.inputs,
      K.publicKey,
      this.__CACHE,
      J,
      L
    );
    if (!re || !re.length)
      throw new Error(
        `Can not sign for input #${B} with the key ${K.publicKey.toString(
          "hex"
        )}`
      );
    return re;
  }
  toBuffer() {
    return checkCache(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return checkCache(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return checkCache(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(B) {
    return this.data.updateGlobal(B), this;
  }
  updateInput(B, W) {
    return W.witnessScript && checkInvalidP2WSH(W.witnessScript), (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[B],
      W,
      "updateInput"
    ), this.data.updateInput(B, W), W.nonWitnessUtxo && addNonWitnessTxCache(
      this.__CACHE,
      this.data.inputs[B],
      B
    ), this;
  }
  updateOutput(B, W) {
    const K = this.data.outputs[B];
    return (0, bip371_1.checkTaprootOutputFields)(
      K,
      W,
      "updateOutput"
    ), this.data.updateOutput(B, W), this;
  }
  addUnknownKeyValToGlobal(B) {
    return this.data.addUnknownKeyValToGlobal(B), this;
  }
  addUnknownKeyValToInput(B, W) {
    return this.data.addUnknownKeyValToInput(B, W), this;
  }
  addUnknownKeyValToOutput(B, W) {
    return this.data.addUnknownKeyValToOutput(B, W), this;
  }
  clearFinalizedInput(B) {
    return this.data.clearFinalizedInput(B), this;
  }
}
psbt$1.Psbt = Psbt;
const transactionFromBuffer = (A) => new PsbtTransaction(A);
class PsbtTransaction {
  constructor(B = Buffer$1.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(B), checkTxEmpty(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(B) {
    if (B.hash === void 0 || B.index === void 0 || !Buffer$1.isBuffer(B.hash) && typeof B.hash != "string" || typeof B.index != "number")
      throw new Error("Error adding input.");
    const W = typeof B.hash == "string" ? (0, bufferutils_1.reverseBuffer)(Buffer$1.from(B.hash, "hex")) : B.hash;
    this.tx.addInput(W, B.index, B.sequence);
  }
  addOutput(B) {
    if (B.script === void 0 || B.value === void 0 || !Buffer$1.isBuffer(B.script) || typeof B.value != "number")
      throw new Error("Error adding output.");
    this.tx.addOutput(B.script, B.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(A, B, W) {
  switch (W) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, A.partialSig);
    case "multisig":
      const K = payments.p2ms({ output: B });
      return hasSigs(K.m, A.partialSig, K.pubkeys);
    default:
      return !1;
  }
}
function checkCache(A) {
  if (A.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function hasSigs(A, B, W) {
  if (!B) return !1;
  let K;
  if (W ? K = W.map((J) => {
    const L = compressPubkey(J);
    return B.find((re) => re.pubkey.equals(L));
  }).filter((J) => !!J) : K = B, K.length > A) throw new Error("Too many signatures");
  return K.length === A;
}
function isFinalized(A) {
  return !!A.finalScriptSig || !!A.finalScriptWitness;
}
function bip32DerivationIsMine(A) {
  return (B) => !(!B.masterFingerprint.equals(A.fingerprint) || !A.derivePath(B.path).publicKey.equals(B.pubkey));
}
function check32Bit(A) {
  if (typeof A != "number" || A !== Math.floor(A) || A > 4294967295 || A < 0)
    throw new Error("Invalid 32 bit integer");
}
function checkFees(A, B, W) {
  const K = B.__FEE_RATE || A.getFeeRate(), J = B.__EXTRACTED_TX.virtualSize(), L = K * J;
  if (K >= W.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(L / 1e8).toFixed(8)} in fees, which is ${K} satoshi per byte for a transaction with a VSize of ${J} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function checkInputsForPartialSig(A, B) {
  A.forEach((W) => {
    if ((0, bip371_1.isTaprootInput)(W) ? (0, bip371_1.checkTaprootInputForSigs)(W, B) : (0, psbtutils_1.checkInputForSig)(W, B))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(A) {
  if (!A.sighashType || !A.partialSig) return;
  const { partialSig: B, sighashType: W } = A;
  B.forEach((K) => {
    const { hashType: J } = bscript.signature.decode(K.signature);
    if (W !== J)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function checkScriptForPubkey(A, B, W) {
  if (!(0, psbtutils_1.pubkeyInScript)(A, B))
    throw new Error(
      `Can not ${W} for this input with the key ${A.toString("hex")}`
    );
}
function checkTxEmpty(A) {
  if (!A.ins.every(
    (W) => W.script && W.script.length === 0 && W.witness && W.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function checkTxForDupeIns(A, B) {
  A.ins.forEach((W) => {
    checkTxInputCache(B, W);
  });
}
function checkTxInputCache(A, B) {
  const W = (0, bufferutils_1.reverseBuffer)(Buffer$1.from(B.hash)).toString("hex") + ":" + B.index;
  if (A.__TX_IN_CACHE[W]) throw new Error("Duplicate input detected.");
  A.__TX_IN_CACHE[W] = 1;
}
function scriptCheckerFactory(A, B) {
  return (W, K, J, L) => {
    const re = A({
      redeem: { output: J }
    }).output;
    if (!K.equals(re))
      throw new Error(
        `${B} for ${L} #${W} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script"), checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  "Witness script"
);
function getTxCacheValue(A, B, W, K) {
  if (!W.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${B}`);
  if (A === "__FEE_RATE" && K.__FEE_RATE) return K.__FEE_RATE;
  if (A === "__FEE" && K.__FEE) return K.__FEE;
  let J, L = !0;
  if (K.__EXTRACTED_TX ? (J = K.__EXTRACTED_TX, L = !1) : J = K.__TX.clone(), inputFinalizeGetAmts(W, J, K, L), A === "__FEE_RATE") return K.__FEE_RATE;
  if (A === "__FEE") return K.__FEE;
}
function getFinalScripts(A, B, W, K, J, L) {
  const re = classifyScript(W);
  if (!canFinalize(B, W, re))
    throw new Error(`Can not finalize input #${A}`);
  return prepareFinalScripts(
    W,
    re,
    B.partialSig,
    K,
    J,
    L
  );
}
function prepareFinalScripts(A, B, W, K, J, L) {
  let re, ie;
  const oe = getPayment(A, B, W), ke = L ? payments.p2wsh({ redeem: oe }) : null, ne = J ? payments.p2sh({ redeem: ke || oe }) : null;
  return K ? (ke ? ie = (0, psbtutils_1.witnessStackToScriptWitness)(
    ke.witness
  ) : ie = (0, psbtutils_1.witnessStackToScriptWitness)(
    oe.witness
  ), ne && (re = ne.input)) : ne ? re = ne.input : re = oe.input, {
    finalScriptSig: re,
    finalScriptWitness: ie
  };
}
function getHashAndSighashType(A, B, W, K, J) {
  const L = (0, utils_1.checkForInput)(A, B), { hash: re, sighashType: ie, script: oe } = getHashForSig(
    B,
    L,
    K,
    !1,
    J
  );
  return checkScriptForPubkey(W, oe, "sign"), {
    hash: re,
    sighashType: ie
  };
}
function getHashForSig(A, B, W, K, J) {
  const L = W.__TX, re = B.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(re, J);
  let ie, oe;
  if (B.nonWitnessUtxo) {
    const pe = nonWitnessUtxoTxFromCache(
      W,
      B,
      A
    ), rt = L.ins[A].hash, nt = pe.getHash();
    if (!rt.equals(nt))
      throw new Error(
        `Non-witness UTXO hash for input #${A} doesn't match the hash specified in the prevout`
      );
    const ot = L.ins[A].index;
    oe = pe.outs[ot];
  } else if (B.witnessUtxo)
    oe = B.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: ke, type: ne } = getMeaningfulScript(
    oe.script,
    A,
    "input",
    B.redeemScript,
    B.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(ne) >= 0)
    ie = L.hashForWitnessV0(
      A,
      ke,
      oe.value,
      re
    );
  else if ((0, psbtutils_1.isP2WPKH)(ke)) {
    const pe = payments.p2pkh({
      hash: ke.slice(2)
    }).output;
    ie = L.hashForWitnessV0(
      A,
      pe,
      oe.value,
      re
    );
  } else {
    if (B.nonWitnessUtxo === void 0 && W.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${A} has witnessUtxo but non-segwit script: ${ke.toString("hex")}`
      );
    !K && W.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), ie = L.hashForSignature(
      A,
      ke,
      re
    );
  }
  return {
    script: ke,
    sighashType: re,
    hash: ie
  };
}
function getAllTaprootHashesForSig(A, B, W, K) {
  const J = [];
  if (B.tapInternalKey) {
    const re = getPrevoutTaprootKey(A, B, K);
    re && J.push(re);
  }
  if (B.tapScriptSig) {
    const re = B.tapScriptSig.map((ie) => ie.pubkey);
    J.push(...re);
  }
  return J.map(
    (re) => getTaprootHashesForSig(A, B, W, re, K)
  ).flat();
}
function getPrevoutTaprootKey(A, B, W) {
  const { script: K } = getScriptAndAmountFromUtxo(A, B, W);
  return (0, psbtutils_1.isP2TR)(K) ? K.subarray(2, 34) : null;
}
function trimTaprootSig(A) {
  return A.length === 64 ? A : A.subarray(0, 64);
}
function getTaprootHashesForSig(A, B, W, K, J, L, re) {
  const ie = J.__TX, oe = B.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(oe, re);
  const ke = W.map(
    (ot, ut) => getScriptAndAmountFromUtxo(ut, ot, J)
  ), ne = ke.map((ot) => ot.script), pe = ke.map((ot) => ot.value), rt = [];
  if (B.tapInternalKey && !L) {
    const ot = getPrevoutTaprootKey(A, B, J) || Buffer$1.from([]);
    if ((0, bip371_1.toXOnly)(K).equals(ot)) {
      const ut = ie.hashForWitnessV1(
        A,
        ne,
        pe,
        oe
      );
      rt.push({ pubkey: K, hash: ut });
    }
  }
  const nt = (B.tapLeafScript || []).filter((ot) => (0, psbtutils_1.pubkeyInScript)(K, ot.script)).map((ot) => {
    const ut = (0, bip341_1.tapleafHash)({
      output: ot.script,
      version: ot.leafVersion
    });
    return Object.assign({ hash: ut }, ot);
  }).filter(
    (ot) => !L || L.equals(ot.hash)
  ).map((ot) => {
    const ut = ie.hashForWitnessV1(
      A,
      ne,
      pe,
      oe,
      ot.hash
    );
    return {
      pubkey: K,
      hash: ut,
      leafHash: ot.hash
    };
  });
  return rt.concat(nt);
}
function checkSighashTypeAllowed(A, B) {
  if (B && B.indexOf(A) < 0) {
    const W = sighashTypeToString(A);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${W}`
    );
  }
}
function getPayment(A, B, W) {
  let K;
  switch (B) {
    case "multisig":
      const J = getSortedSigs(A, W);
      K = payments.p2ms({
        output: A,
        signatures: J
      });
      break;
    case "pubkey":
      K = payments.p2pk({
        output: A,
        signature: W[0].signature
      });
      break;
    case "pubkeyhash":
      K = payments.p2pkh({
        output: A,
        pubkey: W[0].pubkey,
        signature: W[0].signature
      });
      break;
    case "witnesspubkeyhash":
      K = payments.p2wpkh({
        output: A,
        pubkey: W[0].pubkey,
        signature: W[0].signature
      });
      break;
  }
  return K;
}
function getScriptFromInput(A, B, W) {
  const K = W.__TX, J = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (J.isP2SH = !!B.redeemScript, J.isP2WSH = !!B.witnessScript, B.witnessScript)
    J.script = B.witnessScript;
  else if (B.redeemScript)
    J.script = B.redeemScript;
  else if (B.nonWitnessUtxo) {
    const L = nonWitnessUtxoTxFromCache(
      W,
      B,
      A
    ), re = K.ins[A].index;
    J.script = L.outs[re].script;
  } else B.witnessUtxo && (J.script = B.witnessUtxo.script);
  return (B.witnessScript || (0, psbtutils_1.isP2WPKH)(J.script)) && (J.isSegwit = !0), J;
}
function getSignersFromHD(A, B, W) {
  const K = (0, utils_1.checkForInput)(B, A);
  if (!K.bip32Derivation || K.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const J = K.bip32Derivation.map((re) => {
    if (re.masterFingerprint.equals(W.fingerprint))
      return re;
  }).filter((re) => !!re);
  if (J.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return J.map((re) => {
    const ie = W.derivePath(re.path);
    if (!re.pubkey.equals(ie.publicKey))
      throw new Error("pubkey did not match bip32Derivation");
    return ie;
  });
}
function getSortedSigs(A, B) {
  return payments.p2ms({ output: A }).pubkeys.map((K) => (B.filter((J) => J.pubkey.equals(K))[0] || {}).signature).filter((K) => !!K);
}
function scriptWitnessToWitnessStack(A) {
  let B = 0;
  function W(re) {
    return B += re, A.slice(B - re, B);
  }
  function K() {
    const re = varuint.decode(A, B);
    return B += varuint.decode.bytes, re;
  }
  function J() {
    return W(K());
  }
  function L() {
    const re = K(), ie = [];
    for (let oe = 0; oe < re; oe++) ie.push(J());
    return ie;
  }
  return L();
}
function sighashTypeToString(A) {
  let B = A & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (A & 31) {
    case transaction_1.Transaction.SIGHASH_ALL:
      B += "SIGHASH_ALL";
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      B += "SIGHASH_SINGLE";
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      B += "SIGHASH_NONE";
      break;
  }
  return B;
}
function addNonWitnessTxCache(A, B, W) {
  A.__NON_WITNESS_UTXO_BUF_CACHE[W] = B.nonWitnessUtxo;
  const K = transaction_1.Transaction.fromBuffer(B.nonWitnessUtxo);
  A.__NON_WITNESS_UTXO_TX_CACHE[W] = K;
  const J = A, L = W;
  delete B.nonWitnessUtxo, Object.defineProperty(B, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const re = J.__NON_WITNESS_UTXO_BUF_CACHE[L], ie = J.__NON_WITNESS_UTXO_TX_CACHE[L];
      if (re !== void 0)
        return re;
      {
        const oe = ie.toBuffer();
        return J.__NON_WITNESS_UTXO_BUF_CACHE[L] = oe, oe;
      }
    },
    set(re) {
      J.__NON_WITNESS_UTXO_BUF_CACHE[L] = re;
    }
  });
}
function inputFinalizeGetAmts(A, B, W, K) {
  let J = 0;
  A.forEach((oe, ke) => {
    if (K && oe.finalScriptSig && (B.ins[ke].script = oe.finalScriptSig), K && oe.finalScriptWitness && (B.ins[ke].witness = scriptWitnessToWitnessStack(
      oe.finalScriptWitness
    )), oe.witnessUtxo)
      J += oe.witnessUtxo.value;
    else if (oe.nonWitnessUtxo) {
      const ne = nonWitnessUtxoTxFromCache(W, oe, ke), pe = B.ins[ke].index, rt = ne.outs[pe];
      J += rt.value;
    }
  });
  const L = B.outs.reduce((oe, ke) => oe + ke.value, 0), re = J - L;
  if (re < 0)
    throw new Error("Outputs are spending more than Inputs");
  const ie = B.virtualSize();
  W.__FEE = re, W.__EXTRACTED_TX = B, W.__FEE_RATE = Math.floor(re / ie);
}
function nonWitnessUtxoTxFromCache(A, B, W) {
  const K = A.__NON_WITNESS_UTXO_TX_CACHE;
  return K[W] || addNonWitnessTxCache(A, B, W), K[W];
}
function getScriptFromUtxo(A, B, W) {
  const { script: K } = getScriptAndAmountFromUtxo(A, B, W);
  return K;
}
function getScriptAndAmountFromUtxo(A, B, W) {
  if (B.witnessUtxo !== void 0)
    return {
      script: B.witnessUtxo.script,
      value: B.witnessUtxo.value
    };
  if (B.nonWitnessUtxo !== void 0) {
    const J = nonWitnessUtxoTxFromCache(
      W,
      B,
      A
    ).outs[W.__TX.ins[A].index];
    return { script: J.script, value: J.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function pubkeyInInput(A, B, W, K) {
  const J = getScriptFromUtxo(W, B, K), { meaningfulScript: L } = getMeaningfulScript(
    J,
    W,
    "input",
    B.redeemScript,
    B.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(A, L);
}
function pubkeyInOutput(A, B, W, K) {
  const J = K.__TX.outs[W].script, { meaningfulScript: L } = getMeaningfulScript(
    J,
    W,
    "output",
    B.redeemScript,
    B.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(A, L);
}
function redeemFromFinalScriptSig(A) {
  if (!A) return;
  const B = bscript.decompile(A);
  if (!B) return;
  const W = B[B.length - 1];
  if (!(!Buffer$1.isBuffer(W) || isPubkeyLike(W) || isSigLike(W) || !bscript.decompile(W)))
    return W;
}
function redeemFromFinalWitnessScript(A) {
  if (!A) return;
  const B = scriptWitnessToWitnessStack(A), W = B[B.length - 1];
  if (!(isPubkeyLike(W) || !bscript.decompile(W)))
    return W;
}
function compressPubkey(A) {
  if (A.length === 65) {
    const B = A[64] & 1, W = A.slice(0, 33);
    return W[0] = 2 | B, W;
  }
  return A.slice();
}
function isPubkeyLike(A) {
  return A.length === 33 && bscript.isCanonicalPubKey(A);
}
function isSigLike(A) {
  return bscript.isCanonicalScriptSignature(A);
}
function getMeaningfulScript(A, B, W, K, J) {
  const L = (0, psbtutils_1.isP2SHScript)(A), re = L && K && (0, psbtutils_1.isP2WSHScript)(K), ie = (0, psbtutils_1.isP2WSHScript)(A);
  if (L && K === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((ie || re) && J === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let oe;
  return re ? (oe = J, checkRedeemScript(B, A, K, W), checkWitnessScript(B, K, J, W), checkInvalidP2WSH(oe)) : ie ? (oe = J, checkWitnessScript(B, A, J, W), checkInvalidP2WSH(oe)) : L ? (oe = K, checkRedeemScript(B, A, K, W)) : oe = A, {
    meaningfulScript: oe,
    type: re ? "p2sh-p2wsh" : L ? "p2sh" : ie ? "p2wsh" : "raw"
  };
}
function checkInvalidP2WSH(A) {
  if ((0, psbtutils_1.isP2WPKH)(A) || (0, psbtutils_1.isP2SHScript)(A))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function classifyScript(A) {
  return (0, psbtutils_1.isP2WPKH)(A) ? "witnesspubkeyhash" : (0, psbtutils_1.isP2PKH)(A) ? "pubkeyhash" : (0, psbtutils_1.isP2MS)(A) ? "multisig" : (0, psbtutils_1.isP2PK)(A) ? "pubkey" : "nonstandard";
}
function range(A) {
  return [...Array(A).keys()];
}
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.initEccLib = A.Transaction = A.opcodes = A.Psbt = A.Block = A.script = A.payments = A.networks = A.crypto = A.address = void 0;
  const B = requireAddress();
  A.address = B;
  const W = crypto$1;
  A.crypto = W;
  const K = networks;
  A.networks = K;
  const J = requirePayments();
  A.payments = J;
  const L = requireScript();
  A.script = L;
  var re = block;
  Object.defineProperty(A, "Block", {
    enumerable: !0,
    get: function() {
      return re.Block;
    }
  });
  var ie = psbt$1;
  Object.defineProperty(A, "Psbt", {
    enumerable: !0,
    get: function() {
      return ie.Psbt;
    }
  });
  var oe = ops;
  Object.defineProperty(A, "opcodes", {
    enumerable: !0,
    get: function() {
      return oe.OPS;
    }
  });
  var ke = transaction;
  Object.defineProperty(A, "Transaction", {
    enumerable: !0,
    get: function() {
      return ke.Transaction;
    }
  });
  var ne = ecc_lib;
  Object.defineProperty(A, "initEccLib", {
    enumerable: !0,
    get: function() {
      return ne.initEccLib;
    }
  });
})(src$1);
function useSign() {
  const { network: A, publicKey: B, format: W, wallet: K } = useOrdConnect(), [J, L] = useState(null), [re, ie] = useState(!1);
  return { sign: useCallback(
    async (ke, ne, pe) => {
      ie(!0);
      try {
        if (L(null), !W || !B || !K)
          throw new Error("No wallet is connected");
        const rt = src$1.Psbt.fromBase64(ne), nt = await signPsbt({
          address: ke,
          wallet: K,
          network: A,
          psbt: rt,
          options: pe
        });
        return ie(!1), nt;
      } catch (rt) {
        throw L(rt.message), ie(!1), rt;
      }
    },
    [W, A, B, K]
  ), error: J, loading: re };
}
function leatherPaymentTypeFromFormat(A) {
  if (A === "segwit")
    return LeatherAddressType.P2WPKH;
  if (A === "taproot")
    return LeatherAddressType.P2TR;
  throw new Error("Leather payment address format is not supported");
}
async function signMessage({
  message: A,
  wallet: B,
  address: W,
  network: K,
  format: J
}) {
  if (B === Wallet.MAGICEDEN) {
    const { base64: L } = await signMessage$1(A, W, K);
    return L;
  }
  if (B === Wallet.UNISAT) {
    const { base64: L } = await signMessage$2(A, "bip322-simple");
    return L;
  }
  if (B === Wallet.XVERSE) {
    const { base64: L } = await signMessage$3(A, W, K);
    return L;
  }
  if (B === Wallet.LEATHER) {
    const L = leatherPaymentTypeFromFormat(J), { base64: re } = await signMessage$4(A, {
      paymentType: L,
      network: K
    });
    return re;
  }
  if (B === Wallet.OKX) {
    const { base64: L } = await signMessage$5(A, "bip322-simple", K);
    return L;
  }
  throw new Error("Invalid wallet selected");
}
function useSignMessage() {
  const {
    network: A,
    wallet: B,
    publicKey: W,
    format: K,
    address: J
  } = useOrdConnect(), [L, re] = useState(null), [ie, oe] = useState(!1);
  return { signMsg: useCallback(
    async (ne, pe) => {
      oe(!0);
      try {
        if (re(null), !K || !W || !B)
          throw new Error("No wallet is connected");
        if (J.ordinals !== ne && J.payments !== ne)
          throw new Error("Address supplied is not connected address");
        const rt = await signMessage({
          address: ne,
          wallet: B,
          message: pe,
          network: A,
          format: J.ordinals === ne ? K.ordinals : K.payments
        });
        return oe(!1), rt;
      } catch (rt) {
        throw re(rt.message), oe(!1), rt;
      }
    },
    [K, A, W, B, J]
  ), error: L, isLoading: ie };
}
export {
  Chain,
  Network,
  OrdConnectKit,
  OrdConnectProvider,
  SelectWalletModal,
  Wallet,
  useBalance,
  useOrdConnect,
  useSend,
  useSendV2,
  useSign,
  useSignMessage
};
