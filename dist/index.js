(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap";.ord-connect-wallet-button{color:#000;background-color:#fff;font-weight:700;font-size:14px;line-height:20px;border-radius:40px;padding:10px 16px;border:0px;cursor:pointer}.ord-connect-wallet-button:disabled{background-color:#888;cursor:not-allowed}.ord-connect-wallet-button span:before{content:"Connect"}@media screen and (min-width: 768px){.ord-connect-wallet-button{padding:10px 24px}.ord-connect-wallet-button span:before{content:"Connect wallet"}}.ord-connect-wallet-button:enabled:hover{background-color:#f2f2f2}.ord-connect-wallet-button:enabled:active{opacity:.7}.ord-wallet-connected-container{position:relative;display:inline-block}.ord-wallet-connected-button{border-radius:52px;border:1px solid #8c8c8c;background-color:transparent;padding:8px 12px 8px 8px;display:flex;align-items:center;cursor:pointer}.ord-wallet-connected-button .address-container{display:none}@media screen and (min-width: 768px){.ord-wallet-connected-button .address-container{display:block;margin-left:8px}}.ord-wallet-connected-button .address{color:#fff;font-size:14px;font-weight:700;line-height:20px;margin:0}.ord-wallet-connected-button .network-container{display:flex;align-items:center}.ord-wallet-connected-button .status-indicator{width:8px;height:8px;background:#00ad1d;border-radius:999px;margin-right:8px}.ord-wallet-connected-button .network{color:#ffffff80;margin:0;font-size:12px;font-weight:600;line-height:16px}.ord-wallet-connected-button .wallet-profile-icon{width:28px;height:28px;border-radius:999px;background-color:pink;margin-right:8px}.ord-wallet-connected-button .dropdown-button{transition:transform .3s ease;margin-left:16px}.ord-wallet-connected-button .expand-dropdown-button{width:20px;transform:rotate(0)}.ord-wallet-connected-button .close-dropdown-button{transform:rotate(-180deg)}.ord-wallet-connection-dropdown{background:#121212;border-radius:15px;border:.5px solid rgba(255,255,255,.5);width:256px;position:absolute;top:54px;right:0}.ord-wallet-connection-dropdown .dropdown-button{display:flex;align-items:center;background:transparent;border:0px;cursor:pointer;width:100%;justify-content:space-between}.ord-wallet-connection-dropdown .dropdown-button:hover{background:#ffffff1a}.ord-wallet-connection-dropdown .dropdown-button:hover:first-child{border-top-left-radius:15px;border-top-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:hover:last-child{border-bottom-left-radius:15px;border-bottom-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:active{background:#ffffff1a;opacity:.7}.ord-wallet-connection-dropdown .dropdown-button:first-child{padding:26px 16px 18px}.ord-wallet-connection-dropdown .dropdown-button:not(:first-child):not(:last-child){padding:9px 16px}.ord-wallet-connection-dropdown .dropdown-button:last-child{padding:18px 16px 26px}.ord-wallet-connection-dropdown .label{color:#fff;font-size:14px;font-weight:600;flex:1 1 0%;text-align:left}.ord-wallet-connection-dropdown .value{color:#a6a6a6}.ord-wallet-connection-dropdown .change-wallet-label{color:#ffffffb3;font-size:14px;font-weight:700;flex:1 1 0%;text-align:right}.ord-wallet-connection-dropdown .profile-item-container{width:100%;display:flex;flex-direction:column}.ord-wallet-connection-dropdown .profile-item-inner-container{display:flex;justify-content:space-between}.ord-wallet-connection-dropdown .offers{font-size:10px;font-weight:700;line-height:12px;letter-spacing:.08em;color:#fff;padding:4px 12px;border-radius:16px;background:#ffffff1a}.ord-wallet-connection-dropdown .horizontal-separator{margin:6px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal{position:relative;z-index:10}.ord-connect-wallet-modal .backdrop{position:fixed;top:0;right:0;bottom:0;left:0;background:#00000080;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}.ord-connect-wallet-modal .outer-container{position:fixed;top:0;left:0;overflow-y:auto;width:100%;height:100%}.ord-connect-wallet-modal .inner-container{display:flex;align-items:center;justify-content:center;text-align:center;height:100%}.ord-connect-wallet-modal .panel{width:100%;background-color:#121212;overflow:hidden;text-align:left;height:100%}.ord-connect-wallet-modal .panel-title-container{display:flex;justify-content:space-between;padding:32px 24px 0;align-items:center}.ord-connect-wallet-modal .panel-title{color:#fff;font-size:24px;font-style:normal;font-weight:700;line-height:32px;margin:0}.ord-connect-wallet-modal .unsupported-browser-message{color:#fff}.ord-connect-wallet-modal .close-button{display:inline-flex;background:transparent;border:0px;cursor:pointer}.ord-connect-wallet-modal .panel-content-container{margin:32px 24px 0}.ord-connect-wallet-modal .panel-content-inner-container{border-radius:20px;border:1px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .wallet-option-button{display:flex;align-items:center;background:transparent;border:0px;color:#fff;font-size:16px;font-weight:600;line-height:20px;width:100%;cursor:pointer}.ord-connect-wallet-modal .wallet-option-button:disabled .chevron-btn{opacity:.3}.waiting-cursor{cursor:wait!important}.wallet-identifier-container{position:relative;display:inline-block}.wallet-identifier-container img{position:absolute;bottom:4px;right:0;width:12px;border-radius:50%;background-color:#000;object-fit:cover}.ord-connect-wallet-modal .option-wrapper{display:flex;align-items:center;justify-content:space-between;padding:16px 4px;width:100%}.ord-connect-wallet-modal .wallet-option-button{padding:8px 16px}.ord-connect-wallet-modal .wallet-option-button:hover{background:#ffffff1a}.ord-connect-wallet-modal .wallet-option-button:active{background:#ffffff1a;opacity:.7}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-option-button:last-child{padding:8px 16px 16px;border:0px;margin-bottom:0;border-radius:0 0 20px 20px}.ord-connect-wallet-modal .wallet-option-button:only-child{padding:8px 16px;border:0px;margin-bottom:0;border-radius:20px}.ord-connect-wallet-modal .wallet-icon{width:32px;height:32px}.ord-connect-wallet-modal .wallet-option{flex-grow:1;margin-left:12px;text-align:left}.ord-connect-wallet-modal .wallet-option-connected-address{display:flex;padding:4px 8px;align-items:center;margin-left:4px;margin-right:8px;text-align:left;background-color:#00000080;border-radius:20px;-webkit-backdrop-filter:blur(15px);backdrop-filter:blur(15px)}.ord-connect-wallet-modal .wallet-option-connected-address .label{margin-left:4px;font-size:12px;font-weight:400;color:#ffffffb3}.ord-connect-wallet-modal .wallet-option-label{font-size:16px;font-weight:600;line-height:20px;margin:0}.ord-connect-wallet-modal .wallet-option-subtitle{font-size:12px;font-weight:400;line-height:16px;color:#8c8c8c;margin:0}.ord-connect-wallet-modal .horizontal-separator{margin:2px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .error-message{margin:16px 0 0;color:#e54545;font-size:14px;line-height:20px}.ord-connect-wallet-modal .preferred-label{padding:4px 12px;color:#000000b2;background-color:#ffbf18;font-size:12px;line-height:16px;font-weight:400;border-radius:20px;margin-left:4px;margin-right:8px}@media screen and (min-width: 768px){.ord-connect-wallet-modal .outer-container{top:50%;left:50%;transform:translate(-50%,-50%);width:500px;height:auto;border-radius:20px}.ord-connect-wallet-modal .panel{border:1px solid rgba(51,51,51,.5);border-radius:20px}.ord-connect-wallet-modal .panel-title-container{padding:24px 32px 0;border-bottom:0px}.ord-connect-wallet-modal .unsupported-browser-message{font-size:16px;padding-left:24px}.ord-connect-wallet-modal .panel-title{font-size:20px;font-style:normal;font-weight:600;line-height:28px;letter-spacing:.2px}.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .wallet-option{margin-left:16px}}@media screen and (min-width: 1080px){.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .option-wrapper{padding:16px}.ord-connect-wallet-modal .wallet-option-button{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-icon{width:40px;height:40px}.ord-connect-wallet-modal .wallet-option-label{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-connected-address{margin-left:16px;margin-right:16px}.ord-connect-wallet-modal .wallet-option-connected-address .label{font-size:16px}}.ord-connect-font *{font-family:Space Grotesk,sans-serif}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}.ease-in{transition-timing-function:cubic-bezier(.4,0,1,1)}.opacity-0{opacity:0}.opacity-100{opacity:1}.duration-300{transition-duration:.3s}.duration-200{transition-duration:.2s}.scale-95{transform:scale(.95)}.scale-100{transform:scale(1)}')),document.head.appendChild(o)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
import * as React from "react";
import React__default, { useState, useEffect, useCallback, createContext, useMemo, useContext, useRef, useLayoutEffect, forwardRef, Fragment, isValidElement, cloneElement, createElement, useId as useId$1, useReducer, useSyncExternalStore, createRef } from "react";
import * as ReactDOM from "react-dom";
import { createPortal, flushSync } from "react-dom";
import { BrowserWalletNotInstalledError, OrditSDKError, BrowserWalletSigningError, getAddressFormat, getAddressesFromPublicKey, ADDRESS_FORMAT_TO_TYPE, JsonRpcDatasource, PSBTBuilder, BrowserWalletRequestCancelledByUserError } from "@ordzaar/ordit-sdk";
import { getAddresses as getAddresses$1, signPsbt as signPsbt$4, signMessage as signMessage$3, LeatherAddressType } from "@ordzaar/ordit-sdk/leather";
import { getAddresses as getAddresses$2, signPsbt as signPsbt$1, signMessage as signMessage$1 } from "@ordzaar/ordit-sdk/magiceden";
import { getAddresses, signPsbt as signPsbt$5, signMessage as signMessage$4 } from "@ordzaar/ordit-sdk/okx";
import { getAddresses as getAddresses$3, signPsbt as signPsbt$2, signMessage as signMessage$2 } from "@ordzaar/ordit-sdk/unisat";
import { signPsbt as signPsbt$3 } from "@ordzaar/ordit-sdk/xverse";
function getDefaultExportFromCjs$1(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
var browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(B) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(B, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(B, 0);
  try {
    return cachedSetTimeout(B, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, B, 0);
    } catch {
      return cachedSetTimeout.call(this, B, 0);
    }
  }
}
function runClearTimeout(B) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(B);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(B);
  try {
    return cachedClearTimeout(B);
  } catch {
    try {
      return cachedClearTimeout.call(null, B);
    } catch {
      return cachedClearTimeout.call(this, B);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var B = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var z = queue.length; z; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < z; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, z = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(B);
  }
}
process.nextTick = function(B) {
  var z = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var Y = 1; Y < arguments.length; Y++)
      z[Y - 1] = arguments[Y];
  queue.push(new Item(B, z)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(B, z) {
  this.fun = B, this.array = z;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(B) {
  return [];
};
process.binding = function(B) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(B) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$1 = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports$1);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
function getAugmentedNamespace(B) {
  if (B.__esModule) return B;
  var z = B.default;
  if (typeof z == "function") {
    var Y = function ne() {
      return this instanceof ne ? Reflect.construct(z, arguments, this.constructor) : z.apply(this, arguments);
    };
    Y.prototype = z.prototype;
  } else Y = {};
  return Object.defineProperty(Y, "__esModule", { value: !0 }), Object.keys(B).forEach(function(ne) {
    var ie = Object.getOwnPropertyDescriptor(B, ne);
    Object.defineProperty(Y, ne, ie.get ? ie : {
      enumerable: !0,
      get: function() {
        return B[ne];
      }
    });
  }), Y;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var B = React__default, z = Symbol.for("react.element"), Y = Symbol.for("react.fragment"), ne = Object.prototype.hasOwnProperty, ie = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, oe = { key: !0, ref: !0, __self: !0, __source: !0 };
  function se(ae, ve, Pe) {
    var le, Ee = {}, Je = null, Ce = null;
    Pe !== void 0 && (Je = "" + Pe), ve.key !== void 0 && (Je = "" + ve.key), ve.ref !== void 0 && (Ce = ve.ref);
    for (le in ve) ne.call(ve, le) && !oe.hasOwnProperty(le) && (Ee[le] = ve[le]);
    if (ae && ae.defaultProps) for (le in ve = ae.defaultProps, ve) Ee[le] === void 0 && (Ee[le] = ve[le]);
    return { $$typeof: z, type: ae, key: Je, ref: Ce, props: Ee, _owner: ie.current };
  }
  return reactJsxRuntime_production_min.Fragment = Y, reactJsxRuntime_production_min.jsx = se, reactJsxRuntime_production_min.jsxs = se, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {}, hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var B = React__default, z = Symbol.for("react.element"), Y = Symbol.for("react.portal"), ne = Symbol.for("react.fragment"), ie = Symbol.for("react.strict_mode"), oe = Symbol.for("react.profiler"), se = Symbol.for("react.provider"), ae = Symbol.for("react.context"), ve = Symbol.for("react.forward_ref"), Pe = Symbol.for("react.suspense"), le = Symbol.for("react.suspense_list"), Ee = Symbol.for("react.memo"), Je = Symbol.for("react.lazy"), Ce = Symbol.for("react.offscreen"), _t = Symbol.iterator, kt = "@@iterator";
    function Ct(Zt) {
      if (Zt === null || typeof Zt != "object")
        return null;
      var yr = _t && Zt[_t] || Zt[kt];
      return typeof yr == "function" ? yr : null;
    }
    var Lt = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function Pt(Zt) {
      {
        for (var yr = arguments.length, _r = new Array(yr > 1 ? yr - 1 : 0), Sr = 1; Sr < yr; Sr++)
          _r[Sr - 1] = arguments[Sr];
        Ft("error", Zt, _r);
      }
    }
    function Ft(Zt, yr, _r) {
      {
        var Sr = Lt.ReactDebugCurrentFrame, Cr = Sr.getStackAddendum();
        Cr !== "" && (yr += "%s", _r = _r.concat([Cr]));
        var Fr = _r.map(function(Rr) {
          return String(Rr);
        });
        Fr.unshift("Warning: " + yr), Function.prototype.apply.call(console[Zt], console, Fr);
      }
    }
    var Ut = !1, Jt = !1, Vt = !1, ir = !1, jt = !1, Rt;
    Rt = Symbol.for("react.module.reference");
    function Kt(Zt) {
      return !!(typeof Zt == "string" || typeof Zt == "function" || Zt === ne || Zt === oe || jt || Zt === ie || Zt === Pe || Zt === le || ir || Zt === Ce || Ut || Jt || Vt || typeof Zt == "object" && Zt !== null && (Zt.$$typeof === Je || Zt.$$typeof === Ee || Zt.$$typeof === se || Zt.$$typeof === ae || Zt.$$typeof === ve || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Zt.$$typeof === Rt || Zt.getModuleId !== void 0));
    }
    function Bt(Zt, yr, _r) {
      var Sr = Zt.displayName;
      if (Sr)
        return Sr;
      var Cr = yr.displayName || yr.name || "";
      return Cr !== "" ? _r + "(" + Cr + ")" : _r;
    }
    function Xe(Zt) {
      return Zt.displayName || "Context";
    }
    function Ve(Zt) {
      if (Zt == null)
        return null;
      if (typeof Zt.tag == "number" && Pt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Zt == "function")
        return Zt.displayName || Zt.name || null;
      if (typeof Zt == "string")
        return Zt;
      switch (Zt) {
        case ne:
          return "Fragment";
        case Y:
          return "Portal";
        case oe:
          return "Profiler";
        case ie:
          return "StrictMode";
        case Pe:
          return "Suspense";
        case le:
          return "SuspenseList";
      }
      if (typeof Zt == "object")
        switch (Zt.$$typeof) {
          case ae:
            var yr = Zt;
            return Xe(yr) + ".Consumer";
          case se:
            var _r = Zt;
            return Xe(_r._context) + ".Provider";
          case ve:
            return Bt(Zt, Zt.render, "ForwardRef");
          case Ee:
            var Sr = Zt.displayName || null;
            return Sr !== null ? Sr : Ve(Zt.type) || "Memo";
          case Je: {
            var Cr = Zt, Fr = Cr._payload, Rr = Cr._init;
            try {
              return Ve(Rr(Fr));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ge = Object.assign, Ke = 0, ht, wt, vt, $t, Qe, xt, bt;
    function Dt() {
    }
    Dt.__reactDisabledLog = !0;
    function er() {
      {
        if (Ke === 0) {
          ht = console.log, wt = console.info, vt = console.warn, $t = console.error, Qe = console.group, xt = console.groupCollapsed, bt = console.groupEnd;
          var Zt = {
            configurable: !0,
            enumerable: !0,
            value: Dt,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Zt,
            log: Zt,
            warn: Zt,
            error: Zt,
            group: Zt,
            groupCollapsed: Zt,
            groupEnd: Zt
          });
        }
        Ke++;
      }
    }
    function fr() {
      {
        if (Ke--, Ke === 0) {
          var Zt = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: ge({}, Zt, {
              value: ht
            }),
            info: ge({}, Zt, {
              value: wt
            }),
            warn: ge({}, Zt, {
              value: vt
            }),
            error: ge({}, Zt, {
              value: $t
            }),
            group: ge({}, Zt, {
              value: Qe
            }),
            groupCollapsed: ge({}, Zt, {
              value: xt
            }),
            groupEnd: ge({}, Zt, {
              value: bt
            })
          });
        }
        Ke < 0 && Pt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Qt = Lt.ReactCurrentDispatcher, Ht;
    function qt(Zt, yr, _r) {
      {
        if (Ht === void 0)
          try {
            throw Error();
          } catch (Cr) {
            var Sr = Cr.stack.trim().match(/\n( *(at )?)/);
            Ht = Sr && Sr[1] || "";
          }
        return `
` + Ht + Zt;
      }
    }
    var nr = !1, ur;
    {
      var zt = typeof WeakMap == "function" ? WeakMap : Map;
      ur = new zt();
    }
    function Gt(Zt, yr) {
      if (!Zt || nr)
        return "";
      {
        var _r = ur.get(Zt);
        if (_r !== void 0)
          return _r;
      }
      var Sr;
      nr = !0;
      var Cr = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Fr;
      Fr = Qt.current, Qt.current = null, er();
      try {
        if (yr) {
          var Rr = function() {
            throw Error();
          };
          if (Object.defineProperty(Rr.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Rr, []);
            } catch (an) {
              Sr = an;
            }
            Reflect.construct(Zt, [], Rr);
          } else {
            try {
              Rr.call();
            } catch (an) {
              Sr = an;
            }
            Zt.call(Rr.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (an) {
            Sr = an;
          }
          Zt();
        }
      } catch (an) {
        if (an && Sr && typeof an.stack == "string") {
          for (var Gr = an.stack.split(`
`), sn = Sr.stack.split(`
`), en = Gr.length - 1, on = sn.length - 1; en >= 1 && on >= 0 && Gr[en] !== sn[on]; )
            on--;
          for (; en >= 1 && on >= 0; en--, on--)
            if (Gr[en] !== sn[on]) {
              if (en !== 1 || on !== 1)
                do
                  if (en--, on--, on < 0 || Gr[en] !== sn[on]) {
                    var cn = `
` + Gr[en].replace(" at new ", " at ");
                    return Zt.displayName && cn.includes("<anonymous>") && (cn = cn.replace("<anonymous>", Zt.displayName)), typeof Zt == "function" && ur.set(Zt, cn), cn;
                  }
                while (en >= 1 && on >= 0);
              break;
            }
        }
      } finally {
        nr = !1, Qt.current = Fr, fr(), Error.prepareStackTrace = Cr;
      }
      var ln = Zt ? Zt.displayName || Zt.name : "", un = ln ? qt(ln) : "";
      return typeof Zt == "function" && ur.set(Zt, un), un;
    }
    function cr(Zt, yr, _r) {
      return Gt(Zt, !1);
    }
    function gr(Zt) {
      var yr = Zt.prototype;
      return !!(yr && yr.isReactComponent);
    }
    function $r(Zt, yr, _r) {
      if (Zt == null)
        return "";
      if (typeof Zt == "function")
        return Gt(Zt, gr(Zt));
      if (typeof Zt == "string")
        return qt(Zt);
      switch (Zt) {
        case Pe:
          return qt("Suspense");
        case le:
          return qt("SuspenseList");
      }
      if (typeof Zt == "object")
        switch (Zt.$$typeof) {
          case ve:
            return cr(Zt.render);
          case Ee:
            return $r(Zt.type, yr, _r);
          case Je: {
            var Sr = Zt, Cr = Sr._payload, Fr = Sr._init;
            try {
              return $r(Fr(Cr), yr, _r);
            } catch {
            }
          }
        }
      return "";
    }
    var xr = Object.prototype.hasOwnProperty, Mr = {}, kr = Lt.ReactDebugCurrentFrame;
    function br(Zt) {
      if (Zt) {
        var yr = Zt._owner, _r = $r(Zt.type, Zt._source, yr ? yr.type : null);
        kr.setExtraStackFrame(_r);
      } else
        kr.setExtraStackFrame(null);
    }
    function Yr(Zt, yr, _r, Sr, Cr) {
      {
        var Fr = Function.call.bind(xr);
        for (var Rr in Zt)
          if (Fr(Zt, Rr)) {
            var Gr = void 0;
            try {
              if (typeof Zt[Rr] != "function") {
                var sn = Error((Sr || "React class") + ": " + _r + " type `" + Rr + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Zt[Rr] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw sn.name = "Invariant Violation", sn;
              }
              Gr = Zt[Rr](yr, Rr, Sr, _r, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (en) {
              Gr = en;
            }
            Gr && !(Gr instanceof Error) && (br(Cr), Pt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Sr || "React class", _r, Rr, typeof Gr), br(null)), Gr instanceof Error && !(Gr.message in Mr) && (Mr[Gr.message] = !0, br(Cr), Pt("Failed %s type: %s", _r, Gr.message), br(null));
          }
      }
    }
    var jr = Array.isArray;
    function Qr(Zt) {
      return jr(Zt);
    }
    function Xr(Zt) {
      {
        var yr = typeof Symbol == "function" && Symbol.toStringTag, _r = yr && Zt[Symbol.toStringTag] || Zt.constructor.name || "Object";
        return _r;
      }
    }
    function Or(Zt) {
      try {
        return Wr(Zt), !1;
      } catch {
        return !0;
      }
    }
    function Wr(Zt) {
      return "" + Zt;
    }
    function Jr(Zt) {
      if (Or(Zt))
        return Pt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Xr(Zt)), Wr(Zt);
    }
    var Hr = Lt.ReactCurrentOwner, Vr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, tn, Wt;
    function Ot(Zt) {
      if (xr.call(Zt, "ref")) {
        var yr = Object.getOwnPropertyDescriptor(Zt, "ref").get;
        if (yr && yr.isReactWarning)
          return !1;
      }
      return Zt.ref !== void 0;
    }
    function Nt(Zt) {
      if (xr.call(Zt, "key")) {
        var yr = Object.getOwnPropertyDescriptor(Zt, "key").get;
        if (yr && yr.isReactWarning)
          return !1;
      }
      return Zt.key !== void 0;
    }
    function Yt(Zt, yr) {
      typeof Zt.ref == "string" && Hr.current;
    }
    function ar(Zt, yr) {
      {
        var _r = function() {
          tn || (tn = !0, Pt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", yr));
        };
        _r.isReactWarning = !0, Object.defineProperty(Zt, "key", {
          get: _r,
          configurable: !0
        });
      }
    }
    function lr(Zt, yr) {
      {
        var _r = function() {
          Wt || (Wt = !0, Pt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", yr));
        };
        _r.isReactWarning = !0, Object.defineProperty(Zt, "ref", {
          get: _r,
          configurable: !0
        });
      }
    }
    var dr = function(Zt, yr, _r, Sr, Cr, Fr, Rr) {
      var Gr = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: z,
        // Built-in properties that belong on the element
        type: Zt,
        key: yr,
        ref: _r,
        props: Rr,
        // Record the component responsible for creating this element.
        _owner: Fr
      };
      return Gr._store = {}, Object.defineProperty(Gr._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Gr, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Sr
      }), Object.defineProperty(Gr, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Cr
      }), Object.freeze && (Object.freeze(Gr.props), Object.freeze(Gr)), Gr;
    };
    function Ir(Zt, yr, _r, Sr, Cr) {
      {
        var Fr, Rr = {}, Gr = null, sn = null;
        _r !== void 0 && (Jr(_r), Gr = "" + _r), Nt(yr) && (Jr(yr.key), Gr = "" + yr.key), Ot(yr) && (sn = yr.ref, Yt(yr, Cr));
        for (Fr in yr)
          xr.call(yr, Fr) && !Vr.hasOwnProperty(Fr) && (Rr[Fr] = yr[Fr]);
        if (Zt && Zt.defaultProps) {
          var en = Zt.defaultProps;
          for (Fr in en)
            Rr[Fr] === void 0 && (Rr[Fr] = en[Fr]);
        }
        if (Gr || sn) {
          var on = typeof Zt == "function" ? Zt.displayName || Zt.name || "Unknown" : Zt;
          Gr && ar(Rr, on), sn && lr(Rr, on);
        }
        return dr(Zt, Gr, sn, Cr, Sr, Hr.current, Rr);
      }
    }
    var qr = Lt.ReactCurrentOwner, Br = Lt.ReactDebugCurrentFrame;
    function Ur(Zt) {
      if (Zt) {
        var yr = Zt._owner, _r = $r(Zt.type, Zt._source, yr ? yr.type : null);
        Br.setExtraStackFrame(_r);
      } else
        Br.setExtraStackFrame(null);
    }
    var Lr;
    Lr = !1;
    function Dr(Zt) {
      return typeof Zt == "object" && Zt !== null && Zt.$$typeof === z;
    }
    function Zr() {
      {
        if (qr.current) {
          var Zt = Ve(qr.current.type);
          if (Zt)
            return `

Check the render method of \`` + Zt + "`.";
        }
        return "";
      }
    }
    function nn(Zt) {
      return "";
    }
    var tr = {};
    function Xt(Zt) {
      {
        var yr = Zr();
        if (!yr) {
          var _r = typeof Zt == "string" ? Zt : Zt.displayName || Zt.name;
          _r && (yr = `

Check the top-level render call using <` + _r + ">.");
        }
        return yr;
      }
    }
    function rr(Zt, yr) {
      {
        if (!Zt._store || Zt._store.validated || Zt.key != null)
          return;
        Zt._store.validated = !0;
        var _r = Xt(yr);
        if (tr[_r])
          return;
        tr[_r] = !0;
        var Sr = "";
        Zt && Zt._owner && Zt._owner !== qr.current && (Sr = " It was passed a child from " + Ve(Zt._owner.type) + "."), Ur(Zt), Pt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', _r, Sr), Ur(null);
      }
    }
    function or(Zt, yr) {
      {
        if (typeof Zt != "object")
          return;
        if (Qr(Zt))
          for (var _r = 0; _r < Zt.length; _r++) {
            var Sr = Zt[_r];
            Dr(Sr) && rr(Sr, yr);
          }
        else if (Dr(Zt))
          Zt._store && (Zt._store.validated = !0);
        else if (Zt) {
          var Cr = Ct(Zt);
          if (typeof Cr == "function" && Cr !== Zt.entries)
            for (var Fr = Cr.call(Zt), Rr; !(Rr = Fr.next()).done; )
              Dr(Rr.value) && rr(Rr.value, yr);
        }
      }
    }
    function pr(Zt) {
      {
        var yr = Zt.type;
        if (yr == null || typeof yr == "string")
          return;
        var _r;
        if (typeof yr == "function")
          _r = yr.propTypes;
        else if (typeof yr == "object" && (yr.$$typeof === ve || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        yr.$$typeof === Ee))
          _r = yr.propTypes;
        else
          return;
        if (_r) {
          var Sr = Ve(yr);
          Yr(_r, Zt.props, "prop", Sr, Zt);
        } else if (yr.PropTypes !== void 0 && !Lr) {
          Lr = !0;
          var Cr = Ve(yr);
          Pt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Cr || "Unknown");
        }
        typeof yr.getDefaultProps == "function" && !yr.getDefaultProps.isReactClassApproved && Pt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function vr(Zt) {
      {
        for (var yr = Object.keys(Zt.props), _r = 0; _r < yr.length; _r++) {
          var Sr = yr[_r];
          if (Sr !== "children" && Sr !== "key") {
            Ur(Zt), Pt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Sr), Ur(null);
            break;
          }
        }
        Zt.ref !== null && (Ur(Zt), Pt("Invalid attribute `ref` supplied to `React.Fragment`."), Ur(null));
      }
    }
    var wr = {};
    function Er(Zt, yr, _r, Sr, Cr, Fr) {
      {
        var Rr = Kt(Zt);
        if (!Rr) {
          var Gr = "";
          (Zt === void 0 || typeof Zt == "object" && Zt !== null && Object.keys(Zt).length === 0) && (Gr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var sn = nn();
          sn ? Gr += sn : Gr += Zr();
          var en;
          Zt === null ? en = "null" : Qr(Zt) ? en = "array" : Zt !== void 0 && Zt.$$typeof === z ? (en = "<" + (Ve(Zt.type) || "Unknown") + " />", Gr = " Did you accidentally export a JSX literal instead of a component?") : en = typeof Zt, Pt("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", en, Gr);
        }
        var on = Ir(Zt, yr, _r, Cr, Fr);
        if (on == null)
          return on;
        if (Rr) {
          var cn = yr.children;
          if (cn !== void 0)
            if (Sr)
              if (Qr(cn)) {
                for (var ln = 0; ln < cn.length; ln++)
                  or(cn[ln], Zt);
                Object.freeze && Object.freeze(cn);
              } else
                Pt("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              or(cn, Zt);
        }
        if (xr.call(yr, "key")) {
          var un = Ve(Zt), an = Object.keys(yr).filter(function(pn) {
            return pn !== "key";
          }), dn = an.length > 0 ? "{key: someKey, " + an.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!wr[un + dn]) {
            var hn = an.length > 0 ? "{" + an.join(": ..., ") + ": ...}" : "{}";
            Pt(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, dn, un, hn, un), wr[un + dn] = !0;
          }
        }
        return Zt === ne ? vr(on) : pr(on), on;
      }
    }
    function Pr(Zt, yr, _r) {
      return Er(Zt, yr, _r, !0);
    }
    function Ar(Zt, yr, _r) {
      return Er(Zt, yr, _r, !1);
    }
    var Tr = Ar, Nr = Pr;
    reactJsxRuntime_development.Fragment = ne, reactJsxRuntime_development.jsx = Tr, reactJsxRuntime_development.jsxs = Nr;
  }()), reactJsxRuntime_development;
}
process$1.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
function useHasMounted() {
  const [B, z] = useState(!1);
  return useEffect(() => {
    z(!0);
  }, []), B;
}
const KEY_PREFIX = "ord-connect";
function getItemFromLocalStorage(B) {
  typeof window > "u" && console.warn(
    `Attempted to read local storage key ${B} even though environment is not a browser.`
  );
  const z = `${KEY_PREFIX}_${B}`;
  try {
    const Y = window.localStorage.getItem(z);
    return Y != null ? JSON.parse(Y) : null;
  } catch (Y) {
    return console.error(`Error retrieving ${z} from localStorage`, Y), null;
  }
}
function setItemToLocalStorage(B, z) {
  typeof window > "u" && console.warn(
    `Attempted to set local storage key ${B} even though environment is not a browser.`
  );
  const Y = `${KEY_PREFIX}_${B}`;
  try {
    z ? window.localStorage.setItem(Y, JSON.stringify(z)) : window.localStorage.removeItem(Y);
  } catch (ne) {
    console.error(`Error saving ${Y} to localStorage`, ne);
  }
}
function useLocalStorage(B, z, Y = {}) {
  const { initializeWithValue: ne = !0 } = Y, ie = useCallback(() => {
    const ve = getItemFromLocalStorage(B);
    return ve || (setItemToLocalStorage(B, z), z);
  }, [z, B]), [oe, se] = useState(() => ne ? ie() : z), ae = useCallback(
    (ve) => {
      setItemToLocalStorage(B, ve), se(ve);
    },
    [B]
  );
  return useEffect(() => {
    se(ie());
  }, [B]), [oe, ae];
}
var Network = /* @__PURE__ */ ((B) => (B.MAINNET = "mainnet", B.TESTNET = "testnet", B.SIGNET = "signet", B))(Network || {}), Wallet = /* @__PURE__ */ ((B) => (B.UNISAT = "unisat", B.XVERSE = "xverse", B.MAGICEDEN = "magiceden", B.LEATHER = "leather", B.OKX = "okx", B))(Wallet || {}), Chain = /* @__PURE__ */ ((B) => (B.BITCOIN = "bitcoin", B.FRACTAL_BITCOIN = "fractal-bitcoin", B))(Chain || {});
const EMPTY_BIADDRESS_OBJECT = {
  payments: null,
  ordinals: null
}, OrdConnectContext = createContext(
  void 0
), ADDRESS = "address", WALLET = "wallet", PUBLIC_KEY = "publicKey", FORMAT = "format";
function OrdConnectProvider({
  children: B,
  network: z,
  visibleWallets: Y,
  chain: ne = "bitcoin",
  ssr: ie = !1
}) {
  if (!z)
    throw new Error("Network cannot be empty");
  if (!Y || Y.length === 0)
    throw new Error("Visible wallets cannot be empty");
  const [oe, se] = useState(z), [ae, ve] = useState(Y), [Pe, le] = useState(ne), [Ee, Je] = useLocalStorage(
    ADDRESS,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !ie }
  ), [Ce, _t] = useLocalStorage(WALLET, null, {
    initializeWithValue: !ie
  }), [kt, Ct] = useLocalStorage(
    PUBLIC_KEY,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !ie }
  ), [Lt, Pt] = useLocalStorage(
    FORMAT,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !ie }
  ), [Ft, Ut] = useState(!1), Jt = useCallback(() => Ut(!0), []), Vt = useCallback(() => Ut(!1), []), ir = useCallback(() => {
    Je(EMPTY_BIADDRESS_OBJECT), Ct(EMPTY_BIADDRESS_OBJECT), Pt(EMPTY_BIADDRESS_OBJECT), _t(null);
  }, [Je, Pt, Ct, _t]), jt = useMemo(
    () => ({
      address: Ee,
      updateAddress: Je,
      publicKey: kt,
      updatePublicKey: Ct,
      network: oe,
      updateNetwork: se,
      wallet: Ce,
      updateWallet: _t,
      isModalOpen: Ft,
      openModal: Jt,
      closeModal: Vt,
      format: Lt,
      updateFormat: Pt,
      disconnectWallet: ir,
      chain: Pe,
      updateChain: le,
      visibleWallets: ae,
      updateVisibleWallets: ve
    }),
    [
      Ee,
      Je,
      kt,
      Ct,
      oe,
      Ce,
      Ft,
      Jt,
      Vt,
      Lt,
      Pt,
      ir,
      Pe,
      ae,
      _t
    ]
  );
  return useEffect(() => {
    se(z);
  }, [z]), useEffect(() => {
    Pe !== ne && (ir(), le(ne));
  }, [ne, Pe, ir]), /* @__PURE__ */ jsxRuntimeExports.jsx(OrdConnectContext.Provider, { value: jt, children: B });
}
function useOrdConnect() {
  const B = useContext(OrdConnectContext);
  if (!B)
    throw new Error("useOrdConnect must be used within OrdConnectProvider");
  return B;
}
var build = { exports: {} };
(function(B, z) {
  (function(Y, ne) {
    B.exports = ne(React__default);
  })(commonjsGlobal, function(Y) {
    return function(ne) {
      var ie = {};
      function oe(se) {
        if (ie[se]) return ie[se].exports;
        var ae = ie[se] = { i: se, l: !1, exports: {} };
        return ne[se].call(ae.exports, ae, ae.exports, oe), ae.l = !0, ae.exports;
      }
      return oe.m = ne, oe.c = ie, oe.d = function(se, ae, ve) {
        oe.o(se, ae) || Object.defineProperty(se, ae, { enumerable: !0, get: ve });
      }, oe.r = function(se) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(se, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(se, "__esModule", { value: !0 });
      }, oe.t = function(se, ae) {
        if (1 & ae && (se = oe(se)), 8 & ae || 4 & ae && typeof se == "object" && se && se.__esModule) return se;
        var ve = /* @__PURE__ */ Object.create(null);
        if (oe.r(ve), Object.defineProperty(ve, "default", { enumerable: !0, value: se }), 2 & ae && typeof se != "string") for (var Pe in se) oe.d(ve, Pe, (function(le) {
          return se[le];
        }).bind(null, Pe));
        return ve;
      }, oe.n = function(se) {
        var ae = se && se.__esModule ? function() {
          return se.default;
        } : function() {
          return se;
        };
        return oe.d(ae, "a", ae), ae;
      }, oe.o = function(se, ae) {
        return Object.prototype.hasOwnProperty.call(se, ae);
      }, oe.p = "/", oe(oe.s = 1);
    }([function(ne, ie) {
      ne.exports = Y;
    }, function(ne, ie, oe) {
      ne.exports = oe(2);
    }, function(ne, ie, oe) {
      function se(Pt, Ft) {
        if (Pt == null) return {};
        var Ut, Jt, Vt = function(jt, Rt) {
          if (jt == null) return {};
          var Kt, Bt, Xe = {}, Ve = Object.keys(jt);
          for (Bt = 0; Bt < Ve.length; Bt++) Kt = Ve[Bt], Rt.indexOf(Kt) >= 0 || (Xe[Kt] = jt[Kt]);
          return Xe;
        }(Pt, Ft);
        if (Object.getOwnPropertySymbols) {
          var ir = Object.getOwnPropertySymbols(Pt);
          for (Jt = 0; Jt < ir.length; Jt++) Ut = ir[Jt], Ft.indexOf(Ut) >= 0 || Object.prototype.propertyIsEnumerable.call(Pt, Ut) && (Vt[Ut] = Pt[Ut]);
        }
        return Vt;
      }
      oe.r(ie);
      var ae = oe(0), ve = oe.n(ae), Pe = function(Pt) {
        for (var Ft = 0, Ut = 0; Ut < Pt.length; Ut++)
          Ft = (Ft << 5) - Ft + Pt.charCodeAt(Ut), Ft &= Ft;
        return Math.abs(Ft);
      }, le = function(Pt, Ft) {
        return Math.floor(Pt / Math.pow(10, Ft) % 10);
      }, Ee = function(Pt, Ft) {
        return !(le(Pt, Ft) % 2);
      }, Je = function(Pt, Ft, Ut) {
        var Jt = Pt % Ft;
        return Ut && le(Pt, Ut) % 2 === 0 ? -Jt : Jt;
      }, Ce = function(Pt, Ft, Ut) {
        return Ft[Pt % Ut];
      }, _t = function(Pt) {
        var Ft = Pt.name, Ut = Pt.colors, Jt = Pt.title, Vt = Pt.square, ir = Pt.size, jt = se(Pt, ["name", "colors", "title", "square", "size"]), Rt = function(Bt, Xe) {
          var Ve = Pe(Bt), ge = Xe && Xe.length;
          return Array.from({ length: 3 }, function(Ke, ht) {
            return { color: Ce(Ve + ht, Xe, ge), translateX: Je(Ve * (ht + 1), 8, 1), translateY: Je(Ve * (ht + 1), 8, 2), scale: 1.2 + Je(Ve * (ht + 1), 4) / 10, rotate: Je(Ve * (ht + 1), 360, 1) };
          });
        }(Ft, Ut), Kt = ae.useId();
        return ae.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: ir, height: ir }, jt), Jt && ae.createElement("title", null, Ft), ae.createElement("mask", { id: Kt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ae.createElement("rect", { width: 80, height: 80, rx: Vt ? void 0 : 160, fill: "#FFFFFF" })), ae.createElement("g", { mask: "url(#".concat(Kt, ")") }, ae.createElement("rect", { width: 80, height: 80, fill: Rt[0].color }), ae.createElement("path", { filter: "url(#filter_".concat(Kt, ")"), d: "M32.414 59.35L50.376 70.5H72.5v-71H33.728L26.5 13.381l19.057 27.08L32.414 59.35z", fill: Rt[1].color, transform: "translate(" + Rt[1].translateX + " " + Rt[1].translateY + ") rotate(" + Rt[1].rotate + " 40 40) scale(" + Rt[2].scale + ")" }), ae.createElement("path", { filter: "url(#filter_".concat(Kt, ")"), style: { mixBlendMode: "overlay" }, d: "M22.216 24L0 46.75l14.108 38.129L78 86l-3.081-59.276-22.378 4.005 12.972 20.186-23.35 27.395L22.215 24z", fill: Rt[2].color, transform: "translate(" + Rt[2].translateX + " " + Rt[2].translateY + ") rotate(" + Rt[2].rotate + " 40 40) scale(" + Rt[2].scale + ")" })), ae.createElement("defs", null, ae.createElement("filter", { id: "filter_".concat(Kt), filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB" }, ae.createElement("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }), ae.createElement("feBlend", { in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), ae.createElement("feGaussianBlur", { stdDeviation: 7, result: "effect1_foregroundBlur" }))));
      }, kt = { pixel: function(Pt) {
        var Ft = Pt.name, Ut = Pt.colors, Jt = Pt.title, Vt = Pt.square, ir = Pt.size, jt = se(Pt, ["name", "colors", "title", "square", "size"]), Rt = function(Bt, Xe) {
          var Ve = Pe(Bt), ge = Xe && Xe.length;
          return Array.from({ length: 64 }, function(Ke, ht) {
            return Ce(Ve % (ht + 1), Xe, ge);
          });
        }(Ft, Ut), Kt = ae.useId();
        return ae.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: ir, height: ir }, jt), Jt && ae.createElement("title", null, Ft), ae.createElement("mask", { id: Kt, "mask-type": "alpha", maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ae.createElement("rect", { width: 80, height: 80, rx: Vt ? void 0 : 160, fill: "#FFFFFF" })), ae.createElement("g", { mask: "url(#".concat(Kt, ")") }, ae.createElement("rect", { width: 10, height: 10, fill: Rt[0] }), ae.createElement("rect", { x: 20, width: 10, height: 10, fill: Rt[1] }), ae.createElement("rect", { x: 40, width: 10, height: 10, fill: Rt[2] }), ae.createElement("rect", { x: 60, width: 10, height: 10, fill: Rt[3] }), ae.createElement("rect", { x: 10, width: 10, height: 10, fill: Rt[4] }), ae.createElement("rect", { x: 30, width: 10, height: 10, fill: Rt[5] }), ae.createElement("rect", { x: 50, width: 10, height: 10, fill: Rt[6] }), ae.createElement("rect", { x: 70, width: 10, height: 10, fill: Rt[7] }), ae.createElement("rect", { y: 10, width: 10, height: 10, fill: Rt[8] }), ae.createElement("rect", { y: 20, width: 10, height: 10, fill: Rt[9] }), ae.createElement("rect", { y: 30, width: 10, height: 10, fill: Rt[10] }), ae.createElement("rect", { y: 40, width: 10, height: 10, fill: Rt[11] }), ae.createElement("rect", { y: 50, width: 10, height: 10, fill: Rt[12] }), ae.createElement("rect", { y: 60, width: 10, height: 10, fill: Rt[13] }), ae.createElement("rect", { y: 70, width: 10, height: 10, fill: Rt[14] }), ae.createElement("rect", { x: 20, y: 10, width: 10, height: 10, fill: Rt[15] }), ae.createElement("rect", { x: 20, y: 20, width: 10, height: 10, fill: Rt[16] }), ae.createElement("rect", { x: 20, y: 30, width: 10, height: 10, fill: Rt[17] }), ae.createElement("rect", { x: 20, y: 40, width: 10, height: 10, fill: Rt[18] }), ae.createElement("rect", { x: 20, y: 50, width: 10, height: 10, fill: Rt[19] }), ae.createElement("rect", { x: 20, y: 60, width: 10, height: 10, fill: Rt[20] }), ae.createElement("rect", { x: 20, y: 70, width: 10, height: 10, fill: Rt[21] }), ae.createElement("rect", { x: 40, y: 10, width: 10, height: 10, fill: Rt[22] }), ae.createElement("rect", { x: 40, y: 20, width: 10, height: 10, fill: Rt[23] }), ae.createElement("rect", { x: 40, y: 30, width: 10, height: 10, fill: Rt[24] }), ae.createElement("rect", { x: 40, y: 40, width: 10, height: 10, fill: Rt[25] }), ae.createElement("rect", { x: 40, y: 50, width: 10, height: 10, fill: Rt[26] }), ae.createElement("rect", { x: 40, y: 60, width: 10, height: 10, fill: Rt[27] }), ae.createElement("rect", { x: 40, y: 70, width: 10, height: 10, fill: Rt[28] }), ae.createElement("rect", { x: 60, y: 10, width: 10, height: 10, fill: Rt[29] }), ae.createElement("rect", { x: 60, y: 20, width: 10, height: 10, fill: Rt[30] }), ae.createElement("rect", { x: 60, y: 30, width: 10, height: 10, fill: Rt[31] }), ae.createElement("rect", { x: 60, y: 40, width: 10, height: 10, fill: Rt[32] }), ae.createElement("rect", { x: 60, y: 50, width: 10, height: 10, fill: Rt[33] }), ae.createElement("rect", { x: 60, y: 60, width: 10, height: 10, fill: Rt[34] }), ae.createElement("rect", { x: 60, y: 70, width: 10, height: 10, fill: Rt[35] }), ae.createElement("rect", { x: 10, y: 10, width: 10, height: 10, fill: Rt[36] }), ae.createElement("rect", { x: 10, y: 20, width: 10, height: 10, fill: Rt[37] }), ae.createElement("rect", { x: 10, y: 30, width: 10, height: 10, fill: Rt[38] }), ae.createElement("rect", { x: 10, y: 40, width: 10, height: 10, fill: Rt[39] }), ae.createElement("rect", { x: 10, y: 50, width: 10, height: 10, fill: Rt[40] }), ae.createElement("rect", { x: 10, y: 60, width: 10, height: 10, fill: Rt[41] }), ae.createElement("rect", { x: 10, y: 70, width: 10, height: 10, fill: Rt[42] }), ae.createElement("rect", { x: 30, y: 10, width: 10, height: 10, fill: Rt[43] }), ae.createElement("rect", { x: 30, y: 20, width: 10, height: 10, fill: Rt[44] }), ae.createElement("rect", { x: 30, y: 30, width: 10, height: 10, fill: Rt[45] }), ae.createElement("rect", { x: 30, y: 40, width: 10, height: 10, fill: Rt[46] }), ae.createElement("rect", { x: 30, y: 50, width: 10, height: 10, fill: Rt[47] }), ae.createElement("rect", { x: 30, y: 60, width: 10, height: 10, fill: Rt[48] }), ae.createElement("rect", { x: 30, y: 70, width: 10, height: 10, fill: Rt[49] }), ae.createElement("rect", { x: 50, y: 10, width: 10, height: 10, fill: Rt[50] }), ae.createElement("rect", { x: 50, y: 20, width: 10, height: 10, fill: Rt[51] }), ae.createElement("rect", { x: 50, y: 30, width: 10, height: 10, fill: Rt[52] }), ae.createElement("rect", { x: 50, y: 40, width: 10, height: 10, fill: Rt[53] }), ae.createElement("rect", { x: 50, y: 50, width: 10, height: 10, fill: Rt[54] }), ae.createElement("rect", { x: 50, y: 60, width: 10, height: 10, fill: Rt[55] }), ae.createElement("rect", { x: 50, y: 70, width: 10, height: 10, fill: Rt[56] }), ae.createElement("rect", { x: 70, y: 10, width: 10, height: 10, fill: Rt[57] }), ae.createElement("rect", { x: 70, y: 20, width: 10, height: 10, fill: Rt[58] }), ae.createElement("rect", { x: 70, y: 30, width: 10, height: 10, fill: Rt[59] }), ae.createElement("rect", { x: 70, y: 40, width: 10, height: 10, fill: Rt[60] }), ae.createElement("rect", { x: 70, y: 50, width: 10, height: 10, fill: Rt[61] }), ae.createElement("rect", { x: 70, y: 60, width: 10, height: 10, fill: Rt[62] }), ae.createElement("rect", { x: 70, y: 70, width: 10, height: 10, fill: Rt[63] })));
      }, bauhaus: function(Pt) {
        var Ft = Pt.name, Ut = Pt.colors, Jt = Pt.title, Vt = Pt.square, ir = Pt.size, jt = se(Pt, ["name", "colors", "title", "square", "size"]), Rt = function(Bt, Xe) {
          var Ve = Pe(Bt), ge = Xe && Xe.length;
          return Array.from({ length: 4 }, function(Ke, ht) {
            return { color: Ce(Ve + ht, Xe, ge), translateX: Je(Ve * (ht + 1), 40 - (ht + 17), 1), translateY: Je(Ve * (ht + 1), 40 - (ht + 17), 2), rotate: Je(Ve * (ht + 1), 360), isSquare: Ee(Ve, 2) };
          });
        }(Ft, Ut), Kt = ae.useId();
        return ae.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: ir, height: ir }, jt), Jt && ae.createElement("title", null, Ft), ae.createElement("mask", { id: Kt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ae.createElement("rect", { width: 80, height: 80, rx: Vt ? void 0 : 160, fill: "#FFFFFF" })), ae.createElement("g", { mask: "url(#".concat(Kt, ")") }, ae.createElement("rect", { width: 80, height: 80, fill: Rt[0].color }), ae.createElement("rect", { x: 10, y: 30, width: 80, height: Rt[1].isSquare ? 80 : 10, fill: Rt[1].color, transform: "translate(" + Rt[1].translateX + " " + Rt[1].translateY + ") rotate(" + Rt[1].rotate + " 40 40)" }), ae.createElement("circle", { cx: 40, cy: 40, fill: Rt[2].color, r: 16, transform: "translate(" + Rt[2].translateX + " " + Rt[2].translateY + ")" }), ae.createElement("line", { x1: 0, y1: 40, x2: 80, y2: 40, strokeWidth: 2, stroke: Rt[3].color, transform: "translate(" + Rt[3].translateX + " " + Rt[3].translateY + ") rotate(" + Rt[3].rotate + " 40 40)" })));
      }, ring: function(Pt) {
        var Ft = Pt.name, Ut = Pt.colors, Jt = Pt.title, Vt = Pt.square, ir = Pt.size, jt = se(Pt, ["name", "colors", "title", "square", "size"]), Rt = function(Bt, Xe) {
          var Ve = Pe(Xe), ge = Bt && Bt.length, Ke = Array.from({ length: 5 }, function(wt, vt) {
            return Ce(Ve + vt, Bt, ge);
          }), ht = [];
          return ht[0] = Ke[0], ht[1] = Ke[1], ht[2] = Ke[1], ht[3] = Ke[2], ht[4] = Ke[2], ht[5] = Ke[3], ht[6] = Ke[3], ht[7] = Ke[0], ht[8] = Ke[4], ht;
        }(Ut, Ft), Kt = ve.a.useId();
        return ve.a.createElement("svg", Object.assign({ viewBox: "0 0 90 90", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: ir, height: ir }, jt), Jt && ve.a.createElement("title", null, Ft), ve.a.createElement("mask", { id: Kt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 90, height: 90 }, ve.a.createElement("rect", { width: 90, height: 90, rx: Vt ? void 0 : 180, fill: "#FFFFFF" })), ve.a.createElement("g", { mask: "url(#".concat(Kt, ")") }, ve.a.createElement("path", { d: "M0 0h90v45H0z", fill: Rt[0] }), ve.a.createElement("path", { d: "M0 45h90v45H0z", fill: Rt[1] }), ve.a.createElement("path", { d: "M83 45a38 38 0 00-76 0h76z", fill: Rt[2] }), ve.a.createElement("path", { d: "M83 45a38 38 0 01-76 0h76z", fill: Rt[3] }), ve.a.createElement("path", { d: "M77 45a32 32 0 10-64 0h64z", fill: Rt[4] }), ve.a.createElement("path", { d: "M77 45a32 32 0 11-64 0h64z", fill: Rt[5] }), ve.a.createElement("path", { d: "M71 45a26 26 0 00-52 0h52z", fill: Rt[6] }), ve.a.createElement("path", { d: "M71 45a26 26 0 01-52 0h52z", fill: Rt[7] }), ve.a.createElement("circle", { cx: 45, cy: 45, r: 23, fill: Rt[8] })));
      }, beam: function(Pt) {
        var Ft = Pt.name, Ut = Pt.colors, Jt = Pt.title, Vt = Pt.square, ir = Pt.size, jt = se(Pt, ["name", "colors", "title", "square", "size"]), Rt = function(Bt, Xe) {
          var Ve, ge = Pe(Bt), Ke = Xe && Xe.length, ht = Ce(ge, Xe, Ke), wt = Je(ge, 10, 1), vt = wt < 5 ? wt + 4 : wt, $t = Je(ge, 10, 2), Qe = $t < 5 ? $t + 4 : $t;
          return { wrapperColor: ht, faceColor: (Ve = ht, Ve.slice(0, 1) === "#" && (Ve = Ve.slice(1)), (299 * parseInt(Ve.substr(0, 2), 16) + 587 * parseInt(Ve.substr(2, 2), 16) + 114 * parseInt(Ve.substr(4, 2), 16)) / 1e3 >= 128 ? "#000000" : "#FFFFFF"), backgroundColor: Ce(ge + 13, Xe, Ke), wrapperTranslateX: vt, wrapperTranslateY: Qe, wrapperRotate: Je(ge, 360), wrapperScale: 1 + Je(ge, 3) / 10, isMouthOpen: Ee(ge, 2), isCircle: Ee(ge, 1), eyeSpread: Je(ge, 5), mouthSpread: Je(ge, 3), faceRotate: Je(ge, 10, 3), faceTranslateX: vt > 6 ? vt / 2 : Je(ge, 8, 1), faceTranslateY: Qe > 6 ? Qe / 2 : Je(ge, 7, 2) };
        }(Ft, Ut), Kt = ae.useId();
        return ae.createElement("svg", Object.assign({ viewBox: "0 0 36 36", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: ir, height: ir }, jt), Jt && ae.createElement("title", null, Ft), ae.createElement("mask", { id: Kt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 36, height: 36 }, ae.createElement("rect", { width: 36, height: 36, rx: Vt ? void 0 : 72, fill: "#FFFFFF" })), ae.createElement("g", { mask: "url(#".concat(Kt, ")") }, ae.createElement("rect", { width: 36, height: 36, fill: Rt.backgroundColor }), ae.createElement("rect", { x: "0", y: "0", width: 36, height: 36, transform: "translate(" + Rt.wrapperTranslateX + " " + Rt.wrapperTranslateY + ") rotate(" + Rt.wrapperRotate + " 18 18) scale(" + Rt.wrapperScale + ")", fill: Rt.wrapperColor, rx: Rt.isCircle ? 36 : 6 }), ae.createElement("g", { transform: "translate(" + Rt.faceTranslateX + " " + Rt.faceTranslateY + ") rotate(" + Rt.faceRotate + " 18 18)" }, Rt.isMouthOpen ? ae.createElement("path", { d: "M15 " + (19 + Rt.mouthSpread) + "c2 1 4 1 6 0", stroke: Rt.faceColor, fill: "none", strokeLinecap: "round" }) : ae.createElement("path", { d: "M13," + (19 + Rt.mouthSpread) + " a1,0.75 0 0,0 10,0", fill: Rt.faceColor }), ae.createElement("rect", { x: 14 - Rt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: Rt.faceColor }), ae.createElement("rect", { x: 20 + Rt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: Rt.faceColor }))));
      }, sunset: function(Pt) {
        var Ft = Pt.name, Ut = Pt.colors, Jt = Pt.title, Vt = Pt.square, ir = Pt.size, jt = se(Pt, ["name", "colors", "title", "square", "size"]), Rt = function(Xe, Ve) {
          var ge = Pe(Xe), Ke = Ve && Ve.length;
          return Array.from({ length: 4 }, function(ht, wt) {
            return Ce(ge + wt, Ve, Ke);
          });
        }(Ft, Ut), Kt = Ft.replace(/\s/g, ""), Bt = ae.useId();
        return ae.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: ir, height: ir }, jt), Jt && ae.createElement("title", null, Ft), ae.createElement("mask", { id: Bt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ae.createElement("rect", { width: 80, height: 80, rx: Vt ? void 0 : 160, fill: "#FFFFFF" })), ae.createElement("g", { mask: "url(#".concat(Bt, ")") }, ae.createElement("path", { fill: "url(#gradient_paint0_linear_" + Kt + ")", d: "M0 0h80v40H0z" }), ae.createElement("path", { fill: "url(#gradient_paint1_linear_" + Kt + ")", d: "M0 40h80v40H0z" })), ae.createElement("defs", null, ae.createElement("linearGradient", { id: "gradient_paint0_linear_" + Kt, x1: 40, y1: 0, x2: 40, y2: 40, gradientUnits: "userSpaceOnUse" }, ae.createElement("stop", { stopColor: Rt[0] }), ae.createElement("stop", { offset: 1, stopColor: Rt[1] })), ae.createElement("linearGradient", { id: "gradient_paint1_linear_" + Kt, x1: 40, y1: 40, x2: 40, y2: 80, gradientUnits: "userSpaceOnUse" }, ae.createElement("stop", { stopColor: Rt[2] }), ae.createElement("stop", { offset: 1, stopColor: Rt[3] }))));
      }, marble: _t }, Ct = { geometric: "beam", abstract: "bauhaus" }, Lt = function(Pt) {
        var Ft = Pt.variant, Ut = Ft === void 0 ? "marble" : Ft, Jt = Pt.colors, Vt = Jt === void 0 ? ["#92A1C6", "#146A7C", "#F0AB3D", "#C271B4", "#C20D90"] : Jt, ir = Pt.name, jt = ir === void 0 ? "Clara Barton" : ir, Rt = Pt.title, Kt = Rt !== void 0 && Rt, Bt = Pt.size, Xe = Pt.square, Ve = Xe !== void 0 && Xe, ge = se(Pt, ["variant", "colors", "name", "title", "size", "square"]), Ke = kt[Ct[Ut] || Ut] || _t;
        return ve.a.createElement(Ke, Object.assign({ colors: Vt, name: jt, title: Kt, size: Bt, square: Ve }, ge));
      };
      ie.default = Lt;
    }]);
  });
})(build);
var buildExports = build.exports;
const Avatar = /* @__PURE__ */ getDefaultExportFromCjs(buildExports), $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document < "u" ? React__default.useLayoutEffect : () => {
};
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(B) {
  const z = useRef(null);
  return $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    z.current = B;
  }, [
    B
  ]), useCallback((...Y) => {
    const ne = z.current;
    return ne == null ? void 0 : ne(...Y);
  }, []);
}
const $431fbd86ca7dc216$export$b204af158042fbac = (B) => {
  var z;
  return (z = B == null ? void 0 : B.ownerDocument) !== null && z !== void 0 ? z : document;
}, $431fbd86ca7dc216$export$f21a1ffae260145a = (B) => B && "window" in B && B.window === B ? B : $431fbd86ca7dc216$export$b204af158042fbac(B).defaultView || window;
function $c87311424ea30a05$var$testUserAgent(B) {
  var z;
  return typeof window > "u" || window.navigator == null ? !1 : ((z = window.navigator.userAgentData) === null || z === void 0 ? void 0 : z.brands.some((Y) => B.test(Y.brand))) || B.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(B) {
  var z;
  return typeof window < "u" && window.navigator != null ? B.test(((z = window.navigator.userAgentData) === null || z === void 0 ? void 0 : z.platform) || window.navigator.platform) : !1;
}
function $c87311424ea30a05$var$cached(B) {
  let z = null;
  return () => (z == null && (z = B()), z);
}
const $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
}), $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
function $6a7db85432448f7f$export$60278871457622de(B) {
  return B.mozInputSource === 0 && B.isTrusted ? !0 : $c87311424ea30a05$export$a11b0059900ceec8() && B.pointerType ? B.type === "click" && B.buttons === 1 : B.detail === 0 && !B.pointerType;
}
class $8a9cb279dc87e130$export$905e7fc544a71f36 {
  isDefaultPrevented() {
    return this.nativeEvent.defaultPrevented;
  }
  preventDefault() {
    this.defaultPrevented = !0, this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.nativeEvent.stopPropagation(), this.isPropagationStopped = () => !0;
  }
  isPropagationStopped() {
    return !1;
  }
  persist() {
  }
  constructor(z, Y) {
    this.nativeEvent = Y, this.target = Y.target, this.currentTarget = Y.currentTarget, this.relatedTarget = Y.relatedTarget, this.bubbles = Y.bubbles, this.cancelable = Y.cancelable, this.defaultPrevented = Y.defaultPrevented, this.eventPhase = Y.eventPhase, this.isTrusted = Y.isTrusted, this.timeStamp = Y.timeStamp, this.type = z;
  }
}
function $8a9cb279dc87e130$export$715c682d09d639cc(B) {
  let z = useRef({
    isFocused: !1,
    observer: null
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    const ne = z.current;
    return () => {
      ne.observer && (ne.observer.disconnect(), ne.observer = null);
    };
  }, []);
  let Y = $8ae05eaa5c114e9c$export$7f54fc3180508a52((ne) => {
    B == null || B(ne);
  });
  return useCallback((ne) => {
    if (ne.target instanceof HTMLButtonElement || ne.target instanceof HTMLInputElement || ne.target instanceof HTMLTextAreaElement || ne.target instanceof HTMLSelectElement) {
      z.current.isFocused = !0;
      let ie = ne.target, oe = (se) => {
        z.current.isFocused = !1, ie.disabled && Y(new $8a9cb279dc87e130$export$905e7fc544a71f36("blur", se)), z.current.observer && (z.current.observer.disconnect(), z.current.observer = null);
      };
      ie.addEventListener("focusout", oe, {
        once: !0
      }), z.current.observer = new MutationObserver(() => {
        if (z.current.isFocused && ie.disabled) {
          var se;
          (se = z.current.observer) === null || se === void 0 || se.disconnect();
          let ae = ie === document.activeElement ? null : document.activeElement;
          ie.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: ae
          })), ie.dispatchEvent(new FocusEvent("focusout", {
            bubbles: !0,
            relatedTarget: ae
          }));
        }
      }), z.current.observer.observe(ie, {
        attributes: !0,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    Y
  ]);
}
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(B) {
  let { isDisabled: z, onFocus: Y, onBlur: ne, onFocusChange: ie } = B;
  const oe = useCallback((ve) => {
    if (ve.target === ve.currentTarget)
      return ne && ne(ve), ie && ie(!1), !0;
  }, [
    ne,
    ie
  ]), se = $8a9cb279dc87e130$export$715c682d09d639cc(oe), ae = useCallback((ve) => {
    const Pe = $431fbd86ca7dc216$export$b204af158042fbac(ve.target);
    ve.target === ve.currentTarget && Pe.activeElement === ve.target && (Y && Y(ve), ie && ie(!0), se(ve));
  }, [
    ie,
    Y,
    se
  ]);
  return {
    focusProps: {
      onFocus: !z && (Y || ie || ne) ? ae : void 0,
      onBlur: !z && (ne || ie) ? oe : void 0
    }
  };
}
let $507fabe10e71c6fb$var$currentModality = null, $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set(), $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map(), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1;
const $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: !0,
  Escape: !0
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(B, z) {
  for (let Y of $507fabe10e71c6fb$var$changeHandlers) Y(B, z);
}
function $507fabe10e71c6fb$var$isValidKey(B) {
  return !(B.metaKey || !$c87311424ea30a05$export$9ac100e40613ea10() && B.altKey || B.ctrlKey || B.key === "Control" || B.key === "Shift" || B.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(B) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$isValidKey(B) && ($507fabe10e71c6fb$var$currentModality = "keyboard", $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", B));
}
function $507fabe10e71c6fb$var$handlePointerEvent(B) {
  $507fabe10e71c6fb$var$currentModality = "pointer", (B.type === "mousedown" || B.type === "pointerdown") && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", B));
}
function $507fabe10e71c6fb$var$handleClickEvent(B) {
  $6a7db85432448f7f$export$60278871457622de(B) && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$currentModality = "virtual");
}
function $507fabe10e71c6fb$var$handleFocusEvent(B) {
  B.target === window || B.target === document || (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently && ($507fabe10e71c6fb$var$currentModality = "virtual", $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", B)), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1);
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !0;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(B) {
  if (typeof window > "u" || $507fabe10e71c6fb$export$d90243b58daecda7.get($431fbd86ca7dc216$export$f21a1ffae260145a(B))) return;
  const z = $431fbd86ca7dc216$export$f21a1ffae260145a(B), Y = $431fbd86ca7dc216$export$b204af158042fbac(B);
  let ne = z.HTMLElement.prototype.focus;
  z.HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, ne.apply(this, arguments);
  }, Y.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), Y.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), Y.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0), z.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0), z.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < "u" ? (Y.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : (Y.addEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, !0)), z.addEventListener("beforeunload", () => {
    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(B);
  }, {
    once: !0
  }), $507fabe10e71c6fb$export$d90243b58daecda7.set(z, {
    focus: ne
  });
}
const $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (B, z) => {
  const Y = $431fbd86ca7dc216$export$f21a1ffae260145a(B), ne = $431fbd86ca7dc216$export$b204af158042fbac(B);
  z && ne.removeEventListener("DOMContentLoaded", z), $507fabe10e71c6fb$export$d90243b58daecda7.has(Y) && (Y.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(Y).focus, ne.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), ne.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), ne.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0), Y.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0), Y.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < "u" ? (ne.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : (ne.removeEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, !0)), $507fabe10e71c6fb$export$d90243b58daecda7.delete(Y));
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(B) {
  const z = $431fbd86ca7dc216$export$b204af158042fbac(B);
  let Y;
  return z.readyState !== "loading" ? $507fabe10e71c6fb$var$setupGlobalFocusEvents(B) : (Y = () => {
    $507fabe10e71c6fb$var$setupGlobalFocusEvents(B);
  }, z.addEventListener("DOMContentLoaded", Y)), () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(B, Y);
}
typeof document < "u" && $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
const $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(B, z, Y) {
  var ne;
  const ie = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).HTMLInputElement : HTMLInputElement, oe = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).HTMLTextAreaElement : HTMLTextAreaElement, se = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).HTMLElement : HTMLElement, ae = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).KeyboardEvent : KeyboardEvent;
  return B = B || (Y == null ? void 0 : Y.target) instanceof ie && !$507fabe10e71c6fb$var$nonTextInputTypes.has(Y == null || (ne = Y.target) === null || ne === void 0 ? void 0 : ne.type) || (Y == null ? void 0 : Y.target) instanceof oe || (Y == null ? void 0 : Y.target) instanceof se && (Y == null ? void 0 : Y.target.isContentEditable), !(B && z === "keyboard" && Y instanceof ae && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[Y.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(B, z, Y) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents(), useEffect(() => {
    let ne = (ie, oe) => {
      $507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(Y != null && Y.isTextInput), ie, oe) && B($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    return $507fabe10e71c6fb$var$changeHandlers.add(ne), () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(ne);
    };
  }, z);
}
function $9ab94262bd0047c7$export$420e68273165f4ec(B) {
  let { isDisabled: z, onBlurWithin: Y, onFocusWithin: ne, onFocusWithinChange: ie } = B, oe = useRef({
    isFocusWithin: !1
  }), se = useCallback((Pe) => {
    oe.current.isFocusWithin && !Pe.currentTarget.contains(Pe.relatedTarget) && (oe.current.isFocusWithin = !1, Y && Y(Pe), ie && ie(!1));
  }, [
    Y,
    ie,
    oe
  ]), ae = $8a9cb279dc87e130$export$715c682d09d639cc(se), ve = useCallback((Pe) => {
    !oe.current.isFocusWithin && document.activeElement === Pe.target && (ne && ne(Pe), ie && ie(!0), oe.current.isFocusWithin = !0, ae(Pe));
  }, [
    ne,
    ie,
    ae
  ]);
  return z ? {
    focusWithinProps: {
      // These should not have been null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  } : {
    focusWithinProps: {
      onFocus: ve,
      onBlur: se
    }
  };
}
let $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1, $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !0, setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(B) {
  B.pointerType === "touch" && $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (!(typeof document > "u"))
    return typeof PointerEvent < "u" ? document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent) : document.addEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents), $6179b936705e76d3$var$hoverCount++, () => {
      $6179b936705e76d3$var$hoverCount--, !($6179b936705e76d3$var$hoverCount > 0) && (typeof PointerEvent < "u" ? document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent) : document.removeEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents));
    };
}
function $6179b936705e76d3$export$ae780daf29e6d456(B) {
  let { onHoverStart: z, onHoverChange: Y, onHoverEnd: ne, isDisabled: ie } = B, [oe, se] = useState(!1), ae = useRef({
    isHovered: !1,
    ignoreEmulatedMouseEvents: !1,
    pointerType: "",
    target: null
  }).current;
  useEffect($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { hoverProps: ve, triggerHoverEnd: Pe } = useMemo(() => {
    let le = (Ce, _t) => {
      if (ae.pointerType = _t, ie || _t === "touch" || ae.isHovered || !Ce.currentTarget.contains(Ce.target)) return;
      ae.isHovered = !0;
      let kt = Ce.currentTarget;
      ae.target = kt, z && z({
        type: "hoverstart",
        target: kt,
        pointerType: _t
      }), Y && Y(!0), se(!0);
    }, Ee = (Ce, _t) => {
      if (ae.pointerType = "", ae.target = null, _t === "touch" || !ae.isHovered) return;
      ae.isHovered = !1;
      let kt = Ce.currentTarget;
      ne && ne({
        type: "hoverend",
        target: kt,
        pointerType: _t
      }), Y && Y(!1), se(!1);
    }, Je = {};
    return typeof PointerEvent < "u" ? (Je.onPointerEnter = (Ce) => {
      $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && Ce.pointerType === "mouse" || le(Ce, Ce.pointerType);
    }, Je.onPointerLeave = (Ce) => {
      !ie && Ce.currentTarget.contains(Ce.target) && Ee(Ce, Ce.pointerType);
    }) : (Je.onTouchStart = () => {
      ae.ignoreEmulatedMouseEvents = !0;
    }, Je.onMouseEnter = (Ce) => {
      !ae.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && le(Ce, "mouse"), ae.ignoreEmulatedMouseEvents = !1;
    }, Je.onMouseLeave = (Ce) => {
      !ie && Ce.currentTarget.contains(Ce.target) && Ee(Ce, "mouse");
    }), {
      hoverProps: Je,
      triggerHoverEnd: Ee
    };
  }, [
    z,
    Y,
    ne,
    ie,
    ae
  ]);
  return useEffect(() => {
    ie && Pe({
      currentTarget: ae.target
    }, ae.pointerType);
  }, [
    ie
  ]), {
    hoverProps: ve,
    isHovered: oe
  };
}
function $f7dceffc5ad7768b$export$4e328f61c538687f(B = {}) {
  let { autoFocus: z = !1, isTextInput: Y, within: ne } = B, ie = useRef({
    isFocused: !1,
    isFocusVisible: z || $507fabe10e71c6fb$export$b9b3dfddab17db27()
  }), [oe, se] = useState(!1), [ae, ve] = useState(() => ie.current.isFocused && ie.current.isFocusVisible), Pe = useCallback(() => ve(ie.current.isFocused && ie.current.isFocusVisible), []), le = useCallback((Ce) => {
    ie.current.isFocused = Ce, se(Ce), Pe();
  }, [
    Pe
  ]);
  $507fabe10e71c6fb$export$ec71b4b83ac08ec3((Ce) => {
    ie.current.isFocusVisible = Ce, Pe();
  }, [], {
    isTextInput: Y
  });
  let { focusProps: Ee } = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({
    isDisabled: ne,
    onFocusChange: le
  }), { focusWithinProps: Je } = $9ab94262bd0047c7$export$420e68273165f4ec({
    isDisabled: !ne,
    onFocusWithinChange: le
  });
  return {
    isFocused: oe,
    isFocusVisible: ae,
    focusProps: ne ? Je : Ee
  };
}
var i$7 = Object.defineProperty, d$3 = (B, z, Y) => z in B ? i$7(B, z, { enumerable: !0, configurable: !0, writable: !0, value: Y }) : B[z] = Y, r$5 = (B, z, Y) => (d$3(B, typeof z != "symbol" ? z + "" : z, Y), Y);
let o$6 = class {
  constructor() {
    r$5(this, "current", this.detect()), r$5(this, "handoffState", "pending"), r$5(this, "currentId", 0);
  }
  set(z) {
    this.current !== z && (this.handoffState = "pending", this.currentId = 0, this.current = z);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$9 = new o$6();
function u$8(B) {
  return s$9.isServer ? null : B instanceof Node ? B.ownerDocument : B != null && B.hasOwnProperty("current") && B.current instanceof Node ? B.current.ownerDocument : document;
}
function t$4(B) {
  typeof queueMicrotask == "function" ? queueMicrotask(B) : Promise.resolve().then(B).catch((z) => setTimeout(() => {
    throw z;
  }));
}
function o$5() {
  let B = [], z = { addEventListener(Y, ne, ie, oe) {
    return Y.addEventListener(ne, ie, oe), z.add(() => Y.removeEventListener(ne, ie, oe));
  }, requestAnimationFrame(...Y) {
    let ne = requestAnimationFrame(...Y);
    return z.add(() => cancelAnimationFrame(ne));
  }, nextFrame(...Y) {
    return z.requestAnimationFrame(() => z.requestAnimationFrame(...Y));
  }, setTimeout(...Y) {
    let ne = setTimeout(...Y);
    return z.add(() => clearTimeout(ne));
  }, microTask(...Y) {
    let ne = { current: !0 };
    return t$4(() => {
      ne.current && Y[0]();
    }), z.add(() => {
      ne.current = !1;
    });
  }, style(Y, ne, ie) {
    let oe = Y.style.getPropertyValue(ne);
    return Object.assign(Y.style, { [ne]: ie }), this.add(() => {
      Object.assign(Y.style, { [ne]: oe });
    });
  }, group(Y) {
    let ne = o$5();
    return Y(ne), this.add(() => ne.dispose());
  }, add(Y) {
    return B.includes(Y) || B.push(Y), () => {
      let ne = B.indexOf(Y);
      if (ne >= 0) for (let ie of B.splice(ne, 1)) ie();
    };
  }, dispose() {
    for (let Y of B.splice(0)) Y();
  } };
  return z;
}
function p$2() {
  let [B] = useState(o$5);
  return useEffect(() => () => B.dispose(), [B]), B;
}
let n$3 = (B, z) => {
  s$9.isServer ? useEffect(B, z) : useLayoutEffect(B, z);
};
function s$8(B) {
  let z = useRef(B);
  return n$3(() => {
    z.current = B;
  }, [B]), z;
}
let o$4 = function(B) {
  let z = s$8(B);
  return React__default.useCallback((...Y) => z.current(...Y), [z]);
};
function E$2(B) {
  let z = B.width / 2, Y = B.height / 2;
  return { top: B.clientY - Y, right: B.clientX + z, bottom: B.clientY + Y, left: B.clientX - z };
}
function P$3(B, z) {
  return !(!B || !z || B.right < z.left || B.left > z.right || B.bottom < z.top || B.top > z.bottom);
}
function w$5({ disabled: B = !1 } = {}) {
  let z = useRef(null), [Y, ne] = useState(!1), ie = p$2(), oe = o$4(() => {
    z.current = null, ne(!1), ie.dispose();
  }), se = o$4((ae) => {
    if (ie.dispose(), z.current === null) {
      z.current = ae.currentTarget, ne(!0);
      {
        let ve = u$8(ae.currentTarget);
        ie.addEventListener(ve, "pointerup", oe, !1), ie.addEventListener(ve, "pointermove", (Pe) => {
          if (z.current) {
            let le = E$2(Pe);
            ne(P$3(le, z.current.getBoundingClientRect()));
          }
        }, !1), ie.addEventListener(ve, "pointercancel", oe, !1);
      }
    }
  });
  return { pressed: Y, pressProps: B ? {} : { onPointerDown: se, onPointerUp: oe, onClick: oe } };
}
let e$4 = createContext(void 0);
function a$b() {
  return useContext(e$4);
}
function t$3(...B) {
  return Array.from(new Set(B.flatMap((z) => typeof z == "string" ? z.split(" ") : []))).filter(Boolean).join(" ");
}
function u$7(B, z, ...Y) {
  if (B in z) {
    let ie = z[B];
    return typeof ie == "function" ? ie(...Y) : ie;
  }
  let ne = new Error(`Tried to handle "${B}" but there is no handler defined. Only defined handlers are: ${Object.keys(z).map((ie) => `"${ie}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(ne, u$7), ne;
}
var O$3 = ((B) => (B[B.None = 0] = "None", B[B.RenderStrategy = 1] = "RenderStrategy", B[B.Static = 2] = "Static", B))(O$3 || {}), A$1 = ((B) => (B[B.Unmount = 0] = "Unmount", B[B.Hidden = 1] = "Hidden", B))(A$1 || {});
function L$1() {
  let B = U$3();
  return useCallback((z) => C$3({ mergeRefs: B, ...z }), [B]);
}
function C$3({ ourProps: B, theirProps: z, slot: Y, defaultTag: ne, features: ie, visible: oe = !0, name: se, mergeRefs: ae }) {
  ae = ae ?? $$1;
  let ve = P$2(z, B);
  if (oe) return F$2(ve, Y, ne, se, ae);
  let Pe = ie ?? 0;
  if (Pe & 2) {
    let { static: le = !1, ...Ee } = ve;
    if (le) return F$2(Ee, Y, ne, se, ae);
  }
  if (Pe & 1) {
    let { unmount: le = !0, ...Ee } = ve;
    return u$7(le ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return F$2({ ...Ee, hidden: !0, style: { display: "none" } }, Y, ne, se, ae);
    } });
  }
  return F$2(ve, Y, ne, se, ae);
}
function F$2(B, z = {}, Y, ne, ie) {
  let { as: oe = Y, children: se, refName: ae = "ref", ...ve } = h$4(B, ["unmount", "static"]), Pe = B.ref !== void 0 ? { [ae]: B.ref } : {}, le = typeof se == "function" ? se(z) : se;
  "className" in ve && ve.className && typeof ve.className == "function" && (ve.className = ve.className(z)), ve["aria-labelledby"] && ve["aria-labelledby"] === ve.id && (ve["aria-labelledby"] = void 0);
  let Ee = {};
  if (z) {
    let Je = !1, Ce = [];
    for (let [_t, kt] of Object.entries(z)) typeof kt == "boolean" && (Je = !0), kt === !0 && Ce.push(_t.replace(/([A-Z])/g, (Ct) => `-${Ct.toLowerCase()}`));
    if (Je) {
      Ee["data-headlessui-state"] = Ce.join(" ");
      for (let _t of Ce) Ee[`data-${_t}`] = "";
    }
  }
  if (oe === Fragment && (Object.keys(m$4(ve)).length > 0 || Object.keys(m$4(Ee)).length > 0)) if (!isValidElement(le) || Array.isArray(le) && le.length > 1) {
    if (Object.keys(m$4(ve)).length > 0) throw new Error(['Passing props on "Fragment"!', "", `The current component <${ne} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(m$4(ve)).concat(Object.keys(m$4(Ee))).map((Je) => `  - ${Je}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((Je) => `  - ${Je}`).join(`
`)].join(`
`));
  } else {
    let Je = le.props, Ce = Je == null ? void 0 : Je.className, _t = typeof Ce == "function" ? (...Lt) => t$3(Ce(...Lt), ve.className) : t$3(Ce, ve.className), kt = _t ? { className: _t } : {}, Ct = P$2(le.props, m$4(h$4(ve, ["ref"])));
    for (let Lt in Ee) Lt in Ct && delete Ee[Lt];
    return cloneElement(le, Object.assign({}, Ct, Ee, Pe, { ref: ie(H$3(le), Pe.ref) }, kt));
  }
  return createElement(oe, Object.assign({}, h$4(ve, ["ref"]), oe !== Fragment && Pe, oe !== Fragment && Ee), le);
}
function U$3() {
  let B = useRef([]), z = useCallback((Y) => {
    for (let ne of B.current) ne != null && (typeof ne == "function" ? ne(Y) : ne.current = Y);
  }, []);
  return (...Y) => {
    if (!Y.every((ne) => ne == null)) return B.current = Y, z;
  };
}
function $$1(...B) {
  return B.every((z) => z == null) ? void 0 : (z) => {
    for (let Y of B) Y != null && (typeof Y == "function" ? Y(z) : Y.current = z);
  };
}
function P$2(...B) {
  if (B.length === 0) return {};
  if (B.length === 1) return B[0];
  let z = {}, Y = {};
  for (let ne of B) for (let ie in ne) ie.startsWith("on") && typeof ne[ie] == "function" ? (Y[ie] != null || (Y[ie] = []), Y[ie].push(ne[ie])) : z[ie] = ne[ie];
  if (z.disabled || z["aria-disabled"]) for (let ne in Y) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(ne) && (Y[ne] = [(ie) => {
    var oe;
    return (oe = ie == null ? void 0 : ie.preventDefault) == null ? void 0 : oe.call(ie);
  }]);
  for (let ne in Y) Object.assign(z, { [ne](ie, ...oe) {
    let se = Y[ne];
    for (let ae of se) {
      if ((ie instanceof Event || (ie == null ? void 0 : ie.nativeEvent) instanceof Event) && ie.defaultPrevented) return;
      ae(ie, ...oe);
    }
  } });
  return z;
}
function _$2(...B) {
  if (B.length === 0) return {};
  if (B.length === 1) return B[0];
  let z = {}, Y = {};
  for (let ne of B) for (let ie in ne) ie.startsWith("on") && typeof ne[ie] == "function" ? (Y[ie] != null || (Y[ie] = []), Y[ie].push(ne[ie])) : z[ie] = ne[ie];
  for (let ne in Y) Object.assign(z, { [ne](...ie) {
    let oe = Y[ne];
    for (let se of oe) se == null || se(...ie);
  } });
  return z;
}
function K$6(B) {
  var z;
  return Object.assign(forwardRef(B), { displayName: (z = B.displayName) != null ? z : B.name });
}
function m$4(B) {
  let z = Object.assign({}, B);
  for (let Y in z) z[Y] === void 0 && delete z[Y];
  return z;
}
function h$4(B, z = []) {
  let Y = Object.assign({}, B);
  for (let ne of z) ne in Y && delete Y[ne];
  return Y;
}
function H$3(B) {
  return React__default.version.split(".")[0] >= "19" ? B.props.ref : B.ref;
}
let a$a = "span";
var s$7 = ((B) => (B[B.None = 1] = "None", B[B.Focusable = 2] = "Focusable", B[B.Hidden = 4] = "Hidden", B))(s$7 || {});
function l$2(B, z) {
  var Y;
  let { features: ne = 1, ...ie } = B, oe = { ref: z, "aria-hidden": (ne & 2) === 2 ? !0 : (Y = ie["aria-hidden"]) != null ? Y : void 0, hidden: (ne & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(ne & 4) === 4 && (ne & 2) !== 2 && { display: "none" } } };
  return L$1()({ ourProps: oe, theirProps: ie, slot: {}, defaultTag: a$a, name: "Hidden" });
}
let f$a = K$6(l$2), e$3 = createContext(void 0);
function u$6() {
  return useContext(e$3);
}
function r$4(B) {
  let z = B.parentElement, Y = null;
  for (; z && !(z instanceof HTMLFieldSetElement); ) z instanceof HTMLLegendElement && (Y = z), z = z.parentElement;
  let ne = (z == null ? void 0 : z.getAttribute("disabled")) === "";
  return ne && i$6(Y) ? !1 : ne;
}
function i$6(B) {
  if (!B) return !1;
  let z = B.previousElementSibling;
  for (; z !== null; ) {
    if (z instanceof HTMLLegendElement) return !1;
    z = z.previousElementSibling;
  }
  return !0;
}
let u$5 = Symbol();
function T$2(B, z = !0) {
  return Object.assign(B, { [u$5]: z });
}
function y$4(...B) {
  let z = useRef(B);
  useEffect(() => {
    z.current = B;
  }, [B]);
  let Y = o$4((ne) => {
    for (let ie of z.current) ie != null && (typeof ie == "function" ? ie(ne) : ie.current = ne);
  });
  return B.every((ne) => ne == null || (ne == null ? void 0 : ne[u$5])) ? void 0 : Y;
}
let a$9 = createContext(null);
a$9.displayName = "DescriptionContext";
function f$9() {
  let B = useContext(a$9);
  if (B === null) {
    let z = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(z, f$9), z;
  }
  return B;
}
function w$4() {
  let [B, z] = useState([]);
  return [B.length > 0 ? B.join(" ") : void 0, useMemo(() => function(Y) {
    let ne = o$4((oe) => (z((se) => [...se, oe]), () => z((se) => {
      let ae = se.slice(), ve = ae.indexOf(oe);
      return ve !== -1 && ae.splice(ve, 1), ae;
    }))), ie = useMemo(() => ({ register: ne, slot: Y.slot, name: Y.name, props: Y.props, value: Y.value }), [ne, Y.slot, Y.name, Y.props, Y.value]);
    return React__default.createElement(a$9.Provider, { value: ie }, Y.children);
  }, [z])];
}
let S$2 = "p";
function C$2(B, z) {
  let Y = useId$1(), ne = a$b(), { id: ie = `headlessui-description-${Y}`, ...oe } = B, se = f$9(), ae = y$4(z);
  n$3(() => se.register(ie), [ie, se.register]);
  let ve = ne || !1, Pe = useMemo(() => ({ ...se.slot, disabled: ve }), [se.slot, ve]), le = { ref: ae, ...se.props, id: ie };
  return L$1()({ ourProps: le, theirProps: oe, slot: Pe, defaultTag: S$2, name: se.name || "Description" });
}
let _$1 = K$6(C$2), H$2 = Object.assign(_$1, {});
var o$3 = ((B) => (B.Space = " ", B.Enter = "Enter", B.Escape = "Escape", B.Backspace = "Backspace", B.Delete = "Delete", B.ArrowLeft = "ArrowLeft", B.ArrowUp = "ArrowUp", B.ArrowRight = "ArrowRight", B.ArrowDown = "ArrowDown", B.Home = "Home", B.End = "End", B.PageUp = "PageUp", B.PageDown = "PageDown", B.Tab = "Tab", B))(o$3 || {});
let c$4 = createContext(null);
c$4.displayName = "LabelContext";
function P$1() {
  let B = useContext(c$4);
  if (B === null) {
    let z = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(z, P$1), z;
  }
  return B;
}
function I$3(B) {
  var z, Y, ne;
  let ie = (Y = (z = useContext(c$4)) == null ? void 0 : z.value) != null ? Y : void 0;
  return ((ne = void 0) != null ? ne : 0) > 0 ? [ie, ...B].filter(Boolean).join(" ") : ie;
}
function K$5({ inherit: B = !1 } = {}) {
  let z = I$3(), [Y, ne] = useState([]), ie = B ? [z, ...Y].filter(Boolean) : Y;
  return [ie.length > 0 ? ie.join(" ") : void 0, useMemo(() => function(oe) {
    let se = o$4((ve) => (ne((Pe) => [...Pe, ve]), () => ne((Pe) => {
      let le = Pe.slice(), Ee = le.indexOf(ve);
      return Ee !== -1 && le.splice(Ee, 1), le;
    }))), ae = useMemo(() => ({ register: se, slot: oe.slot, name: oe.name, props: oe.props, value: oe.value }), [se, oe.slot, oe.name, oe.props, oe.value]);
    return React__default.createElement(c$4.Provider, { value: ae }, oe.children);
  }, [ne])];
}
let N$1 = "label";
function G$2(B, z) {
  var Y;
  let ne = useId$1(), ie = P$1(), oe = u$6(), se = a$b(), { id: ae = `headlessui-label-${ne}`, htmlFor: ve = oe ?? ((Y = ie.props) == null ? void 0 : Y.htmlFor), passive: Pe = !1, ...le } = B, Ee = y$4(z);
  n$3(() => ie.register(ae), [ae, ie.register]);
  let Je = o$4((Ct) => {
    let Lt = Ct.currentTarget;
    if (Lt instanceof HTMLLabelElement && Ct.preventDefault(), ie.props && "onClick" in ie.props && typeof ie.props.onClick == "function" && ie.props.onClick(Ct), Lt instanceof HTMLLabelElement) {
      let Pt = document.getElementById(Lt.htmlFor);
      if (Pt) {
        let Ft = Pt.getAttribute("disabled");
        if (Ft === "true" || Ft === "") return;
        let Ut = Pt.getAttribute("aria-disabled");
        if (Ut === "true" || Ut === "") return;
        (Pt instanceof HTMLInputElement && (Pt.type === "radio" || Pt.type === "checkbox") || Pt.role === "radio" || Pt.role === "checkbox" || Pt.role === "switch") && Pt.click(), Pt.focus({ preventScroll: !0 });
      }
    }
  }), Ce = se || !1, _t = useMemo(() => ({ ...ie.slot, disabled: Ce }), [ie.slot, Ce]), kt = { ref: Ee, ...ie.props, id: ae, htmlFor: ve, onClick: Je };
  return Pe && ("onClick" in kt && (delete kt.htmlFor, delete kt.onClick), "onClick" in le && delete le.onClick), L$1()({ ourProps: kt, theirProps: le, slot: _t, defaultTag: ve ? N$1 : "div", name: ie.name || "Label" });
}
let U$2 = K$6(G$2);
Object.assign(U$2, {});
let e$2 = createContext(() => {
});
function C$1({ value: B, children: z }) {
  return React__default.createElement(e$2.Provider, { value: B }, z);
}
function f$8(B) {
  if (B === null) return { width: 0, height: 0 };
  let { width: z, height: Y } = B.getBoundingClientRect();
  return { width: z, height: Y };
}
function d$2(B, z = !1) {
  let [Y, ne] = useReducer(() => ({}), {}), ie = useMemo(() => f$8(B), [B, Y]);
  return n$3(() => {
    if (!B) return;
    let oe = new ResizeObserver(ne);
    return oe.observe(B), () => {
      oe.disconnect();
    };
  }, [B]), z ? { width: `${ie.width}px`, height: `${ie.height}px` } : ie;
}
let a$8 = class extends Map {
  constructor(z) {
    super(), this.factory = z;
  }
  get(z) {
    let Y = super.get(z);
    return Y === void 0 && (Y = this.factory(z), this.set(z, Y)), Y;
  }
};
function a$7(B, z) {
  let Y = B(), ne = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return Y;
  }, subscribe(ie) {
    return ne.add(ie), () => ne.delete(ie);
  }, dispatch(ie, ...oe) {
    let se = z[ie].call(Y, ...oe);
    se && (Y = se, ne.forEach((ae) => ae()));
  } };
}
function o$2(B) {
  return useSyncExternalStore(B.subscribe, B.getSnapshot, B.getSnapshot);
}
let p$1 = new a$8(() => a$7(() => [], { ADD(B) {
  return this.includes(B) ? this : [...this, B];
}, REMOVE(B) {
  let z = this.indexOf(B);
  if (z === -1) return this;
  let Y = this.slice();
  return Y.splice(z, 1), Y;
} }));
function x$3(B, z) {
  let Y = p$1.get(z), ne = useId$1(), ie = o$2(Y);
  if (n$3(() => {
    if (B) return Y.dispatch("ADD", ne), () => Y.dispatch("REMOVE", ne);
  }, [Y, B]), !B) return !1;
  let oe = ie.indexOf(ne), se = ie.length;
  return oe === -1 && (oe = se, se += 1), oe === se - 1;
}
let f$7 = /* @__PURE__ */ new Map(), u$4 = /* @__PURE__ */ new Map();
function h$3(B) {
  var z;
  let Y = (z = u$4.get(B)) != null ? z : 0;
  return u$4.set(B, Y + 1), Y !== 0 ? () => m$3(B) : (f$7.set(B, { "aria-hidden": B.getAttribute("aria-hidden"), inert: B.inert }), B.setAttribute("aria-hidden", "true"), B.inert = !0, () => m$3(B));
}
function m$3(B) {
  var z;
  let Y = (z = u$4.get(B)) != null ? z : 1;
  if (Y === 1 ? u$4.delete(B) : u$4.set(B, Y - 1), Y !== 1) return;
  let ne = f$7.get(B);
  ne && (ne["aria-hidden"] === null ? B.removeAttribute("aria-hidden") : B.setAttribute("aria-hidden", ne["aria-hidden"]), B.inert = ne.inert, f$7.delete(B));
}
function y$3(B, { allowed: z, disallowed: Y } = {}) {
  let ne = x$3(B, "inert-others");
  n$3(() => {
    var ie, oe;
    if (!ne) return;
    let se = o$5();
    for (let ve of (ie = Y == null ? void 0 : Y()) != null ? ie : []) ve && se.add(h$3(ve));
    let ae = (oe = z == null ? void 0 : z()) != null ? oe : [];
    for (let ve of ae) {
      if (!ve) continue;
      let Pe = u$8(ve);
      if (!Pe) continue;
      let le = ve.parentElement;
      for (; le && le !== Pe.body; ) {
        for (let Ee of le.children) ae.some((Je) => Ee.contains(Je)) || se.add(h$3(Ee));
        le = le.parentElement;
      }
    }
    return se.dispose;
  }, [ne, z, Y]);
}
function m$2(B, z, Y) {
  let ne = s$8((ie) => {
    let oe = ie.getBoundingClientRect();
    oe.x === 0 && oe.y === 0 && oe.width === 0 && oe.height === 0 && Y();
  });
  useEffect(() => {
    if (!B) return;
    let ie = z === null ? null : z instanceof HTMLElement ? z : z.current;
    if (!ie) return;
    let oe = o$5();
    if (typeof ResizeObserver < "u") {
      let se = new ResizeObserver(() => ne.current(ie));
      se.observe(ie), oe.add(() => se.disconnect());
    }
    if (typeof IntersectionObserver < "u") {
      let se = new IntersectionObserver(() => ne.current(ie));
      se.observe(ie), oe.add(() => se.disconnect());
    }
    return () => oe.dispose();
  }, [z, ne, B]);
}
let f$6 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((B) => `${B}:not([tabindex='-1'])`).join(","), p = ["[data-autofocus]"].map((B) => `${B}:not([tabindex='-1'])`).join(",");
var F$1 = ((B) => (B[B.First = 1] = "First", B[B.Previous = 2] = "Previous", B[B.Next = 4] = "Next", B[B.Last = 8] = "Last", B[B.WrapAround = 16] = "WrapAround", B[B.NoScroll = 32] = "NoScroll", B[B.AutoFocus = 64] = "AutoFocus", B))(F$1 || {}), T$1 = ((B) => (B[B.Error = 0] = "Error", B[B.Overflow = 1] = "Overflow", B[B.Success = 2] = "Success", B[B.Underflow = 3] = "Underflow", B))(T$1 || {}), y$2 = ((B) => (B[B.Previous = -1] = "Previous", B[B.Next = 1] = "Next", B))(y$2 || {});
function b$2(B = document.body) {
  return B == null ? [] : Array.from(B.querySelectorAll(f$6)).sort((z, Y) => Math.sign((z.tabIndex || Number.MAX_SAFE_INTEGER) - (Y.tabIndex || Number.MAX_SAFE_INTEGER)));
}
function S$1(B = document.body) {
  return B == null ? [] : Array.from(B.querySelectorAll(p)).sort((z, Y) => Math.sign((z.tabIndex || Number.MAX_SAFE_INTEGER) - (Y.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var h$2 = ((B) => (B[B.Strict = 0] = "Strict", B[B.Loose = 1] = "Loose", B))(h$2 || {});
function A(B, z = 0) {
  var Y;
  return B === ((Y = u$8(B)) == null ? void 0 : Y.body) ? !1 : u$7(z, { 0() {
    return B.matches(f$6);
  }, 1() {
    let ne = B;
    for (; ne !== null; ) {
      if (ne.matches(f$6)) return !0;
      ne = ne.parentElement;
    }
    return !1;
  } });
}
function G$1(B) {
  let z = u$8(B);
  o$5().nextFrame(() => {
    z && !A(z.activeElement, 0) && I$2(B);
  });
}
var H$1 = ((B) => (B[B.Keyboard = 0] = "Keyboard", B[B.Mouse = 1] = "Mouse", B))(H$1 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (B) => {
  B.metaKey || B.altKey || B.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (B) => {
  B.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : B.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function I$2(B) {
  B == null || B.focus({ preventScroll: !0 });
}
let w$3 = ["textarea", "input"].join(",");
function O$2(B) {
  var z, Y;
  return (Y = (z = B == null ? void 0 : B.matches) == null ? void 0 : z.call(B, w$3)) != null ? Y : !1;
}
function _(B, z = (Y) => Y) {
  return B.slice().sort((Y, ne) => {
    let ie = z(Y), oe = z(ne);
    if (ie === null || oe === null) return 0;
    let se = ie.compareDocumentPosition(oe);
    return se & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : se & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function j$3(B, z) {
  return P(b$2(), z, { relativeTo: B });
}
function P(B, z, { sorted: Y = !0, relativeTo: ne = null, skipElements: ie = [] } = {}) {
  let oe = Array.isArray(B) ? B.length > 0 ? B[0].ownerDocument : document : B.ownerDocument, se = Array.isArray(B) ? Y ? _(B) : B : z & 64 ? S$1(B) : b$2(B);
  ie.length > 0 && se.length > 1 && (se = se.filter((Ce) => !ie.some((_t) => _t != null && "current" in _t ? (_t == null ? void 0 : _t.current) === Ce : _t === Ce))), ne = ne ?? oe.activeElement;
  let ae = (() => {
    if (z & 5) return 1;
    if (z & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ve = (() => {
    if (z & 1) return 0;
    if (z & 2) return Math.max(0, se.indexOf(ne)) - 1;
    if (z & 4) return Math.max(0, se.indexOf(ne)) + 1;
    if (z & 8) return se.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), Pe = z & 32 ? { preventScroll: !0 } : {}, le = 0, Ee = se.length, Je;
  do {
    if (le >= Ee || le + Ee <= 0) return 0;
    let Ce = ve + le;
    if (z & 16) Ce = (Ce + Ee) % Ee;
    else {
      if (Ce < 0) return 3;
      if (Ce >= Ee) return 1;
    }
    Je = se[Ce], Je == null || Je.focus(Pe), le += ae;
  } while (Je !== oe.activeElement);
  return z & 6 && O$2(Je) && Je.select(), 2;
}
function t$2() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$5() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$2() {
  return t$2() || i$5();
}
function i$4(B, z, Y, ne) {
  let ie = s$8(Y);
  useEffect(() => {
    if (!B) return;
    function oe(se) {
      ie.current(se);
    }
    return document.addEventListener(z, oe, ne), () => document.removeEventListener(z, oe, ne);
  }, [B, z, ne]);
}
function s$6(B, z, Y, ne) {
  let ie = s$8(Y);
  useEffect(() => {
    if (!B) return;
    function oe(se) {
      ie.current(se);
    }
    return window.addEventListener(z, oe, ne), () => window.removeEventListener(z, oe, ne);
  }, [B, z, ne]);
}
const E$1 = 30;
function R$3(B, z, Y) {
  let ne = x$3(B, "outside-click"), ie = s$8(Y), oe = useCallback(function(ve, Pe) {
    if (ve.defaultPrevented) return;
    let le = Pe(ve);
    if (le === null || !le.getRootNode().contains(le) || !le.isConnected) return;
    let Ee = function Je(Ce) {
      return typeof Ce == "function" ? Je(Ce()) : Array.isArray(Ce) || Ce instanceof Set ? Ce : [Ce];
    }(z);
    for (let Je of Ee) if (Je !== null && (Je.contains(le) || ve.composed && ve.composedPath().includes(Je))) return;
    return !A(le, h$2.Loose) && le.tabIndex !== -1 && ve.preventDefault(), ie.current(ve, le);
  }, [ie, z]), se = useRef(null);
  i$4(ne, "pointerdown", (ve) => {
    var Pe, le;
    se.current = ((le = (Pe = ve.composedPath) == null ? void 0 : Pe.call(ve)) == null ? void 0 : le[0]) || ve.target;
  }, !0), i$4(ne, "mousedown", (ve) => {
    var Pe, le;
    se.current = ((le = (Pe = ve.composedPath) == null ? void 0 : Pe.call(ve)) == null ? void 0 : le[0]) || ve.target;
  }, !0), i$4(ne, "click", (ve) => {
    n$2() || se.current && (oe(ve, () => se.current), se.current = null);
  }, !0);
  let ae = useRef({ x: 0, y: 0 });
  i$4(ne, "touchstart", (ve) => {
    ae.current.x = ve.touches[0].clientX, ae.current.y = ve.touches[0].clientY;
  }, !0), i$4(ne, "touchend", (ve) => {
    let Pe = { x: ve.changedTouches[0].clientX, y: ve.changedTouches[0].clientY };
    if (!(Math.abs(Pe.x - ae.current.x) >= E$1 || Math.abs(Pe.y - ae.current.y) >= E$1)) return oe(ve, () => ve.target instanceof HTMLElement ? ve.target : null);
  }, !0), s$6(ne, "blur", (ve) => oe(ve, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$1(...B) {
  return useMemo(() => u$8(...B), [...B]);
}
function E(B, z, Y, ne) {
  let ie = s$8(Y);
  useEffect(() => {
    B = B ?? window;
    function oe(se) {
      ie.current(se);
    }
    return B.addEventListener(z, oe, ne), () => B.removeEventListener(z, oe, ne);
  }, [B, z, ne]);
}
function e$1(B, z) {
  return useMemo(() => {
    var Y;
    if (B.type) return B.type;
    let ne = (Y = B.as) != null ? Y : "button";
    if (typeof ne == "string" && ne.toLowerCase() === "button" || (z == null ? void 0 : z.tagName) === "BUTTON" && !z.hasAttribute("type")) return "button";
  }, [B.type, B.as, z]);
}
function d$1() {
  let B;
  return { before({ doc: z }) {
    var Y;
    let ne = z.documentElement, ie = (Y = z.defaultView) != null ? Y : window;
    B = Math.max(0, ie.innerWidth - ne.clientWidth);
  }, after({ doc: z, d: Y }) {
    let ne = z.documentElement, ie = Math.max(0, ne.clientWidth - ne.offsetWidth), oe = Math.max(0, B - ie);
    Y.style(ne, "paddingRight", `${oe}px`);
  } };
}
function d() {
  return t$2() ? { before({ doc: B, d: z, meta: Y }) {
    function ne(ie) {
      return Y.containers.flatMap((oe) => oe()).some((oe) => oe.contains(ie));
    }
    z.microTask(() => {
      var ie;
      if (window.getComputedStyle(B.documentElement).scrollBehavior !== "auto") {
        let ae = o$5();
        ae.style(B.documentElement, "scrollBehavior", "auto"), z.add(() => z.microTask(() => ae.dispose()));
      }
      let oe = (ie = window.scrollY) != null ? ie : window.pageYOffset, se = null;
      z.addEventListener(B, "click", (ae) => {
        if (ae.target instanceof HTMLElement) try {
          let ve = ae.target.closest("a");
          if (!ve) return;
          let { hash: Pe } = new URL(ve.href), le = B.querySelector(Pe);
          le && !ne(le) && (se = le);
        } catch {
        }
      }, !0), z.addEventListener(B, "touchstart", (ae) => {
        if (ae.target instanceof HTMLElement) if (ne(ae.target)) {
          let ve = ae.target;
          for (; ve.parentElement && ne(ve.parentElement); ) ve = ve.parentElement;
          z.style(ve, "overscrollBehavior", "contain");
        } else z.style(ae.target, "touchAction", "none");
      }), z.addEventListener(B, "touchmove", (ae) => {
        if (ae.target instanceof HTMLElement) {
          if (ae.target.tagName === "INPUT") return;
          if (ne(ae.target)) {
            let ve = ae.target;
            for (; ve.parentElement && ve.dataset.headlessuiPortal !== "" && !(ve.scrollHeight > ve.clientHeight || ve.scrollWidth > ve.clientWidth); ) ve = ve.parentElement;
            ve.dataset.headlessuiPortal === "" && ae.preventDefault();
          } else ae.preventDefault();
        }
      }, { passive: !1 }), z.add(() => {
        var ae;
        let ve = (ae = window.scrollY) != null ? ae : window.pageYOffset;
        oe !== ve && window.scrollTo(0, oe), se && se.isConnected && (se.scrollIntoView({ block: "nearest" }), se = null);
      });
    });
  } } : {};
}
function r$3() {
  return { before({ doc: B, d: z }) {
    z.style(B.documentElement, "overflow", "hidden");
  } };
}
function m$1(B) {
  let z = {};
  for (let Y of B) Object.assign(z, Y(z));
  return z;
}
let a$6 = a$7(() => /* @__PURE__ */ new Map(), { PUSH(B, z) {
  var Y;
  let ne = (Y = this.get(B)) != null ? Y : { doc: B, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return ne.count++, ne.meta.add(z), this.set(B, ne), this;
}, POP(B, z) {
  let Y = this.get(B);
  return Y && (Y.count--, Y.meta.delete(z)), this;
}, SCROLL_PREVENT({ doc: B, d: z, meta: Y }) {
  let ne = { doc: B, d: z, meta: m$1(Y) }, ie = [d(), d$1(), r$3()];
  ie.forEach(({ before: oe }) => oe == null ? void 0 : oe(ne)), ie.forEach(({ after: oe }) => oe == null ? void 0 : oe(ne));
}, SCROLL_ALLOW({ d: B }) {
  B.dispose();
}, TEARDOWN({ doc: B }) {
  this.delete(B);
} });
a$6.subscribe(() => {
  let B = a$6.getSnapshot(), z = /* @__PURE__ */ new Map();
  for (let [Y] of B) z.set(Y, Y.documentElement.style.overflow);
  for (let Y of B.values()) {
    let ne = z.get(Y.doc) === "hidden", ie = Y.count !== 0;
    (ie && !ne || !ie && ne) && a$6.dispatch(Y.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", Y), Y.count === 0 && a$6.dispatch("TEARDOWN", Y);
  }
});
function a$5(B, z, Y = () => ({ containers: [] })) {
  let ne = o$2(a$6), ie = z ? ne.get(z) : void 0, oe = ie ? ie.count > 0 : !1;
  return n$3(() => {
    if (!(!z || !B)) return a$6.dispatch("PUSH", z, Y), () => a$6.dispatch("POP", z, Y);
  }, [B, z]), oe;
}
function f$5(B, z, Y = () => [document.body]) {
  let ne = x$3(B, "scroll-lock");
  a$5(ne, z, (ie) => {
    var oe;
    return { containers: [...(oe = ie.containers) != null ? oe : [], Y] };
  });
}
function t$1(B) {
  return [B.screenX, B.screenY];
}
function u$3() {
  let B = useRef([-1, -1]);
  return { wasMoved(z) {
    let Y = t$1(z);
    return B.current[0] === Y[0] && B.current[1] === Y[1] ? !1 : (B.current = Y, !0);
  }, update(z) {
    B.current = t$1(z);
  } };
}
function c$3(B = 0) {
  let [z, Y] = useState(B), ne = useCallback((ve) => Y(ve), [z]), ie = useCallback((ve) => Y((Pe) => Pe | ve), [z]), oe = useCallback((ve) => (z & ve) === ve, [z]), se = useCallback((ve) => Y((Pe) => Pe & ~ve), [Y]), ae = useCallback((ve) => Y((Pe) => Pe ^ ve), [Y]);
  return { flags: z, setFlag: ne, addFlag: ie, hasFlag: oe, removeFlag: se, toggleFlag: ae };
}
var T, b$1;
typeof process$1 < "u" && typeof globalThis < "u" && typeof Element < "u" && ((T = process$1 == null ? void 0 : process$1.env) == null ? void 0 : T.NODE_ENV) === "test" && typeof ((b$1 = Element == null ? void 0 : Element.prototype) == null ? void 0 : b$1.getAnimations) > "u" && (Element.prototype.getAnimations = function() {
  return console.warn(["Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.", "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.", "", "Example usage:", "```js", "import { mockAnimationsApi } from 'jsdom-testing-mocks'", "mockAnimationsApi()", "```"].join(`
`)), [];
});
var L = ((B) => (B[B.None = 0] = "None", B[B.Closed = 1] = "Closed", B[B.Enter = 2] = "Enter", B[B.Leave = 4] = "Leave", B))(L || {});
function R$2(B) {
  let z = {};
  for (let Y in B) B[Y] === !0 && (z[`data-${Y}`] = "");
  return z;
}
function x$2(B, z, Y, ne) {
  let [ie, oe] = useState(Y), { hasFlag: se, addFlag: ae, removeFlag: ve } = c$3(B && ie ? 3 : 0), Pe = useRef(!1), le = useRef(!1), Ee = p$2();
  return n$3(() => {
    var Je;
    if (B) {
      if (Y && oe(!0), !z) {
        Y && ae(3);
        return;
      }
      return (Je = ne == null ? void 0 : ne.start) == null || Je.call(ne, Y), C(z, { inFlight: Pe, prepare() {
        le.current ? le.current = !1 : le.current = Pe.current, Pe.current = !0, !le.current && (Y ? (ae(3), ve(4)) : (ae(4), ve(2)));
      }, run() {
        le.current ? Y ? (ve(3), ae(4)) : (ve(4), ae(3)) : Y ? ve(1) : ae(1);
      }, done() {
        var Ce;
        le.current && typeof z.getAnimations == "function" && z.getAnimations().length > 0 || (Pe.current = !1, ve(7), Y || oe(!1), (Ce = ne == null ? void 0 : ne.end) == null || Ce.call(ne, Y));
      } });
    }
  }, [B, Y, z, Ee]), B ? [ie, { closed: se(1), enter: se(2), leave: se(4), transition: se(2) || se(4) }] : [Y, { closed: void 0, enter: void 0, leave: void 0, transition: void 0 }];
}
function C(B, { prepare: z, run: Y, done: ne, inFlight: ie }) {
  let oe = o$5();
  return j$2(B, { prepare: z, inFlight: ie }), oe.nextFrame(() => {
    Y(), oe.requestAnimationFrame(() => {
      oe.add(M$2(B, ne));
    });
  }), oe.dispose;
}
function M$2(B, z) {
  var Y, ne;
  let ie = o$5();
  if (!B) return ie.dispose;
  let oe = !1;
  ie.add(() => {
    oe = !0;
  });
  let se = (ne = (Y = B.getAnimations) == null ? void 0 : Y.call(B).filter((ae) => ae instanceof CSSTransition)) != null ? ne : [];
  return se.length === 0 ? (z(), ie.dispose) : (Promise.allSettled(se.map((ae) => ae.finished)).then(() => {
    oe || z();
  }), ie.dispose);
}
function j$2(B, { inFlight: z, prepare: Y }) {
  if (z != null && z.current) {
    Y();
    return;
  }
  let ne = B.style.transition;
  B.style.transition = "none", Y(), B.offsetHeight, B.style.transition = ne;
}
function F(B, { container: z, accept: Y, walk: ne }) {
  let ie = useRef(Y), oe = useRef(ne);
  useEffect(() => {
    ie.current = Y, oe.current = ne;
  }, [Y, ne]), n$3(() => {
    if (!z || !B) return;
    let se = u$8(z);
    if (!se) return;
    let ae = ie.current, ve = oe.current, Pe = Object.assign((Ee) => ae(Ee), { acceptNode: ae }), le = se.createTreeWalker(z, NodeFilter.SHOW_ELEMENT, Pe, !1);
    for (; le.nextNode(); ) ve(le.currentNode);
  }, [z, B, ie, oe]);
}
function m(B, z) {
  let Y = useRef([]), ne = o$4(B);
  useEffect(() => {
    let ie = [...Y.current];
    for (let [oe, se] of z.entries()) if (Y.current[oe] !== se) {
      let ae = ne(z, ie);
      return Y.current = z, ae;
    }
  }, [ne, ...z]);
}
function hasWindow() {
  return typeof window < "u";
}
function getNodeName(B) {
  return isNode(B) ? (B.nodeName || "").toLowerCase() : "#document";
}
function getWindow(B) {
  var z;
  return (B == null || (z = B.ownerDocument) == null ? void 0 : z.defaultView) || window;
}
function getDocumentElement(B) {
  var z;
  return (z = (isNode(B) ? B.ownerDocument : B.document) || window.document) == null ? void 0 : z.documentElement;
}
function isNode(B) {
  return hasWindow() ? B instanceof Node || B instanceof getWindow(B).Node : !1;
}
function isElement(B) {
  return hasWindow() ? B instanceof Element || B instanceof getWindow(B).Element : !1;
}
function isHTMLElement(B) {
  return hasWindow() ? B instanceof HTMLElement || B instanceof getWindow(B).HTMLElement : !1;
}
function isShadowRoot(B) {
  return !hasWindow() || typeof ShadowRoot > "u" ? !1 : B instanceof ShadowRoot || B instanceof getWindow(B).ShadowRoot;
}
function isOverflowElement(B) {
  const {
    overflow: z,
    overflowX: Y,
    overflowY: ne,
    display: ie
  } = getComputedStyle$1(B);
  return /auto|scroll|overlay|hidden|clip/.test(z + ne + Y) && !["inline", "contents"].includes(ie);
}
function isTableElement(B) {
  return ["table", "td", "th"].includes(getNodeName(B));
}
function isTopLayer(B) {
  return [":popover-open", ":modal"].some((z) => {
    try {
      return B.matches(z);
    } catch {
      return !1;
    }
  });
}
function isContainingBlock(B) {
  const z = isWebKit(), Y = isElement(B) ? getComputedStyle$1(B) : B;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((ne) => Y[ne] ? Y[ne] !== "none" : !1) || (Y.containerType ? Y.containerType !== "normal" : !1) || !z && (Y.backdropFilter ? Y.backdropFilter !== "none" : !1) || !z && (Y.filter ? Y.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((ne) => (Y.willChange || "").includes(ne)) || ["paint", "layout", "strict", "content"].some((ne) => (Y.contain || "").includes(ne));
}
function getContainingBlock(B) {
  let z = getParentNode(B);
  for (; isHTMLElement(z) && !isLastTraversableNode(z); ) {
    if (isContainingBlock(z))
      return z;
    if (isTopLayer(z))
      return null;
    z = getParentNode(z);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(B) {
  return ["html", "body", "#document"].includes(getNodeName(B));
}
function getComputedStyle$1(B) {
  return getWindow(B).getComputedStyle(B);
}
function getNodeScroll(B) {
  return isElement(B) ? {
    scrollLeft: B.scrollLeft,
    scrollTop: B.scrollTop
  } : {
    scrollLeft: B.scrollX,
    scrollTop: B.scrollY
  };
}
function getParentNode(B) {
  if (getNodeName(B) === "html")
    return B;
  const z = (
    // Step into the shadow DOM of the parent of a slotted node.
    B.assignedSlot || // DOM Element detected.
    B.parentNode || // ShadowRoot detected.
    isShadowRoot(B) && B.host || // Fallback.
    getDocumentElement(B)
  );
  return isShadowRoot(z) ? z.host : z;
}
function getNearestOverflowAncestor(B) {
  const z = getParentNode(B);
  return isLastTraversableNode(z) ? B.ownerDocument ? B.ownerDocument.body : B.body : isHTMLElement(z) && isOverflowElement(z) ? z : getNearestOverflowAncestor(z);
}
function getOverflowAncestors(B, z, Y) {
  var ne;
  z === void 0 && (z = []), Y === void 0 && (Y = !0);
  const ie = getNearestOverflowAncestor(B), oe = ie === ((ne = B.ownerDocument) == null ? void 0 : ne.body), se = getWindow(ie);
  if (oe) {
    const ae = getFrameElement(se);
    return z.concat(se, se.visualViewport || [], isOverflowElement(ie) ? ie : [], ae && Y ? getOverflowAncestors(ae) : []);
  }
  return z.concat(ie, getOverflowAncestors(ie, [], Y));
}
function getFrameElement(B) {
  return B.parent && Object.getPrototypeOf(B.parent) ? B.frameElement : null;
}
function getUserAgent() {
  const B = navigator.userAgentData;
  return B && Array.isArray(B.brands) ? B.brands.map((z) => {
    let {
      brand: Y,
      version: ne
    } = z;
    return Y + "/" + ne;
  }).join(" ") : navigator.userAgent;
}
const min$2 = Math.min, max$3 = Math.max, round$2 = Math.round, floor$2 = Math.floor, createCoords = (B) => ({
  x: B,
  y: B
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(B, z, Y) {
  return max$3(B, min$2(z, Y));
}
function evaluate(B, z) {
  return typeof B == "function" ? B(z) : B;
}
function getSide(B) {
  return B.split("-")[0];
}
function getAlignment(B) {
  return B.split("-")[1];
}
function getOppositeAxis(B) {
  return B === "x" ? "y" : "x";
}
function getAxisLength(B) {
  return B === "y" ? "height" : "width";
}
function getSideAxis(B) {
  return ["top", "bottom"].includes(getSide(B)) ? "y" : "x";
}
function getAlignmentAxis(B) {
  return getOppositeAxis(getSideAxis(B));
}
function getAlignmentSides(B, z, Y) {
  Y === void 0 && (Y = !1);
  const ne = getAlignment(B), ie = getAlignmentAxis(B), oe = getAxisLength(ie);
  let se = ie === "x" ? ne === (Y ? "end" : "start") ? "right" : "left" : ne === "start" ? "bottom" : "top";
  return z.reference[oe] > z.floating[oe] && (se = getOppositePlacement(se)), [se, getOppositePlacement(se)];
}
function getExpandedPlacements(B) {
  const z = getOppositePlacement(B);
  return [getOppositeAlignmentPlacement(B), z, getOppositeAlignmentPlacement(z)];
}
function getOppositeAlignmentPlacement(B) {
  return B.replace(/start|end/g, (z) => oppositeAlignmentMap[z]);
}
function getSideList(B, z, Y) {
  const ne = ["left", "right"], ie = ["right", "left"], oe = ["top", "bottom"], se = ["bottom", "top"];
  switch (B) {
    case "top":
    case "bottom":
      return Y ? z ? ie : ne : z ? ne : ie;
    case "left":
    case "right":
      return z ? oe : se;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(B, z, Y, ne) {
  const ie = getAlignment(B);
  let oe = getSideList(getSide(B), Y === "start", ne);
  return ie && (oe = oe.map((se) => se + "-" + ie), z && (oe = oe.concat(oe.map(getOppositeAlignmentPlacement)))), oe;
}
function getOppositePlacement(B) {
  return B.replace(/left|right|bottom|top/g, (z) => oppositeSideMap[z]);
}
function expandPaddingObject(B) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...B
  };
}
function getPaddingObject(B) {
  return typeof B != "number" ? expandPaddingObject(B) : {
    top: B,
    right: B,
    bottom: B,
    left: B
  };
}
function rectToClientRect(B) {
  const {
    x: z,
    y: Y,
    width: ne,
    height: ie
  } = B;
  return {
    width: ne,
    height: ie,
    top: Y,
    left: z,
    right: z + ne,
    bottom: Y + ie,
    x: z,
    y: Y
  };
}
function computeCoordsFromPlacement(B, z, Y) {
  let {
    reference: ne,
    floating: ie
  } = B;
  const oe = getSideAxis(z), se = getAlignmentAxis(z), ae = getAxisLength(se), ve = getSide(z), Pe = oe === "y", le = ne.x + ne.width / 2 - ie.width / 2, Ee = ne.y + ne.height / 2 - ie.height / 2, Je = ne[ae] / 2 - ie[ae] / 2;
  let Ce;
  switch (ve) {
    case "top":
      Ce = {
        x: le,
        y: ne.y - ie.height
      };
      break;
    case "bottom":
      Ce = {
        x: le,
        y: ne.y + ne.height
      };
      break;
    case "right":
      Ce = {
        x: ne.x + ne.width,
        y: Ee
      };
      break;
    case "left":
      Ce = {
        x: ne.x - ie.width,
        y: Ee
      };
      break;
    default:
      Ce = {
        x: ne.x,
        y: ne.y
      };
  }
  switch (getAlignment(z)) {
    case "start":
      Ce[se] -= Je * (Y && Pe ? -1 : 1);
      break;
    case "end":
      Ce[se] += Je * (Y && Pe ? -1 : 1);
      break;
  }
  return Ce;
}
const computePosition$1 = async (B, z, Y) => {
  const {
    placement: ne = "bottom",
    strategy: ie = "absolute",
    middleware: oe = [],
    platform: se
  } = Y, ae = oe.filter(Boolean), ve = await (se.isRTL == null ? void 0 : se.isRTL(z));
  let Pe = await se.getElementRects({
    reference: B,
    floating: z,
    strategy: ie
  }), {
    x: le,
    y: Ee
  } = computeCoordsFromPlacement(Pe, ne, ve), Je = ne, Ce = {}, _t = 0;
  for (let kt = 0; kt < ae.length; kt++) {
    const {
      name: Ct,
      fn: Lt
    } = ae[kt], {
      x: Pt,
      y: Ft,
      data: Ut,
      reset: Jt
    } = await Lt({
      x: le,
      y: Ee,
      initialPlacement: ne,
      placement: Je,
      strategy: ie,
      middlewareData: Ce,
      rects: Pe,
      platform: se,
      elements: {
        reference: B,
        floating: z
      }
    });
    le = Pt ?? le, Ee = Ft ?? Ee, Ce = {
      ...Ce,
      [Ct]: {
        ...Ce[Ct],
        ...Ut
      }
    }, Jt && _t <= 50 && (_t++, typeof Jt == "object" && (Jt.placement && (Je = Jt.placement), Jt.rects && (Pe = Jt.rects === !0 ? await se.getElementRects({
      reference: B,
      floating: z,
      strategy: ie
    }) : Jt.rects), {
      x: le,
      y: Ee
    } = computeCoordsFromPlacement(Pe, Je, ve)), kt = -1);
  }
  return {
    x: le,
    y: Ee,
    placement: Je,
    strategy: ie,
    middlewareData: Ce
  };
};
async function detectOverflow$1(B, z) {
  var Y;
  z === void 0 && (z = {});
  const {
    x: ne,
    y: ie,
    platform: oe,
    rects: se,
    elements: ae,
    strategy: ve
  } = B, {
    boundary: Pe = "clippingAncestors",
    rootBoundary: le = "viewport",
    elementContext: Ee = "floating",
    altBoundary: Je = !1,
    padding: Ce = 0
  } = evaluate(z, B), _t = getPaddingObject(Ce), Ct = ae[Je ? Ee === "floating" ? "reference" : "floating" : Ee], Lt = rectToClientRect(await oe.getClippingRect({
    element: (Y = await (oe.isElement == null ? void 0 : oe.isElement(Ct))) == null || Y ? Ct : Ct.contextElement || await (oe.getDocumentElement == null ? void 0 : oe.getDocumentElement(ae.floating)),
    boundary: Pe,
    rootBoundary: le,
    strategy: ve
  })), Pt = Ee === "floating" ? {
    x: ne,
    y: ie,
    width: se.floating.width,
    height: se.floating.height
  } : se.reference, Ft = await (oe.getOffsetParent == null ? void 0 : oe.getOffsetParent(ae.floating)), Ut = await (oe.isElement == null ? void 0 : oe.isElement(Ft)) ? await (oe.getScale == null ? void 0 : oe.getScale(Ft)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, Jt = rectToClientRect(oe.convertOffsetParentRelativeRectToViewportRelativeRect ? await oe.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: ae,
    rect: Pt,
    offsetParent: Ft,
    strategy: ve
  }) : Pt);
  return {
    top: (Lt.top - Jt.top + _t.top) / Ut.y,
    bottom: (Jt.bottom - Lt.bottom + _t.bottom) / Ut.y,
    left: (Lt.left - Jt.left + _t.left) / Ut.x,
    right: (Jt.right - Lt.right + _t.right) / Ut.x
  };
}
const flip$2 = function(B) {
  return B === void 0 && (B = {}), {
    name: "flip",
    options: B,
    async fn(z) {
      var Y, ne;
      const {
        placement: ie,
        middlewareData: oe,
        rects: se,
        initialPlacement: ae,
        platform: ve,
        elements: Pe
      } = z, {
        mainAxis: le = !0,
        crossAxis: Ee = !0,
        fallbackPlacements: Je,
        fallbackStrategy: Ce = "bestFit",
        fallbackAxisSideDirection: _t = "none",
        flipAlignment: kt = !0,
        ...Ct
      } = evaluate(B, z);
      if ((Y = oe.arrow) != null && Y.alignmentOffset)
        return {};
      const Lt = getSide(ie), Pt = getSideAxis(ae), Ft = getSide(ae) === ae, Ut = await (ve.isRTL == null ? void 0 : ve.isRTL(Pe.floating)), Jt = Je || (Ft || !kt ? [getOppositePlacement(ae)] : getExpandedPlacements(ae)), Vt = _t !== "none";
      !Je && Vt && Jt.push(...getOppositeAxisPlacements(ae, kt, _t, Ut));
      const ir = [ae, ...Jt], jt = await detectOverflow$1(z, Ct), Rt = [];
      let Kt = ((ne = oe.flip) == null ? void 0 : ne.overflows) || [];
      if (le && Rt.push(jt[Lt]), Ee) {
        const ge = getAlignmentSides(ie, se, Ut);
        Rt.push(jt[ge[0]], jt[ge[1]]);
      }
      if (Kt = [...Kt, {
        placement: ie,
        overflows: Rt
      }], !Rt.every((ge) => ge <= 0)) {
        var Bt, Xe;
        const ge = (((Bt = oe.flip) == null ? void 0 : Bt.index) || 0) + 1, Ke = ir[ge];
        if (Ke)
          return {
            data: {
              index: ge,
              overflows: Kt
            },
            reset: {
              placement: Ke
            }
          };
        let ht = (Xe = Kt.filter((wt) => wt.overflows[0] <= 0).sort((wt, vt) => wt.overflows[1] - vt.overflows[1])[0]) == null ? void 0 : Xe.placement;
        if (!ht)
          switch (Ce) {
            case "bestFit": {
              var Ve;
              const wt = (Ve = Kt.filter((vt) => {
                if (Vt) {
                  const $t = getSideAxis(vt.placement);
                  return $t === Pt || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  $t === "y";
                }
                return !0;
              }).map((vt) => [vt.placement, vt.overflows.filter(($t) => $t > 0).reduce(($t, Qe) => $t + Qe, 0)]).sort((vt, $t) => vt[1] - $t[1])[0]) == null ? void 0 : Ve[0];
              wt && (ht = wt);
              break;
            }
            case "initialPlacement":
              ht = ae;
              break;
          }
        if (ie !== ht)
          return {
            reset: {
              placement: ht
            }
          };
      }
      return {};
    }
  };
};
async function convertValueToCoords(B, z) {
  const {
    placement: Y,
    platform: ne,
    elements: ie
  } = B, oe = await (ne.isRTL == null ? void 0 : ne.isRTL(ie.floating)), se = getSide(Y), ae = getAlignment(Y), ve = getSideAxis(Y) === "y", Pe = ["left", "top"].includes(se) ? -1 : 1, le = oe && ve ? -1 : 1, Ee = evaluate(z, B);
  let {
    mainAxis: Je,
    crossAxis: Ce,
    alignmentAxis: _t
  } = typeof Ee == "number" ? {
    mainAxis: Ee,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: Ee.mainAxis || 0,
    crossAxis: Ee.crossAxis || 0,
    alignmentAxis: Ee.alignmentAxis
  };
  return ae && typeof _t == "number" && (Ce = ae === "end" ? _t * -1 : _t), ve ? {
    x: Ce * le,
    y: Je * Pe
  } : {
    x: Je * Pe,
    y: Ce * le
  };
}
const offset$2 = function(B) {
  return B === void 0 && (B = 0), {
    name: "offset",
    options: B,
    async fn(z) {
      var Y, ne;
      const {
        x: ie,
        y: oe,
        placement: se,
        middlewareData: ae
      } = z, ve = await convertValueToCoords(z, B);
      return se === ((Y = ae.offset) == null ? void 0 : Y.placement) && (ne = ae.arrow) != null && ne.alignmentOffset ? {} : {
        x: ie + ve.x,
        y: oe + ve.y,
        data: {
          ...ve,
          placement: se
        }
      };
    }
  };
}, shift$2 = function(B) {
  return B === void 0 && (B = {}), {
    name: "shift",
    options: B,
    async fn(z) {
      const {
        x: Y,
        y: ne,
        placement: ie
      } = z, {
        mainAxis: oe = !0,
        crossAxis: se = !1,
        limiter: ae = {
          fn: (Ct) => {
            let {
              x: Lt,
              y: Pt
            } = Ct;
            return {
              x: Lt,
              y: Pt
            };
          }
        },
        ...ve
      } = evaluate(B, z), Pe = {
        x: Y,
        y: ne
      }, le = await detectOverflow$1(z, ve), Ee = getSideAxis(getSide(ie)), Je = getOppositeAxis(Ee);
      let Ce = Pe[Je], _t = Pe[Ee];
      if (oe) {
        const Ct = Je === "y" ? "top" : "left", Lt = Je === "y" ? "bottom" : "right", Pt = Ce + le[Ct], Ft = Ce - le[Lt];
        Ce = clamp(Pt, Ce, Ft);
      }
      if (se) {
        const Ct = Ee === "y" ? "top" : "left", Lt = Ee === "y" ? "bottom" : "right", Pt = _t + le[Ct], Ft = _t - le[Lt];
        _t = clamp(Pt, _t, Ft);
      }
      const kt = ae.fn({
        ...z,
        [Je]: Ce,
        [Ee]: _t
      });
      return {
        ...kt,
        data: {
          x: kt.x - Y,
          y: kt.y - ne,
          enabled: {
            [Je]: oe,
            [Ee]: se
          }
        }
      };
    }
  };
}, size$2 = function(B) {
  return B === void 0 && (B = {}), {
    name: "size",
    options: B,
    async fn(z) {
      var Y, ne;
      const {
        placement: ie,
        rects: oe,
        platform: se,
        elements: ae
      } = z, {
        apply: ve = () => {
        },
        ...Pe
      } = evaluate(B, z), le = await detectOverflow$1(z, Pe), Ee = getSide(ie), Je = getAlignment(ie), Ce = getSideAxis(ie) === "y", {
        width: _t,
        height: kt
      } = oe.floating;
      let Ct, Lt;
      Ee === "top" || Ee === "bottom" ? (Ct = Ee, Lt = Je === (await (se.isRTL == null ? void 0 : se.isRTL(ae.floating)) ? "start" : "end") ? "left" : "right") : (Lt = Ee, Ct = Je === "end" ? "top" : "bottom");
      const Pt = kt - le.top - le.bottom, Ft = _t - le.left - le.right, Ut = min$2(kt - le[Ct], Pt), Jt = min$2(_t - le[Lt], Ft), Vt = !z.middlewareData.shift;
      let ir = Ut, jt = Jt;
      if ((Y = z.middlewareData.shift) != null && Y.enabled.x && (jt = Ft), (ne = z.middlewareData.shift) != null && ne.enabled.y && (ir = Pt), Vt && !Je) {
        const Kt = max$3(le.left, 0), Bt = max$3(le.right, 0), Xe = max$3(le.top, 0), Ve = max$3(le.bottom, 0);
        Ce ? jt = _t - 2 * (Kt !== 0 || Bt !== 0 ? Kt + Bt : max$3(le.left, le.right)) : ir = kt - 2 * (Xe !== 0 || Ve !== 0 ? Xe + Ve : max$3(le.top, le.bottom));
      }
      await ve({
        ...z,
        availableWidth: jt,
        availableHeight: ir
      });
      const Rt = await se.getDimensions(ae.floating);
      return _t !== Rt.width || kt !== Rt.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function getCssDimensions(B) {
  const z = getComputedStyle$1(B);
  let Y = parseFloat(z.width) || 0, ne = parseFloat(z.height) || 0;
  const ie = isHTMLElement(B), oe = ie ? B.offsetWidth : Y, se = ie ? B.offsetHeight : ne, ae = round$2(Y) !== oe || round$2(ne) !== se;
  return ae && (Y = oe, ne = se), {
    width: Y,
    height: ne,
    $: ae
  };
}
function unwrapElement(B) {
  return isElement(B) ? B : B.contextElement;
}
function getScale(B) {
  const z = unwrapElement(B);
  if (!isHTMLElement(z))
    return createCoords(1);
  const Y = z.getBoundingClientRect(), {
    width: ne,
    height: ie,
    $: oe
  } = getCssDimensions(z);
  let se = (oe ? round$2(Y.width) : Y.width) / ne, ae = (oe ? round$2(Y.height) : Y.height) / ie;
  return (!se || !Number.isFinite(se)) && (se = 1), (!ae || !Number.isFinite(ae)) && (ae = 1), {
    x: se,
    y: ae
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(B) {
  const z = getWindow(B);
  return !isWebKit() || !z.visualViewport ? noOffsets : {
    x: z.visualViewport.offsetLeft,
    y: z.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(B, z, Y) {
  return z === void 0 && (z = !1), !Y || z && Y !== getWindow(B) ? !1 : z;
}
function getBoundingClientRect(B, z, Y, ne) {
  z === void 0 && (z = !1), Y === void 0 && (Y = !1);
  const ie = B.getBoundingClientRect(), oe = unwrapElement(B);
  let se = createCoords(1);
  z && (ne ? isElement(ne) && (se = getScale(ne)) : se = getScale(B));
  const ae = shouldAddVisualOffsets(oe, Y, ne) ? getVisualOffsets(oe) : createCoords(0);
  let ve = (ie.left + ae.x) / se.x, Pe = (ie.top + ae.y) / se.y, le = ie.width / se.x, Ee = ie.height / se.y;
  if (oe) {
    const Je = getWindow(oe), Ce = ne && isElement(ne) ? getWindow(ne) : ne;
    let _t = Je, kt = getFrameElement(_t);
    for (; kt && ne && Ce !== _t; ) {
      const Ct = getScale(kt), Lt = kt.getBoundingClientRect(), Pt = getComputedStyle$1(kt), Ft = Lt.left + (kt.clientLeft + parseFloat(Pt.paddingLeft)) * Ct.x, Ut = Lt.top + (kt.clientTop + parseFloat(Pt.paddingTop)) * Ct.y;
      ve *= Ct.x, Pe *= Ct.y, le *= Ct.x, Ee *= Ct.y, ve += Ft, Pe += Ut, _t = getWindow(kt), kt = getFrameElement(_t);
    }
  }
  return rectToClientRect({
    width: le,
    height: Ee,
    x: ve,
    y: Pe
  });
}
function getWindowScrollBarX(B, z) {
  const Y = getNodeScroll(B).scrollLeft;
  return z ? z.left + Y : getBoundingClientRect(getDocumentElement(B)).left + Y;
}
function getHTMLOffset(B, z, Y) {
  Y === void 0 && (Y = !1);
  const ne = B.getBoundingClientRect(), ie = ne.left + z.scrollLeft - (Y ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(B, ne)
  )), oe = ne.top + z.scrollTop;
  return {
    x: ie,
    y: oe
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(B) {
  let {
    elements: z,
    rect: Y,
    offsetParent: ne,
    strategy: ie
  } = B;
  const oe = ie === "fixed", se = getDocumentElement(ne), ae = z ? isTopLayer(z.floating) : !1;
  if (ne === se || ae && oe)
    return Y;
  let ve = {
    scrollLeft: 0,
    scrollTop: 0
  }, Pe = createCoords(1);
  const le = createCoords(0), Ee = isHTMLElement(ne);
  if ((Ee || !Ee && !oe) && ((getNodeName(ne) !== "body" || isOverflowElement(se)) && (ve = getNodeScroll(ne)), isHTMLElement(ne))) {
    const Ce = getBoundingClientRect(ne);
    Pe = getScale(ne), le.x = Ce.x + ne.clientLeft, le.y = Ce.y + ne.clientTop;
  }
  const Je = se && !Ee && !oe ? getHTMLOffset(se, ve, !0) : createCoords(0);
  return {
    width: Y.width * Pe.x,
    height: Y.height * Pe.y,
    x: Y.x * Pe.x - ve.scrollLeft * Pe.x + le.x + Je.x,
    y: Y.y * Pe.y - ve.scrollTop * Pe.y + le.y + Je.y
  };
}
function getClientRects(B) {
  return Array.from(B.getClientRects());
}
function getDocumentRect(B) {
  const z = getDocumentElement(B), Y = getNodeScroll(B), ne = B.ownerDocument.body, ie = max$3(z.scrollWidth, z.clientWidth, ne.scrollWidth, ne.clientWidth), oe = max$3(z.scrollHeight, z.clientHeight, ne.scrollHeight, ne.clientHeight);
  let se = -Y.scrollLeft + getWindowScrollBarX(B);
  const ae = -Y.scrollTop;
  return getComputedStyle$1(ne).direction === "rtl" && (se += max$3(z.clientWidth, ne.clientWidth) - ie), {
    width: ie,
    height: oe,
    x: se,
    y: ae
  };
}
function getViewportRect(B, z) {
  const Y = getWindow(B), ne = getDocumentElement(B), ie = Y.visualViewport;
  let oe = ne.clientWidth, se = ne.clientHeight, ae = 0, ve = 0;
  if (ie) {
    oe = ie.width, se = ie.height;
    const Pe = isWebKit();
    (!Pe || Pe && z === "fixed") && (ae = ie.offsetLeft, ve = ie.offsetTop);
  }
  return {
    width: oe,
    height: se,
    x: ae,
    y: ve
  };
}
function getInnerBoundingClientRect(B, z) {
  const Y = getBoundingClientRect(B, !0, z === "fixed"), ne = Y.top + B.clientTop, ie = Y.left + B.clientLeft, oe = isHTMLElement(B) ? getScale(B) : createCoords(1), se = B.clientWidth * oe.x, ae = B.clientHeight * oe.y, ve = ie * oe.x, Pe = ne * oe.y;
  return {
    width: se,
    height: ae,
    x: ve,
    y: Pe
  };
}
function getClientRectFromClippingAncestor(B, z, Y) {
  let ne;
  if (z === "viewport")
    ne = getViewportRect(B, Y);
  else if (z === "document")
    ne = getDocumentRect(getDocumentElement(B));
  else if (isElement(z))
    ne = getInnerBoundingClientRect(z, Y);
  else {
    const ie = getVisualOffsets(B);
    ne = {
      x: z.x - ie.x,
      y: z.y - ie.y,
      width: z.width,
      height: z.height
    };
  }
  return rectToClientRect(ne);
}
function hasFixedPositionAncestor(B, z) {
  const Y = getParentNode(B);
  return Y === z || !isElement(Y) || isLastTraversableNode(Y) ? !1 : getComputedStyle$1(Y).position === "fixed" || hasFixedPositionAncestor(Y, z);
}
function getClippingElementAncestors(B, z) {
  const Y = z.get(B);
  if (Y)
    return Y;
  let ne = getOverflowAncestors(B, [], !1).filter((ae) => isElement(ae) && getNodeName(ae) !== "body"), ie = null;
  const oe = getComputedStyle$1(B).position === "fixed";
  let se = oe ? getParentNode(B) : B;
  for (; isElement(se) && !isLastTraversableNode(se); ) {
    const ae = getComputedStyle$1(se), ve = isContainingBlock(se);
    !ve && ae.position === "fixed" && (ie = null), (oe ? !ve && !ie : !ve && ae.position === "static" && !!ie && ["absolute", "fixed"].includes(ie.position) || isOverflowElement(se) && !ve && hasFixedPositionAncestor(B, se)) ? ne = ne.filter((le) => le !== se) : ie = ae, se = getParentNode(se);
  }
  return z.set(B, ne), ne;
}
function getClippingRect(B) {
  let {
    element: z,
    boundary: Y,
    rootBoundary: ne,
    strategy: ie
  } = B;
  const se = [...Y === "clippingAncestors" ? isTopLayer(z) ? [] : getClippingElementAncestors(z, this._c) : [].concat(Y), ne], ae = se[0], ve = se.reduce((Pe, le) => {
    const Ee = getClientRectFromClippingAncestor(z, le, ie);
    return Pe.top = max$3(Ee.top, Pe.top), Pe.right = min$2(Ee.right, Pe.right), Pe.bottom = min$2(Ee.bottom, Pe.bottom), Pe.left = max$3(Ee.left, Pe.left), Pe;
  }, getClientRectFromClippingAncestor(z, ae, ie));
  return {
    width: ve.right - ve.left,
    height: ve.bottom - ve.top,
    x: ve.left,
    y: ve.top
  };
}
function getDimensions(B) {
  const {
    width: z,
    height: Y
  } = getCssDimensions(B);
  return {
    width: z,
    height: Y
  };
}
function getRectRelativeToOffsetParent(B, z, Y) {
  const ne = isHTMLElement(z), ie = getDocumentElement(z), oe = Y === "fixed", se = getBoundingClientRect(B, !0, oe, z);
  let ae = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const ve = createCoords(0);
  if (ne || !ne && !oe)
    if ((getNodeName(z) !== "body" || isOverflowElement(ie)) && (ae = getNodeScroll(z)), ne) {
      const Je = getBoundingClientRect(z, !0, oe, z);
      ve.x = Je.x + z.clientLeft, ve.y = Je.y + z.clientTop;
    } else ie && (ve.x = getWindowScrollBarX(ie));
  const Pe = ie && !ne && !oe ? getHTMLOffset(ie, ae) : createCoords(0), le = se.left + ae.scrollLeft - ve.x - Pe.x, Ee = se.top + ae.scrollTop - ve.y - Pe.y;
  return {
    x: le,
    y: Ee,
    width: se.width,
    height: se.height
  };
}
function isStaticPositioned(B) {
  return getComputedStyle$1(B).position === "static";
}
function getTrueOffsetParent(B, z) {
  if (!isHTMLElement(B) || getComputedStyle$1(B).position === "fixed")
    return null;
  if (z)
    return z(B);
  let Y = B.offsetParent;
  return getDocumentElement(B) === Y && (Y = Y.ownerDocument.body), Y;
}
function getOffsetParent(B, z) {
  const Y = getWindow(B);
  if (isTopLayer(B))
    return Y;
  if (!isHTMLElement(B)) {
    let ie = getParentNode(B);
    for (; ie && !isLastTraversableNode(ie); ) {
      if (isElement(ie) && !isStaticPositioned(ie))
        return ie;
      ie = getParentNode(ie);
    }
    return Y;
  }
  let ne = getTrueOffsetParent(B, z);
  for (; ne && isTableElement(ne) && isStaticPositioned(ne); )
    ne = getTrueOffsetParent(ne, z);
  return ne && isLastTraversableNode(ne) && isStaticPositioned(ne) && !isContainingBlock(ne) ? Y : ne || getContainingBlock(B) || Y;
}
const getElementRects = async function(B) {
  const z = this.getOffsetParent || getOffsetParent, Y = this.getDimensions, ne = await Y(B.floating);
  return {
    reference: getRectRelativeToOffsetParent(B.reference, await z(B.floating), B.strategy),
    floating: {
      x: 0,
      y: 0,
      width: ne.width,
      height: ne.height
    }
  };
};
function isRTL(B) {
  return getComputedStyle$1(B).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(B, z) {
  return B.x === z.x && B.y === z.y && B.width === z.width && B.height === z.height;
}
function observeMove(B, z) {
  let Y = null, ne;
  const ie = getDocumentElement(B);
  function oe() {
    var ae;
    clearTimeout(ne), (ae = Y) == null || ae.disconnect(), Y = null;
  }
  function se(ae, ve) {
    ae === void 0 && (ae = !1), ve === void 0 && (ve = 1), oe();
    const Pe = B.getBoundingClientRect(), {
      left: le,
      top: Ee,
      width: Je,
      height: Ce
    } = Pe;
    if (ae || z(), !Je || !Ce)
      return;
    const _t = floor$2(Ee), kt = floor$2(ie.clientWidth - (le + Je)), Ct = floor$2(ie.clientHeight - (Ee + Ce)), Lt = floor$2(le), Ft = {
      rootMargin: -_t + "px " + -kt + "px " + -Ct + "px " + -Lt + "px",
      threshold: max$3(0, min$2(1, ve)) || 1
    };
    let Ut = !0;
    function Jt(Vt) {
      const ir = Vt[0].intersectionRatio;
      if (ir !== ve) {
        if (!Ut)
          return se();
        ir ? se(!1, ir) : ne = setTimeout(() => {
          se(!1, 1e-7);
        }, 1e3);
      }
      ir === 1 && !rectsAreEqual(Pe, B.getBoundingClientRect()) && se(), Ut = !1;
    }
    try {
      Y = new IntersectionObserver(Jt, {
        ...Ft,
        // Handle <iframe>s
        root: ie.ownerDocument
      });
    } catch {
      Y = new IntersectionObserver(Jt, Ft);
    }
    Y.observe(B);
  }
  return se(!0), oe;
}
function autoUpdate(B, z, Y, ne) {
  ne === void 0 && (ne = {});
  const {
    ancestorScroll: ie = !0,
    ancestorResize: oe = !0,
    elementResize: se = typeof ResizeObserver == "function",
    layoutShift: ae = typeof IntersectionObserver == "function",
    animationFrame: ve = !1
  } = ne, Pe = unwrapElement(B), le = ie || oe ? [...Pe ? getOverflowAncestors(Pe) : [], ...getOverflowAncestors(z)] : [];
  le.forEach((Lt) => {
    ie && Lt.addEventListener("scroll", Y, {
      passive: !0
    }), oe && Lt.addEventListener("resize", Y);
  });
  const Ee = Pe && ae ? observeMove(Pe, Y) : null;
  let Je = -1, Ce = null;
  se && (Ce = new ResizeObserver((Lt) => {
    let [Pt] = Lt;
    Pt && Pt.target === Pe && Ce && (Ce.unobserve(z), cancelAnimationFrame(Je), Je = requestAnimationFrame(() => {
      var Ft;
      (Ft = Ce) == null || Ft.observe(z);
    })), Y();
  }), Pe && !ve && Ce.observe(Pe), Ce.observe(z));
  let _t, kt = ve ? getBoundingClientRect(B) : null;
  ve && Ct();
  function Ct() {
    const Lt = getBoundingClientRect(B);
    kt && !rectsAreEqual(kt, Lt) && Y(), kt = Lt, _t = requestAnimationFrame(Ct);
  }
  return Y(), () => {
    var Lt;
    le.forEach((Pt) => {
      ie && Pt.removeEventListener("scroll", Y), oe && Pt.removeEventListener("resize", Y);
    }), Ee == null || Ee(), (Lt = Ce) == null || Lt.disconnect(), Ce = null, ve && cancelAnimationFrame(_t);
  };
}
const detectOverflow = detectOverflow$1, offset$1 = offset$2, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, computePosition = (B, z, Y) => {
  const ne = /* @__PURE__ */ new Map(), ie = {
    platform,
    ...Y
  }, oe = {
    ...ie.platform,
    _c: ne
  };
  return computePosition$1(B, z, {
    ...ie,
    platform: oe
  });
};
var index$1 = typeof document < "u" ? useLayoutEffect : useEffect;
function deepEqual(B, z) {
  if (B === z)
    return !0;
  if (typeof B != typeof z)
    return !1;
  if (typeof B == "function" && B.toString() === z.toString())
    return !0;
  let Y, ne, ie;
  if (B && z && typeof B == "object") {
    if (Array.isArray(B)) {
      if (Y = B.length, Y !== z.length) return !1;
      for (ne = Y; ne-- !== 0; )
        if (!deepEqual(B[ne], z[ne]))
          return !1;
      return !0;
    }
    if (ie = Object.keys(B), Y = ie.length, Y !== Object.keys(z).length)
      return !1;
    for (ne = Y; ne-- !== 0; )
      if (!{}.hasOwnProperty.call(z, ie[ne]))
        return !1;
    for (ne = Y; ne-- !== 0; ) {
      const oe = ie[ne];
      if (!(oe === "_owner" && B.$$typeof) && !deepEqual(B[oe], z[oe]))
        return !1;
    }
    return !0;
  }
  return B !== B && z !== z;
}
function getDPR(B) {
  return typeof window > "u" ? 1 : (B.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(B, z) {
  const Y = getDPR(B);
  return Math.round(z * Y) / Y;
}
function useLatestRef(B) {
  const z = React.useRef(B);
  return index$1(() => {
    z.current = B;
  }), z;
}
function useFloating$1(B) {
  B === void 0 && (B = {});
  const {
    placement: z = "bottom",
    strategy: Y = "absolute",
    middleware: ne = [],
    platform: ie,
    elements: {
      reference: oe,
      floating: se
    } = {},
    transform: ae = !0,
    whileElementsMounted: ve,
    open: Pe
  } = B, [le, Ee] = React.useState({
    x: 0,
    y: 0,
    strategy: Y,
    placement: z,
    middlewareData: {},
    isPositioned: !1
  }), [Je, Ce] = React.useState(ne);
  deepEqual(Je, ne) || Ce(ne);
  const [_t, kt] = React.useState(null), [Ct, Lt] = React.useState(null), Pt = React.useCallback((vt) => {
    vt !== Vt.current && (Vt.current = vt, kt(vt));
  }, []), Ft = React.useCallback((vt) => {
    vt !== ir.current && (ir.current = vt, Lt(vt));
  }, []), Ut = oe || _t, Jt = se || Ct, Vt = React.useRef(null), ir = React.useRef(null), jt = React.useRef(le), Rt = ve != null, Kt = useLatestRef(ve), Bt = useLatestRef(ie), Xe = useLatestRef(Pe), Ve = React.useCallback(() => {
    if (!Vt.current || !ir.current)
      return;
    const vt = {
      placement: z,
      strategy: Y,
      middleware: Je
    };
    Bt.current && (vt.platform = Bt.current), computePosition(Vt.current, ir.current, vt).then(($t) => {
      const Qe = {
        ...$t,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: Xe.current !== !1
      };
      ge.current && !deepEqual(jt.current, Qe) && (jt.current = Qe, ReactDOM.flushSync(() => {
        Ee(Qe);
      }));
    });
  }, [Je, z, Y, Bt, Xe]);
  index$1(() => {
    Pe === !1 && jt.current.isPositioned && (jt.current.isPositioned = !1, Ee((vt) => ({
      ...vt,
      isPositioned: !1
    })));
  }, [Pe]);
  const ge = React.useRef(!1);
  index$1(() => (ge.current = !0, () => {
    ge.current = !1;
  }), []), index$1(() => {
    if (Ut && (Vt.current = Ut), Jt && (ir.current = Jt), Ut && Jt) {
      if (Kt.current)
        return Kt.current(Ut, Jt, Ve);
      Ve();
    }
  }, [Ut, Jt, Ve, Kt, Rt]);
  const Ke = React.useMemo(() => ({
    reference: Vt,
    floating: ir,
    setReference: Pt,
    setFloating: Ft
  }), [Pt, Ft]), ht = React.useMemo(() => ({
    reference: Ut,
    floating: Jt
  }), [Ut, Jt]), wt = React.useMemo(() => {
    const vt = {
      position: Y,
      left: 0,
      top: 0
    };
    if (!ht.floating)
      return vt;
    const $t = roundByDPR(ht.floating, le.x), Qe = roundByDPR(ht.floating, le.y);
    return ae ? {
      ...vt,
      transform: "translate(" + $t + "px, " + Qe + "px)",
      ...getDPR(ht.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: Y,
      left: $t,
      top: Qe
    };
  }, [Y, ae, ht.floating, le.x, le.y]);
  return React.useMemo(() => ({
    ...le,
    update: Ve,
    refs: Ke,
    elements: ht,
    floatingStyles: wt
  }), [le, Ve, Ke, ht, wt]);
}
const offset = (B, z) => ({
  ...offset$1(B),
  options: [B, z]
}), shift = (B, z) => ({
  ...shift$1(B),
  options: [B, z]
}), flip = (B, z) => ({
  ...flip$1(B),
  options: [B, z]
}), size = (B, z) => ({
  ...size$1(B),
  options: [B, z]
}), SafeReact = {
  ...React
}, useInsertionEffect = SafeReact.useInsertionEffect, useSafeInsertionEffect = useInsertionEffect || ((B) => B());
function useEffectEvent(B) {
  const z = React.useRef(() => {
    if (process$1.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return useSafeInsertionEffect(() => {
    z.current = B;
  }), React.useCallback(function() {
    for (var Y = arguments.length, ne = new Array(Y), ie = 0; ie < Y; ie++)
      ne[ie] = arguments[ie];
    return z.current == null ? void 0 : z.current(...ne);
  }, []);
}
var index = typeof document < "u" ? useLayoutEffect : useEffect;
let serverHandoffComplete = !1, count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [B, z] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  return index(() => {
    B == null && z(genId());
  }, []), React.useEffect(() => {
    serverHandoffComplete = !0;
  }, []), B;
}
const useReactId = SafeReact.useId, useId = useReactId || useFloatingId;
let devMessageSet;
process$1.env.NODE_ENV !== "production" && (devMessageSet = /* @__PURE__ */ new Set());
function warn() {
  for (var B, z = arguments.length, Y = new Array(z), ne = 0; ne < z; ne++)
    Y[ne] = arguments[ne];
  const ie = "Floating UI: " + Y.join(" ");
  if (!((B = devMessageSet) != null && B.has(ie))) {
    var oe;
    (oe = devMessageSet) == null || oe.add(ie), console.warn(ie);
  }
}
function error() {
  for (var B, z = arguments.length, Y = new Array(z), ne = 0; ne < z; ne++)
    Y[ne] = arguments[ne];
  const ie = "Floating UI: " + Y.join(" ");
  if (!((B = devMessageSet) != null && B.has(ie))) {
    var oe;
    (oe = devMessageSet) == null || oe.add(ie), console.error(ie);
  }
}
function createPubSub() {
  const B = /* @__PURE__ */ new Map();
  return {
    emit(z, Y) {
      var ne;
      (ne = B.get(z)) == null || ne.forEach((ie) => ie(Y));
    },
    on(z, Y) {
      B.set(z, [...B.get(z) || [], Y]);
    },
    off(z, Y) {
      var ne;
      B.set(z, ((ne = B.get(z)) == null ? void 0 : ne.filter((ie) => ie !== Y)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ React.createContext(null), FloatingTreeContext = /* @__PURE__ */ React.createContext(null), useFloatingParentNodeId = () => {
  var B;
  return ((B = React.useContext(FloatingNodeContext)) == null ? void 0 : B.id) || null;
}, useFloatingTree = () => React.useContext(FloatingTreeContext), FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
function useFloatingRootContext(B) {
  const {
    open: z = !1,
    onOpenChange: Y,
    elements: ne
  } = B, ie = useId(), oe = React.useRef({}), [se] = React.useState(() => createPubSub()), ae = useFloatingParentNodeId() != null;
  if (process$1.env.NODE_ENV !== "production") {
    const Ce = ne.reference;
    Ce && !isElement(Ce) && error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
  }
  const [ve, Pe] = React.useState(ne.reference), le = useEffectEvent((Ce, _t, kt) => {
    oe.current.openEvent = Ce ? _t : void 0, se.emit("openchange", {
      open: Ce,
      event: _t,
      reason: kt,
      nested: ae
    }), Y == null || Y(Ce, _t, kt);
  }), Ee = React.useMemo(() => ({
    setPositionReference: Pe
  }), []), Je = React.useMemo(() => ({
    reference: ve || ne.reference || null,
    floating: ne.floating || null,
    domReference: ne.reference
  }), [ve, ne.reference, ne.floating]);
  return React.useMemo(() => ({
    dataRef: oe,
    open: z,
    onOpenChange: le,
    elements: Je,
    events: se,
    floatingId: ie,
    refs: Ee
  }), [z, le, Je, se, ie, Ee]);
}
function useFloating(B) {
  B === void 0 && (B = {});
  const {
    nodeId: z
  } = B, Y = useFloatingRootContext({
    ...B,
    elements: {
      reference: null,
      floating: null,
      ...B.elements
    }
  }), ne = B.rootContext || Y, ie = ne.elements, [oe, se] = React.useState(null), [ae, ve] = React.useState(null), le = (ie == null ? void 0 : ie.domReference) || oe, Ee = React.useRef(null), Je = useFloatingTree();
  index(() => {
    le && (Ee.current = le);
  }, [le]);
  const Ce = useFloating$1({
    ...B,
    elements: {
      ...ie,
      ...ae && {
        reference: ae
      }
    }
  }), _t = React.useCallback((Ft) => {
    const Ut = isElement(Ft) ? {
      getBoundingClientRect: () => Ft.getBoundingClientRect(),
      contextElement: Ft
    } : Ft;
    ve(Ut), Ce.refs.setReference(Ut);
  }, [Ce.refs]), kt = React.useCallback((Ft) => {
    (isElement(Ft) || Ft === null) && (Ee.current = Ft, se(Ft)), (isElement(Ce.refs.reference.current) || Ce.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    Ft !== null && !isElement(Ft)) && Ce.refs.setReference(Ft);
  }, [Ce.refs]), Ct = React.useMemo(() => ({
    ...Ce.refs,
    setReference: kt,
    setPositionReference: _t,
    domReference: Ee
  }), [Ce.refs, kt, _t]), Lt = React.useMemo(() => ({
    ...Ce.elements,
    domReference: le
  }), [Ce.elements, le]), Pt = React.useMemo(() => ({
    ...Ce,
    ...ne,
    refs: Ct,
    elements: Lt,
    nodeId: z
  }), [Ce, Ct, Lt, z, ne]);
  return index(() => {
    ne.dataRef.current.floatingContext = Pt;
    const Ft = Je == null ? void 0 : Je.nodesRef.current.find((Ut) => Ut.id === z);
    Ft && (Ft.context = Pt);
  }), React.useMemo(() => ({
    ...Ce,
    context: Pt,
    refs: Ct,
    elements: Lt
  }), [Ce, Ct, Lt, Pt]);
}
const ACTIVE_KEY = "active", SELECTED_KEY = "selected";
function mergeProps(B, z, Y) {
  const ne = /* @__PURE__ */ new Map(), ie = Y === "item";
  let oe = B;
  if (ie && B) {
    const {
      [ACTIVE_KEY]: se,
      [SELECTED_KEY]: ae,
      ...ve
    } = B;
    oe = ve;
  }
  return {
    ...Y === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...oe,
    ...z.map((se) => {
      const ae = se ? se[Y] : null;
      return typeof ae == "function" ? B ? ae(B) : null : ae;
    }).concat(B).reduce((se, ae) => (ae && Object.entries(ae).forEach((ve) => {
      let [Pe, le] = ve;
      if (!(ie && [ACTIVE_KEY, SELECTED_KEY].includes(Pe)))
        if (Pe.indexOf("on") === 0) {
          if (ne.has(Pe) || ne.set(Pe, []), typeof le == "function") {
            var Ee;
            (Ee = ne.get(Pe)) == null || Ee.push(le), se[Pe] = function() {
              for (var Je, Ce = arguments.length, _t = new Array(Ce), kt = 0; kt < Ce; kt++)
                _t[kt] = arguments[kt];
              return (Je = ne.get(Pe)) == null ? void 0 : Je.map((Ct) => Ct(..._t)).find((Ct) => Ct !== void 0);
            };
          }
        } else
          se[Pe] = le;
    }), se), {})
  };
}
function useInteractions(B) {
  B === void 0 && (B = []);
  const z = B.map((ae) => ae == null ? void 0 : ae.reference), Y = B.map((ae) => ae == null ? void 0 : ae.floating), ne = B.map((ae) => ae == null ? void 0 : ae.item), ie = React.useCallback(
    (ae) => mergeProps(ae, B, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    z
  ), oe = React.useCallback(
    (ae) => mergeProps(ae, B, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    Y
  ), se = React.useCallback(
    (ae) => mergeProps(ae, B, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    ne
  );
  return React.useMemo(() => ({
    getReferenceProps: ie,
    getFloatingProps: oe,
    getItemProps: se
  }), [ie, oe, se]);
}
function getArgsWithCustomFloatingHeight(B, z) {
  return {
    ...B,
    rects: {
      ...B.rects,
      floating: {
        ...B.rects.floating,
        height: z
      }
    }
  };
}
const inner = (B) => ({
  name: "inner",
  options: B,
  async fn(z) {
    const {
      listRef: Y,
      overflowRef: ne,
      onFallbackChange: ie,
      offset: oe = 0,
      index: se = 0,
      minItemsVisible: ae = 4,
      referenceOverflowThreshold: ve = 0,
      scrollRef: Pe,
      ...le
    } = evaluate(B, z), {
      rects: Ee,
      elements: {
        floating: Je
      }
    } = z, Ce = Y.current[se], _t = (Pe == null ? void 0 : Pe.current) || Je, kt = Je.clientTop || _t.clientTop, Ct = Je.clientTop !== 0, Lt = _t.clientTop !== 0, Pt = Je === _t;
    if (process$1.env.NODE_ENV !== "production" && (z.placement.startsWith("bottom") || warn('`placement` side must be "bottom" when using the `inner`', "middleware.")), !Ce)
      return {};
    const Ft = {
      ...z,
      ...await offset(-Ce.offsetTop - Je.clientTop - Ee.reference.height / 2 - Ce.offsetHeight / 2 - oe).fn(z)
    }, Ut = await detectOverflow(getArgsWithCustomFloatingHeight(Ft, _t.scrollHeight + kt + Je.clientTop), le), Jt = await detectOverflow(Ft, {
      ...le,
      elementContext: "reference"
    }), Vt = max$3(0, Ut.top), ir = Ft.y + Vt, Kt = (_t.scrollHeight > _t.clientHeight ? (Bt) => Bt : round$2)(max$3(0, _t.scrollHeight + (Ct && Pt || Lt ? kt * 2 : 0) - Vt - max$3(0, Ut.bottom)));
    if (_t.style.maxHeight = Kt + "px", _t.scrollTop = Vt, ie) {
      const Bt = _t.offsetHeight < Ce.offsetHeight * min$2(ae, Y.current.length) - 1 || Jt.top >= -ve || Jt.bottom >= -ve;
      ReactDOM.flushSync(() => ie(Bt));
    }
    return ne && (ne.current = await detectOverflow(getArgsWithCustomFloatingHeight({
      ...Ft,
      y: ir
    }, _t.offsetHeight + kt + Je.clientTop), le)), {
      y: ir
    };
  }
});
function useInnerOffset(B, z) {
  const {
    open: Y,
    elements: ne
  } = B, {
    enabled: ie = !0,
    overflowRef: oe,
    scrollRef: se,
    onChange: ae
  } = z, ve = useEffectEvent(ae), Pe = React.useRef(!1), le = React.useRef(null), Ee = React.useRef(null);
  React.useEffect(() => {
    if (!ie) return;
    function Ce(kt) {
      if (kt.ctrlKey || !_t || oe.current == null)
        return;
      const Ct = kt.deltaY, Lt = oe.current.top >= -0.5, Pt = oe.current.bottom >= -0.5, Ft = _t.scrollHeight - _t.clientHeight, Ut = Ct < 0 ? -1 : 1, Jt = Ct < 0 ? "max" : "min";
      _t.scrollHeight <= _t.clientHeight || (!Lt && Ct > 0 || !Pt && Ct < 0 ? (kt.preventDefault(), ReactDOM.flushSync(() => {
        ve((Vt) => Vt + Math[Jt](Ct, Ft * Ut));
      })) : /firefox/i.test(getUserAgent()) && (_t.scrollTop += Ct));
    }
    const _t = (se == null ? void 0 : se.current) || ne.floating;
    if (Y && _t)
      return _t.addEventListener("wheel", Ce), requestAnimationFrame(() => {
        le.current = _t.scrollTop, oe.current != null && (Ee.current = {
          ...oe.current
        });
      }), () => {
        le.current = null, Ee.current = null, _t.removeEventListener("wheel", Ce);
      };
  }, [ie, Y, ne.floating, oe, se, ve]);
  const Je = React.useMemo(() => ({
    onKeyDown() {
      Pe.current = !0;
    },
    onWheel() {
      Pe.current = !1;
    },
    onPointerMove() {
      Pe.current = !1;
    },
    onScroll() {
      const Ce = (se == null ? void 0 : se.current) || ne.floating;
      if (!(!oe.current || !Ce || !Pe.current)) {
        if (le.current !== null) {
          const _t = Ce.scrollTop - le.current;
          (oe.current.bottom < -0.5 && _t < -1 || oe.current.top < -0.5 && _t > 1) && ReactDOM.flushSync(() => ve((kt) => kt + _t));
        }
        requestAnimationFrame(() => {
          le.current = Ce.scrollTop;
        });
      }
    }
  }), [ne.floating, ve, oe, se]);
  return React.useMemo(() => ie ? {
    floating: Je
  } : {}, [ie, Je]);
}
let y$1 = createContext({ styles: void 0, setReference: () => {
}, setFloating: () => {
}, getReferenceProps: () => ({}), getFloatingProps: () => ({}), slot: {} });
y$1.displayName = "FloatingContext";
let H = createContext(null);
H.displayName = "PlacementContext";
function xe(B) {
  return useMemo(() => B ? typeof B == "string" ? { to: B } : B : null, [B]);
}
function ye$1() {
  return useContext(y$1).setReference;
}
function Fe$1() {
  return useContext(y$1).getReferenceProps;
}
function be() {
  let { getFloatingProps: B, slot: z } = useContext(y$1);
  return useCallback((...Y) => Object.assign({}, B(...Y), { "data-anchor": z.anchor }), [B, z]);
}
function Re(B = null) {
  B === !1 && (B = null), typeof B == "string" && (B = { to: B });
  let z = useContext(H), Y = useMemo(() => B, [JSON.stringify(B, (ie, oe) => {
    var se;
    return (se = oe == null ? void 0 : oe.outerHTML) != null ? se : oe;
  })]);
  n$3(() => {
    z == null || z(Y ?? null);
  }, [z, Y]);
  let ne = useContext(y$1);
  return useMemo(() => [ne.setFloating, B ? ne.styles : {}], [ne.setFloating, B, ne.styles]);
}
let q = 4;
function Me$1({ children: B, enabled: z = !0 }) {
  let [Y, ne] = useState(null), [ie, oe] = useState(0), se = useRef(null), [ae, ve] = useState(null);
  pe(ae);
  let Pe = z && Y !== null && ae !== null, { to: le = "bottom", gap: Ee = 0, offset: Je = 0, padding: Ce = 0, inner: _t } = ce(Y, ae), [kt, Ct = "center"] = le.split(" ");
  n$3(() => {
    Pe && oe(0);
  }, [Pe]);
  let { refs: Lt, floatingStyles: Pt, context: Ft } = useFloating({ open: Pe, placement: kt === "selection" ? Ct === "center" ? "bottom" : `bottom-${Ct}` : Ct === "center" ? `${kt}` : `${kt}-${Ct}`, strategy: "absolute", transform: !1, middleware: [offset({ mainAxis: kt === "selection" ? 0 : Ee, crossAxis: Je }), shift({ padding: Ce }), kt !== "selection" && flip({ padding: Ce }), kt === "selection" && _t ? inner({ ..._t, padding: Ce, overflowRef: se, offset: ie, minItemsVisible: q, referenceOverflowThreshold: Ce, onFallbackChange(Bt) {
    var Xe, Ve;
    if (!Bt) return;
    let ge = Ft.elements.floating;
    if (!ge) return;
    let Ke = parseFloat(getComputedStyle(ge).scrollPaddingBottom) || 0, ht = Math.min(q, ge.childElementCount), wt = 0, vt = 0;
    for (let $t of (Ve = (Xe = Ft.elements.floating) == null ? void 0 : Xe.childNodes) != null ? Ve : []) if ($t instanceof HTMLElement) {
      let Qe = $t.offsetTop, xt = Qe + $t.clientHeight + Ke, bt = ge.scrollTop, Dt = bt + ge.clientHeight;
      if (Qe >= bt && xt <= Dt) ht--;
      else {
        vt = Math.max(0, Math.min(xt, Dt) - Math.max(Qe, bt)), wt = $t.clientHeight;
        break;
      }
    }
    ht >= 1 && oe(($t) => {
      let Qe = wt * ht - vt + Ke;
      return $t >= Qe ? $t : Qe;
    });
  } }) : null, size({ padding: Ce, apply({ availableWidth: Bt, availableHeight: Xe, elements: Ve }) {
    Object.assign(Ve.floating.style, { overflow: "auto", maxWidth: `${Bt}px`, maxHeight: `min(var(--anchor-max-height, 100vh), ${Xe}px)` });
  } })].filter(Boolean), whileElementsMounted: autoUpdate }), [Ut = kt, Jt = Ct] = Ft.placement.split("-");
  kt === "selection" && (Ut = "selection");
  let Vt = useMemo(() => ({ anchor: [Ut, Jt].filter(Boolean).join(" ") }), [Ut, Jt]), ir = useInnerOffset(Ft, { overflowRef: se, onChange: oe }), { getReferenceProps: jt, getFloatingProps: Rt } = useInteractions([ir]), Kt = o$4((Bt) => {
    ve(Bt), Lt.setFloating(Bt);
  });
  return React.createElement(H.Provider, { value: ne }, React.createElement(y$1.Provider, { value: { setFloating: Kt, setReference: Lt.setReference, styles: Pt, getReferenceProps: jt, getFloatingProps: Rt, slot: Vt } }, B));
}
function pe(B) {
  n$3(() => {
    if (!B) return;
    let z = new MutationObserver(() => {
      let Y = window.getComputedStyle(B).maxHeight, ne = parseFloat(Y);
      if (isNaN(ne)) return;
      let ie = parseInt(Y);
      isNaN(ie) || ne !== ie && (B.style.maxHeight = `${Math.ceil(ne)}px`);
    });
    return z.observe(B, { attributes: !0, attributeFilter: ["style"] }), () => {
      z.disconnect();
    };
  }, [B]);
}
function ce(B, z) {
  var Y, ne, ie;
  let oe = V$1((Y = B == null ? void 0 : B.gap) != null ? Y : "var(--anchor-gap, 0)", z), se = V$1((ne = B == null ? void 0 : B.offset) != null ? ne : "var(--anchor-offset, 0)", z), ae = V$1((ie = B == null ? void 0 : B.padding) != null ? ie : "var(--anchor-padding, 0)", z);
  return { ...B, gap: oe, offset: se, padding: ae };
}
function V$1(B, z, Y = void 0) {
  let ne = p$2(), ie = o$4((ve, Pe) => {
    if (ve == null) return [Y, null];
    if (typeof ve == "number") return [ve, null];
    if (typeof ve == "string") {
      if (!Pe) return [Y, null];
      let le = J$1(ve, Pe);
      return [le, (Ee) => {
        let Je = D$1(ve);
        {
          let Ce = Je.map((_t) => window.getComputedStyle(Pe).getPropertyValue(_t));
          ne.requestAnimationFrame(function _t() {
            ne.nextFrame(_t);
            let kt = !1;
            for (let [Lt, Pt] of Je.entries()) {
              let Ft = window.getComputedStyle(Pe).getPropertyValue(Pt);
              if (Ce[Lt] !== Ft) {
                Ce[Lt] = Ft, kt = !0;
                break;
              }
            }
            if (!kt) return;
            let Ct = J$1(ve, Pe);
            le !== Ct && (Ee(Ct), le = Ct);
          });
        }
        return ne.dispose;
      }];
    }
    return [Y, null];
  }), oe = useMemo(() => ie(B, z)[0], [B, z]), [se = oe, ae] = useState();
  return n$3(() => {
    let [ve, Pe] = ie(B, z);
    if (ae(ve), !!Pe) return Pe(ae);
  }, [B, z]), se;
}
function D$1(B) {
  let z = /var\((.*)\)/.exec(B);
  if (z) {
    let Y = z[1].indexOf(",");
    if (Y === -1) return [z[1]];
    let ne = z[1].slice(0, Y).trim(), ie = z[1].slice(Y + 1).trim();
    return ie ? [ne, ...D$1(ie)] : [ne];
  }
  return [];
}
function J$1(B, z) {
  let Y = document.createElement("div");
  z.appendChild(Y), Y.style.setProperty("margin-top", "0px", "important"), Y.style.setProperty("margin-top", B, "important");
  let ne = parseFloat(window.getComputedStyle(Y).marginTop) || 0;
  return z.removeChild(Y), ne;
}
let n = createContext(null);
n.displayName = "OpenClosedContext";
var i$3 = ((B) => (B[B.Open = 1] = "Open", B[B.Closed = 2] = "Closed", B[B.Closing = 4] = "Closing", B[B.Opening = 8] = "Opening", B))(i$3 || {});
function u$2() {
  return useContext(n);
}
function c$2({ value: B, children: z }) {
  return React__default.createElement(n.Provider, { value: B }, z);
}
function s$5({ children: B }) {
  return React__default.createElement(n.Provider, { value: null }, B);
}
function t(B) {
  function z() {
    document.readyState !== "loading" && (B(), document.removeEventListener("DOMContentLoaded", z));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", z), z());
}
let r$2 = [];
t(() => {
  function B(z) {
    if (!(z.target instanceof HTMLElement) || z.target === document.body || r$2[0] === z.target) return;
    let Y = z.target;
    Y = Y.closest(f$6), r$2.unshift(Y ?? z.target), r$2 = r$2.filter((ne) => ne != null && ne.isConnected), r$2.splice(10);
  }
  window.addEventListener("click", B, { capture: !0 }), window.addEventListener("mousedown", B, { capture: !0 }), window.addEventListener("focus", B, { capture: !0 }), document.body.addEventListener("click", B, { capture: !0 }), document.body.addEventListener("mousedown", B, { capture: !0 }), document.body.addEventListener("focus", B, { capture: !0 });
});
function u$1(B) {
  throw new Error("Unexpected object: " + B);
}
var c$1 = ((B) => (B[B.First = 0] = "First", B[B.Previous = 1] = "Previous", B[B.Next = 2] = "Next", B[B.Last = 3] = "Last", B[B.Specific = 4] = "Specific", B[B.Nothing = 5] = "Nothing", B))(c$1 || {});
function f$4(B, z) {
  let Y = z.resolveItems();
  if (Y.length <= 0) return null;
  let ne = z.resolveActiveIndex(), ie = ne ?? -1;
  switch (B.focus) {
    case 0: {
      for (let oe = 0; oe < Y.length; ++oe) if (!z.resolveDisabled(Y[oe], oe, Y)) return oe;
      return ne;
    }
    case 1: {
      ie === -1 && (ie = Y.length);
      for (let oe = ie - 1; oe >= 0; --oe) if (!z.resolveDisabled(Y[oe], oe, Y)) return oe;
      return ne;
    }
    case 2: {
      for (let oe = ie + 1; oe < Y.length; ++oe) if (!z.resolveDisabled(Y[oe], oe, Y)) return oe;
      return ne;
    }
    case 3: {
      for (let oe = Y.length - 1; oe >= 0; --oe) if (!z.resolveDisabled(Y[oe], oe, Y)) return oe;
      return ne;
    }
    case 4: {
      for (let oe = 0; oe < Y.length; ++oe) if (z.resolveId(Y[oe], oe, Y) === B.id) return oe;
      return ne;
    }
    case 5:
      return null;
    default:
      u$1(B);
  }
}
function c(B) {
  let z = o$4(B), Y = useRef(!1);
  useEffect(() => (Y.current = !1, () => {
    Y.current = !0, t$4(() => {
      Y.current && z();
    });
  }), [z]);
}
function s$4() {
  let B = typeof document > "u";
  return "useSyncExternalStore" in React ? ((z) => z.useSyncExternalStore)(React)(() => () => {
  }, () => !1, () => !B) : !1;
}
function l$1() {
  let B = s$4(), [z, Y] = React.useState(s$9.isHandoffComplete);
  return z && s$9.isHandoffComplete === !1 && Y(!1), React.useEffect(() => {
    z !== !0 && Y(!0);
  }, [z]), React.useEffect(() => s$9.handoff(), []), B ? !1 : z;
}
let e = createContext(!1);
function a$4() {
  return useContext(e);
}
function l(B) {
  return React__default.createElement(e.Provider, { value: B.force }, B.children);
}
function N(B) {
  let z = a$4(), Y = useContext(v), ne = n$1(B), [ie, oe] = useState(() => {
    var se;
    if (!z && Y !== null) return (se = Y.current) != null ? se : null;
    if (s$9.isServer) return null;
    let ae = ne == null ? void 0 : ne.getElementById("headlessui-portal-root");
    if (ae) return ae;
    if (ne === null) return null;
    let ve = ne.createElement("div");
    return ve.setAttribute("id", "headlessui-portal-root"), ne.body.appendChild(ve);
  });
  return useEffect(() => {
    ie !== null && (ne != null && ne.body.contains(ie) || ne == null || ne.body.appendChild(ie));
  }, [ie, ne]), useEffect(() => {
    z || Y !== null && oe(Y.current);
  }, [Y, oe, z]), ie;
}
let M$1 = Fragment, S = K$6(function(B, z) {
  let Y = B, ne = useRef(null), ie = y$4(T$2((Ee) => {
    ne.current = Ee;
  }), z), oe = n$1(ne), se = N(ne), [ae] = useState(() => {
    var Ee;
    return s$9.isServer ? null : (Ee = oe == null ? void 0 : oe.createElement("div")) != null ? Ee : null;
  }), ve = useContext(y), Pe = l$1();
  n$3(() => {
    !se || !ae || se.contains(ae) || (ae.setAttribute("data-headlessui-portal", ""), se.appendChild(ae));
  }, [se, ae]), n$3(() => {
    if (ae && ve) return ve.register(ae);
  }, [ve, ae]), c(() => {
    var Ee;
    !se || !ae || (ae instanceof Node && se.contains(ae) && se.removeChild(ae), se.childNodes.length <= 0 && ((Ee = se.parentElement) == null || Ee.removeChild(se)));
  });
  let le = L$1();
  return Pe ? !se || !ae ? null : createPortal(le({ ourProps: { ref: ie }, theirProps: Y, slot: {}, defaultTag: M$1, name: "Portal" }), ae) : null;
});
function j$1(B, z) {
  let Y = y$4(z), { enabled: ne = !0, ...ie } = B, oe = L$1();
  return ne ? React__default.createElement(S, { ...ie, ref: Y }) : oe({ ourProps: { ref: Y }, theirProps: ie, slot: {}, defaultTag: M$1, name: "Portal" });
}
let W$6 = Fragment, v = createContext(null);
function I$1(B, z) {
  let { target: Y, ...ne } = B, ie = { ref: y$4(z) }, oe = L$1();
  return React__default.createElement(v.Provider, { value: Y }, oe({ ourProps: ie, theirProps: ne, defaultTag: W$6, name: "Popover.Group" }));
}
let y = createContext(null);
function te$1() {
  let B = useContext(y), z = useRef([]), Y = o$4((oe) => (z.current.push(oe), B && B.register(oe), () => ne(oe))), ne = o$4((oe) => {
    let se = z.current.indexOf(oe);
    se !== -1 && z.current.splice(se, 1), B && B.unregister(oe);
  }), ie = useMemo(() => ({ register: Y, unregister: ne, portals: z }), [Y, ne, z]);
  return [z, useMemo(() => function({ children: oe }) {
    return React__default.createElement(y.Provider, { value: ie }, oe);
  }, [ie])];
}
let J = K$6(j$1), X$1 = K$6(I$1), re$1 = Object.assign(J, { Group: X$1 });
function a$3(B, z = typeof document < "u" ? document.defaultView : null, Y) {
  let ne = x$3(B, "escape");
  E(z, "keydown", (ie) => {
    ne && (ie.defaultPrevented || ie.key === o$3.Escape && Y(ie));
  });
}
function f$3() {
  var B;
  let [z] = useState(() => typeof window < "u" && typeof window.matchMedia == "function" ? window.matchMedia("(pointer: coarse)") : null), [Y, ne] = useState((B = z == null ? void 0 : z.matches) != null ? B : !1);
  return n$3(() => {
    if (!z) return;
    function ie(oe) {
      ne(oe.matches);
    }
    return z.addEventListener("change", ie), () => z.removeEventListener("change", ie);
  }, [z]), Y;
}
function R$1({ defaultContainers: B = [], portals: z, mainTreeNode: Y } = {}) {
  let ne = n$1(Y), ie = o$4(() => {
    var oe, se;
    let ae = [];
    for (let ve of B) ve !== null && (ve instanceof HTMLElement ? ae.push(ve) : "current" in ve && ve.current instanceof HTMLElement && ae.push(ve.current));
    if (z != null && z.current) for (let ve of z.current) ae.push(ve);
    for (let ve of (oe = ne == null ? void 0 : ne.querySelectorAll("html > *, body > *")) != null ? oe : []) ve !== document.body && ve !== document.head && ve instanceof HTMLElement && ve.id !== "headlessui-portal-root" && (Y && (ve.contains(Y) || ve.contains((se = Y == null ? void 0 : Y.getRootNode()) == null ? void 0 : se.host)) || ae.some((Pe) => ve.contains(Pe)) || ae.push(ve));
    return ae;
  });
  return { resolveContainers: ie, contains: o$4((oe) => ie().some((se) => se.contains(oe))) };
}
let a$2 = createContext(null);
function O$1({ children: B, node: z }) {
  let [Y, ne] = useState(null), ie = b(z ?? Y);
  return React__default.createElement(a$2.Provider, { value: ie }, B, ie === null && React__default.createElement(f$a, { features: s$7.Hidden, ref: (oe) => {
    var se, ae;
    if (oe) {
      for (let ve of (ae = (se = u$8(oe)) == null ? void 0 : se.querySelectorAll("html > *, body > *")) != null ? ae : []) if (ve !== document.body && ve !== document.head && ve instanceof HTMLElement && ve != null && ve.contains(oe)) {
        ne(ve);
        break;
      }
    }
  } }));
}
function b(B = null) {
  var z;
  return (z = useContext(a$2)) != null ? z : B;
}
function f$2() {
  let B = useRef(!1);
  return n$3(() => (B.current = !0, () => {
    B.current = !1;
  }), []), B;
}
var a$1 = ((B) => (B[B.Forwards = 0] = "Forwards", B[B.Backwards = 1] = "Backwards", B))(a$1 || {});
function u() {
  let B = useRef(0);
  return s$6(!0, "keydown", (z) => {
    z.key === "Tab" && (B.current = z.shiftKey ? 1 : 0);
  }, !0), B;
}
function U$1(B) {
  if (!B) return /* @__PURE__ */ new Set();
  if (typeof B == "function") return new Set(B());
  let z = /* @__PURE__ */ new Set();
  for (let Y of B.current) Y.current instanceof HTMLElement && z.add(Y.current);
  return z;
}
let Z = "div";
var x$1 = ((B) => (B[B.None = 0] = "None", B[B.InitialFocus = 1] = "InitialFocus", B[B.TabLock = 2] = "TabLock", B[B.FocusLock = 4] = "FocusLock", B[B.RestoreFocus = 8] = "RestoreFocus", B[B.AutoFocus = 16] = "AutoFocus", B))(x$1 || {});
function $(B, z) {
  let Y = useRef(null), ne = y$4(Y, z), { initialFocus: ie, initialFocusFallback: oe, containers: se, features: ae = 15, ...ve } = B;
  l$1() || (ae = 0);
  let Pe = n$1(Y);
  ee(ae, { ownerDocument: Pe });
  let le = te(ae, { ownerDocument: Pe, container: Y, initialFocus: ie, initialFocusFallback: oe });
  re(ae, { ownerDocument: Pe, container: Y, containers: se, previousActiveElement: le });
  let Ee = u(), Je = o$4((Pt) => {
    let Ft = Y.current;
    Ft && ((Ut) => Ut())(() => {
      u$7(Ee.current, { [a$1.Forwards]: () => {
        P(Ft, F$1.First, { skipElements: [Pt.relatedTarget, oe] });
      }, [a$1.Backwards]: () => {
        P(Ft, F$1.Last, { skipElements: [Pt.relatedTarget, oe] });
      } });
    });
  }), Ce = x$3(!!(ae & 2), "focus-trap#tab-lock"), _t = p$2(), kt = useRef(!1), Ct = { ref: ne, onKeyDown(Pt) {
    Pt.key == "Tab" && (kt.current = !0, _t.requestAnimationFrame(() => {
      kt.current = !1;
    }));
  }, onBlur(Pt) {
    if (!(ae & 4)) return;
    let Ft = U$1(se);
    Y.current instanceof HTMLElement && Ft.add(Y.current);
    let Ut = Pt.relatedTarget;
    Ut instanceof HTMLElement && Ut.dataset.headlessuiFocusGuard !== "true" && (I(Ft, Ut) || (kt.current ? P(Y.current, u$7(Ee.current, { [a$1.Forwards]: () => F$1.Next, [a$1.Backwards]: () => F$1.Previous }) | F$1.WrapAround, { relativeTo: Pt.target }) : Pt.target instanceof HTMLElement && I$2(Pt.target)));
  } }, Lt = L$1();
  return React__default.createElement(React__default.Fragment, null, Ce && React__default.createElement(f$a, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: Je, features: s$7.Focusable }), Lt({ ourProps: Ct, theirProps: ve, defaultTag: Z, name: "FocusTrap" }), Ce && React__default.createElement(f$a, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: Je, features: s$7.Focusable }));
}
let D = K$6($), ye = Object.assign(D, { features: x$1 });
function w$2(B = !0) {
  let z = useRef(r$2.slice());
  return m(([Y], [ne]) => {
    ne === !0 && Y === !1 && t$4(() => {
      z.current.splice(0);
    }), ne === !1 && Y === !0 && (z.current = r$2.slice());
  }, [B, r$2, z]), o$4(() => {
    var Y;
    return (Y = z.current.find((ne) => ne != null && ne.isConnected)) != null ? Y : null;
  });
}
function ee(B, { ownerDocument: z }) {
  let Y = !!(B & 8), ne = w$2(Y);
  m(() => {
    Y || (z == null ? void 0 : z.activeElement) === (z == null ? void 0 : z.body) && I$2(ne());
  }, [Y]), c(() => {
    Y && I$2(ne());
  });
}
function te(B, { ownerDocument: z, container: Y, initialFocus: ne, initialFocusFallback: ie }) {
  let oe = useRef(null), se = x$3(!!(B & 1), "focus-trap#initial-focus"), ae = f$2();
  return m(() => {
    if (B === 0) return;
    if (!se) {
      ie != null && ie.current && I$2(ie.current);
      return;
    }
    let ve = Y.current;
    ve && t$4(() => {
      if (!ae.current) return;
      let Pe = z == null ? void 0 : z.activeElement;
      if (ne != null && ne.current) {
        if ((ne == null ? void 0 : ne.current) === Pe) {
          oe.current = Pe;
          return;
        }
      } else if (ve.contains(Pe)) {
        oe.current = Pe;
        return;
      }
      if (ne != null && ne.current) I$2(ne.current);
      else {
        if (B & 16) {
          if (P(ve, F$1.First | F$1.AutoFocus) !== T$1.Error) return;
        } else if (P(ve, F$1.First) !== T$1.Error) return;
        if (ie != null && ie.current && (I$2(ie.current), (z == null ? void 0 : z.activeElement) === ie.current)) return;
        console.warn("There are no focusable elements inside the <FocusTrap />");
      }
      oe.current = z == null ? void 0 : z.activeElement;
    });
  }, [ie, se, B]), oe;
}
function re(B, { ownerDocument: z, container: Y, containers: ne, previousActiveElement: ie }) {
  let oe = f$2(), se = !!(B & 4);
  E(z == null ? void 0 : z.defaultView, "focus", (ae) => {
    if (!se || !oe.current) return;
    let ve = U$1(ne);
    Y.current instanceof HTMLElement && ve.add(Y.current);
    let Pe = ie.current;
    if (!Pe) return;
    let le = ae.target;
    le && le instanceof HTMLElement ? I(ve, le) ? (ie.current = le, I$2(le)) : (ae.preventDefault(), ae.stopPropagation(), I$2(Pe)) : I$2(ie.current);
  }, !0);
}
function I(B, z) {
  for (let Y of B) if (Y.contains(z)) return !0;
  return !1;
}
function ue(B) {
  var z;
  return !!(B.enter || B.enterFrom || B.enterTo || B.leave || B.leaveFrom || B.leaveTo) || ((z = B.as) != null ? z : de) !== Fragment || React__default.Children.count(B.children) === 1;
}
let w$1 = createContext(null);
w$1.displayName = "TransitionContext";
var _e = ((B) => (B.Visible = "visible", B.Hidden = "hidden", B))(_e || {});
function De() {
  let B = useContext(w$1);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
function He$1() {
  let B = useContext(M);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
let M = createContext(null);
M.displayName = "NestingContext";
function U(B) {
  return "children" in B ? U(B.children) : B.current.filter(({ el: z }) => z.current !== null).filter(({ state: z }) => z === "visible").length > 0;
}
function Te(B, z) {
  let Y = s$8(B), ne = useRef([]), ie = f$2(), oe = p$2(), se = o$4((Ce, _t = A$1.Hidden) => {
    let kt = ne.current.findIndex(({ el: Ct }) => Ct === Ce);
    kt !== -1 && (u$7(_t, { [A$1.Unmount]() {
      ne.current.splice(kt, 1);
    }, [A$1.Hidden]() {
      ne.current[kt].state = "hidden";
    } }), oe.microTask(() => {
      var Ct;
      !U(ne) && ie.current && ((Ct = Y.current) == null || Ct.call(Y));
    }));
  }), ae = o$4((Ce) => {
    let _t = ne.current.find(({ el: kt }) => kt === Ce);
    return _t ? _t.state !== "visible" && (_t.state = "visible") : ne.current.push({ el: Ce, state: "visible" }), () => se(Ce, A$1.Unmount);
  }), ve = useRef([]), Pe = useRef(Promise.resolve()), le = useRef({ enter: [], leave: [] }), Ee = o$4((Ce, _t, kt) => {
    ve.current.splice(0), z && (z.chains.current[_t] = z.chains.current[_t].filter(([Ct]) => Ct !== Ce)), z == null || z.chains.current[_t].push([Ce, new Promise((Ct) => {
      ve.current.push(Ct);
    })]), z == null || z.chains.current[_t].push([Ce, new Promise((Ct) => {
      Promise.all(le.current[_t].map(([Lt, Pt]) => Pt)).then(() => Ct());
    })]), _t === "enter" ? Pe.current = Pe.current.then(() => z == null ? void 0 : z.wait.current).then(() => kt(_t)) : kt(_t);
  }), Je = o$4((Ce, _t, kt) => {
    Promise.all(le.current[_t].splice(0).map(([Ct, Lt]) => Lt)).then(() => {
      var Ct;
      (Ct = ve.current.shift()) == null || Ct();
    }).then(() => kt(_t));
  });
  return useMemo(() => ({ children: ne, register: ae, unregister: se, onStart: Ee, onStop: Je, wait: Pe, chains: le }), [ae, se, ne, Ee, Je, le, Pe]);
}
let de = Fragment, fe = O$3.RenderStrategy;
function Ae(B, z) {
  var Y, ne;
  let { transition: ie = !0, beforeEnter: oe, afterEnter: se, beforeLeave: ae, afterLeave: ve, enter: Pe, enterFrom: le, enterTo: Ee, entered: Je, leave: Ce, leaveFrom: _t, leaveTo: kt, ...Ct } = B, [Lt, Pt] = useState(null), Ft = useRef(null), Ut = ue(B), Jt = y$4(...Ut ? [Ft, z, Pt] : z === null ? [] : [z]), Vt = (Y = Ct.unmount) == null || Y ? A$1.Unmount : A$1.Hidden, { show: ir, appear: jt, initial: Rt } = De(), [Kt, Bt] = useState(ir ? "visible" : "hidden"), Xe = He$1(), { register: Ve, unregister: ge } = Xe;
  n$3(() => Ve(Ft), [Ve, Ft]), n$3(() => {
    if (Vt === A$1.Hidden && Ft.current) {
      if (ir && Kt !== "visible") {
        Bt("visible");
        return;
      }
      return u$7(Kt, { hidden: () => ge(Ft), visible: () => Ve(Ft) });
    }
  }, [Kt, Ft, Ve, ge, ir, Vt]);
  let Ke = l$1();
  n$3(() => {
    if (Ut && Ke && Kt === "visible" && Ft.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [Ft, Kt, Ke, Ut]);
  let ht = Rt && !jt, wt = jt && ir && Rt, vt = useRef(!1), $t = Te(() => {
    vt.current || (Bt("hidden"), ge(Ft));
  }, Xe), Qe = o$4((Ht) => {
    vt.current = !0;
    let qt = Ht ? "enter" : "leave";
    $t.onStart(Ft, qt, (nr) => {
      nr === "enter" ? oe == null || oe() : nr === "leave" && (ae == null || ae());
    });
  }), xt = o$4((Ht) => {
    let qt = Ht ? "enter" : "leave";
    vt.current = !1, $t.onStop(Ft, qt, (nr) => {
      nr === "enter" ? se == null || se() : nr === "leave" && (ve == null || ve());
    }), qt === "leave" && !U($t) && (Bt("hidden"), ge(Ft));
  });
  useEffect(() => {
    Ut && ie || (Qe(ir), xt(ir));
  }, [ir, Ut, ie]);
  let bt = !(!ie || !Ut || !Ke || ht), [, Dt] = x$2(bt, Lt, ir, { start: Qe, end: xt }), er = m$4({ ref: Jt, className: ((ne = t$3(Ct.className, wt && Pe, wt && le, Dt.enter && Pe, Dt.enter && Dt.closed && le, Dt.enter && !Dt.closed && Ee, Dt.leave && Ce, Dt.leave && !Dt.closed && _t, Dt.leave && Dt.closed && kt, !Dt.transition && ir && Je)) == null ? void 0 : ne.trim()) || void 0, ...R$2(Dt) }), fr = 0;
  Kt === "visible" && (fr |= i$3.Open), Kt === "hidden" && (fr |= i$3.Closed), Dt.enter && (fr |= i$3.Opening), Dt.leave && (fr |= i$3.Closing);
  let Qt = L$1();
  return React__default.createElement(M.Provider, { value: $t }, React__default.createElement(c$2, { value: fr }, Qt({ ourProps: er, theirProps: Ct, defaultTag: de, features: fe, visible: Kt === "visible", name: "Transition.Child" })));
}
function Ie$1(B, z) {
  let { show: Y, appear: ne = !1, unmount: ie = !0, ...oe } = B, se = useRef(null), ae = ue(B), ve = y$4(...ae ? [se, z] : z === null ? [] : [z]);
  l$1();
  let Pe = u$2();
  if (Y === void 0 && Pe !== null && (Y = (Pe & i$3.Open) === i$3.Open), Y === void 0) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [le, Ee] = useState(Y ? "visible" : "hidden"), Je = Te(() => {
    Y || Ee("hidden");
  }), [Ce, _t] = useState(!0), kt = useRef([Y]);
  n$3(() => {
    Ce !== !1 && kt.current[kt.current.length - 1] !== Y && (kt.current.push(Y), _t(!1));
  }, [kt, Y]);
  let Ct = useMemo(() => ({ show: Y, appear: ne, initial: Ce }), [Y, ne, Ce]);
  n$3(() => {
    Y ? Ee("visible") : !U(Je) && se.current !== null && Ee("hidden");
  }, [Y, Je]);
  let Lt = { unmount: ie }, Pt = o$4(() => {
    var Jt;
    Ce && _t(!1), (Jt = B.beforeEnter) == null || Jt.call(B);
  }), Ft = o$4(() => {
    var Jt;
    Ce && _t(!1), (Jt = B.beforeLeave) == null || Jt.call(B);
  }), Ut = L$1();
  return React__default.createElement(M.Provider, { value: Je }, React__default.createElement(w$1.Provider, { value: Ct }, Ut({ ourProps: { ...Lt, as: Fragment, children: React__default.createElement(me, { ref: ve, ...Lt, ...oe, beforeEnter: Pt, beforeLeave: Ft }) }, theirProps: {}, defaultTag: Fragment, features: fe, visible: le === "visible", name: "Transition" })));
}
function Le(B, z) {
  let Y = useContext(w$1) !== null, ne = u$2() !== null;
  return React__default.createElement(React__default.Fragment, null, !Y && ne ? React__default.createElement(X, { ref: z, ...B }) : React__default.createElement(me, { ref: z, ...B }));
}
let X = K$6(Ie$1), me = K$6(Ae), Fe = K$6(Le), ze$1 = Object.assign(X, { Child: Fe, Root: X });
var Oe = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(Oe || {}), he = ((B) => (B[B.SetTitleId = 0] = "SetTitleId", B))(he || {});
let Se = { 0(B, z) {
  return B.titleId === z.id ? B : { ...B, titleId: z.id };
} }, k$1 = createContext(null);
k$1.displayName = "DialogContext";
function O(B) {
  let z = useContext(k$1);
  if (z === null) {
    let Y = new Error(`<${B} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(Y, O), Y;
  }
  return z;
}
function Ie(B, z) {
  return u$7(z.type, Se, B, z);
}
let V = K$6(function(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-dialog-${Y}`, open: ie, onClose: oe, initialFocus: se, role: ae = "dialog", autoFocus: ve = !0, __demoMode: Pe = !1, unmount: le = !1, ...Ee } = B, Je = useRef(!1);
  ae = function() {
    return ae === "dialog" || ae === "alertdialog" ? ae : (Je.current || (Je.current = !0, console.warn(`Invalid role [${ae}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let Ce = u$2();
  ie === void 0 && Ce !== null && (ie = (Ce & i$3.Open) === i$3.Open);
  let _t = useRef(null), kt = y$4(_t, z), Ct = n$1(_t), Lt = ie ? 0 : 1, [Pt, Ft] = useReducer(Ie, { titleId: null, descriptionId: null, panelRef: createRef() }), Ut = o$4(() => oe(!1)), Jt = o$4((xt) => Ft({ type: 0, id: xt })), Vt = l$1() ? Lt === 0 : !1, [ir, jt] = te$1(), Rt = { get current() {
    var xt;
    return (xt = Pt.panelRef.current) != null ? xt : _t.current;
  } }, Kt = b(), { resolveContainers: Bt } = R$1({ mainTreeNode: Kt, portals: ir, defaultContainers: [Rt] }), Xe = Ce !== null ? (Ce & i$3.Closing) === i$3.Closing : !1;
  y$3(Pe || Xe ? !1 : Vt, { allowed: o$4(() => {
    var xt, bt;
    return [(bt = (xt = _t.current) == null ? void 0 : xt.closest("[data-headlessui-portal]")) != null ? bt : null];
  }), disallowed: o$4(() => {
    var xt;
    return [(xt = Kt == null ? void 0 : Kt.closest("body > *:not(#headlessui-portal-root)")) != null ? xt : null];
  }) }), R$3(Vt, Bt, (xt) => {
    xt.preventDefault(), Ut();
  }), a$3(Vt, Ct == null ? void 0 : Ct.defaultView, (xt) => {
    xt.preventDefault(), xt.stopPropagation(), document.activeElement && "blur" in document.activeElement && typeof document.activeElement.blur == "function" && document.activeElement.blur(), Ut();
  }), f$5(Pe || Xe ? !1 : Vt, Ct, Bt), m$2(Vt, _t, Ut);
  let [Ve, ge] = w$4(), Ke = useMemo(() => [{ dialogState: Lt, close: Ut, setTitleId: Jt, unmount: le }, Pt], [Lt, Pt, Ut, Jt, le]), ht = useMemo(() => ({ open: Lt === 0 }), [Lt]), wt = { ref: kt, id: ne, role: ae, tabIndex: -1, "aria-modal": Pe ? void 0 : Lt === 0 ? !0 : void 0, "aria-labelledby": Pt.titleId, "aria-describedby": Ve, unmount: le }, vt = !f$3(), $t = x$1.None;
  Vt && !Pe && ($t |= x$1.RestoreFocus, $t |= x$1.TabLock, ve && ($t |= x$1.AutoFocus), vt && ($t |= x$1.InitialFocus));
  let Qe = L$1();
  return React__default.createElement(s$5, null, React__default.createElement(l, { force: !0 }, React__default.createElement(re$1, null, React__default.createElement(k$1.Provider, { value: Ke }, React__default.createElement(X$1, { target: _t }, React__default.createElement(l, { force: !1 }, React__default.createElement(ge, { slot: ht }, React__default.createElement(jt, null, React__default.createElement(ye, { initialFocus: se, initialFocusFallback: _t, containers: Bt, features: $t }, React__default.createElement(C$1, { value: Ut }, Qe({ ourProps: wt, theirProps: Ee, slot: ht, defaultTag: Me, features: Ge, visible: Lt === 0, name: "Dialog" })))))))))));
}), Me = "div", Ge = O$3.RenderStrategy | O$3.Static;
function ke(B, z) {
  let { transition: Y = !1, open: ne, ...ie } = B, oe = u$2(), se = B.hasOwnProperty("open") || oe !== null, ae = B.hasOwnProperty("onClose");
  if (!se && !ae) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!se) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!ae) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (!oe && typeof B.open != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${B.open}`);
  if (typeof B.onClose != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${B.onClose}`);
  return (ne !== void 0 || Y) && !ie.static ? React__default.createElement(O$1, null, React__default.createElement(ze$1, { show: ne, transition: Y, unmount: ie.unmount }, React__default.createElement(V, { ref: z, ...ie }))) : React__default.createElement(O$1, null, React__default.createElement(V, { ref: z, open: ne, ...ie }));
}
let we = "div";
function Be(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-dialog-panel-${Y}`, transition: ie = !1, ...oe } = B, [{ dialogState: se, unmount: ae }, ve] = O("Dialog.Panel"), Pe = y$4(z, ve.panelRef), le = useMemo(() => ({ open: se === 0 }), [se]), Ee = o$4((Ct) => {
    Ct.stopPropagation();
  }), Je = { ref: Pe, id: ne, onClick: Ee }, Ce = ie ? Fe : Fragment, _t = ie ? { unmount: ae } : {}, kt = L$1();
  return React__default.createElement(Ce, { ..._t }, kt({ ourProps: Je, theirProps: oe, slot: le, defaultTag: we, name: "Dialog.Panel" }));
}
let Ue = "div";
function He(B, z) {
  let { transition: Y = !1, ...ne } = B, [{ dialogState: ie, unmount: oe }] = O("Dialog.Backdrop"), se = useMemo(() => ({ open: ie === 0 }), [ie]), ae = { ref: z, "aria-hidden": !0 }, ve = Y ? Fe : Fragment, Pe = Y ? { unmount: oe } : {}, le = L$1();
  return React__default.createElement(ve, { ...Pe }, le({ ourProps: ae, theirProps: ne, slot: se, defaultTag: Ue, name: "Dialog.Backdrop" }));
}
let Ne = "h2";
function We(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-dialog-title-${Y}`, ...ie } = B, [{ dialogState: oe, setTitleId: se }] = O("Dialog.Title"), ae = y$4(z);
  useEffect(() => (se(ne), () => se(null)), [ne, se]);
  let ve = useMemo(() => ({ open: oe === 0 }), [oe]), Pe = { ref: ae, id: ne };
  return L$1()({ ourProps: Pe, theirProps: ie, slot: ve, defaultTag: Ne, name: "Dialog.Title" });
}
let $e = K$6(ke), je = K$6(Be);
K$6(He);
let Ye$1 = K$6(We), yt$1 = Object.assign($e, { Panel: je, Title: Ye$1, Description: H$2 });
function s$3(B, z) {
  let Y = useRef({ left: 0, top: 0 });
  if (n$3(() => {
    if (!z) return;
    let ie = z.getBoundingClientRect();
    ie && (Y.current = ie);
  }, [B, z]), z == null || !B || z === document.activeElement) return !1;
  let ne = z.getBoundingClientRect();
  return ne.top !== Y.current.top || ne.left !== Y.current.left;
}
let a = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$1(B) {
  var z, Y;
  let ne = (z = B.innerText) != null ? z : "", ie = B.cloneNode(!0);
  if (!(ie instanceof HTMLElement)) return ne;
  let oe = !1;
  for (let ae of ie.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) ae.remove(), oe = !0;
  let se = oe ? (Y = ie.innerText) != null ? Y : "" : ne;
  return a.test(se) && (se = se.replace(a, "")), se;
}
function g$2(B) {
  let z = B.getAttribute("aria-label");
  if (typeof z == "string") return z.trim();
  let Y = B.getAttribute("aria-labelledby");
  if (Y) {
    let ne = Y.split(" ").map((ie) => {
      let oe = document.getElementById(ie);
      if (oe) {
        let se = oe.getAttribute("aria-label");
        return typeof se == "string" ? se.trim() : o$1(oe).trim();
      }
      return null;
    }).filter(Boolean);
    if (ne.length > 0) return ne.join(", ");
  }
  return o$1(B).trim();
}
function s$2(B) {
  let z = useRef(""), Y = useRef("");
  return o$4(() => {
    let ne = B.current;
    if (!ne) return "";
    let ie = ne.innerText;
    if (z.current === ie) return Y.current;
    let oe = g$2(ne).trim().toLowerCase();
    return z.current = ie, Y.current = oe, oe;
  });
}
var qe = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(qe || {}), ze = ((B) => (B[B.Pointer = 0] = "Pointer", B[B.Other = 1] = "Other", B))(ze || {}), Ye = ((B) => (B[B.OpenMenu = 0] = "OpenMenu", B[B.CloseMenu = 1] = "CloseMenu", B[B.GoToItem = 2] = "GoToItem", B[B.Search = 3] = "Search", B[B.ClearSearch = 4] = "ClearSearch", B[B.RegisterItem = 5] = "RegisterItem", B[B.UnregisterItem = 6] = "UnregisterItem", B[B.SetButtonElement = 7] = "SetButtonElement", B[B.SetItemsElement = 8] = "SetItemsElement", B))(Ye || {});
function j(B, z = (Y) => Y) {
  let Y = B.activeItemIndex !== null ? B.items[B.activeItemIndex] : null, ne = _(z(B.items.slice()), (oe) => oe.dataRef.current.domRef.current), ie = Y ? ne.indexOf(Y) : null;
  return ie === -1 && (ie = null), { items: ne, activeItemIndex: ie };
}
let Ze = { 1(B) {
  return B.menuState === 1 ? B : { ...B, activeItemIndex: null, menuState: 1 };
}, 0(B) {
  return B.menuState === 0 ? B : { ...B, __demoMode: !1, menuState: 0 };
}, 2: (B, z) => {
  var Y, ne, ie, oe, se;
  if (B.menuState === 1) return B;
  let ae = { ...B, searchQuery: "", activationTrigger: (Y = z.trigger) != null ? Y : 1, __demoMode: !1 };
  if (z.focus === c$1.Nothing) return { ...ae, activeItemIndex: null };
  if (z.focus === c$1.Specific) return { ...ae, activeItemIndex: B.items.findIndex((le) => le.id === z.id) };
  if (z.focus === c$1.Previous) {
    let le = B.activeItemIndex;
    if (le !== null) {
      let Ee = B.items[le].dataRef.current.domRef, Je = f$4(z, { resolveItems: () => B.items, resolveActiveIndex: () => B.activeItemIndex, resolveId: (Ce) => Ce.id, resolveDisabled: (Ce) => Ce.dataRef.current.disabled });
      if (Je !== null) {
        let Ce = B.items[Je].dataRef.current.domRef;
        if (((ne = Ee.current) == null ? void 0 : ne.previousElementSibling) === Ce.current || ((ie = Ce.current) == null ? void 0 : ie.previousElementSibling) === null) return { ...ae, activeItemIndex: Je };
      }
    }
  } else if (z.focus === c$1.Next) {
    let le = B.activeItemIndex;
    if (le !== null) {
      let Ee = B.items[le].dataRef.current.domRef, Je = f$4(z, { resolveItems: () => B.items, resolveActiveIndex: () => B.activeItemIndex, resolveId: (Ce) => Ce.id, resolveDisabled: (Ce) => Ce.dataRef.current.disabled });
      if (Je !== null) {
        let Ce = B.items[Je].dataRef.current.domRef;
        if (((oe = Ee.current) == null ? void 0 : oe.nextElementSibling) === Ce.current || ((se = Ce.current) == null ? void 0 : se.nextElementSibling) === null) return { ...ae, activeItemIndex: Je };
      }
    }
  }
  let ve = j(B), Pe = f$4(z, { resolveItems: () => ve.items, resolveActiveIndex: () => ve.activeItemIndex, resolveId: (le) => le.id, resolveDisabled: (le) => le.dataRef.current.disabled });
  return { ...ae, ...ve, activeItemIndex: Pe };
}, 3: (B, z) => {
  let Y = B.searchQuery !== "" ? 0 : 1, ne = B.searchQuery + z.value.toLowerCase(), ie = (B.activeItemIndex !== null ? B.items.slice(B.activeItemIndex + Y).concat(B.items.slice(0, B.activeItemIndex + Y)) : B.items).find((se) => {
    var ae;
    return ((ae = se.dataRef.current.textValue) == null ? void 0 : ae.startsWith(ne)) && !se.dataRef.current.disabled;
  }), oe = ie ? B.items.indexOf(ie) : -1;
  return oe === -1 || oe === B.activeItemIndex ? { ...B, searchQuery: ne } : { ...B, searchQuery: ne, activeItemIndex: oe, activationTrigger: 1 };
}, 4(B) {
  return B.searchQuery === "" ? B : { ...B, searchQuery: "", searchActiveItemIndex: null };
}, 5: (B, z) => {
  let Y = j(B, (ne) => [...ne, { id: z.id, dataRef: z.dataRef }]);
  return { ...B, ...Y };
}, 6: (B, z) => {
  let Y = j(B, (ne) => {
    let ie = ne.findIndex((oe) => oe.id === z.id);
    return ie !== -1 && ne.splice(ie, 1), ne;
  });
  return { ...B, ...Y, activationTrigger: 1 };
}, 7: (B, z) => B.buttonElement === z.element ? B : { ...B, buttonElement: z.element }, 8: (B, z) => B.itemsElement === z.element ? B : { ...B, itemsElement: z.element } }, Q = createContext(null);
Q.displayName = "MenuContext";
function w(B) {
  let z = useContext(Q);
  if (z === null) {
    let Y = new Error(`<${B} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(Y, w), Y;
  }
  return z;
}
function et(B, z) {
  return u$7(z.type, Ze, B, z);
}
let tt = Fragment;
function nt(B, z) {
  let { __demoMode: Y = !1, ...ne } = B, ie = useReducer(et, { __demoMode: Y, menuState: Y ? 0 : 1, buttonElement: null, itemsElement: null, items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: oe, itemsElement: se, buttonElement: ae }, ve] = ie, Pe = y$4(z);
  R$3(oe === 0, [ae, se], (_t, kt) => {
    ve({ type: 1 }), A(kt, h$2.Loose) || (_t.preventDefault(), ae == null || ae.focus());
  });
  let le = o$4(() => {
    ve({ type: 1 });
  }), Ee = useMemo(() => ({ open: oe === 0, close: le }), [oe, le]), Je = { ref: Pe }, Ce = L$1();
  return React__default.createElement(Me$1, null, React__default.createElement(Q.Provider, { value: ie }, React__default.createElement(c$2, { value: u$7(oe, { 0: i$3.Open, 1: i$3.Closed }) }, Ce({ ourProps: Je, theirProps: ne, slot: Ee, defaultTag: tt, name: "Menu" }))));
}
let rt = "button";
function ot(B, z) {
  var Y;
  let ne = useId$1(), { id: ie = `headlessui-menu-button-${ne}`, disabled: oe = !1, autoFocus: se = !1, ...ae } = B, [ve, Pe] = w("Menu.Button"), le = Fe$1(), Ee = y$4(z, ye$1(), o$4((ir) => Pe({ type: 7, element: ir }))), Je = o$4((ir) => {
    switch (ir.key) {
      case o$3.Space:
      case o$3.Enter:
      case o$3.ArrowDown:
        ir.preventDefault(), ir.stopPropagation(), flushSync(() => Pe({ type: 0 })), Pe({ type: 2, focus: c$1.First });
        break;
      case o$3.ArrowUp:
        ir.preventDefault(), ir.stopPropagation(), flushSync(() => Pe({ type: 0 })), Pe({ type: 2, focus: c$1.Last });
        break;
    }
  }), Ce = o$4((ir) => {
    switch (ir.key) {
      case o$3.Space:
        ir.preventDefault();
        break;
    }
  }), _t = o$4((ir) => {
    var jt;
    if (r$4(ir.currentTarget)) return ir.preventDefault();
    oe || (ve.menuState === 0 ? (flushSync(() => Pe({ type: 1 })), (jt = ve.buttonElement) == null || jt.focus({ preventScroll: !0 })) : (ir.preventDefault(), Pe({ type: 0 })));
  }), { isFocusVisible: kt, focusProps: Ct } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: se }), { isHovered: Lt, hoverProps: Pt } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: oe }), { pressed: Ft, pressProps: Ut } = w$5({ disabled: oe }), Jt = useMemo(() => ({ open: ve.menuState === 0, active: Ft || ve.menuState === 0, disabled: oe, hover: Lt, focus: kt, autofocus: se }), [ve, Lt, kt, Ft, oe, se]), Vt = _$2(le(), { ref: Ee, id: ie, type: e$1(B, ve.buttonElement), "aria-haspopup": "menu", "aria-controls": (Y = ve.itemsElement) == null ? void 0 : Y.id, "aria-expanded": ve.menuState === 0, disabled: oe || void 0, autoFocus: se, onKeyDown: Je, onKeyUp: Ce, onClick: _t }, Ct, Pt, Ut);
  return L$1()({ ourProps: Vt, theirProps: ae, slot: Jt, defaultTag: rt, name: "Menu.Button" });
}
let at = "div", lt = O$3.RenderStrategy | O$3.Static;
function it(B, z) {
  var Y, ne;
  let ie = useId$1(), { id: oe = `headlessui-menu-items-${ie}`, anchor: se, portal: ae = !1, modal: ve = !0, transition: Pe = !1, ...le } = B, Ee = xe(se), [Je, Ce] = w("Menu.Items"), [_t, kt] = Re(Ee), Ct = be(), [Lt, Pt] = useState(null), Ft = y$4(z, Ee ? _t : null, o$4((vt) => Ce({ type: 8, element: vt })), Pt), Ut = n$1(Je.itemsElement);
  Ee && (ae = !0);
  let Jt = u$2(), [Vt, ir] = x$2(Pe, Lt, Jt !== null ? (Jt & i$3.Open) === i$3.Open : Je.menuState === 0);
  m$2(Vt, Je.buttonElement, () => {
    Ce({ type: 1 });
  });
  let jt = Je.__demoMode ? !1 : ve && Je.menuState === 0;
  f$5(jt, Ut);
  let Rt = Je.__demoMode ? !1 : ve && Je.menuState === 0;
  y$3(Rt, { allowed: useCallback(() => [Je.buttonElement, Je.itemsElement], [Je.buttonElement, Je.itemsElement]) });
  let Kt = Je.menuState !== 0, Bt = s$3(Kt, Je.buttonElement) ? !1 : Vt;
  useEffect(() => {
    let vt = Je.itemsElement;
    vt && Je.menuState === 0 && vt !== (Ut == null ? void 0 : Ut.activeElement) && vt.focus({ preventScroll: !0 });
  }, [Je.menuState, Je.itemsElement, Ut]), F(Je.menuState === 0, { container: Je.itemsElement, accept(vt) {
    return vt.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : vt.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(vt) {
    vt.setAttribute("role", "none");
  } });
  let Xe = p$2(), Ve = o$4((vt) => {
    var $t, Qe, xt;
    switch (Xe.dispose(), vt.key) {
      case o$3.Space:
        if (Je.searchQuery !== "") return vt.preventDefault(), vt.stopPropagation(), Ce({ type: 3, value: vt.key });
      case o$3.Enter:
        if (vt.preventDefault(), vt.stopPropagation(), Ce({ type: 1 }), Je.activeItemIndex !== null) {
          let { dataRef: bt } = Je.items[Je.activeItemIndex];
          (Qe = ($t = bt.current) == null ? void 0 : $t.domRef.current) == null || Qe.click();
        }
        G$1(Je.buttonElement);
        break;
      case o$3.ArrowDown:
        return vt.preventDefault(), vt.stopPropagation(), Ce({ type: 2, focus: c$1.Next });
      case o$3.ArrowUp:
        return vt.preventDefault(), vt.stopPropagation(), Ce({ type: 2, focus: c$1.Previous });
      case o$3.Home:
      case o$3.PageUp:
        return vt.preventDefault(), vt.stopPropagation(), Ce({ type: 2, focus: c$1.First });
      case o$3.End:
      case o$3.PageDown:
        return vt.preventDefault(), vt.stopPropagation(), Ce({ type: 2, focus: c$1.Last });
      case o$3.Escape:
        vt.preventDefault(), vt.stopPropagation(), flushSync(() => Ce({ type: 1 })), (xt = Je.buttonElement) == null || xt.focus({ preventScroll: !0 });
        break;
      case o$3.Tab:
        vt.preventDefault(), vt.stopPropagation(), flushSync(() => Ce({ type: 1 })), j$3(Je.buttonElement, vt.shiftKey ? F$1.Previous : F$1.Next);
        break;
      default:
        vt.key.length === 1 && (Ce({ type: 3, value: vt.key }), Xe.setTimeout(() => Ce({ type: 4 }), 350));
        break;
    }
  }), ge = o$4((vt) => {
    switch (vt.key) {
      case o$3.Space:
        vt.preventDefault();
        break;
    }
  }), Ke = useMemo(() => ({ open: Je.menuState === 0 }), [Je.menuState]), ht = _$2(Ee ? Ct() : {}, { "aria-activedescendant": Je.activeItemIndex === null || (Y = Je.items[Je.activeItemIndex]) == null ? void 0 : Y.id, "aria-labelledby": (ne = Je.buttonElement) == null ? void 0 : ne.id, id: oe, onKeyDown: Ve, onKeyUp: ge, role: "menu", tabIndex: Je.menuState === 0 ? 0 : void 0, ref: Ft, style: { ...le.style, ...kt, "--button-width": d$2(Je.buttonElement, !0).width }, ...R$2(ir) }), wt = L$1();
  return React__default.createElement(re$1, { enabled: ae ? B.static || Vt : !1 }, wt({ ourProps: ht, theirProps: le, slot: Ke, defaultTag: at, features: lt, visible: Bt, name: "Menu.Items" }));
}
let st = Fragment;
function ut(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-menu-item-${Y}`, disabled: ie = !1, ...oe } = B, [se, ae] = w("Menu.Item"), ve = se.activeItemIndex !== null ? se.items[se.activeItemIndex].id === ne : !1, Pe = useRef(null), le = y$4(z, Pe);
  n$3(() => {
    if (!se.__demoMode && se.menuState === 0 && ve && se.activationTrigger !== 0) return o$5().requestAnimationFrame(() => {
      var Bt, Xe;
      (Xe = (Bt = Pe.current) == null ? void 0 : Bt.scrollIntoView) == null || Xe.call(Bt, { block: "nearest" });
    });
  }, [se.__demoMode, Pe, ve, se.menuState, se.activationTrigger, se.activeItemIndex]);
  let Ee = s$2(Pe), Je = useRef({ disabled: ie, domRef: Pe, get textValue() {
    return Ee();
  } });
  n$3(() => {
    Je.current.disabled = ie;
  }, [Je, ie]), n$3(() => (ae({ type: 5, id: ne, dataRef: Je }), () => ae({ type: 6, id: ne })), [Je, ne]);
  let Ce = o$4(() => {
    ae({ type: 1 });
  }), _t = o$4((Bt) => {
    if (ie) return Bt.preventDefault();
    ae({ type: 1 }), G$1(se.buttonElement);
  }), kt = o$4(() => {
    if (ie) return ae({ type: 2, focus: c$1.Nothing });
    ae({ type: 2, focus: c$1.Specific, id: ne });
  }), Ct = u$3(), Lt = o$4((Bt) => {
    Ct.update(Bt), !ie && (ve || ae({ type: 2, focus: c$1.Specific, id: ne, trigger: 0 }));
  }), Pt = o$4((Bt) => {
    Ct.wasMoved(Bt) && (ie || ve || ae({ type: 2, focus: c$1.Specific, id: ne, trigger: 0 }));
  }), Ft = o$4((Bt) => {
    Ct.wasMoved(Bt) && (ie || ve && ae({ type: 2, focus: c$1.Nothing }));
  }), [Ut, Jt] = K$5(), [Vt, ir] = w$4(), jt = useMemo(() => ({ active: ve, focus: ve, disabled: ie, close: Ce }), [ve, ie, Ce]), Rt = { id: ne, ref: le, role: "menuitem", tabIndex: ie === !0 ? void 0 : -1, "aria-disabled": ie === !0 ? !0 : void 0, "aria-labelledby": Ut, "aria-describedby": Vt, disabled: void 0, onClick: _t, onFocus: kt, onPointerEnter: Lt, onMouseEnter: Lt, onPointerMove: Pt, onMouseMove: Pt, onPointerLeave: Ft, onMouseLeave: Ft }, Kt = L$1();
  return React__default.createElement(Jt, null, React__default.createElement(ir, null, Kt({ ourProps: Rt, theirProps: oe, slot: jt, defaultTag: st, name: "Menu.Item" })));
}
let pt = "div";
function mt(B, z) {
  let [Y, ne] = K$5(), ie = B, oe = { ref: z, "aria-labelledby": Y, role: "group" }, se = L$1();
  return React__default.createElement(ne, null, se({ ourProps: oe, theirProps: ie, slot: {}, defaultTag: pt, name: "Menu.Section" }));
}
let dt = "header";
function ct(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-menu-heading-${Y}`, ...ie } = B, oe = P$1();
  n$3(() => oe.register(ne), [ne, oe.register]);
  let se = { id: ne, ref: z, role: "presentation", ...oe.props };
  return L$1()({ ourProps: se, theirProps: ie, slot: {}, defaultTag: dt, name: "Menu.Heading" });
}
let ft$2 = "div";
function Tt(B, z) {
  let Y = B, ne = { ref: z, role: "separator" };
  return L$1()({ ourProps: ne, theirProps: Y, slot: {}, defaultTag: ft$2, name: "Menu.Separator" });
}
let yt = K$6(nt), It = K$6(ot), gt = K$6(it), Et = K$6(ut), Mt = K$6(mt), St = K$6(ct), At = K$6(Tt), rn = Object.assign(yt, { Button: It, Items: gt, Item: Et, Section: Mt, Heading: St, Separator: At });
const ChevronDownIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5%207.5L10%2012.5L15%207.5'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LeatherWalletIcon = "data:image/svg+xml,%3csvg%20width='41'%20height='40'%20viewBox='0%200%2041%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20x='0.5'%20width='40'%20height='40'%20rx='20'%20fill='url(%23pattern0)'/%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_21497_326778'%20transform='translate(-0.00625)%20scale(0.0125)'/%3e%3c/pattern%3e%3cimage%20id='image0_21497_326778'%20width='81'%20height='80'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFEAAABQCAYAAABh05mTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAi3SURBVHgB7Z1dbBRVFMfPLJVuE1lGFNOENi5v2sbY8kIbEymJtJiYSIVq9AEKrQm+0A+Q+KBpqz5ppIU3Ywvti4kWktaYQFsTi4nZ8sTyQH3TIa0JD0Km2wQWkB3Pf3Zms/Oxu7Mfszvb7i9Zdjt7Zzfz33PuOffcOxeBSowoisEtRG0KUZAo9pJAQjD+mkTtkYzED1lQH0I4RnTHRxR+lh+SLMtUIgQqMkFWbZ3okEKxffz1h8gqVK6EfSQs8vPsv7K8SEWkKCJqwrURKX2K+uw6kkDKokC+qWII6qqIEC9CsT7+mn4qnMVlCwsqjNyT5UlyCVdE9Ih4ZlwTs+Ai7hADEG+YvCOeGYg5wGLOUIEomIg7RbHpKSmX+GUTlQHcZ04+Q76Ru7IsUZ4URETN+sao/JA4oh/PN/hsoTxA37fFX32VBTxJ5YnI2UJ3jb+aHkYfXaccydkSazlJfkzKbxRPjMseFmJmG1tlLkl7TiJq/R8E9GrwyJXwVhI6s+0nsxZxAwuoI7GQ+7MRMisRN4GAOlKAhGanru0jh6AP3CQCgmCErxWB00ljR9E5KYjU0uahlq+5lqP2bKaGjkTc6q+GgC/TpkNoqvHXrD2MRpfStcrozpxID1GZjELcQRl9QRTb0rVIG1i0QHKTKqQNNGnd2e+vDtHmCCSZEJ+Q4n8QfTRn92ZKd9bcOEgVVGJc1kvl1rburEXjv6mCARZr8Z68tt983NYSnxANUQULmNqws0aLJVasMD121mixxIoVpsfOGg2WWI5W2NrSQu3tb9LBjnaqq6tTj4WWlmj68hWanr5CbmC2RoOIz4titxIv8XueQCBA5779mjra21O2mb58mQZPnyU34Gi9W9YqPYY8kSu8ENDz42NY3M8zV2hPc3Pado0NDRSJROjmzTAVGp7swnBwMf5ao5SuPDT0OR1sP2A41vHW26oAZiDg9I8/JFw3E/iMxlddGbVK9+W13XiRCCyPiQ5RCYBb9p44roqiP0JLN2wFBHBhOwHRD45PXKLV1VXL59fXOxM8S1ApU3+dKv0ITyG+o1DxaW3Zazk2N79g27an54QaSJKB2L0fnVRFBMvLyyz0N1QMfPElMWHVEllRsUhrZCw0cL9lZnVl1XIM1td7otty/L33P0wICAKB7ZY2a2v2Vp0vMDw8qyJWlbDUZeeakXXrRQ/2n7K0HRn5km6z5SV/Vm9Pt6EN3DtV15AviqabKmLMY/XCul1WYVtbjW4MccYvGrOx4aHPLEKPT0ySi8CJg6qIHKL3UYlYXv7Tcqyr613j30cOW8Q5N3Yh8RrvXbv6iyVnhNDIFd2Ec8QmLTorJasZLie5o07XkSPUwxE78XfXYcP7qjjTcXEQbOZYwEabvhUBxy1X1sGqXjXZrvH7h6lExVcI0tq6l+pNltbWto9Tk13xFIiFSmaFz9n54k6a+P47tr4DVF1dbflcjFQWr+e8MiQLlLtqsr1D3F6K7CYB0pafOIEuBOaUx20UEma3oGdkJT+lEgJrXI+ss/W9QfkA4Y4ePW6I2G7jI+GuEI8u3qjcIDDYRdhMQLzR0QtFsz4TkqdE1EFgGRw4lVZMWO+1uQWa59FNicTT8aaIOoP9fTQw0Gc8duYTmmPx3I66WSBVkYdpaHzF8DeEc6vQmgey4wVNpcBcbAiFbpDX4LqiXIXqLKc4VEyQE7Zw9Ubv89C/ra7+Y+jbICByxGTmFhbIi+juLFERJuohzAAHDLOF6UDMc2Pn1T6v3VSkBUuhkgaQVNzSk22st3G1CIEAgUDhBL2wmhydkfsd5Gq39xBGtD5RuEUuggKCUwGBXuFOJuTACmHhK3f+MjxSWX2hYCsM6+6MmZxj5BKDA1YBEWkxDQDq6nbZFhCSmZ//lbzIUz3FwT3DMXIHWILZqlCBGf7iK0OuhzawVnPFRsdJXmhXJXc5n+S4LMenB/6LW6IrtNjMoUxcnLRcHPpBNZFOMb+CAkWHTbBJxlzVBm6Oo3HjOp5VESEnZvXJBSJcWDBjJyzSGUydphIK749z6QuzffU2w0EELks/6vJwkEtf6nruxLzzDlEc5sMFX4eTqsyFC0TyHAhso8bGhqwDAM6/fTtuZanOHzxzNlG8dYMYCc1w54SIbo6hQ3/8nnVlRj2Phco1uqrF3tfzK61lwDp5j5GLWy6dy3qY0dHz6nQohDBPyGcC7XGum3B/mLg1w7QWpwbKtlGBwUVhQmrPnibLUM4MrO80i45VXQABaOLiJXVY2MgFiUznI5CgMLuSpfDZwq78QTQaVRfCG1aFocqtubQr8y1waSyBw1I45IUQBCLhgtE/OqkNotaI2UD9fIAfCTknKjzFqC2yFS7ek2X7pXWAA8wYdg2hCilhETuTtz+wiOjlIq1HSAQUHUs9Mb5wUZiiCrZgRxPrMRs0a0Rlp3IjkBGLFQLbO6oQdThS11CJVop5FSTXekROxpf6BMLuIhJVUGE3Pi+nuBs/pYgYT2O7E6oAJC55Dad6M+0Nkg+iUYnd+jl+6W5l0+OwG++X0+wJkXG2774s97s1HCwPhBEUGdK1cDRl+jTu1hJtMtAPshENZ27nkE2Y9oQ1N864I4njyXv0CfhQvKSND66104mAIOvNhXDvhm+Dby6UKZCYyXoZCTpZzSIl2niEsxUQ5LQWZyMKyUFkKhcBQc5b/2H4U+2vmfXFV04EqawRRpDK8TVFKQfy2j8RQj6MPprihBx9axuVH9iEsjPffWZz2vrPDi0FKpv9FJEDYijnNAKn/6wCw5Xxfq0yHiRvgk3NBwq5/3Ze7mwH9tVCX8m/NMbcXrrdTd3VmOuBH6MmQAWk4JaYjHbfGywTd2MGqQQI8a30p8pus3I7sL8Ei3msSLcEy5ji4B9wpuy3zbdD/18vYmydQkHTI3Vx0fViCWf4ZioxmqhNivpQXvOp2zYLQe2mTdPQUpDwL7cLC6SwtfluYVkgVrUVIsrmyv91DJTKn0hYjQAAAABJRU5ErkJggg=='/%3e%3c/defs%3e%3c/svg%3e", LogoutIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.5%2017.5H4.16667C3.72464%2017.5%203.30072%2017.3244%202.98816%2017.0118C2.67559%2016.6993%202.5%2016.2754%202.5%2015.8333V4.16667C2.5%203.72464%202.67559%203.30072%202.98816%202.98816C3.30072%202.67559%203.72464%202.5%204.16667%202.5H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.333%2014.1667L17.4997%2010L13.333%205.83337'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M17.5%2010H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", MagicEdenWalletIcon = "data:image/svg+xml,%3csvg%20width='25'%20height='24'%20viewBox='0%200%2025%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20x='0.423462'%20width='24'%20height='24'%20rx='12'%20fill='%231C1326'/%3e%3cpath%20d='M15.6787%209.69931L16.5929%2010.7735C16.6976%2010.8942%2016.7904%2010.9934%2016.8279%2011.0499C17.1013%2011.3216%2017.2546%2011.6889%2017.2544%2012.0716C17.2288%2012.523%2016.9345%2012.8305%2016.662%2013.1594L16.0222%2013.9106L15.6885%2014.2998C15.6765%2014.3132%2015.6688%2014.3298%2015.6663%2014.3475C15.6638%2014.3652%2015.6666%2014.3832%2015.6743%2014.3993C15.6821%2014.4155%2015.6945%2014.429%2015.71%2014.4383C15.7255%2014.4476%2015.7434%2014.4522%2015.7616%2014.4515H19.0968C19.6062%2014.4515%2020.248%2014.8797%2020.2105%2015.5297C20.2095%2015.8251%2020.0899%2016.1081%2019.8779%2016.317C19.6659%2016.5259%2019.3788%2016.6437%2019.079%2016.6447H13.856C13.5124%2016.6447%2012.5883%2016.6817%2012.3296%2015.8936C12.2746%2015.7289%2012.2671%2015.5524%2012.3079%2015.3837C12.3831%2015.1343%2012.502%2014.8998%2012.6594%2014.6909C12.922%2014.3017%2013.2064%2013.9125%2013.4868%2013.535C13.8481%2013.0407%2014.2194%2012.5619%2014.5847%2012.0579C14.5977%2012.0415%2014.6047%2012.0213%2014.6047%2012.0005C14.6047%2011.9797%2014.5977%2011.9595%2014.5847%2011.9431L13.2577%2010.3863C13.2491%2010.375%2013.2379%2010.3658%2013.225%2010.3595C13.2122%2010.3532%2013.198%2010.3499%2013.1836%2010.3499C13.1693%2010.3499%2013.1551%2010.3532%2013.1423%2010.3595C13.1295%2010.3658%2013.1182%2010.375%2013.1096%2010.3863C12.7542%2010.8591%2011.1982%2012.9531%2010.8664%2013.3773C10.5346%2013.8016%209.71714%2013.8249%209.26493%2013.3773L7.18959%2011.3243C7.17633%2011.3112%207.1594%2011.3022%207.14103%2011.2986C7.12261%2011.295%207.10348%2011.2968%207.08614%2011.3039C7.06879%2011.311%207.05398%2011.323%207.04358%2011.3384C7.03317%2011.3538%207.02764%2011.3719%207.02768%2011.3904V15.3389C7.03256%2015.6192%206.94837%2015.8938%206.78689%2016.1245C6.6254%2016.3552%206.39473%2016.5303%206.12722%2016.6253C5.95626%2016.6839%205.77359%2016.7014%205.59439%2016.6763C5.41518%2016.6513%205.24465%2016.5843%205.09704%2016.4811C4.94943%2016.3779%204.82898%2016.2414%204.74575%2016.083C4.66252%2015.9246%204.61892%2015.7489%204.61859%2015.5705V8.47138C4.63049%208.21553%204.7239%207.96991%204.88554%207.76938C5.04719%207.56885%205.26884%207.42363%205.51901%207.35435C5.73365%207.298%205.95954%207.29856%206.17386%207.35599C6.38817%207.41341%206.58326%207.52563%206.73936%207.6813L9.93042%2010.83C9.93998%2010.8395%209.95151%2010.8469%209.96431%2010.8516C9.97706%2010.8562%209.9907%2010.8581%2010.0043%2010.857C10.0178%2010.8559%2010.031%2010.8518%2010.0428%2010.8451C10.0546%2010.8385%2010.0648%2010.8293%2010.0726%2010.8183L12.3395%207.72606C12.4442%207.60053%2012.5756%207.49905%2012.7243%207.42883C12.873%207.35856%2013.0355%207.32121%2013.2005%207.31933H19.0968C19.2581%207.31956%2019.4176%207.35378%2019.5644%207.41969C19.7113%207.48555%2019.8422%207.5816%2019.9484%207.70131C20.0546%207.82108%2020.1336%207.9618%2020.1802%208.11405C20.2267%208.2663%2020.2397%208.42661%2020.2184%208.58425C20.1768%208.85767%2020.0361%209.107%2019.8222%209.28592C19.6083%209.46485%2019.3358%209.56127%2019.0553%209.55728H15.7537C15.7371%209.55766%2015.7209%209.56244%2015.7068%209.57111C15.6928%209.57974%2015.6813%209.59197%2015.6736%209.60645C15.666%209.62099%2015.6624%209.63725%2015.6632%209.65356C15.6641%209.66992%2015.6695%209.68572%2015.6787%209.69931Z'%20fill='url(%23paint0_radial_6204_5907)'/%3e%3cdefs%3e%3cradialGradient%20id='paint0_radial_6204_5907'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(4.66396%207.31249)%20rotate(31.8526)%20scale(18.4306%2015.0426)'%3e%3cstop%20stop-color='%237500EB'/%3e%3cstop%20offset='0.48642'%20stop-color='%23E42575'/%3e%3cstop%20offset='0.791667'%20stop-color='%23E42575'/%3e%3cstop%20offset='1'%20stop-color='%23FF6914'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", OKXWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cg%20clip-path='url(%23clip0_6327_5988)'%3e%3crect%20width='24'%20height='24'%20rx='12'%20fill='black'/%3e%3crect%20x='5.37042'%20y='5.10571'%20width='14.1245'%20height='14.3972'%20fill='url(%23pattern0)'/%3e%3c/g%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_6327_5988'%20transform='matrix(0.00331001%200%200%200.00324732%20-0.161%20-0.168981)'/%3e%3c/pattern%3e%3cclipPath%20id='clip0_6327_5988'%3e%3crect%20width='24'%20height='24'%20fill='white'/%3e%3c/clipPath%3e%3cimage%20id='image0_6327_5988'%20width='399'%20height='399'%20xlink:href='data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gKgSUNDX1BST0ZJTEUAAQEAAAKQbGNtcwQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwQVBQTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLWxjbXMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkZXNjAAABCAAAADhjcHJ0AAABQAAAAE53dHB0AAABkAAAABRjaGFkAAABpAAAACxyWFlaAAAB0AAAABRiWFlaAAAB5AAAABRnWFlaAAAB+AAAABRyVFJDAAACDAAAACBnVFJDAAACLAAAACBiVFJDAAACTAAAACBjaHJtAAACbAAAACRtbHVjAAAAAAAAAAEAAAAMZW5VUwAAABwAAAAcAHMAUgBHAEIAIABiAHUAaQBsAHQALQBpAG4AAG1sdWMAAAAAAAAAAQAAAAxlblVTAAAAMgAAABwATgBvACAAYwBvAHAAeQByAGkAZwBoAHQALAAgAHUAcwBlACAAZgByAGUAZQBsAHkAAAAAWFlaIAAAAAAAAPbWAAEAAAAA0y1zZjMyAAAAAAABDEoAAAXj///zKgAAB5sAAP2H///7ov///aMAAAPYAADAlFhZWiAAAAAAAABvlAAAOO4AAAOQWFlaIAAAAAAAACSdAAAPgwAAtr5YWVogAAAAAAAAYqUAALeQAAAY3nBhcmEAAAAAAAMAAAACZmYAAPKnAAANWQAAE9AAAApbcGFyYQAAAAAAAwAAAAJmZgAA8qcAAA1ZAAAT0AAACltwYXJhAAAAAAADAAAAAmZmAADypwAADVkAABPQAAAKW2Nocm0AAAAAAAMAAAAAo9cAAFR7AABMzQAAmZoAACZmAAAPXP/bAEMABQMEBAQDBQQEBAUFBQYHDAgHBwcHDwsLCQwRDxISEQ8RERMWHBcTFBoVEREYIRgaHR0fHx8TFyIkIh4kHB4fHv/bAEMBBQUFBwYHDggIDh4UERQeHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHv/CABEIAY8BjwMBIgACEQEDEQH/xAAbAAEBAQEBAQEBAAAAAAAAAAAACAYHBQECBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf2K5JLV2JEV2JEV2JE+V4IzbnDAAAA2Jnf1XYkRXYkRXYkRXYkD+KxpMPMAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyHXgAAABO/O+hc9AAAG6wu5KTAAAAk2spMPGAAAAAAAAAA3OGHRHOx0RzsdEc7HRPnPB1TauhnPHQxzx0Mc8dDHPMd3TDHLf3zsdEc7HRHOx0RzsbvDfkAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAADYGPboYVuhhW6GFbr4dQ6Hwvdm5YYblhhuWGG5wzEnIm4/RhW6GFboYVuhhWyxoAAAAAAAAAB/fXsiV2AAAATpz7onOwAABuMPuikgAAAJLrSTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAf21zHPqFcJNFZJNFZJNFZJN+Gjwf34AAANljRZiS/0Vkk0Vkk0Vkk0VdJjygAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8QAJRAAAAMIAwEBAQEAAAAAAAAAAAUwAQIDBAYWNTYHFEAVUIAR/9oACAEBAAEFAv7/AIUtMRXelOjpTo6U6OlOjpTo6U6OlOh6Tm3WJOyk0870p0dKdHSnR0p0dKdHSnR0p0RZaZhO+WUhsizcGE5BhIVtLwpc+QpCBCmD9CI45EcNITsAy8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+Qvax2fRr5rG1AhQ7WMqNE7ax458spVBvLwLwOBeBwLwOBeBwLwOBeBwLwOA2rzj/KaJGHbLPJxZ5OLPJxZ5OLPJxZ5OLPJxZ5OKlIHCiC5Vxwx28DgXgcC8DgXgcC8DgXgcC8DgTFVG8aF7+P9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/fK04bzMG1DsWodi1DsWodi1DsWodi1DsNpU6YylTuEUOXWSC6yQXWSC6yQXWSC6yQXWSC6yQVSfwDKVdpY7ay1DsWodi1DsWodi1DsWodi1DsTFNHMCF5ZB1j88jXzrGVAhRDrHqjROXWOHHkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vySb7IU5DfciOIVxGhxj9Cjo0OBUKDWsdYaxHYxp5YM/PQHPrGg+saD6xoPrGg+saD6xoPrGgeNDJ5iThmZOu/WNB9Y0H1jQfWNB9Y0H1jQfWNBGMJ+ND/v8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAwEBPwEcf//EABQRAQAAAAAAAAAAAAAAAAAAAJD/2gAIAQIBAT8BHH//xAA5EAABAQUDCQcCBQUAAAAAAAACAQADBDCTETSyNUBEcnN0g5KxBRITITFQUUFhFDJxkaFCY4CBkP/aAAgBAQAGPwL/AD/tduHpp8iKq10iKatdIimrXSIpq10iKatdIimrXSIpq10iKat3ihX6Js1loQwr5UX0VAVrpEU1a6RFNWukRTVrpEU1a6RFNWukRTVrpEU1bvPHD0B+SBUzZy6L0M0FWF06FAAUsRE+kl4jkEBDFDVE+ZMOD4UIUtKxfsklQMUISSxUX6tFOHf5Hb4hT/S5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw6qtiI9HrKWxfR0NsmHtX1QsMqNJPRYg8S5sLlHoPEHyRTG1W0fkbR+RtH5G0fkbR+RtH5G0fkb1cJw2e9odovnhIp2eS+ZL8tpHO2kc7aRztpHO2kc7aRztpHO2kc7B2j2c+eD4Zpair5p90ZEUnJfdXbaPyNo/I2j8jaPyNo/I2j8jaPyMTvxQd976gNi+wcUpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxe08UpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxewI9CEsEvTvEiNdwqC13CoLXcKgtdwqC13CoLXcKgtdwqC1v4YV4gs97O7RA3dhqqLZ6L8KjXg6ZNeDpk14OmTXg6ZNeDpk14OmTXg6ZNeDpkw9n9ngb3xCS1e7/AAjW/hRT9XgtdwqC13CoLXcKgtdwqC13CoLXcKgtdwqCxPChbRHzXukirmzgS80V4KL+8olRLLXYqsmHtS2xCX+JUaApYiRBonNmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5q5eF6AaEv7shgSEJJaip9ZLzwyQu4CAtnzJhyekgito2r90kqqrYiNFvna2gb4yH9FXNu45jYh0PwD1URspRlcmylGVybKUZXJspRlcmylGVybKUZXJspRlcmsLtGLVF/vFLQQ7QixFPREfE2UoyuTZSjK5NlKMrk2UoyuTZSjK5NlKMrk2UoyuTeG+jol4K/wBJPVVP+AH/xAAoEAABAgUDBAIDAQAAAAAAAAABAPARMFFxwSFAYTFBUKGBsYCR0ZD/2gAIAQEAAT8h/P8A4J2T0nVhOrCdWE6sJ1YTqwnVhEoL6kgA9S9fFxED6TqwnVhOrCdWE6sJ1YTqwuEdA9jbRoBAyhMFC+2bQJIclZQALr9Rk6bVK0JIRH5kwD3GiAPYoPBFlygbVzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwBHCEmmiUMQEiBQ6mSNoEGLxSimxIg7YGgrRYL9/lczbrmbdczbrmbdczbrmbdczbowgDT0I6P2UWbMNLqCRprCC4m2XE2y4m2XE2y4m2XE2y4m2XE2y6tWBFjoS8NOUVDDlH9LmbdczbrmbdczbrmbdczbrmbdQuIIHQvB7I6mJ37q0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPAFnDRj0isCYp1ZTqynVlOrKdWU6sp1ZR5onYf2QiPHWTpA9R2TqwnVhOrCdWE6sJ1YTqwnVhFzcVkIwOgOpMUNaj2ivtOrKdWU6sp1ZTqynVlOrKhN5o6FgYn42wJoOKghKBzI5Hc6j6AkwooGiOhjlDhBpQAtq50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4EeP4sAFRD3GiAPcSYbaa6hB1HuTTmpESAe5IywESSYABR8BqpJG2FRr/ACYFNzKbmU3MpuZTcym5lNzKJes4Ew+5egkAAA9puZTcym5lNzKbmU3MpuZRl1HFb4J/wA//2gAMAwEAAgADAAAAEPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPNPPPPNPPPOPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPHPPPOPPPPPPPPPPPPPPPLDDDDHPPPOLDDDLPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPMMMNOMMMJMMMMPPPPPPPPPPPPPPPPNPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPGPPPPNPPPPPPPPJPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP/xAAUEQEAAAAAAAAAAAAAAAAAAACQ/9oACAEDAQE/EBx//8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAgEBPxAcf//EACYQAQABAwQBBQEBAQEAAAAAAAERACExMFDw8UFAUWFxgZGhgJD/2gAIAQEAAT8Q/wC/7iwi5HtITQrVq1atWrCYGTo91YGmFR4LPuJBNCtWrVq1ashDEGcXFwPTMgkmUNR+NBDFHgkAGjGQMElGBYlk+V0Z5/JGGs5ADHmL2oAINBHwCRqEGyJkowgOspMT9B689m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m532jVRKGE+AMr9aRbEZ5iB/Ef3REhc/ylj/ADSBSf8AhFB/npgQrBGWBKMPeT812GvYa9hr2GvYa9hr2Gpvwi7fIkP6NGdVgHBWMCAAY8AD0GvQa9Br0GvQa9Br0GvQaoA4tpWaDaBQ+Uxag7pCD7WQfwrsNew17DXsNew17DXsNVC+nwRDKqvkhPCUlElbq+vxc7blW4udtyrcXO25VuLnbcq3FztuVbi523Ktxc7blW4udtprQPDZ/YhgPiQnJbQq1atWrVqnZQW6PwSalFaSYDLLyEHLNodGrVq1atWrVYBaqOR+8hLB7EzZWRExA+wcaFWrVq1atUQqIDAlRkHwX0xHUpwCT9KACDROYeHikfmB+aPkbIkEb9njSCi7bBED6D157NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvtGqigkRZmQf4UD4BI1IhZEw6MktLQEshaSx9kTJowshWgFKuJQfbotXweCJVWwBlr5etjM/RPTY2XGH0I86AMGDBgwYMKoQ8D2Ri0qsukbFYO/sAQNAGDBgwYMH/q6K5SP8/8AP/Z'/%3e%3c/defs%3e%3c/svg%3e", UnisatWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.8742%204.5804L18.5392%208.15088C18.8511%208.45416%2019.0047%208.76103%2018.9999%209.07026C18.995%209.3795%2018.8608%209.66136%2018.5984%209.91707C18.3239%2010.1847%2018.0277%2010.3203%2017.7109%2010.3262C17.3941%2010.331%2017.0797%2010.1811%2016.7677%209.87785L13.0193%206.22648C12.5937%205.8114%2012.1825%205.51762%2011.7872%205.34516C11.3917%205.1727%2010.9758%205.14535%2010.5405%205.26428C10.104%205.38203%209.63603%205.68532%209.13422%206.17295C8.44258%206.84733%208.11246%207.48007%208.14634%208.0712C8.18018%208.6623%208.52358%209.27602%209.17534%209.90996L12.954%2013.5922C13.2696%2013.8991%2013.4244%2014.2059%2013.4195%2014.5104C13.4147%2014.8161%2013.2793%2015.098%2013.012%2015.3584C12.746%2015.6177%2012.4522%2015.7533%2012.133%2015.764C11.8137%2015.7747%2011.4957%2015.6261%2011.1813%2015.3192L7.51634%2011.7487C6.92022%2011.1683%206.48975%2010.6188%206.22495%2010.1002C5.96014%209.58168%205.86099%208.99533%205.92991%208.34118C5.99158%207.78099%206.17416%207.23864%206.47887%206.71294C6.78237%206.18723%207.21768%205.64964%207.78237%205.09896C8.45466%204.44362%209.09673%203.94171%209.70858%203.59203C10.3192%203.24236%2010.9105%203.04849%2011.4812%203.00806C12.0532%202.96762%2012.6166%203.07942%2013.1741%203.34346C13.7315%203.6075%2014.2974%204.01902%2014.873%204.5804H14.8742Z'%20fill='url(%23paint0_linear_4212_6487)'/%3e%3cpath%20d='M9.12459%2018.9872L5.46081%2015.4167C5.14884%2015.1122%204.99527%2014.8066%205.00011%2014.4973C5.00495%2014.1881%205.13917%2013.9062%205.40156%2013.6505C5.67604%2013.3829%205.97229%2013.2473%206.28909%2013.2414C6.60589%2013.2366%206.92028%2013.3853%207.23225%2013.6897L10.9795%2017.3411C11.4063%2017.7562%2011.8162%2018.05%2012.2116%2018.2224C12.607%2018.3949%2013.023%2018.421%2013.4595%2018.3033C13.896%2018.1856%2014.3639%2017.8823%2014.8657%2017.3934C15.5574%2016.7191%2015.8875%2016.0863%2015.8537%2015.4952C15.8198%2014.9041%2015.4764%2014.2904%2014.8247%2013.6553L12.8114%2011.7106C12.4958%2011.4038%2012.341%2011.0969%2012.3458%2010.7925C12.3507%2010.4868%2012.4861%2010.2049%2012.7533%209.94445C13.0194%209.68514%2013.3132%209.54957%2013.6324%209.53887C13.9516%209.52816%2014.2696%209.67682%2014.584%209.9837L16.4824%2011.8165C17.0785%2012.3969%2017.509%2012.9464%2017.7738%2013.465C18.0386%2013.9835%2018.1378%2014.5699%2018.0688%2015.224C18.0072%2015.7842%2017.8246%2016.3266%2017.5199%2016.8523C17.2164%2017.378%2016.7811%2017.9156%2016.2164%2018.4663C15.5441%2019.1216%2014.902%2019.6235%2014.2902%2019.9732C13.6783%2020.3229%2013.0871%2020.5179%2012.5151%2020.5583C11.9432%2020.5988%2011.3797%2020.487%2010.8223%2020.2229C10.2648%2019.9589%209.69894%2019.5474%209.12338%2018.986L9.12459%2018.9872Z'%20fill='url(%23paint1_linear_4212_6487)'/%3e%3cpath%20d='M11.4098%209.77448C12.153%209.77448%2012.7556%209.18182%2012.7556%208.4507C12.7556%207.71962%2012.153%207.12695%2011.4098%207.12695C10.6665%207.12695%2010.064%207.71962%2010.064%208.4507C10.064%209.18182%2010.6665%209.77448%2011.4098%209.77448Z'%20fill='url(%23paint2_radial_4212_6487)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_4212_6487'%20x1='17.9364'%20y1='6.66057'%20x2='6.64095'%20y2='11.7639'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23201C1B'/%3e%3cstop%20offset='0.36'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4B852'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_4212_6487'%20x1='6.3763'%20y1='17.0541'%20x2='19.5023'%20y2='13.0825'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231F1D1C'/%3e%3cstop%20offset='0.37'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4FB52'/%3e%3c/linearGradient%3e%3cradialGradient%20id='paint2_radial_4212_6487'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(11.4098%208.45191)%20scale(1.34581%201.32377)'%3e%3cstop%20stop-color='%23F4B852'/%3e%3cstop%20offset='0.33'%20stop-color='%23EA8101'/%3e%3cstop%20offset='0.64'%20stop-color='%2377390D'/%3e%3cstop%20offset='1'%20stop-color='%23211C1D'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", XverseWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M19.4283%2019.185V16.4677C19.4283%2016.36%2019.3855%2016.2572%2019.3092%2016.1809L7.74741%204.61916C7.67106%204.54281%207.56829%204.5%207.46055%204.5H4.74332C4.60917%204.5%204.5%204.60917%204.5%204.74332V7.26787C4.5%207.37562%204.54281%207.47837%204.61916%207.55472L8.76923%2011.7047C8.86412%2011.7997%208.86412%2011.9538%208.76923%2012.0487L4.57136%2016.2465C4.52569%2016.2922%204.5%2016.3543%204.5%2016.4185V19.185C4.5%2019.319%204.60917%2019.4283%204.74332%2019.4283H9.28369C9.41784%2019.4283%209.527%2019.319%209.527%2019.185V17.5552C9.527%2017.491%209.55271%2017.4289%209.59838%2017.3832L11.8504%2015.1312C11.9453%2015.0363%2012.0994%2015.0363%2012.1943%2015.1312L16.3729%2019.3099C16.4492%2019.3862%2016.552%2019.429%2016.6597%2019.429H19.1843C19.3185%2019.429%2019.4276%2019.3198%2019.4276%2019.1857L19.4283%2019.185Z'%20fill='white'/%3e%3cpath%20d='M13.372%208.09816H15.6461C15.781%208.09816%2015.8909%208.20805%2015.8909%208.34292V10.617C15.8909%2010.8353%2016.1549%2010.9445%2016.309%2010.7897L19.4287%207.66505C19.4743%207.61937%2019.5001%207.5573%2019.5001%207.49236V4.75588C19.5001%204.62102%2019.3908%204.51114%2019.2553%204.51114L16.4781%204.50757C16.4132%204.50757%2016.3511%204.53326%2016.3047%204.57892L13.1986%207.68003C13.0445%207.83415%2013.1537%208.09816%2013.3713%208.09816H13.372Z'%20fill='%23EE7A30'/%3e%3c/svg%3e";
function truncateMiddle(B, z = 4, Y = 5) {
  if (B.length <= z + Y)
    return B;
  const ne = B.slice(0, z), ie = B.slice(B.length - Y);
  return `${ne}...${ie}`;
}
const WALLET_TO_ICON = {
  [Wallet.MAGICEDEN]: MagicEdenWalletIcon,
  [Wallet.UNISAT]: UnisatWalletIcon,
  [Wallet.XVERSE]: XverseWalletIcon,
  [Wallet.LEATHER]: LeatherWalletIcon,
  [Wallet.OKX]: OKXWalletIcon
}, NETWORK_DISPLAY_NAME = {
  [Network.MAINNET]: "Mainnet",
  [Network.TESTNET]: "Testnet",
  [Network.SIGNET]: "Signet"
};
function PostConnectButton({
  address: B,
  network: z,
  onViewProfile: Y,
  onChangeWallet: ne,
  onDisconnectWallet: ie,
  renderAvatar: oe
}) {
  const { wallet: se } = useOrdConnect();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    rn,
    {
      as: "section",
      className: "ord-connect-font ord-wallet-connected-container relative inline-block text-left",
      children: ({ open: ae }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(rn.Button, { className: "ord-wallet-connected-button", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-identifier-container", children: [
            oe ? oe(B, "large") : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Avatar,
              {
                size: 28,
                variant: "beam",
                name: B,
                colors: ["#1C2DCB", "#F226B8"]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: WALLET_TO_ICON[se],
                alt: `${se} is connected`
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "address-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "address", children: truncateMiddle(B) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "network-container", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-indicator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "network", children: NETWORK_DISPLAY_NAME[z] ?? z })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: ChevronDownIcon,
              className: `dropdown-button ${ae ? "close-dropdown-button" : "expand-dropdown-button"}`,
              alt: ""
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ze$1,
          {
            as: Fragment,
            enter: "transition ease-out duration-100",
            enterFrom: "transform opacity-0 scale-95",
            enterTo: "transform opacity-100 scale-100",
            leave: "transition ease-in duration-75",
            leaveFrom: "transform opacity-100 scale-100",
            leaveTo: "transform opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(rn.Items, { className: "ord-wallet-connection-dropdown", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                rn.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => Y == null ? void 0 : Y(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "View profile" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: truncateMiddle(B) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                rn.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => ne == null ? void 0 : ne(),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "change-wallet-label", children: "Change wallet" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                rn.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => ie == null ? void 0 : ie(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Disconnect wallet" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: LogoutIcon, className: "logout-icon", alt: "" })
                  ]
                }
              )
            ] })
          }
        )
      ] })
    }
  );
}
function PreConnectButton({
  openModal: B,
  disabled: z
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      onClick: B,
      disabled: z,
      "data-testid": "connect-wallet-button",
      className: "ord-connect-font ord-connect-wallet-button",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {})
    }
  );
}
const CloseModalIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M12%2022C17.5228%2022%2022%2017.5228%2022%2012C22%206.47715%2017.5228%202%2012%202C6.47715%202%202%206.47715%202%2012C2%2017.5228%206.47715%2022%2012%2022Z'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M15%209L9%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M9%209L15%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e";
function isMobileUserAgent() {
  return typeof window > "u" ? !1 : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
    window.navigator.userAgent
  );
}
var buffer$1 = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength$1;
base64Js$1.toByteArray = toByteArray$1;
base64Js$1.fromByteArray = fromByteArray$1;
var lookup$1 = [], revLookup$1 = [], Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len$1 = code$1.length; i$2 < len$1; ++i$2)
  lookup$1[i$2] = code$1[i$2], revLookup$1[code$1.charCodeAt(i$2)] = i$2;
revLookup$1[45] = 62;
revLookup$1[95] = 63;
function getLens$1(B) {
  var z = B.length;
  if (z % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var Y = B.indexOf("=");
  Y === -1 && (Y = z);
  var ne = Y === z ? 0 : 4 - Y % 4;
  return [Y, ne];
}
function byteLength$1(B) {
  var z = getLens$1(B), Y = z[0], ne = z[1];
  return (Y + ne) * 3 / 4 - ne;
}
function _byteLength$1(B, z, Y) {
  return (z + Y) * 3 / 4 - Y;
}
function toByteArray$1(B) {
  var z, Y = getLens$1(B), ne = Y[0], ie = Y[1], oe = new Arr$1(_byteLength$1(B, ne, ie)), se = 0, ae = ie > 0 ? ne - 4 : ne, ve;
  for (ve = 0; ve < ae; ve += 4)
    z = revLookup$1[B.charCodeAt(ve)] << 18 | revLookup$1[B.charCodeAt(ve + 1)] << 12 | revLookup$1[B.charCodeAt(ve + 2)] << 6 | revLookup$1[B.charCodeAt(ve + 3)], oe[se++] = z >> 16 & 255, oe[se++] = z >> 8 & 255, oe[se++] = z & 255;
  return ie === 2 && (z = revLookup$1[B.charCodeAt(ve)] << 2 | revLookup$1[B.charCodeAt(ve + 1)] >> 4, oe[se++] = z & 255), ie === 1 && (z = revLookup$1[B.charCodeAt(ve)] << 10 | revLookup$1[B.charCodeAt(ve + 1)] << 4 | revLookup$1[B.charCodeAt(ve + 2)] >> 2, oe[se++] = z >> 8 & 255, oe[se++] = z & 255), oe;
}
function tripletToBase64$1(B) {
  return lookup$1[B >> 18 & 63] + lookup$1[B >> 12 & 63] + lookup$1[B >> 6 & 63] + lookup$1[B & 63];
}
function encodeChunk$1(B, z, Y) {
  for (var ne, ie = [], oe = z; oe < Y; oe += 3)
    ne = (B[oe] << 16 & 16711680) + (B[oe + 1] << 8 & 65280) + (B[oe + 2] & 255), ie.push(tripletToBase64$1(ne));
  return ie.join("");
}
function fromByteArray$1(B) {
  for (var z, Y = B.length, ne = Y % 3, ie = [], oe = 16383, se = 0, ae = Y - ne; se < ae; se += oe)
    ie.push(encodeChunk$1(B, se, se + oe > ae ? ae : se + oe));
  return ne === 1 ? (z = B[Y - 1], ie.push(
    lookup$1[z >> 2] + lookup$1[z << 4 & 63] + "=="
  )) : ne === 2 && (z = (B[Y - 2] << 8) + B[Y - 1], ie.push(
    lookup$1[z >> 10] + lookup$1[z >> 4 & 63] + lookup$1[z << 2 & 63] + "="
  )), ie.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(B, z, Y, ne, ie) {
  var oe, se, ae = ie * 8 - ne - 1, ve = (1 << ae) - 1, Pe = ve >> 1, le = -7, Ee = Y ? ie - 1 : 0, Je = Y ? -1 : 1, Ce = B[z + Ee];
  for (Ee += Je, oe = Ce & (1 << -le) - 1, Ce >>= -le, le += ae; le > 0; oe = oe * 256 + B[z + Ee], Ee += Je, le -= 8)
    ;
  for (se = oe & (1 << -le) - 1, oe >>= -le, le += ne; le > 0; se = se * 256 + B[z + Ee], Ee += Je, le -= 8)
    ;
  if (oe === 0)
    oe = 1 - Pe;
  else {
    if (oe === ve)
      return se ? NaN : (Ce ? -1 : 1) * (1 / 0);
    se = se + Math.pow(2, ne), oe = oe - Pe;
  }
  return (Ce ? -1 : 1) * se * Math.pow(2, oe - ne);
};
ieee754.write = function(B, z, Y, ne, ie, oe) {
  var se, ae, ve, Pe = oe * 8 - ie - 1, le = (1 << Pe) - 1, Ee = le >> 1, Je = ie === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Ce = ne ? 0 : oe - 1, _t = ne ? 1 : -1, kt = z < 0 || z === 0 && 1 / z < 0 ? 1 : 0;
  for (z = Math.abs(z), isNaN(z) || z === 1 / 0 ? (ae = isNaN(z) ? 1 : 0, se = le) : (se = Math.floor(Math.log(z) / Math.LN2), z * (ve = Math.pow(2, -se)) < 1 && (se--, ve *= 2), se + Ee >= 1 ? z += Je / ve : z += Je * Math.pow(2, 1 - Ee), z * ve >= 2 && (se++, ve /= 2), se + Ee >= le ? (ae = 0, se = le) : se + Ee >= 1 ? (ae = (z * ve - 1) * Math.pow(2, ie), se = se + Ee) : (ae = z * Math.pow(2, Ee - 1) * Math.pow(2, ie), se = 0)); ie >= 8; B[Y + Ce] = ae & 255, Ce += _t, ae /= 256, ie -= 8)
    ;
  for (se = se << ie | ae, Pe += ie; Pe > 0; B[Y + Ce] = se & 255, Ce += _t, se /= 256, Pe -= 8)
    ;
  B[Y + Ce - _t] |= kt * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(B) {
  const z = base64Js$1, Y = ieee754, ne = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  B.Buffer = le, B.SlowBuffer = Jt, B.INSPECT_MAX_BYTES = 50;
  const ie = 2147483647;
  B.kMaxLength = ie;
  const { Uint8Array: oe, ArrayBuffer: se, SharedArrayBuffer: ae } = globalThis;
  le.TYPED_ARRAY_SUPPORT = ve(), !le.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function ve() {
    try {
      const Wt = new oe(1), Ot = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(Ot, oe.prototype), Object.setPrototypeOf(Wt, Ot), Wt.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(le.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (le.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(le.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (le.isBuffer(this))
        return this.byteOffset;
    }
  });
  function Pe(Wt) {
    if (Wt > ie)
      throw new RangeError('The value "' + Wt + '" is invalid for option "size"');
    const Ot = new oe(Wt);
    return Object.setPrototypeOf(Ot, le.prototype), Ot;
  }
  function le(Wt, Ot, Nt) {
    if (typeof Wt == "number") {
      if (typeof Ot == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return _t(Wt);
    }
    return Ee(Wt, Ot, Nt);
  }
  le.poolSize = 8192;
  function Ee(Wt, Ot, Nt) {
    if (typeof Wt == "string")
      return kt(Wt, Ot);
    if (se.isView(Wt))
      return Lt(Wt);
    if (Wt == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Wt
      );
    if (Wr(Wt, se) || Wt && Wr(Wt.buffer, se) || typeof ae < "u" && (Wr(Wt, ae) || Wt && Wr(Wt.buffer, ae)))
      return Pt(Wt, Ot, Nt);
    if (typeof Wt == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Yt = Wt.valueOf && Wt.valueOf();
    if (Yt != null && Yt !== Wt)
      return le.from(Yt, Ot, Nt);
    const ar = Ft(Wt);
    if (ar) return ar;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Wt[Symbol.toPrimitive] == "function")
      return le.from(Wt[Symbol.toPrimitive]("string"), Ot, Nt);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Wt
    );
  }
  le.from = function(Wt, Ot, Nt) {
    return Ee(Wt, Ot, Nt);
  }, Object.setPrototypeOf(le.prototype, oe.prototype), Object.setPrototypeOf(le, oe);
  function Je(Wt) {
    if (typeof Wt != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Wt < 0)
      throw new RangeError('The value "' + Wt + '" is invalid for option "size"');
  }
  function Ce(Wt, Ot, Nt) {
    return Je(Wt), Wt <= 0 ? Pe(Wt) : Ot !== void 0 ? typeof Nt == "string" ? Pe(Wt).fill(Ot, Nt) : Pe(Wt).fill(Ot) : Pe(Wt);
  }
  le.alloc = function(Wt, Ot, Nt) {
    return Ce(Wt, Ot, Nt);
  };
  function _t(Wt) {
    return Je(Wt), Pe(Wt < 0 ? 0 : Ut(Wt) | 0);
  }
  le.allocUnsafe = function(Wt) {
    return _t(Wt);
  }, le.allocUnsafeSlow = function(Wt) {
    return _t(Wt);
  };
  function kt(Wt, Ot) {
    if ((typeof Ot != "string" || Ot === "") && (Ot = "utf8"), !le.isEncoding(Ot))
      throw new TypeError("Unknown encoding: " + Ot);
    const Nt = Vt(Wt, Ot) | 0;
    let Yt = Pe(Nt);
    const ar = Yt.write(Wt, Ot);
    return ar !== Nt && (Yt = Yt.slice(0, ar)), Yt;
  }
  function Ct(Wt) {
    const Ot = Wt.length < 0 ? 0 : Ut(Wt.length) | 0, Nt = Pe(Ot);
    for (let Yt = 0; Yt < Ot; Yt += 1)
      Nt[Yt] = Wt[Yt] & 255;
    return Nt;
  }
  function Lt(Wt) {
    if (Wr(Wt, oe)) {
      const Ot = new oe(Wt);
      return Pt(Ot.buffer, Ot.byteOffset, Ot.byteLength);
    }
    return Ct(Wt);
  }
  function Pt(Wt, Ot, Nt) {
    if (Ot < 0 || Wt.byteLength < Ot)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Wt.byteLength < Ot + (Nt || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Yt;
    return Ot === void 0 && Nt === void 0 ? Yt = new oe(Wt) : Nt === void 0 ? Yt = new oe(Wt, Ot) : Yt = new oe(Wt, Ot, Nt), Object.setPrototypeOf(Yt, le.prototype), Yt;
  }
  function Ft(Wt) {
    if (le.isBuffer(Wt)) {
      const Ot = Ut(Wt.length) | 0, Nt = Pe(Ot);
      return Nt.length === 0 || Wt.copy(Nt, 0, 0, Ot), Nt;
    }
    if (Wt.length !== void 0)
      return typeof Wt.length != "number" || Jr(Wt.length) ? Pe(0) : Ct(Wt);
    if (Wt.type === "Buffer" && Array.isArray(Wt.data))
      return Ct(Wt.data);
  }
  function Ut(Wt) {
    if (Wt >= ie)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + ie.toString(16) + " bytes");
    return Wt | 0;
  }
  function Jt(Wt) {
    return +Wt != Wt && (Wt = 0), le.alloc(+Wt);
  }
  le.isBuffer = function(Ot) {
    return Ot != null && Ot._isBuffer === !0 && Ot !== le.prototype;
  }, le.compare = function(Ot, Nt) {
    if (Wr(Ot, oe) && (Ot = le.from(Ot, Ot.offset, Ot.byteLength)), Wr(Nt, oe) && (Nt = le.from(Nt, Nt.offset, Nt.byteLength)), !le.isBuffer(Ot) || !le.isBuffer(Nt))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (Ot === Nt) return 0;
    let Yt = Ot.length, ar = Nt.length;
    for (let lr = 0, dr = Math.min(Yt, ar); lr < dr; ++lr)
      if (Ot[lr] !== Nt[lr]) {
        Yt = Ot[lr], ar = Nt[lr];
        break;
      }
    return Yt < ar ? -1 : ar < Yt ? 1 : 0;
  }, le.isEncoding = function(Ot) {
    switch (String(Ot).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, le.concat = function(Ot, Nt) {
    if (!Array.isArray(Ot))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (Ot.length === 0)
      return le.alloc(0);
    let Yt;
    if (Nt === void 0)
      for (Nt = 0, Yt = 0; Yt < Ot.length; ++Yt)
        Nt += Ot[Yt].length;
    const ar = le.allocUnsafe(Nt);
    let lr = 0;
    for (Yt = 0; Yt < Ot.length; ++Yt) {
      let dr = Ot[Yt];
      if (Wr(dr, oe))
        lr + dr.length > ar.length ? (le.isBuffer(dr) || (dr = le.from(dr)), dr.copy(ar, lr)) : oe.prototype.set.call(
          ar,
          dr,
          lr
        );
      else if (le.isBuffer(dr))
        dr.copy(ar, lr);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      lr += dr.length;
    }
    return ar;
  };
  function Vt(Wt, Ot) {
    if (le.isBuffer(Wt))
      return Wt.length;
    if (se.isView(Wt) || Wr(Wt, se))
      return Wt.byteLength;
    if (typeof Wt != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Wt
      );
    const Nt = Wt.length, Yt = arguments.length > 2 && arguments[2] === !0;
    if (!Yt && Nt === 0) return 0;
    let ar = !1;
    for (; ; )
      switch (Ot) {
        case "ascii":
        case "latin1":
        case "binary":
          return Nt;
        case "utf8":
        case "utf-8":
          return Yr(Wt).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Nt * 2;
        case "hex":
          return Nt >>> 1;
        case "base64":
          return Xr(Wt).length;
        default:
          if (ar)
            return Yt ? -1 : Yr(Wt).length;
          Ot = ("" + Ot).toLowerCase(), ar = !0;
      }
  }
  le.byteLength = Vt;
  function ir(Wt, Ot, Nt) {
    let Yt = !1;
    if ((Ot === void 0 || Ot < 0) && (Ot = 0), Ot > this.length || ((Nt === void 0 || Nt > this.length) && (Nt = this.length), Nt <= 0) || (Nt >>>= 0, Ot >>>= 0, Nt <= Ot))
      return "";
    for (Wt || (Wt = "utf8"); ; )
      switch (Wt) {
        case "hex":
          return bt(this, Ot, Nt);
        case "utf8":
        case "utf-8":
          return wt(this, Ot, Nt);
        case "ascii":
          return Qe(this, Ot, Nt);
        case "latin1":
        case "binary":
          return xt(this, Ot, Nt);
        case "base64":
          return ht(this, Ot, Nt);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Dt(this, Ot, Nt);
        default:
          if (Yt) throw new TypeError("Unknown encoding: " + Wt);
          Wt = (Wt + "").toLowerCase(), Yt = !0;
      }
  }
  le.prototype._isBuffer = !0;
  function jt(Wt, Ot, Nt) {
    const Yt = Wt[Ot];
    Wt[Ot] = Wt[Nt], Wt[Nt] = Yt;
  }
  le.prototype.swap16 = function() {
    const Ot = this.length;
    if (Ot % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Nt = 0; Nt < Ot; Nt += 2)
      jt(this, Nt, Nt + 1);
    return this;
  }, le.prototype.swap32 = function() {
    const Ot = this.length;
    if (Ot % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Nt = 0; Nt < Ot; Nt += 4)
      jt(this, Nt, Nt + 3), jt(this, Nt + 1, Nt + 2);
    return this;
  }, le.prototype.swap64 = function() {
    const Ot = this.length;
    if (Ot % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Nt = 0; Nt < Ot; Nt += 8)
      jt(this, Nt, Nt + 7), jt(this, Nt + 1, Nt + 6), jt(this, Nt + 2, Nt + 5), jt(this, Nt + 3, Nt + 4);
    return this;
  }, le.prototype.toString = function() {
    const Ot = this.length;
    return Ot === 0 ? "" : arguments.length === 0 ? wt(this, 0, Ot) : ir.apply(this, arguments);
  }, le.prototype.toLocaleString = le.prototype.toString, le.prototype.equals = function(Ot) {
    if (!le.isBuffer(Ot)) throw new TypeError("Argument must be a Buffer");
    return this === Ot ? !0 : le.compare(this, Ot) === 0;
  }, le.prototype.inspect = function() {
    let Ot = "";
    const Nt = B.INSPECT_MAX_BYTES;
    return Ot = this.toString("hex", 0, Nt).replace(/(.{2})/g, "$1 ").trim(), this.length > Nt && (Ot += " ... "), "<Buffer " + Ot + ">";
  }, ne && (le.prototype[ne] = le.prototype.inspect), le.prototype.compare = function(Ot, Nt, Yt, ar, lr) {
    if (Wr(Ot, oe) && (Ot = le.from(Ot, Ot.offset, Ot.byteLength)), !le.isBuffer(Ot))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Ot
      );
    if (Nt === void 0 && (Nt = 0), Yt === void 0 && (Yt = Ot ? Ot.length : 0), ar === void 0 && (ar = 0), lr === void 0 && (lr = this.length), Nt < 0 || Yt > Ot.length || ar < 0 || lr > this.length)
      throw new RangeError("out of range index");
    if (ar >= lr && Nt >= Yt)
      return 0;
    if (ar >= lr)
      return -1;
    if (Nt >= Yt)
      return 1;
    if (Nt >>>= 0, Yt >>>= 0, ar >>>= 0, lr >>>= 0, this === Ot) return 0;
    let dr = lr - ar, Ir = Yt - Nt;
    const qr = Math.min(dr, Ir), Br = this.slice(ar, lr), Ur = Ot.slice(Nt, Yt);
    for (let Lr = 0; Lr < qr; ++Lr)
      if (Br[Lr] !== Ur[Lr]) {
        dr = Br[Lr], Ir = Ur[Lr];
        break;
      }
    return dr < Ir ? -1 : Ir < dr ? 1 : 0;
  };
  function Rt(Wt, Ot, Nt, Yt, ar) {
    if (Wt.length === 0) return -1;
    if (typeof Nt == "string" ? (Yt = Nt, Nt = 0) : Nt > 2147483647 ? Nt = 2147483647 : Nt < -2147483648 && (Nt = -2147483648), Nt = +Nt, Jr(Nt) && (Nt = ar ? 0 : Wt.length - 1), Nt < 0 && (Nt = Wt.length + Nt), Nt >= Wt.length) {
      if (ar) return -1;
      Nt = Wt.length - 1;
    } else if (Nt < 0)
      if (ar) Nt = 0;
      else return -1;
    if (typeof Ot == "string" && (Ot = le.from(Ot, Yt)), le.isBuffer(Ot))
      return Ot.length === 0 ? -1 : Kt(Wt, Ot, Nt, Yt, ar);
    if (typeof Ot == "number")
      return Ot = Ot & 255, typeof oe.prototype.indexOf == "function" ? ar ? oe.prototype.indexOf.call(Wt, Ot, Nt) : oe.prototype.lastIndexOf.call(Wt, Ot, Nt) : Kt(Wt, [Ot], Nt, Yt, ar);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Kt(Wt, Ot, Nt, Yt, ar) {
    let lr = 1, dr = Wt.length, Ir = Ot.length;
    if (Yt !== void 0 && (Yt = String(Yt).toLowerCase(), Yt === "ucs2" || Yt === "ucs-2" || Yt === "utf16le" || Yt === "utf-16le")) {
      if (Wt.length < 2 || Ot.length < 2)
        return -1;
      lr = 2, dr /= 2, Ir /= 2, Nt /= 2;
    }
    function qr(Ur, Lr) {
      return lr === 1 ? Ur[Lr] : Ur.readUInt16BE(Lr * lr);
    }
    let Br;
    if (ar) {
      let Ur = -1;
      for (Br = Nt; Br < dr; Br++)
        if (qr(Wt, Br) === qr(Ot, Ur === -1 ? 0 : Br - Ur)) {
          if (Ur === -1 && (Ur = Br), Br - Ur + 1 === Ir) return Ur * lr;
        } else
          Ur !== -1 && (Br -= Br - Ur), Ur = -1;
    } else
      for (Nt + Ir > dr && (Nt = dr - Ir), Br = Nt; Br >= 0; Br--) {
        let Ur = !0;
        for (let Lr = 0; Lr < Ir; Lr++)
          if (qr(Wt, Br + Lr) !== qr(Ot, Lr)) {
            Ur = !1;
            break;
          }
        if (Ur) return Br;
      }
    return -1;
  }
  le.prototype.includes = function(Ot, Nt, Yt) {
    return this.indexOf(Ot, Nt, Yt) !== -1;
  }, le.prototype.indexOf = function(Ot, Nt, Yt) {
    return Rt(this, Ot, Nt, Yt, !0);
  }, le.prototype.lastIndexOf = function(Ot, Nt, Yt) {
    return Rt(this, Ot, Nt, Yt, !1);
  };
  function Bt(Wt, Ot, Nt, Yt) {
    Nt = Number(Nt) || 0;
    const ar = Wt.length - Nt;
    Yt ? (Yt = Number(Yt), Yt > ar && (Yt = ar)) : Yt = ar;
    const lr = Ot.length;
    Yt > lr / 2 && (Yt = lr / 2);
    let dr;
    for (dr = 0; dr < Yt; ++dr) {
      const Ir = parseInt(Ot.substr(dr * 2, 2), 16);
      if (Jr(Ir)) return dr;
      Wt[Nt + dr] = Ir;
    }
    return dr;
  }
  function Xe(Wt, Ot, Nt, Yt) {
    return Or(Yr(Ot, Wt.length - Nt), Wt, Nt, Yt);
  }
  function Ve(Wt, Ot, Nt, Yt) {
    return Or(jr(Ot), Wt, Nt, Yt);
  }
  function ge(Wt, Ot, Nt, Yt) {
    return Or(Xr(Ot), Wt, Nt, Yt);
  }
  function Ke(Wt, Ot, Nt, Yt) {
    return Or(Qr(Ot, Wt.length - Nt), Wt, Nt, Yt);
  }
  le.prototype.write = function(Ot, Nt, Yt, ar) {
    if (Nt === void 0)
      ar = "utf8", Yt = this.length, Nt = 0;
    else if (Yt === void 0 && typeof Nt == "string")
      ar = Nt, Yt = this.length, Nt = 0;
    else if (isFinite(Nt))
      Nt = Nt >>> 0, isFinite(Yt) ? (Yt = Yt >>> 0, ar === void 0 && (ar = "utf8")) : (ar = Yt, Yt = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const lr = this.length - Nt;
    if ((Yt === void 0 || Yt > lr) && (Yt = lr), Ot.length > 0 && (Yt < 0 || Nt < 0) || Nt > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ar || (ar = "utf8");
    let dr = !1;
    for (; ; )
      switch (ar) {
        case "hex":
          return Bt(this, Ot, Nt, Yt);
        case "utf8":
        case "utf-8":
          return Xe(this, Ot, Nt, Yt);
        case "ascii":
        case "latin1":
        case "binary":
          return Ve(this, Ot, Nt, Yt);
        case "base64":
          return ge(this, Ot, Nt, Yt);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ke(this, Ot, Nt, Yt);
        default:
          if (dr) throw new TypeError("Unknown encoding: " + ar);
          ar = ("" + ar).toLowerCase(), dr = !0;
      }
  }, le.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ht(Wt, Ot, Nt) {
    return Ot === 0 && Nt === Wt.length ? z.fromByteArray(Wt) : z.fromByteArray(Wt.slice(Ot, Nt));
  }
  function wt(Wt, Ot, Nt) {
    Nt = Math.min(Wt.length, Nt);
    const Yt = [];
    let ar = Ot;
    for (; ar < Nt; ) {
      const lr = Wt[ar];
      let dr = null, Ir = lr > 239 ? 4 : lr > 223 ? 3 : lr > 191 ? 2 : 1;
      if (ar + Ir <= Nt) {
        let qr, Br, Ur, Lr;
        switch (Ir) {
          case 1:
            lr < 128 && (dr = lr);
            break;
          case 2:
            qr = Wt[ar + 1], (qr & 192) === 128 && (Lr = (lr & 31) << 6 | qr & 63, Lr > 127 && (dr = Lr));
            break;
          case 3:
            qr = Wt[ar + 1], Br = Wt[ar + 2], (qr & 192) === 128 && (Br & 192) === 128 && (Lr = (lr & 15) << 12 | (qr & 63) << 6 | Br & 63, Lr > 2047 && (Lr < 55296 || Lr > 57343) && (dr = Lr));
            break;
          case 4:
            qr = Wt[ar + 1], Br = Wt[ar + 2], Ur = Wt[ar + 3], (qr & 192) === 128 && (Br & 192) === 128 && (Ur & 192) === 128 && (Lr = (lr & 15) << 18 | (qr & 63) << 12 | (Br & 63) << 6 | Ur & 63, Lr > 65535 && Lr < 1114112 && (dr = Lr));
        }
      }
      dr === null ? (dr = 65533, Ir = 1) : dr > 65535 && (dr -= 65536, Yt.push(dr >>> 10 & 1023 | 55296), dr = 56320 | dr & 1023), Yt.push(dr), ar += Ir;
    }
    return $t(Yt);
  }
  const vt = 4096;
  function $t(Wt) {
    const Ot = Wt.length;
    if (Ot <= vt)
      return String.fromCharCode.apply(String, Wt);
    let Nt = "", Yt = 0;
    for (; Yt < Ot; )
      Nt += String.fromCharCode.apply(
        String,
        Wt.slice(Yt, Yt += vt)
      );
    return Nt;
  }
  function Qe(Wt, Ot, Nt) {
    let Yt = "";
    Nt = Math.min(Wt.length, Nt);
    for (let ar = Ot; ar < Nt; ++ar)
      Yt += String.fromCharCode(Wt[ar] & 127);
    return Yt;
  }
  function xt(Wt, Ot, Nt) {
    let Yt = "";
    Nt = Math.min(Wt.length, Nt);
    for (let ar = Ot; ar < Nt; ++ar)
      Yt += String.fromCharCode(Wt[ar]);
    return Yt;
  }
  function bt(Wt, Ot, Nt) {
    const Yt = Wt.length;
    (!Ot || Ot < 0) && (Ot = 0), (!Nt || Nt < 0 || Nt > Yt) && (Nt = Yt);
    let ar = "";
    for (let lr = Ot; lr < Nt; ++lr)
      ar += Hr[Wt[lr]];
    return ar;
  }
  function Dt(Wt, Ot, Nt) {
    const Yt = Wt.slice(Ot, Nt);
    let ar = "";
    for (let lr = 0; lr < Yt.length - 1; lr += 2)
      ar += String.fromCharCode(Yt[lr] + Yt[lr + 1] * 256);
    return ar;
  }
  le.prototype.slice = function(Ot, Nt) {
    const Yt = this.length;
    Ot = ~~Ot, Nt = Nt === void 0 ? Yt : ~~Nt, Ot < 0 ? (Ot += Yt, Ot < 0 && (Ot = 0)) : Ot > Yt && (Ot = Yt), Nt < 0 ? (Nt += Yt, Nt < 0 && (Nt = 0)) : Nt > Yt && (Nt = Yt), Nt < Ot && (Nt = Ot);
    const ar = this.subarray(Ot, Nt);
    return Object.setPrototypeOf(ar, le.prototype), ar;
  };
  function er(Wt, Ot, Nt) {
    if (Wt % 1 !== 0 || Wt < 0) throw new RangeError("offset is not uint");
    if (Wt + Ot > Nt) throw new RangeError("Trying to access beyond buffer length");
  }
  le.prototype.readUintLE = le.prototype.readUIntLE = function(Ot, Nt, Yt) {
    Ot = Ot >>> 0, Nt = Nt >>> 0, Yt || er(Ot, Nt, this.length);
    let ar = this[Ot], lr = 1, dr = 0;
    for (; ++dr < Nt && (lr *= 256); )
      ar += this[Ot + dr] * lr;
    return ar;
  }, le.prototype.readUintBE = le.prototype.readUIntBE = function(Ot, Nt, Yt) {
    Ot = Ot >>> 0, Nt = Nt >>> 0, Yt || er(Ot, Nt, this.length);
    let ar = this[Ot + --Nt], lr = 1;
    for (; Nt > 0 && (lr *= 256); )
      ar += this[Ot + --Nt] * lr;
    return ar;
  }, le.prototype.readUint8 = le.prototype.readUInt8 = function(Ot, Nt) {
    return Ot = Ot >>> 0, Nt || er(Ot, 1, this.length), this[Ot];
  }, le.prototype.readUint16LE = le.prototype.readUInt16LE = function(Ot, Nt) {
    return Ot = Ot >>> 0, Nt || er(Ot, 2, this.length), this[Ot] | this[Ot + 1] << 8;
  }, le.prototype.readUint16BE = le.prototype.readUInt16BE = function(Ot, Nt) {
    return Ot = Ot >>> 0, Nt || er(Ot, 2, this.length), this[Ot] << 8 | this[Ot + 1];
  }, le.prototype.readUint32LE = le.prototype.readUInt32LE = function(Ot, Nt) {
    return Ot = Ot >>> 0, Nt || er(Ot, 4, this.length), (this[Ot] | this[Ot + 1] << 8 | this[Ot + 2] << 16) + this[Ot + 3] * 16777216;
  }, le.prototype.readUint32BE = le.prototype.readUInt32BE = function(Ot, Nt) {
    return Ot = Ot >>> 0, Nt || er(Ot, 4, this.length), this[Ot] * 16777216 + (this[Ot + 1] << 16 | this[Ot + 2] << 8 | this[Ot + 3]);
  }, le.prototype.readBigUInt64LE = Vr(function(Ot) {
    Ot = Ot >>> 0, xr(Ot, "offset");
    const Nt = this[Ot], Yt = this[Ot + 7];
    (Nt === void 0 || Yt === void 0) && Mr(Ot, this.length - 8);
    const ar = Nt + this[++Ot] * 2 ** 8 + this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 24, lr = this[++Ot] + this[++Ot] * 2 ** 8 + this[++Ot] * 2 ** 16 + Yt * 2 ** 24;
    return BigInt(ar) + (BigInt(lr) << BigInt(32));
  }), le.prototype.readBigUInt64BE = Vr(function(Ot) {
    Ot = Ot >>> 0, xr(Ot, "offset");
    const Nt = this[Ot], Yt = this[Ot + 7];
    (Nt === void 0 || Yt === void 0) && Mr(Ot, this.length - 8);
    const ar = Nt * 2 ** 24 + this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 8 + this[++Ot], lr = this[++Ot] * 2 ** 24 + this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 8 + Yt;
    return (BigInt(ar) << BigInt(32)) + BigInt(lr);
  }), le.prototype.readIntLE = function(Ot, Nt, Yt) {
    Ot = Ot >>> 0, Nt = Nt >>> 0, Yt || er(Ot, Nt, this.length);
    let ar = this[Ot], lr = 1, dr = 0;
    for (; ++dr < Nt && (lr *= 256); )
      ar += this[Ot + dr] * lr;
    return lr *= 128, ar >= lr && (ar -= Math.pow(2, 8 * Nt)), ar;
  }, le.prototype.readIntBE = function(Ot, Nt, Yt) {
    Ot = Ot >>> 0, Nt = Nt >>> 0, Yt || er(Ot, Nt, this.length);
    let ar = Nt, lr = 1, dr = this[Ot + --ar];
    for (; ar > 0 && (lr *= 256); )
      dr += this[Ot + --ar] * lr;
    return lr *= 128, dr >= lr && (dr -= Math.pow(2, 8 * Nt)), dr;
  }, le.prototype.readInt8 = function(Ot, Nt) {
    return Ot = Ot >>> 0, Nt || er(Ot, 1, this.length), this[Ot] & 128 ? (255 - this[Ot] + 1) * -1 : this[Ot];
  }, le.prototype.readInt16LE = function(Ot, Nt) {
    Ot = Ot >>> 0, Nt || er(Ot, 2, this.length);
    const Yt = this[Ot] | this[Ot + 1] << 8;
    return Yt & 32768 ? Yt | 4294901760 : Yt;
  }, le.prototype.readInt16BE = function(Ot, Nt) {
    Ot = Ot >>> 0, Nt || er(Ot, 2, this.length);
    const Yt = this[Ot + 1] | this[Ot] << 8;
    return Yt & 32768 ? Yt | 4294901760 : Yt;
  }, le.prototype.readInt32LE = function(Ot, Nt) {
    return Ot = Ot >>> 0, Nt || er(Ot, 4, this.length), this[Ot] | this[Ot + 1] << 8 | this[Ot + 2] << 16 | this[Ot + 3] << 24;
  }, le.prototype.readInt32BE = function(Ot, Nt) {
    return Ot = Ot >>> 0, Nt || er(Ot, 4, this.length), this[Ot] << 24 | this[Ot + 1] << 16 | this[Ot + 2] << 8 | this[Ot + 3];
  }, le.prototype.readBigInt64LE = Vr(function(Ot) {
    Ot = Ot >>> 0, xr(Ot, "offset");
    const Nt = this[Ot], Yt = this[Ot + 7];
    (Nt === void 0 || Yt === void 0) && Mr(Ot, this.length - 8);
    const ar = this[Ot + 4] + this[Ot + 5] * 2 ** 8 + this[Ot + 6] * 2 ** 16 + (Yt << 24);
    return (BigInt(ar) << BigInt(32)) + BigInt(Nt + this[++Ot] * 2 ** 8 + this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 24);
  }), le.prototype.readBigInt64BE = Vr(function(Ot) {
    Ot = Ot >>> 0, xr(Ot, "offset");
    const Nt = this[Ot], Yt = this[Ot + 7];
    (Nt === void 0 || Yt === void 0) && Mr(Ot, this.length - 8);
    const ar = (Nt << 24) + // Overflow
    this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 8 + this[++Ot];
    return (BigInt(ar) << BigInt(32)) + BigInt(this[++Ot] * 2 ** 24 + this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 8 + Yt);
  }), le.prototype.readFloatLE = function(Ot, Nt) {
    return Ot = Ot >>> 0, Nt || er(Ot, 4, this.length), Y.read(this, Ot, !0, 23, 4);
  }, le.prototype.readFloatBE = function(Ot, Nt) {
    return Ot = Ot >>> 0, Nt || er(Ot, 4, this.length), Y.read(this, Ot, !1, 23, 4);
  }, le.prototype.readDoubleLE = function(Ot, Nt) {
    return Ot = Ot >>> 0, Nt || er(Ot, 8, this.length), Y.read(this, Ot, !0, 52, 8);
  }, le.prototype.readDoubleBE = function(Ot, Nt) {
    return Ot = Ot >>> 0, Nt || er(Ot, 8, this.length), Y.read(this, Ot, !1, 52, 8);
  };
  function fr(Wt, Ot, Nt, Yt, ar, lr) {
    if (!le.isBuffer(Wt)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (Ot > ar || Ot < lr) throw new RangeError('"value" argument is out of bounds');
    if (Nt + Yt > Wt.length) throw new RangeError("Index out of range");
  }
  le.prototype.writeUintLE = le.prototype.writeUIntLE = function(Ot, Nt, Yt, ar) {
    if (Ot = +Ot, Nt = Nt >>> 0, Yt = Yt >>> 0, !ar) {
      const Ir = Math.pow(2, 8 * Yt) - 1;
      fr(this, Ot, Nt, Yt, Ir, 0);
    }
    let lr = 1, dr = 0;
    for (this[Nt] = Ot & 255; ++dr < Yt && (lr *= 256); )
      this[Nt + dr] = Ot / lr & 255;
    return Nt + Yt;
  }, le.prototype.writeUintBE = le.prototype.writeUIntBE = function(Ot, Nt, Yt, ar) {
    if (Ot = +Ot, Nt = Nt >>> 0, Yt = Yt >>> 0, !ar) {
      const Ir = Math.pow(2, 8 * Yt) - 1;
      fr(this, Ot, Nt, Yt, Ir, 0);
    }
    let lr = Yt - 1, dr = 1;
    for (this[Nt + lr] = Ot & 255; --lr >= 0 && (dr *= 256); )
      this[Nt + lr] = Ot / dr & 255;
    return Nt + Yt;
  }, le.prototype.writeUint8 = le.prototype.writeUInt8 = function(Ot, Nt, Yt) {
    return Ot = +Ot, Nt = Nt >>> 0, Yt || fr(this, Ot, Nt, 1, 255, 0), this[Nt] = Ot & 255, Nt + 1;
  }, le.prototype.writeUint16LE = le.prototype.writeUInt16LE = function(Ot, Nt, Yt) {
    return Ot = +Ot, Nt = Nt >>> 0, Yt || fr(this, Ot, Nt, 2, 65535, 0), this[Nt] = Ot & 255, this[Nt + 1] = Ot >>> 8, Nt + 2;
  }, le.prototype.writeUint16BE = le.prototype.writeUInt16BE = function(Ot, Nt, Yt) {
    return Ot = +Ot, Nt = Nt >>> 0, Yt || fr(this, Ot, Nt, 2, 65535, 0), this[Nt] = Ot >>> 8, this[Nt + 1] = Ot & 255, Nt + 2;
  }, le.prototype.writeUint32LE = le.prototype.writeUInt32LE = function(Ot, Nt, Yt) {
    return Ot = +Ot, Nt = Nt >>> 0, Yt || fr(this, Ot, Nt, 4, 4294967295, 0), this[Nt + 3] = Ot >>> 24, this[Nt + 2] = Ot >>> 16, this[Nt + 1] = Ot >>> 8, this[Nt] = Ot & 255, Nt + 4;
  }, le.prototype.writeUint32BE = le.prototype.writeUInt32BE = function(Ot, Nt, Yt) {
    return Ot = +Ot, Nt = Nt >>> 0, Yt || fr(this, Ot, Nt, 4, 4294967295, 0), this[Nt] = Ot >>> 24, this[Nt + 1] = Ot >>> 16, this[Nt + 2] = Ot >>> 8, this[Nt + 3] = Ot & 255, Nt + 4;
  };
  function Qt(Wt, Ot, Nt, Yt, ar) {
    $r(Ot, Yt, ar, Wt, Nt, 7);
    let lr = Number(Ot & BigInt(4294967295));
    Wt[Nt++] = lr, lr = lr >> 8, Wt[Nt++] = lr, lr = lr >> 8, Wt[Nt++] = lr, lr = lr >> 8, Wt[Nt++] = lr;
    let dr = Number(Ot >> BigInt(32) & BigInt(4294967295));
    return Wt[Nt++] = dr, dr = dr >> 8, Wt[Nt++] = dr, dr = dr >> 8, Wt[Nt++] = dr, dr = dr >> 8, Wt[Nt++] = dr, Nt;
  }
  function Ht(Wt, Ot, Nt, Yt, ar) {
    $r(Ot, Yt, ar, Wt, Nt, 7);
    let lr = Number(Ot & BigInt(4294967295));
    Wt[Nt + 7] = lr, lr = lr >> 8, Wt[Nt + 6] = lr, lr = lr >> 8, Wt[Nt + 5] = lr, lr = lr >> 8, Wt[Nt + 4] = lr;
    let dr = Number(Ot >> BigInt(32) & BigInt(4294967295));
    return Wt[Nt + 3] = dr, dr = dr >> 8, Wt[Nt + 2] = dr, dr = dr >> 8, Wt[Nt + 1] = dr, dr = dr >> 8, Wt[Nt] = dr, Nt + 8;
  }
  le.prototype.writeBigUInt64LE = Vr(function(Ot, Nt = 0) {
    return Qt(this, Ot, Nt, BigInt(0), BigInt("0xffffffffffffffff"));
  }), le.prototype.writeBigUInt64BE = Vr(function(Ot, Nt = 0) {
    return Ht(this, Ot, Nt, BigInt(0), BigInt("0xffffffffffffffff"));
  }), le.prototype.writeIntLE = function(Ot, Nt, Yt, ar) {
    if (Ot = +Ot, Nt = Nt >>> 0, !ar) {
      const qr = Math.pow(2, 8 * Yt - 1);
      fr(this, Ot, Nt, Yt, qr - 1, -qr);
    }
    let lr = 0, dr = 1, Ir = 0;
    for (this[Nt] = Ot & 255; ++lr < Yt && (dr *= 256); )
      Ot < 0 && Ir === 0 && this[Nt + lr - 1] !== 0 && (Ir = 1), this[Nt + lr] = (Ot / dr >> 0) - Ir & 255;
    return Nt + Yt;
  }, le.prototype.writeIntBE = function(Ot, Nt, Yt, ar) {
    if (Ot = +Ot, Nt = Nt >>> 0, !ar) {
      const qr = Math.pow(2, 8 * Yt - 1);
      fr(this, Ot, Nt, Yt, qr - 1, -qr);
    }
    let lr = Yt - 1, dr = 1, Ir = 0;
    for (this[Nt + lr] = Ot & 255; --lr >= 0 && (dr *= 256); )
      Ot < 0 && Ir === 0 && this[Nt + lr + 1] !== 0 && (Ir = 1), this[Nt + lr] = (Ot / dr >> 0) - Ir & 255;
    return Nt + Yt;
  }, le.prototype.writeInt8 = function(Ot, Nt, Yt) {
    return Ot = +Ot, Nt = Nt >>> 0, Yt || fr(this, Ot, Nt, 1, 127, -128), Ot < 0 && (Ot = 255 + Ot + 1), this[Nt] = Ot & 255, Nt + 1;
  }, le.prototype.writeInt16LE = function(Ot, Nt, Yt) {
    return Ot = +Ot, Nt = Nt >>> 0, Yt || fr(this, Ot, Nt, 2, 32767, -32768), this[Nt] = Ot & 255, this[Nt + 1] = Ot >>> 8, Nt + 2;
  }, le.prototype.writeInt16BE = function(Ot, Nt, Yt) {
    return Ot = +Ot, Nt = Nt >>> 0, Yt || fr(this, Ot, Nt, 2, 32767, -32768), this[Nt] = Ot >>> 8, this[Nt + 1] = Ot & 255, Nt + 2;
  }, le.prototype.writeInt32LE = function(Ot, Nt, Yt) {
    return Ot = +Ot, Nt = Nt >>> 0, Yt || fr(this, Ot, Nt, 4, 2147483647, -2147483648), this[Nt] = Ot & 255, this[Nt + 1] = Ot >>> 8, this[Nt + 2] = Ot >>> 16, this[Nt + 3] = Ot >>> 24, Nt + 4;
  }, le.prototype.writeInt32BE = function(Ot, Nt, Yt) {
    return Ot = +Ot, Nt = Nt >>> 0, Yt || fr(this, Ot, Nt, 4, 2147483647, -2147483648), Ot < 0 && (Ot = 4294967295 + Ot + 1), this[Nt] = Ot >>> 24, this[Nt + 1] = Ot >>> 16, this[Nt + 2] = Ot >>> 8, this[Nt + 3] = Ot & 255, Nt + 4;
  }, le.prototype.writeBigInt64LE = Vr(function(Ot, Nt = 0) {
    return Qt(this, Ot, Nt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), le.prototype.writeBigInt64BE = Vr(function(Ot, Nt = 0) {
    return Ht(this, Ot, Nt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function qt(Wt, Ot, Nt, Yt, ar, lr) {
    if (Nt + Yt > Wt.length) throw new RangeError("Index out of range");
    if (Nt < 0) throw new RangeError("Index out of range");
  }
  function nr(Wt, Ot, Nt, Yt, ar) {
    return Ot = +Ot, Nt = Nt >>> 0, ar || qt(Wt, Ot, Nt, 4), Y.write(Wt, Ot, Nt, Yt, 23, 4), Nt + 4;
  }
  le.prototype.writeFloatLE = function(Ot, Nt, Yt) {
    return nr(this, Ot, Nt, !0, Yt);
  }, le.prototype.writeFloatBE = function(Ot, Nt, Yt) {
    return nr(this, Ot, Nt, !1, Yt);
  };
  function ur(Wt, Ot, Nt, Yt, ar) {
    return Ot = +Ot, Nt = Nt >>> 0, ar || qt(Wt, Ot, Nt, 8), Y.write(Wt, Ot, Nt, Yt, 52, 8), Nt + 8;
  }
  le.prototype.writeDoubleLE = function(Ot, Nt, Yt) {
    return ur(this, Ot, Nt, !0, Yt);
  }, le.prototype.writeDoubleBE = function(Ot, Nt, Yt) {
    return ur(this, Ot, Nt, !1, Yt);
  }, le.prototype.copy = function(Ot, Nt, Yt, ar) {
    if (!le.isBuffer(Ot)) throw new TypeError("argument should be a Buffer");
    if (Yt || (Yt = 0), !ar && ar !== 0 && (ar = this.length), Nt >= Ot.length && (Nt = Ot.length), Nt || (Nt = 0), ar > 0 && ar < Yt && (ar = Yt), ar === Yt || Ot.length === 0 || this.length === 0) return 0;
    if (Nt < 0)
      throw new RangeError("targetStart out of bounds");
    if (Yt < 0 || Yt >= this.length) throw new RangeError("Index out of range");
    if (ar < 0) throw new RangeError("sourceEnd out of bounds");
    ar > this.length && (ar = this.length), Ot.length - Nt < ar - Yt && (ar = Ot.length - Nt + Yt);
    const lr = ar - Yt;
    return this === Ot && typeof oe.prototype.copyWithin == "function" ? this.copyWithin(Nt, Yt, ar) : oe.prototype.set.call(
      Ot,
      this.subarray(Yt, ar),
      Nt
    ), lr;
  }, le.prototype.fill = function(Ot, Nt, Yt, ar) {
    if (typeof Ot == "string") {
      if (typeof Nt == "string" ? (ar = Nt, Nt = 0, Yt = this.length) : typeof Yt == "string" && (ar = Yt, Yt = this.length), ar !== void 0 && typeof ar != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ar == "string" && !le.isEncoding(ar))
        throw new TypeError("Unknown encoding: " + ar);
      if (Ot.length === 1) {
        const dr = Ot.charCodeAt(0);
        (ar === "utf8" && dr < 128 || ar === "latin1") && (Ot = dr);
      }
    } else typeof Ot == "number" ? Ot = Ot & 255 : typeof Ot == "boolean" && (Ot = Number(Ot));
    if (Nt < 0 || this.length < Nt || this.length < Yt)
      throw new RangeError("Out of range index");
    if (Yt <= Nt)
      return this;
    Nt = Nt >>> 0, Yt = Yt === void 0 ? this.length : Yt >>> 0, Ot || (Ot = 0);
    let lr;
    if (typeof Ot == "number")
      for (lr = Nt; lr < Yt; ++lr)
        this[lr] = Ot;
    else {
      const dr = le.isBuffer(Ot) ? Ot : le.from(Ot, ar), Ir = dr.length;
      if (Ir === 0)
        throw new TypeError('The value "' + Ot + '" is invalid for argument "value"');
      for (lr = 0; lr < Yt - Nt; ++lr)
        this[lr + Nt] = dr[lr % Ir];
    }
    return this;
  };
  const zt = {};
  function Gt(Wt, Ot, Nt) {
    zt[Wt] = class extends Nt {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: Ot.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Wt}]`, this.stack, delete this.name;
      }
      get code() {
        return Wt;
      }
      set code(ar) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: ar,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Wt}]: ${this.message}`;
      }
    };
  }
  Gt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Wt) {
      return Wt ? `${Wt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Gt(
    "ERR_INVALID_ARG_TYPE",
    function(Wt, Ot) {
      return `The "${Wt}" argument must be of type number. Received type ${typeof Ot}`;
    },
    TypeError
  ), Gt(
    "ERR_OUT_OF_RANGE",
    function(Wt, Ot, Nt) {
      let Yt = `The value of "${Wt}" is out of range.`, ar = Nt;
      return Number.isInteger(Nt) && Math.abs(Nt) > 2 ** 32 ? ar = cr(String(Nt)) : typeof Nt == "bigint" && (ar = String(Nt), (Nt > BigInt(2) ** BigInt(32) || Nt < -(BigInt(2) ** BigInt(32))) && (ar = cr(ar)), ar += "n"), Yt += ` It must be ${Ot}. Received ${ar}`, Yt;
    },
    RangeError
  );
  function cr(Wt) {
    let Ot = "", Nt = Wt.length;
    const Yt = Wt[0] === "-" ? 1 : 0;
    for (; Nt >= Yt + 4; Nt -= 3)
      Ot = `_${Wt.slice(Nt - 3, Nt)}${Ot}`;
    return `${Wt.slice(0, Nt)}${Ot}`;
  }
  function gr(Wt, Ot, Nt) {
    xr(Ot, "offset"), (Wt[Ot] === void 0 || Wt[Ot + Nt] === void 0) && Mr(Ot, Wt.length - (Nt + 1));
  }
  function $r(Wt, Ot, Nt, Yt, ar, lr) {
    if (Wt > Nt || Wt < Ot) {
      const dr = typeof Ot == "bigint" ? "n" : "";
      let Ir;
      throw Ot === 0 || Ot === BigInt(0) ? Ir = `>= 0${dr} and < 2${dr} ** ${(lr + 1) * 8}${dr}` : Ir = `>= -(2${dr} ** ${(lr + 1) * 8 - 1}${dr}) and < 2 ** ${(lr + 1) * 8 - 1}${dr}`, new zt.ERR_OUT_OF_RANGE("value", Ir, Wt);
    }
    gr(Yt, ar, lr);
  }
  function xr(Wt, Ot) {
    if (typeof Wt != "number")
      throw new zt.ERR_INVALID_ARG_TYPE(Ot, "number", Wt);
  }
  function Mr(Wt, Ot, Nt) {
    throw Math.floor(Wt) !== Wt ? (xr(Wt, Nt), new zt.ERR_OUT_OF_RANGE("offset", "an integer", Wt)) : Ot < 0 ? new zt.ERR_BUFFER_OUT_OF_BOUNDS() : new zt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${Ot}`,
      Wt
    );
  }
  const kr = /[^+/0-9A-Za-z-_]/g;
  function br(Wt) {
    if (Wt = Wt.split("=")[0], Wt = Wt.trim().replace(kr, ""), Wt.length < 2) return "";
    for (; Wt.length % 4 !== 0; )
      Wt = Wt + "=";
    return Wt;
  }
  function Yr(Wt, Ot) {
    Ot = Ot || 1 / 0;
    let Nt;
    const Yt = Wt.length;
    let ar = null;
    const lr = [];
    for (let dr = 0; dr < Yt; ++dr) {
      if (Nt = Wt.charCodeAt(dr), Nt > 55295 && Nt < 57344) {
        if (!ar) {
          if (Nt > 56319) {
            (Ot -= 3) > -1 && lr.push(239, 191, 189);
            continue;
          } else if (dr + 1 === Yt) {
            (Ot -= 3) > -1 && lr.push(239, 191, 189);
            continue;
          }
          ar = Nt;
          continue;
        }
        if (Nt < 56320) {
          (Ot -= 3) > -1 && lr.push(239, 191, 189), ar = Nt;
          continue;
        }
        Nt = (ar - 55296 << 10 | Nt - 56320) + 65536;
      } else ar && (Ot -= 3) > -1 && lr.push(239, 191, 189);
      if (ar = null, Nt < 128) {
        if ((Ot -= 1) < 0) break;
        lr.push(Nt);
      } else if (Nt < 2048) {
        if ((Ot -= 2) < 0) break;
        lr.push(
          Nt >> 6 | 192,
          Nt & 63 | 128
        );
      } else if (Nt < 65536) {
        if ((Ot -= 3) < 0) break;
        lr.push(
          Nt >> 12 | 224,
          Nt >> 6 & 63 | 128,
          Nt & 63 | 128
        );
      } else if (Nt < 1114112) {
        if ((Ot -= 4) < 0) break;
        lr.push(
          Nt >> 18 | 240,
          Nt >> 12 & 63 | 128,
          Nt >> 6 & 63 | 128,
          Nt & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return lr;
  }
  function jr(Wt) {
    const Ot = [];
    for (let Nt = 0; Nt < Wt.length; ++Nt)
      Ot.push(Wt.charCodeAt(Nt) & 255);
    return Ot;
  }
  function Qr(Wt, Ot) {
    let Nt, Yt, ar;
    const lr = [];
    for (let dr = 0; dr < Wt.length && !((Ot -= 2) < 0); ++dr)
      Nt = Wt.charCodeAt(dr), Yt = Nt >> 8, ar = Nt % 256, lr.push(ar), lr.push(Yt);
    return lr;
  }
  function Xr(Wt) {
    return z.toByteArray(br(Wt));
  }
  function Or(Wt, Ot, Nt, Yt) {
    let ar;
    for (ar = 0; ar < Yt && !(ar + Nt >= Ot.length || ar >= Wt.length); ++ar)
      Ot[ar + Nt] = Wt[ar];
    return ar;
  }
  function Wr(Wt, Ot) {
    return Wt instanceof Ot || Wt != null && Wt.constructor != null && Wt.constructor.name != null && Wt.constructor.name === Ot.name;
  }
  function Jr(Wt) {
    return Wt !== Wt;
  }
  const Hr = function() {
    const Wt = "0123456789abcdef", Ot = new Array(256);
    for (let Nt = 0; Nt < 16; ++Nt) {
      const Yt = Nt * 16;
      for (let ar = 0; ar < 16; ++ar)
        Ot[Yt + ar] = Wt[Nt] + Wt[ar];
    }
    return Ot;
  }();
  function Vr(Wt) {
    return typeof BigInt > "u" ? tn : Wt;
  }
  function tn() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$D = buffer$1.Buffer, Blob = buffer$1.Blob, BlobOptions = buffer$1.BlobOptions, Buffer$1$1 = buffer$1.Buffer, File = buffer$1.File, FileOptions = buffer$1.FileOptions, INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES, SlowBuffer = buffer$1.SlowBuffer, TranscodeEncoding = buffer$1.TranscodeEncoding, atob = buffer$1.atob, btoa = buffer$1.btoa, constants$1 = buffer$1.constants, isAscii = buffer$1.isAscii, isUtf8 = buffer$1.isUtf8, kMaxLength = buffer$1.kMaxLength, kStringMaxLength = buffer$1.kStringMaxLength, resolveObjectURL = buffer$1.resolveObjectURL, transcode = buffer$1.transcode, dist$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob,
  btoa,
  constants: constants$1,
  default: Buffer$D,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var store2;
function getGlobalMessage(B) {
  return store2 == null ? void 0 : store2.get(B);
}
var store3;
function getSchemaMessage(B) {
  return store3 == null ? void 0 : store3.get(B);
}
var store4;
function getSpecificMessage(B, z) {
  var Y;
  return (Y = store4 == null ? void 0 : store4.get(B)) == null ? void 0 : Y.get(z);
}
function _stringify(B) {
  var Y, ne;
  const z = typeof B;
  return z === "string" ? `"${B}"` : z === "number" || z === "bigint" || z === "boolean" ? `${B}` : z === "object" || z === "function" ? (B && ((ne = (Y = Object.getPrototypeOf(B)) == null ? void 0 : Y.constructor) == null ? void 0 : ne.name)) ?? "null" : z;
}
function _addIssue(B, z, Y, ne, ie) {
  const oe = ie && "input" in ie ? ie.input : Y.value, se = (ie == null ? void 0 : ie.expected) ?? B.expects ?? null, ae = (ie == null ? void 0 : ie.received) ?? _stringify(oe), ve = {
    kind: B.kind,
    type: B.type,
    input: oe,
    expected: se,
    received: ae,
    message: `Invalid ${z}: ${se ? `Expected ${se} but r` : "R"}eceived ${ae}`,
    requirement: B.requirement,
    path: ie == null ? void 0 : ie.path,
    issues: ie == null ? void 0 : ie.issues,
    lang: ne.lang,
    abortEarly: ne.abortEarly,
    abortPipeEarly: ne.abortPipeEarly
  }, Pe = B.kind === "schema", le = (ie == null ? void 0 : ie.message) ?? B.message ?? getSpecificMessage(B.reference, ve.lang) ?? (Pe ? getSchemaMessage(ve.lang) : null) ?? ne.message ?? getGlobalMessage(ve.lang);
  le && (ve.message = typeof le == "function" ? (
    // @ts-expect-error
    le(ve)
  ) : le), Pe && (Y.typed = !1), Y.issues ? Y.issues.push(ve) : Y.issues = [ve];
}
function _isValidObjectKey(B, z) {
  return Object.hasOwn(B, z) && z !== "__proto__" && z !== "prototype" && z !== "constructor";
}
function _joinExpects(B, z) {
  const Y = [...new Set(B)];
  return Y.length > 1 ? `(${Y.join(` ${z} `)})` : Y[0] ?? "never";
}
function check$e(B, z) {
  return {
    kind: "validation",
    type: "check",
    reference: check$e,
    async: !1,
    expects: null,
    requirement: B,
    message: z,
    _run(Y, ne) {
      return Y.typed && !this.requirement(Y.value) && _addIssue(this, "input", Y, ne), Y;
    }
  };
}
function maxLength(B, z) {
  return {
    kind: "validation",
    type: "max_length",
    reference: maxLength,
    async: !1,
    expects: `<=${B}`,
    requirement: B,
    message: z,
    _run(Y, ne) {
      return Y.typed && Y.value.length > this.requirement && _addIssue(this, "length", Y, ne, {
        received: `${Y.value.length}`
      }), Y;
    }
  };
}
function minLength(B, z) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: !1,
    expects: `>=${B}`,
    requirement: B,
    message: z,
    _run(Y, ne) {
      return Y.typed && Y.value.length < this.requirement && _addIssue(this, "length", Y, ne, {
        received: `${Y.value.length}`
      }), Y;
    }
  };
}
function getDefault(B, z, Y) {
  return typeof B.default == "function" ? (
    // @ts-expect-error
    B.default(z, Y)
  ) : (
    // @ts-expect-error
    B.default
  );
}
function is(B, z) {
  return !B._run({ typed: !1, value: z }, { abortEarly: !0 }).issues;
}
function array(B, z) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: !1,
    item: B,
    message: z,
    _run(Y, ne) {
      var oe;
      const ie = Y.value;
      if (Array.isArray(ie)) {
        Y.typed = !0, Y.value = [];
        for (let se = 0; se < ie.length; se++) {
          const ae = ie[se], ve = this.item._run({ typed: !1, value: ae }, ne);
          if (ve.issues) {
            const Pe = {
              type: "array",
              origin: "value",
              input: ie,
              key: se,
              value: ae
            };
            for (const le of ve.issues)
              le.path ? le.path.unshift(Pe) : le.path = [Pe], (oe = Y.issues) == null || oe.push(le);
            if (Y.issues || (Y.issues = ve.issues), ne.abortEarly) {
              Y.typed = !1;
              break;
            }
          }
          ve.typed || (Y.typed = !1), Y.value.push(ve.value);
        }
      } else
        _addIssue(this, "type", Y, ne);
      return Y;
    }
  };
}
function boolean(B) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message: B,
    _run(z, Y) {
      return typeof z.value == "boolean" ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function enum_(B, z) {
  const Y = Object.entries(B).filter(([ne]) => isNaN(+ne)).map(([, ne]) => ne);
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: _joinExpects(Y.map(_stringify), "|"),
    async: !1,
    enum: B,
    options: Y,
    message: z,
    _run(ne, ie) {
      return this.options.includes(ne.value) ? ne.typed = !0 : _addIssue(this, "type", ne, ie), ne;
    }
  };
}
function literal(B, z) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(B),
    async: !1,
    literal: B,
    message: z,
    _run(Y, ne) {
      return Y.value === this.literal ? Y.typed = !0 : _addIssue(this, "type", Y, ne), Y;
    }
  };
}
function looseObject(B, z) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: !1,
    entries: B,
    message: z,
    _run(Y, ne) {
      var oe;
      const ie = Y.value;
      if (ie && typeof ie == "object") {
        Y.typed = !0, Y.value = {};
        for (const se in this.entries) {
          const ae = ie[se], ve = this.entries[se]._run(
            { typed: !1, value: ae },
            ne
          );
          if (ve.issues) {
            const Pe = {
              type: "object",
              origin: "value",
              input: ie,
              key: se,
              value: ae
            };
            for (const le of ve.issues)
              le.path ? le.path.unshift(Pe) : le.path = [Pe], (oe = Y.issues) == null || oe.push(le);
            if (Y.issues || (Y.issues = ve.issues), ne.abortEarly) {
              Y.typed = !1;
              break;
            }
          }
          ve.typed || (Y.typed = !1), (ve.value !== void 0 || se in ie) && (Y.value[se] = ve.value);
        }
        if (!Y.issues || !ne.abortEarly)
          for (const se in ie)
            _isValidObjectKey(ie, se) && !(se in this.entries) && (Y.value[se] = ie[se]);
      } else
        _addIssue(this, "type", Y, ne);
      return Y;
    }
  };
}
function nonOptional(B, z) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: !1,
    wrapped: B,
    message: z,
    _run(Y, ne) {
      return Y.value === void 0 ? (_addIssue(this, "type", Y, ne), Y) : this.wrapped._run(Y, ne);
    }
  };
}
function null_(B) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: !1,
    message: B,
    _run(z, Y) {
      return z.value === null ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function nullish(B, ...z) {
  const Y = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `(${B.expects} | null | undefined)`,
    async: !1,
    wrapped: B,
    _run(ne, ie) {
      return (ne.value === null || ne.value === void 0) && ("default" in this && (ne.value = getDefault(
        this,
        ne,
        ie
      )), ne.value === null || ne.value === void 0) ? (ne.typed = !0, ne) : this.wrapped._run(ne, ie);
    }
  };
  return 0 in z && (Y.default = z[0]), Y;
}
function number(B) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: !1,
    message: B,
    _run(z, Y) {
      return typeof z.value == "number" && !isNaN(z.value) ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function object(B, z) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries: B,
    message: z,
    _run(Y, ne) {
      var oe;
      const ie = Y.value;
      if (ie && typeof ie == "object") {
        Y.typed = !0, Y.value = {};
        for (const se in this.entries) {
          const ae = ie[se], ve = this.entries[se]._run(
            { typed: !1, value: ae },
            ne
          );
          if (ve.issues) {
            const Pe = {
              type: "object",
              origin: "value",
              input: ie,
              key: se,
              value: ae
            };
            for (const le of ve.issues)
              le.path ? le.path.unshift(Pe) : le.path = [Pe], (oe = Y.issues) == null || oe.push(le);
            if (Y.issues || (Y.issues = ve.issues), ne.abortEarly) {
              Y.typed = !1;
              break;
            }
          }
          ve.typed || (Y.typed = !1), (ve.value !== void 0 || se in ie) && (Y.value[se] = ve.value);
        }
      } else
        _addIssue(this, "type", Y, ne);
      return Y;
    }
  };
}
function optional(B, ...z) {
  const Y = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${B.expects} | undefined)`,
    async: !1,
    wrapped: B,
    _run(ne, ie) {
      return ne.value === void 0 && ("default" in this && (ne.value = getDefault(
        this,
        ne,
        ie
      )), ne.value === void 0) ? (ne.typed = !0, ne) : this.wrapped._run(ne, ie);
    }
  };
  return 0 in z && (Y.default = z[0]), Y;
}
function picklist(B, z) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: _joinExpects(B.map(_stringify), "|"),
    async: !1,
    options: B,
    message: z,
    _run(Y, ne) {
      return this.options.includes(Y.value) ? Y.typed = !0 : _addIssue(this, "type", Y, ne), Y;
    }
  };
}
function record(B, z, Y) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: !1,
    key: B,
    value: z,
    message: Y,
    _run(ne, ie) {
      var se, ae;
      const oe = ne.value;
      if (oe && typeof oe == "object") {
        ne.typed = !0, ne.value = {};
        for (const ve in oe)
          if (_isValidObjectKey(oe, ve)) {
            const Pe = oe[ve], le = this.key._run(
              { typed: !1, value: ve },
              ie
            );
            if (le.issues) {
              const Je = {
                type: "object",
                origin: "key",
                input: oe,
                key: ve,
                value: Pe
              };
              for (const Ce of le.issues)
                Ce.path = [Je], (se = ne.issues) == null || se.push(Ce);
              if (ne.issues || (ne.issues = le.issues), ie.abortEarly) {
                ne.typed = !1;
                break;
              }
            }
            const Ee = this.value._run(
              { typed: !1, value: Pe },
              ie
            );
            if (Ee.issues) {
              const Je = {
                type: "object",
                origin: "value",
                input: oe,
                key: ve,
                value: Pe
              };
              for (const Ce of Ee.issues)
                Ce.path ? Ce.path.unshift(Je) : Ce.path = [Je], (ae = ne.issues) == null || ae.push(Ce);
              if (ne.issues || (ne.issues = Ee.issues), ie.abortEarly) {
                ne.typed = !1;
                break;
              }
            }
            (!le.typed || !Ee.typed) && (ne.typed = !1), le.typed && (ne.value[le.value] = Ee.value);
          }
      } else
        _addIssue(this, "type", ne, ie);
      return ne;
    }
  };
}
function string(B) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message: B,
    _run(z, Y) {
      return typeof z.value == "string" ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function _subIssues(B) {
  let z;
  if (B)
    for (const Y of B)
      z ? z.push(...Y.issues) : z = Y.issues;
  return z;
}
function union(B, z) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: _joinExpects(
      B.map((Y) => Y.expects),
      "|"
    ),
    async: !1,
    options: B,
    message: z,
    _run(Y, ne) {
      let ie, oe, se;
      for (const ae of this.options) {
        const ve = ae._run(
          { typed: !1, value: Y.value },
          ne
        );
        if (ve.typed)
          if (ve.issues)
            oe ? oe.push(ve) : oe = [ve];
          else {
            ie = ve;
            break;
          }
        else
          se ? se.push(ve) : se = [ve];
      }
      if (ie)
        return ie;
      if (oe) {
        if (oe.length === 1)
          return oe[0];
        _addIssue(this, "type", Y, ne, {
          issues: _subIssues(oe)
        }), Y.typed = !0;
      } else {
        if ((se == null ? void 0 : se.length) === 1)
          return se[0];
        _addIssue(this, "type", Y, ne, {
          issues: _subIssues(se)
        });
      }
      return Y;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(B) {
      return B.typed = !0, B;
    }
  };
}
function variant(B, z, Y) {
  return {
    kind: "schema",
    type: "variant",
    reference: variant,
    expects: "Object",
    async: !1,
    key: B,
    options: z,
    message: Y,
    _run(ne, ie) {
      const oe = ne.value;
      if (oe && typeof oe == "object") {
        let se, ae = 0, ve = this.key, Pe = [];
        const le = (Ee, Je) => {
          for (const Ce of Ee.options) {
            if (Ce.type === "variant")
              le(Ce, new Set(Je).add(Ce.key));
            else {
              let _t = !0, kt = 0;
              for (const Ct of Je) {
                if (Ce.entries[Ct]._run(
                  // @ts-expect-error
                  { typed: !1, value: oe[Ct] },
                  ie
                ).issues) {
                  _t = !1, ve !== Ct && (ae < kt || ae === kt && Ct in oe && !(ve in oe)) && (ae = kt, ve = Ct, Pe = []), ve === Ct && Pe.push(
                    Ce.entries[Ct].expects
                  );
                  break;
                }
                kt++;
              }
              if (_t) {
                const Ct = Ce._run(
                  { typed: !1, value: oe },
                  ie
                );
                (!se || !se.typed && Ct.typed) && (se = Ct);
              }
            }
            if (se && !se.issues)
              break;
          }
        };
        if (le(this, /* @__PURE__ */ new Set([this.key])), se)
          return se;
        _addIssue(this, "type", ne, ie, {
          // @ts-expect-error
          input: oe[ve],
          expected: _joinExpects(Pe, "|"),
          path: [
            {
              type: "object",
              origin: "value",
              input: oe,
              key: ve,
              // @ts-expect-error
              value: oe[ve]
            }
          ]
        });
      } else
        _addIssue(this, "type", ne, ie);
      return ne;
    }
  };
}
function omit(B, z) {
  const Y = {
    ...B.entries
  };
  for (const ne of z)
    delete Y[ne];
  return { ...B, entries: Y };
}
function pipe(...B) {
  return {
    ...B[0],
    pipe: B,
    _run(z, Y) {
      for (const ne of B)
        if (ne.kind !== "metadata") {
          if (z.issues && (ne.kind === "schema" || ne.kind === "transformation")) {
            z.typed = !1;
            break;
          }
          (!z.issues || !Y.abortEarly && !Y.abortPipeEarly) && (z = ne._run(z, Y));
        }
      return z;
    }
  };
}
function unwrap(B) {
  return B.wrapped;
}
var lib$1 = {}, signer = {}, base64Url = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(B) {
  var z = B.length;
  if (z % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var Y = B.indexOf("=");
  Y === -1 && (Y = z);
  var ne = Y === z ? 0 : 4 - Y % 4;
  return [Y, ne];
}
function byteLength(B) {
  var z = getLens(B), Y = z[0], ne = z[1];
  return (Y + ne) * 3 / 4 - ne;
}
function _byteLength(B, z, Y) {
  return (z + Y) * 3 / 4 - Y;
}
function toByteArray(B) {
  var z, Y = getLens(B), ne = Y[0], ie = Y[1], oe = new Arr(_byteLength(B, ne, ie)), se = 0, ae = ie > 0 ? ne - 4 : ne, ve;
  for (ve = 0; ve < ae; ve += 4)
    z = revLookup[B.charCodeAt(ve)] << 18 | revLookup[B.charCodeAt(ve + 1)] << 12 | revLookup[B.charCodeAt(ve + 2)] << 6 | revLookup[B.charCodeAt(ve + 3)], oe[se++] = z >> 16 & 255, oe[se++] = z >> 8 & 255, oe[se++] = z & 255;
  return ie === 2 && (z = revLookup[B.charCodeAt(ve)] << 2 | revLookup[B.charCodeAt(ve + 1)] >> 4, oe[se++] = z & 255), ie === 1 && (z = revLookup[B.charCodeAt(ve)] << 10 | revLookup[B.charCodeAt(ve + 1)] << 4 | revLookup[B.charCodeAt(ve + 2)] >> 2, oe[se++] = z >> 8 & 255, oe[se++] = z & 255), oe;
}
function tripletToBase64(B) {
  return lookup[B >> 18 & 63] + lookup[B >> 12 & 63] + lookup[B >> 6 & 63] + lookup[B & 63];
}
function encodeChunk(B, z, Y) {
  for (var ne, ie = [], oe = z; oe < Y; oe += 3)
    ne = (B[oe] << 16 & 16711680) + (B[oe + 1] << 8 & 65280) + (B[oe + 2] & 255), ie.push(tripletToBase64(ne));
  return ie.join("");
}
function fromByteArray(B) {
  for (var z, Y = B.length, ne = Y % 3, ie = [], oe = 16383, se = 0, ae = Y - ne; se < ae; se += oe)
    ie.push(encodeChunk(B, se, se + oe > ae ? ae : se + oe));
  return ne === 1 ? (z = B[Y - 1], ie.push(
    lookup[z >> 2] + lookup[z << 4 & 63] + "=="
  )) : ne === 2 && (z = (B[Y - 2] << 8) + B[Y - 1], ie.push(
    lookup[z >> 10] + lookup[z >> 4 & 63] + lookup[z << 2 & 63] + "="
  )), ie.join("");
}
Object.defineProperty(base64Url, "__esModule", { value: !0 });
base64Url.decode = base64Url.encode = base64Url.unescape = base64Url.escape = base64Url.pad = void 0;
const base64_js_1$1 = base64Js;
function pad(B) {
  return `${B}${"=".repeat(4 - (B.length % 4 || 4))}`;
}
base64Url.pad = pad;
function escape(B) {
  return B.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
base64Url.escape = escape;
function unescape(B) {
  return pad(B).replace(/-/g, "+").replace(/_/g, "/");
}
base64Url.unescape = unescape;
function encode$j(B) {
  return escape((0, base64_js_1$1.fromByteArray)(new TextEncoder().encode(B)));
}
base64Url.encode = encode$j;
function decode$j(B) {
  return new TextDecoder().decode((0, base64_js_1$1.toByteArray)(pad(unescape(B))));
}
base64Url.decode = decode$j;
var cryptoClients = {}, secp256k1$1 = {}, hmac$1 = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.anumber = anumber;
_assert.abytes = abytes;
_assert.ahash = ahash;
_assert.aexists = aexists;
_assert.aoutput = aoutput;
function anumber(B) {
  if (!Number.isSafeInteger(B) || B < 0)
    throw new Error("positive integer expected, got " + B);
}
function isBytes(B) {
  return B instanceof Uint8Array || ArrayBuffer.isView(B) && B.constructor.name === "Uint8Array";
}
function abytes(B, ...z) {
  if (!isBytes(B))
    throw new Error("Uint8Array expected");
  if (z.length > 0 && !z.includes(B.length))
    throw new Error("Uint8Array expected of length " + z + ", got length=" + B.length);
}
function ahash(B) {
  if (typeof B != "function" || typeof B.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber(B.outputLen), anumber(B.blockLen);
}
function aexists(B, z = !0) {
  if (B.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (z && B.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(B, z) {
  abytes(B);
  const Y = z.outputLen;
  if (B.length < Y)
    throw new Error("digestInto() expects output buffer of length at least " + Y);
}
var utils$p = {}, crypto$4 = {};
Object.defineProperty(crypto$4, "__esModule", { value: !0 });
crypto$4.crypto = void 0;
crypto$4.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(B) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.Hash = B.nextTick = B.byteSwapIfBE = B.isLE = void 0, B.isBytes = ne, B.u8 = ie, B.u32 = oe, B.createView = se, B.rotr = ae, B.rotl = ve, B.byteSwap = Pe, B.byteSwap32 = le, B.bytesToHex = Je, B.hexToBytes = kt, B.asyncLoop = Lt, B.utf8ToBytes = Pt, B.toBytes = Ft, B.concatBytes = Ut, B.checkOpts = Vt, B.wrapConstructor = ir, B.wrapConstructorWithOpts = jt, B.wrapXOFConstructorWithOpts = Rt, B.randomBytes = Kt;
  const z = crypto$4, Y = _assert;
  function ne(Bt) {
    return Bt instanceof Uint8Array || ArrayBuffer.isView(Bt) && Bt.constructor.name === "Uint8Array";
  }
  function ie(Bt) {
    return new Uint8Array(Bt.buffer, Bt.byteOffset, Bt.byteLength);
  }
  function oe(Bt) {
    return new Uint32Array(Bt.buffer, Bt.byteOffset, Math.floor(Bt.byteLength / 4));
  }
  function se(Bt) {
    return new DataView(Bt.buffer, Bt.byteOffset, Bt.byteLength);
  }
  function ae(Bt, Xe) {
    return Bt << 32 - Xe | Bt >>> Xe;
  }
  function ve(Bt, Xe) {
    return Bt << Xe | Bt >>> 32 - Xe >>> 0;
  }
  B.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  function Pe(Bt) {
    return Bt << 24 & 4278190080 | Bt << 8 & 16711680 | Bt >>> 8 & 65280 | Bt >>> 24 & 255;
  }
  B.byteSwapIfBE = B.isLE ? (Bt) => Bt : (Bt) => Pe(Bt);
  function le(Bt) {
    for (let Xe = 0; Xe < Bt.length; Xe++)
      Bt[Xe] = Pe(Bt[Xe]);
  }
  const Ee = /* @__PURE__ */ Array.from({ length: 256 }, (Bt, Xe) => Xe.toString(16).padStart(2, "0"));
  function Je(Bt) {
    (0, Y.abytes)(Bt);
    let Xe = "";
    for (let Ve = 0; Ve < Bt.length; Ve++)
      Xe += Ee[Bt[Ve]];
    return Xe;
  }
  const Ce = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function _t(Bt) {
    if (Bt >= Ce._0 && Bt <= Ce._9)
      return Bt - Ce._0;
    if (Bt >= Ce.A && Bt <= Ce.F)
      return Bt - (Ce.A - 10);
    if (Bt >= Ce.a && Bt <= Ce.f)
      return Bt - (Ce.a - 10);
  }
  function kt(Bt) {
    if (typeof Bt != "string")
      throw new Error("hex string expected, got " + typeof Bt);
    const Xe = Bt.length, Ve = Xe / 2;
    if (Xe % 2)
      throw new Error("hex string expected, got unpadded hex of length " + Xe);
    const ge = new Uint8Array(Ve);
    for (let Ke = 0, ht = 0; Ke < Ve; Ke++, ht += 2) {
      const wt = _t(Bt.charCodeAt(ht)), vt = _t(Bt.charCodeAt(ht + 1));
      if (wt === void 0 || vt === void 0) {
        const $t = Bt[ht] + Bt[ht + 1];
        throw new Error('hex string expected, got non-hex character "' + $t + '" at index ' + ht);
      }
      ge[Ke] = wt * 16 + vt;
    }
    return ge;
  }
  const Ct = async () => {
  };
  B.nextTick = Ct;
  async function Lt(Bt, Xe, Ve) {
    let ge = Date.now();
    for (let Ke = 0; Ke < Bt; Ke++) {
      Ve(Ke);
      const ht = Date.now() - ge;
      ht >= 0 && ht < Xe || (await (0, B.nextTick)(), ge += ht);
    }
  }
  function Pt(Bt) {
    if (typeof Bt != "string")
      throw new Error("utf8ToBytes expected string, got " + typeof Bt);
    return new Uint8Array(new TextEncoder().encode(Bt));
  }
  function Ft(Bt) {
    return typeof Bt == "string" && (Bt = Pt(Bt)), (0, Y.abytes)(Bt), Bt;
  }
  function Ut(...Bt) {
    let Xe = 0;
    for (let ge = 0; ge < Bt.length; ge++) {
      const Ke = Bt[ge];
      (0, Y.abytes)(Ke), Xe += Ke.length;
    }
    const Ve = new Uint8Array(Xe);
    for (let ge = 0, Ke = 0; ge < Bt.length; ge++) {
      const ht = Bt[ge];
      Ve.set(ht, Ke), Ke += ht.length;
    }
    return Ve;
  }
  class Jt {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  B.Hash = Jt;
  function Vt(Bt, Xe) {
    if (Xe !== void 0 && {}.toString.call(Xe) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(Bt, Xe);
  }
  function ir(Bt) {
    const Xe = (ge) => Bt().update(Ft(ge)).digest(), Ve = Bt();
    return Xe.outputLen = Ve.outputLen, Xe.blockLen = Ve.blockLen, Xe.create = () => Bt(), Xe;
  }
  function jt(Bt) {
    const Xe = (ge, Ke) => Bt(Ke).update(Ft(ge)).digest(), Ve = Bt({});
    return Xe.outputLen = Ve.outputLen, Xe.blockLen = Ve.blockLen, Xe.create = (ge) => Bt(ge), Xe;
  }
  function Rt(Bt) {
    const Xe = (ge, Ke) => Bt(Ke).update(Ft(ge)).digest(), Ve = Bt({});
    return Xe.outputLen = Ve.outputLen, Xe.blockLen = Ve.blockLen, Xe.create = (ge) => Bt(ge), Xe;
  }
  function Kt(Bt = 32) {
    if (z.crypto && typeof z.crypto.getRandomValues == "function")
      return z.crypto.getRandomValues(new Uint8Array(Bt));
    if (z.crypto && typeof z.crypto.randomBytes == "function")
      return z.crypto.randomBytes(Bt);
    throw new Error("crypto.getRandomValues must be defined");
  }
})(utils$p);
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.hmac = B.HMAC = void 0;
  const z = _assert, Y = utils$p;
  class ne extends Y.Hash {
    constructor(se, ae) {
      super(), this.finished = !1, this.destroyed = !1, (0, z.ahash)(se);
      const ve = (0, Y.toBytes)(ae);
      if (this.iHash = se.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const Pe = this.blockLen, le = new Uint8Array(Pe);
      le.set(ve.length > Pe ? se.create().update(ve).digest() : ve);
      for (let Ee = 0; Ee < le.length; Ee++)
        le[Ee] ^= 54;
      this.iHash.update(le), this.oHash = se.create();
      for (let Ee = 0; Ee < le.length; Ee++)
        le[Ee] ^= 106;
      this.oHash.update(le), le.fill(0);
    }
    update(se) {
      return (0, z.aexists)(this), this.iHash.update(se), this;
    }
    digestInto(se) {
      (0, z.aexists)(this), (0, z.abytes)(se, this.outputLen), this.finished = !0, this.iHash.digestInto(se), this.oHash.update(se), this.oHash.digestInto(se), this.destroy();
    }
    digest() {
      const se = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(se), se;
    }
    _cloneInto(se) {
      se || (se = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: ae, iHash: ve, finished: Pe, destroyed: le, blockLen: Ee, outputLen: Je } = this;
      return se = se, se.finished = Pe, se.destroyed = le, se.blockLen = Ee, se.outputLen = Je, se.oHash = ae._cloneInto(se.oHash), se.iHash = ve._cloneInto(se.iHash), se;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  B.HMAC = ne;
  const ie = (oe, se, ae) => new ne(oe, se).update(ae).digest();
  B.hmac = ie, B.hmac.create = (oe, se) => new ne(oe, se);
})(hmac$1);
var sha256$4 = {}, _md = {};
Object.defineProperty(_md, "__esModule", { value: !0 });
_md.HashMD = void 0;
_md.setBigUint64 = setBigUint64;
_md.Chi = Chi;
_md.Maj = Maj;
const _assert_js_1 = _assert, utils_js_1$3 = utils$p;
function setBigUint64(B, z, Y, ne) {
  if (typeof B.setBigUint64 == "function")
    return B.setBigUint64(z, Y, ne);
  const ie = BigInt(32), oe = BigInt(4294967295), se = Number(Y >> ie & oe), ae = Number(Y & oe), ve = ne ? 4 : 0, Pe = ne ? 0 : 4;
  B.setUint32(z + ve, se, ne), B.setUint32(z + Pe, ae, ne);
}
function Chi(B, z, Y) {
  return B & z ^ ~B & Y;
}
function Maj(B, z, Y) {
  return B & z ^ B & Y ^ z & Y;
}
class HashMD extends utils_js_1$3.Hash {
  constructor(z, Y, ne, ie) {
    super(), this.blockLen = z, this.outputLen = Y, this.padOffset = ne, this.isLE = ie, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(z), this.view = (0, utils_js_1$3.createView)(this.buffer);
  }
  update(z) {
    (0, _assert_js_1.aexists)(this);
    const { view: Y, buffer: ne, blockLen: ie } = this;
    z = (0, utils_js_1$3.toBytes)(z);
    const oe = z.length;
    for (let se = 0; se < oe; ) {
      const ae = Math.min(ie - this.pos, oe - se);
      if (ae === ie) {
        const ve = (0, utils_js_1$3.createView)(z);
        for (; ie <= oe - se; se += ie)
          this.process(ve, se);
        continue;
      }
      ne.set(z.subarray(se, se + ae), this.pos), this.pos += ae, se += ae, this.pos === ie && (this.process(Y, 0), this.pos = 0);
    }
    return this.length += z.length, this.roundClean(), this;
  }
  digestInto(z) {
    (0, _assert_js_1.aexists)(this), (0, _assert_js_1.aoutput)(z, this), this.finished = !0;
    const { buffer: Y, view: ne, blockLen: ie, isLE: oe } = this;
    let { pos: se } = this;
    Y[se++] = 128, this.buffer.subarray(se).fill(0), this.padOffset > ie - se && (this.process(ne, 0), se = 0);
    for (let Ee = se; Ee < ie; Ee++)
      Y[Ee] = 0;
    setBigUint64(ne, ie - 8, BigInt(this.length * 8), oe), this.process(ne, 0);
    const ae = (0, utils_js_1$3.createView)(z), ve = this.outputLen;
    if (ve % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const Pe = ve / 4, le = this.get();
    if (Pe > le.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let Ee = 0; Ee < Pe; Ee++)
      ae.setUint32(4 * Ee, le[Ee], oe);
  }
  digest() {
    const { buffer: z, outputLen: Y } = this;
    this.digestInto(z);
    const ne = z.slice(0, Y);
    return this.destroy(), ne;
  }
  _cloneInto(z) {
    z || (z = new this.constructor()), z.set(...this.get());
    const { blockLen: Y, buffer: ne, length: ie, finished: oe, destroyed: se, pos: ae } = this;
    return z.length = ie, z.pos = ae, z.finished = oe, z.destroyed = se, ie % Y && z.buffer.set(ne), z;
  }
}
_md.HashMD = HashMD;
Object.defineProperty(sha256$4, "__esModule", { value: !0 });
sha256$4.sha224 = sha256$4.sha256 = sha256$4.SHA256 = void 0;
const _md_js_1$2 = _md, utils_js_1$2 = utils$p, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
let SHA256$2 = class extends _md_js_1$2.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: z, B: Y, C: ne, D: ie, E: oe, F: se, G: ae, H: ve } = this;
    return [z, Y, ne, ie, oe, se, ae, ve];
  }
  // prettier-ignore
  set(z, Y, ne, ie, oe, se, ae, ve) {
    this.A = z | 0, this.B = Y | 0, this.C = ne | 0, this.D = ie | 0, this.E = oe | 0, this.F = se | 0, this.G = ae | 0, this.H = ve | 0;
  }
  process(z, Y) {
    for (let Ee = 0; Ee < 16; Ee++, Y += 4)
      SHA256_W[Ee] = z.getUint32(Y, !1);
    for (let Ee = 16; Ee < 64; Ee++) {
      const Je = SHA256_W[Ee - 15], Ce = SHA256_W[Ee - 2], _t = (0, utils_js_1$2.rotr)(Je, 7) ^ (0, utils_js_1$2.rotr)(Je, 18) ^ Je >>> 3, kt = (0, utils_js_1$2.rotr)(Ce, 17) ^ (0, utils_js_1$2.rotr)(Ce, 19) ^ Ce >>> 10;
      SHA256_W[Ee] = kt + SHA256_W[Ee - 7] + _t + SHA256_W[Ee - 16] | 0;
    }
    let { A: ne, B: ie, C: oe, D: se, E: ae, F: ve, G: Pe, H: le } = this;
    for (let Ee = 0; Ee < 64; Ee++) {
      const Je = (0, utils_js_1$2.rotr)(ae, 6) ^ (0, utils_js_1$2.rotr)(ae, 11) ^ (0, utils_js_1$2.rotr)(ae, 25), Ce = le + Je + (0, _md_js_1$2.Chi)(ae, ve, Pe) + SHA256_K[Ee] + SHA256_W[Ee] | 0, kt = ((0, utils_js_1$2.rotr)(ne, 2) ^ (0, utils_js_1$2.rotr)(ne, 13) ^ (0, utils_js_1$2.rotr)(ne, 22)) + (0, _md_js_1$2.Maj)(ne, ie, oe) | 0;
      le = Pe, Pe = ve, ve = ae, ae = se + Ce | 0, se = oe, oe = ie, ie = ne, ne = Ce + kt | 0;
    }
    ne = ne + this.A | 0, ie = ie + this.B | 0, oe = oe + this.C | 0, se = se + this.D | 0, ae = ae + this.E | 0, ve = ve + this.F | 0, Pe = Pe + this.G | 0, le = le + this.H | 0, this.set(ne, ie, oe, se, ae, ve, Pe, le);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
sha256$4.SHA256 = SHA256$2;
let SHA224$1 = class extends SHA256$2 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
sha256$4.sha256 = (0, utils_js_1$2.wrapConstructor)(() => new SHA256$2());
sha256$4.sha224 = (0, utils_js_1$2.wrapConstructor)(() => new SHA224$1());
var lib = {}, cryptoBrowserify = {}, browser$b = { exports: {} }, safeBuffer$2 = { exports: {} };
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(dist$1);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(B, z) {
  var Y = require$$0$1, ne = Y.Buffer;
  function ie(se, ae) {
    for (var ve in se)
      ae[ve] = se[ve];
  }
  ne.from && ne.alloc && ne.allocUnsafe && ne.allocUnsafeSlow ? B.exports = Y : (ie(Y, z), z.Buffer = oe);
  function oe(se, ae, ve) {
    return ne(se, ae, ve);
  }
  oe.prototype = Object.create(ne.prototype), ie(ne, oe), oe.from = function(se, ae, ve) {
    if (typeof se == "number")
      throw new TypeError("Argument must not be a number");
    return ne(se, ae, ve);
  }, oe.alloc = function(se, ae, ve) {
    if (typeof se != "number")
      throw new TypeError("Argument must be a number");
    var Pe = ne(se);
    return ae !== void 0 ? typeof ve == "string" ? Pe.fill(ae, ve) : Pe.fill(ae) : Pe.fill(0), Pe;
  }, oe.allocUnsafe = function(se) {
    if (typeof se != "number")
      throw new TypeError("Argument must be a number");
    return ne(se);
  }, oe.allocUnsafeSlow = function(se) {
    if (typeof se != "number")
      throw new TypeError("Argument must be a number");
    return Y.SlowBuffer(se);
  };
})(safeBuffer$2, safeBuffer$2.exports);
var safeBufferExports$1 = safeBuffer$2.exports, MAX_BYTES = 65536, MAX_UINT32 = 4294967295;
function oldBrowser$1() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Buffer$C = safeBufferExports$1.Buffer, crypto$3 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
crypto$3 && crypto$3.getRandomValues ? browser$b.exports = randomBytes$2 : browser$b.exports = oldBrowser$1;
function randomBytes$2(B, z) {
  if (B > MAX_UINT32) throw new RangeError("requested too many random bytes");
  var Y = Buffer$C.allocUnsafe(B);
  if (B > 0)
    if (B > MAX_BYTES)
      for (var ne = 0; ne < B; ne += MAX_BYTES)
        crypto$3.getRandomValues(Y.slice(ne, ne + MAX_BYTES));
    else
      crypto$3.getRandomValues(Y);
  return typeof z == "function" ? process$1.nextTick(function() {
    z(null, Y);
  }) : Y;
}
var browserExports = browser$b.exports, inherits_browser = { exports: {} };
typeof Object.create == "function" ? inherits_browser.exports = function(z, Y) {
  Y && (z.super_ = Y, z.prototype = Object.create(Y.prototype, {
    constructor: {
      value: z,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser.exports = function(z, Y) {
  if (Y) {
    z.super_ = Y;
    var ne = function() {
    };
    ne.prototype = Y.prototype, z.prototype = new ne(), z.prototype.constructor = z;
  }
};
var inherits_browserExports = inherits_browser.exports, readableBrowser$1 = { exports: {} }, events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function(z, Y, ne) {
  return Function.prototype.apply.call(z, Y, ne);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(z) {
  return Object.getOwnPropertyNames(z).concat(Object.getOwnPropertySymbols(z));
} : ReflectOwnKeys = function(z) {
  return Object.getOwnPropertyNames(z);
};
function ProcessEmitWarning(B) {
  console && console.warn && console.warn(B);
}
var NumberIsNaN = Number.isNaN || function(z) {
  return z !== z;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(B) {
  if (typeof B != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof B);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(B) {
    if (typeof B != "number" || B < 0 || NumberIsNaN(B))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + B + ".");
    defaultMaxListeners = B;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function(z) {
  if (typeof z != "number" || z < 0 || NumberIsNaN(z))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + z + ".");
  return this._maxListeners = z, this;
};
function _getMaxListeners(B) {
  return B._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : B._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function(z) {
  for (var Y = [], ne = 1; ne < arguments.length; ne++) Y.push(arguments[ne]);
  var ie = z === "error", oe = this._events;
  if (oe !== void 0)
    ie = ie && oe.error === void 0;
  else if (!ie)
    return !1;
  if (ie) {
    var se;
    if (Y.length > 0 && (se = Y[0]), se instanceof Error)
      throw se;
    var ae = new Error("Unhandled error." + (se ? " (" + se.message + ")" : ""));
    throw ae.context = se, ae;
  }
  var ve = oe[z];
  if (ve === void 0)
    return !1;
  if (typeof ve == "function")
    ReflectApply(ve, this, Y);
  else
    for (var Pe = ve.length, le = arrayClone(ve, Pe), ne = 0; ne < Pe; ++ne)
      ReflectApply(le[ne], this, Y);
  return !0;
};
function _addListener(B, z, Y, ne) {
  var ie, oe, se;
  if (checkListener(Y), oe = B._events, oe === void 0 ? (oe = B._events = /* @__PURE__ */ Object.create(null), B._eventsCount = 0) : (oe.newListener !== void 0 && (B.emit(
    "newListener",
    z,
    Y.listener ? Y.listener : Y
  ), oe = B._events), se = oe[z]), se === void 0)
    se = oe[z] = Y, ++B._eventsCount;
  else if (typeof se == "function" ? se = oe[z] = ne ? [Y, se] : [se, Y] : ne ? se.unshift(Y) : se.push(Y), ie = _getMaxListeners(B), ie > 0 && se.length > ie && !se.warned) {
    se.warned = !0;
    var ae = new Error("Possible EventEmitter memory leak detected. " + se.length + " " + String(z) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    ae.name = "MaxListenersExceededWarning", ae.emitter = B, ae.type = z, ae.count = se.length, ProcessEmitWarning(ae);
  }
  return B;
}
EventEmitter.prototype.addListener = function(z, Y) {
  return _addListener(this, z, Y, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function(z, Y) {
  return _addListener(this, z, Y, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(B, z, Y) {
  var ne = { fired: !1, wrapFn: void 0, target: B, type: z, listener: Y }, ie = onceWrapper.bind(ne);
  return ie.listener = Y, ne.wrapFn = ie, ie;
}
EventEmitter.prototype.once = function(z, Y) {
  return checkListener(Y), this.on(z, _onceWrap(this, z, Y)), this;
};
EventEmitter.prototype.prependOnceListener = function(z, Y) {
  return checkListener(Y), this.prependListener(z, _onceWrap(this, z, Y)), this;
};
EventEmitter.prototype.removeListener = function(z, Y) {
  var ne, ie, oe, se, ae;
  if (checkListener(Y), ie = this._events, ie === void 0)
    return this;
  if (ne = ie[z], ne === void 0)
    return this;
  if (ne === Y || ne.listener === Y)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete ie[z], ie.removeListener && this.emit("removeListener", z, ne.listener || Y));
  else if (typeof ne != "function") {
    for (oe = -1, se = ne.length - 1; se >= 0; se--)
      if (ne[se] === Y || ne[se].listener === Y) {
        ae = ne[se].listener, oe = se;
        break;
      }
    if (oe < 0)
      return this;
    oe === 0 ? ne.shift() : spliceOne(ne, oe), ne.length === 1 && (ie[z] = ne[0]), ie.removeListener !== void 0 && this.emit("removeListener", z, ae || Y);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function(z) {
  var Y, ne, ie;
  if (ne = this._events, ne === void 0)
    return this;
  if (ne.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : ne[z] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete ne[z]), this;
  if (arguments.length === 0) {
    var oe = Object.keys(ne), se;
    for (ie = 0; ie < oe.length; ++ie)
      se = oe[ie], se !== "removeListener" && this.removeAllListeners(se);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (Y = ne[z], typeof Y == "function")
    this.removeListener(z, Y);
  else if (Y !== void 0)
    for (ie = Y.length - 1; ie >= 0; ie--)
      this.removeListener(z, Y[ie]);
  return this;
};
function _listeners(B, z, Y) {
  var ne = B._events;
  if (ne === void 0)
    return [];
  var ie = ne[z];
  return ie === void 0 ? [] : typeof ie == "function" ? Y ? [ie.listener || ie] : [ie] : Y ? unwrapListeners(ie) : arrayClone(ie, ie.length);
}
EventEmitter.prototype.listeners = function(z) {
  return _listeners(this, z, !0);
};
EventEmitter.prototype.rawListeners = function(z) {
  return _listeners(this, z, !1);
};
EventEmitter.listenerCount = function(B, z) {
  return typeof B.listenerCount == "function" ? B.listenerCount(z) : listenerCount.call(B, z);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(B) {
  var z = this._events;
  if (z !== void 0) {
    var Y = z[B];
    if (typeof Y == "function")
      return 1;
    if (Y !== void 0)
      return Y.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(B, z) {
  for (var Y = new Array(z), ne = 0; ne < z; ++ne)
    Y[ne] = B[ne];
  return Y;
}
function spliceOne(B, z) {
  for (; z + 1 < B.length; z++)
    B[z] = B[z + 1];
  B.pop();
}
function unwrapListeners(B) {
  for (var z = new Array(B.length), Y = 0; Y < z.length; ++Y)
    z[Y] = B[Y].listener || B[Y];
  return z;
}
function once(B, z) {
  return new Promise(function(Y, ne) {
    function ie(se) {
      B.removeListener(z, oe), ne(se);
    }
    function oe() {
      typeof B.removeListener == "function" && B.removeListener("error", ie), Y([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(B, z, oe, { once: !0 }), z !== "error" && addErrorHandlerIfEventEmitter(B, ie, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(B, z, Y) {
  typeof B.on == "function" && eventTargetAgnosticAddListener(B, "error", z, Y);
}
function eventTargetAgnosticAddListener(B, z, Y, ne) {
  if (typeof B.on == "function")
    ne.once ? B.once(z, Y) : B.on(z, Y);
  else if (typeof B.addEventListener == "function")
    B.addEventListener(z, function ie(oe) {
      ne.once && B.removeEventListener(z, ie), Y(oe);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof B);
}
var eventsExports = events.exports, streamBrowser$1, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser$1 = eventsExports.EventEmitter), streamBrowser$1;
}
var util$3 = {}, types$5 = {}, shams$1 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var z = {}, Y = Symbol("test"), ne = Object(Y);
  if (typeof Y == "string" || Object.prototype.toString.call(Y) !== "[object Symbol]" || Object.prototype.toString.call(ne) !== "[object Symbol]")
    return !1;
  var ie = 42;
  z[Y] = ie;
  for (var oe in z)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(z).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(z).length !== 0)
    return !1;
  var se = Object.getOwnPropertySymbols(z);
  if (se.length !== 1 || se[0] !== Y || !Object.prototype.propertyIsEnumerable.call(z, Y))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var ae = (
      /** @type {PropertyDescriptor} */
      Object.getOwnPropertyDescriptor(z, Y)
    );
    if (ae.value !== ie || ae.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esObjectAtoms = Object, esErrors = Error, _eval = EvalError, range$3 = RangeError, ref = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, abs$1 = Math.abs, floor$1 = Math.floor, max$2 = Math.max, min$1 = Math.min, pow$1 = Math.pow, round$1 = Math.round, _isNaN = Number.isNaN || function(z) {
  return z !== z;
}, $isNaN = _isNaN, sign$2 = function(z) {
  return $isNaN(z) || z === 0 ? z : z < 0 ? -1 : 1;
}, gOPD$3 = Object.getOwnPropertyDescriptor, $gOPD$1 = gOPD$3;
if ($gOPD$1)
  try {
    $gOPD$1([], "length");
  } catch {
    $gOPD$1 = null;
  }
var gopd$1 = $gOPD$1, $defineProperty$3 = Object.defineProperty || !1;
if ($defineProperty$3)
  try {
    $defineProperty$3({}, "a", { value: 1 });
  } catch {
    $defineProperty$3 = !1;
  }
var esDefineProperty = $defineProperty$3, hasSymbols$1, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols$1;
  hasRequiredHasSymbols = 1;
  var B = typeof Symbol < "u" && Symbol, z = shams$1;
  return hasSymbols$1 = function() {
    return typeof B != "function" || typeof Symbol != "function" || typeof B("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : z();
  }, hasSymbols$1;
}
var Reflect_getPrototypeOf, hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  return hasRequiredReflect_getPrototypeOf || (hasRequiredReflect_getPrototypeOf = 1, Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Reflect_getPrototypeOf;
}
var Object_getPrototypeOf, hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var B = esObjectAtoms;
  return Object_getPrototypeOf = B.getPrototypeOf || null, Object_getPrototypeOf;
}
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$3 = Object.prototype.toString, max$1 = Math.max, funcType = "[object Function]", concatty = function(z, Y) {
  for (var ne = [], ie = 0; ie < z.length; ie += 1)
    ne[ie] = z[ie];
  for (var oe = 0; oe < Y.length; oe += 1)
    ne[oe + z.length] = Y[oe];
  return ne;
}, slicy = function(z, Y) {
  for (var ne = [], ie = Y, oe = 0; ie < z.length; ie += 1, oe += 1)
    ne[oe] = z[ie];
  return ne;
}, joiny = function(B, z) {
  for (var Y = "", ne = 0; ne < B.length; ne += 1)
    Y += B[ne], ne + 1 < B.length && (Y += z);
  return Y;
}, implementation$1 = function(z) {
  var Y = this;
  if (typeof Y != "function" || toStr$3.apply(Y) !== funcType)
    throw new TypeError(ERROR_MESSAGE + Y);
  for (var ne = slicy(arguments, 1), ie, oe = function() {
    if (this instanceof ie) {
      var le = Y.apply(
        this,
        concatty(ne, arguments)
      );
      return Object(le) === le ? le : this;
    }
    return Y.apply(
      z,
      concatty(ne, arguments)
    );
  }, se = max$1(0, Y.length - ne.length), ae = [], ve = 0; ve < se; ve++)
    ae[ve] = "$" + ve;
  if (ie = Function("binder", "return function (" + joiny(ae, ",") + "){ return binder.apply(this,arguments); }")(oe), Y.prototype) {
    var Pe = function() {
    };
    Pe.prototype = Y.prototype, ie.prototype = new Pe(), Pe.prototype = null;
  }
  return ie;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, functionCall = Function.prototype.call, functionApply = Function.prototype.apply, reflectApply$1 = typeof Reflect < "u" && Reflect && Reflect.apply, bind$4 = functionBind, $apply$2 = functionApply, $call$2 = functionCall, $reflectApply = reflectApply$1, actualApply$1 = $reflectApply || bind$4.call($call$2, $apply$2), bind$3 = functionBind, $TypeError$4 = type, $call$1 = functionCall, $actualApply = actualApply$1, callBindApplyHelpers = function(z) {
  if (z.length < 1 || typeof z[0] != "function")
    throw new $TypeError$4("a function is required");
  return $actualApply(bind$3, $call$1, z);
}, get, hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var B = callBindApplyHelpers, z = gopd$1, Y;
  try {
    Y = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (se) {
    if (!se || typeof se != "object" || !("code" in se) || se.code !== "ERR_PROTO_ACCESS")
      throw se;
  }
  var ne = !!Y && z && z(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), ie = Object, oe = ie.getPrototypeOf;
  return get = ne && typeof ne.get == "function" ? B([ne.get]) : typeof oe == "function" ? (
    /** @type {import('./get')} */
    function(ae) {
      return oe(ae == null ? ae : ie(ae));
    }
  ) : !1, get;
}
var getProto$2, hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto$2;
  hasRequiredGetProto = 1;
  var B = requireReflect_getPrototypeOf(), z = requireObject_getPrototypeOf(), Y = requireGet();
  return getProto$2 = B ? function(ie) {
    return B(ie);
  } : z ? function(ie) {
    if (!ie || typeof ie != "object" && typeof ie != "function")
      throw new TypeError("getProto: not an object");
    return z(ie);
  } : Y ? function(ie) {
    return Y(ie);
  } : null, getProto$2;
}
var call = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$2 = functionBind, hasown = bind$2.call(call, $hasOwn), undefined$1, $Object = esObjectAtoms, $Error = esErrors, $EvalError = _eval, $RangeError = range$3, $ReferenceError = ref, $SyntaxError$1 = syntax, $TypeError$3 = type, $URIError = uri, abs = abs$1, floor = floor$1, max = max$2, min = min$1, pow = pow$1, round = round$1, sign$1 = sign$2, $Function = Function, getEvalledConstructor = function(B) {
  try {
    return $Function('"use strict"; return (' + B + ").constructor;")();
  } catch {
  }
}, $gOPD = gopd$1, $defineProperty$2 = esDefineProperty, throwTypeError = function() {
  throw new $TypeError$3();
}, ThrowTypeError = $gOPD ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = requireHasSymbols()(), getProto$1 = requireGetProto(), $ObjectGPO = requireObject_getPrototypeOf(), $ReflectGPO = requireReflect_getPrototypeOf(), $apply$1 = functionApply, $call = functionCall, needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": $Object,
  "%Object.getOwnPropertyDescriptor%": $gOPD,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet,
  "%Function.prototype.call%": $call,
  "%Function.prototype.apply%": $apply$1,
  "%Object.defineProperty%": $defineProperty$2,
  "%Object.getPrototypeOf%": $ObjectGPO,
  "%Math.abs%": abs,
  "%Math.floor%": floor,
  "%Math.max%": max,
  "%Math.min%": min,
  "%Math.pow%": pow,
  "%Math.round%": round,
  "%Math.sign%": sign$1,
  "%Reflect.getPrototypeOf%": $ReflectGPO
};
if (getProto$1)
  try {
    null.error;
  } catch (B) {
    var errorProto = getProto$1(getProto$1(B));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function B(z) {
  var Y;
  if (z === "%AsyncFunction%")
    Y = getEvalledConstructor("async function () {}");
  else if (z === "%GeneratorFunction%")
    Y = getEvalledConstructor("function* () {}");
  else if (z === "%AsyncGeneratorFunction%")
    Y = getEvalledConstructor("async function* () {}");
  else if (z === "%AsyncGenerator%") {
    var ne = B("%AsyncGeneratorFunction%");
    ne && (Y = ne.prototype);
  } else if (z === "%AsyncIteratorPrototype%") {
    var ie = B("%AsyncGenerator%");
    ie && getProto$1 && (Y = getProto$1(ie.prototype));
  }
  return INTRINSICS[z] = Y, Y;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind$1 = functionBind, hasOwn$1 = hasown, $concat = bind$1.call($call, Array.prototype.concat), $spliceApply = bind$1.call($apply$1, Array.prototype.splice), $replace = bind$1.call($call, String.prototype.replace), $strSlice = bind$1.call($call, String.prototype.slice), $exec$2 = bind$1.call($call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function(z) {
  var Y = $strSlice(z, 0, 1), ne = $strSlice(z, -1);
  if (Y === "%" && ne !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (ne === "%" && Y !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var ie = [];
  return $replace(z, rePropName, function(oe, se, ae, ve) {
    ie[ie.length] = ae ? $replace(ve, reEscapeChar, "$1") : se || oe;
  }), ie;
}, getBaseIntrinsic = function(z, Y) {
  var ne = z, ie;
  if (hasOwn$1(LEGACY_ALIASES, ne) && (ie = LEGACY_ALIASES[ne], ne = "%" + ie[0] + "%"), hasOwn$1(INTRINSICS, ne)) {
    var oe = INTRINSICS[ne];
    if (oe === needsEval && (oe = doEval(ne)), typeof oe > "u" && !Y)
      throw new $TypeError$3("intrinsic " + z + " exists, but is not available. Please file an issue!");
    return {
      alias: ie,
      name: ne,
      value: oe
    };
  }
  throw new $SyntaxError$1("intrinsic " + z + " does not exist!");
}, getIntrinsic = function(z, Y) {
  if (typeof z != "string" || z.length === 0)
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof Y != "boolean")
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  if ($exec$2(/^%?[^%]*%?$/, z) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var ne = stringToPath(z), ie = ne.length > 0 ? ne[0] : "", oe = getBaseIntrinsic("%" + ie + "%", Y), se = oe.name, ae = oe.value, ve = !1, Pe = oe.alias;
  Pe && (ie = Pe[0], $spliceApply(ne, $concat([0, 1], Pe)));
  for (var le = 1, Ee = !0; le < ne.length; le += 1) {
    var Je = ne[le], Ce = $strSlice(Je, 0, 1), _t = $strSlice(Je, -1);
    if ((Ce === '"' || Ce === "'" || Ce === "`" || _t === '"' || _t === "'" || _t === "`") && Ce !== _t)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((Je === "constructor" || !Ee) && (ve = !0), ie += "." + Je, se = "%" + ie + "%", hasOwn$1(INTRINSICS, se))
      ae = INTRINSICS[se];
    else if (ae != null) {
      if (!(Je in ae)) {
        if (!Y)
          throw new $TypeError$3("base intrinsic for " + z + " exists, but the property is not available.");
        return;
      }
      if ($gOPD && le + 1 >= ne.length) {
        var kt = $gOPD(ae, Je);
        Ee = !!kt, Ee && "get" in kt && !("originalValue" in kt.get) ? ae = kt.get : ae = ae[Je];
      } else
        Ee = hasOwn$1(ae, Je), ae = ae[Je];
      Ee && !ve && (INTRINSICS[se] = ae);
    }
  }
  return ae;
}, GetIntrinsic$1 = getIntrinsic, callBindBasic = callBindApplyHelpers, $indexOf$1 = callBindBasic([GetIntrinsic$1("%String.prototype.indexOf%")]), callBound$5 = function(z, Y) {
  var ne = (
    /** @type {Parameters<typeof callBindBasic>[0][0]} */
    GetIntrinsic$1(z, !!Y)
  );
  return typeof ne == "function" && $indexOf$1(z, ".prototype.") > -1 ? callBindBasic([ne]) : ne;
}, hasToStringTag$4 = shams(), callBound$4 = callBound$5, $toString$2 = callBound$4("Object.prototype.toString"), isStandardArguments = function(z) {
  return hasToStringTag$4 && z && typeof z == "object" && Symbol.toStringTag in z ? !1 : $toString$2(z) === "[object Arguments]";
}, isLegacyArguments = function(z) {
  return isStandardArguments(z) ? !0 : z !== null && typeof z == "object" && "length" in z && typeof z.length == "number" && z.length >= 0 && $toString$2(z) !== "[object Array]" && "callee" in z && $toString$2(z.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments, callBound$3 = callBound$5, hasToStringTag$3 = shams(), hasOwn = hasown, gOPD$2 = gopd$1, fn;
if (hasToStringTag$3) {
  var $exec$1 = callBound$3("RegExp.prototype.exec"), isRegexMarker = {}, throwRegexMarker = function() {
    throw isRegexMarker;
  }, badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  typeof Symbol.toPrimitive == "symbol" && (badStringifier[Symbol.toPrimitive] = throwRegexMarker), fn = function(z) {
    if (!z || typeof z != "object")
      return !1;
    var Y = (
      /** @type {NonNullable<typeof gOPD>} */
      gOPD$2(
        /** @type {{ lastIndex?: unknown }} */
        z,
        "lastIndex"
      )
    ), ne = Y && hasOwn(Y, "value");
    if (!ne)
      return !1;
    try {
      $exec$1(
        z,
        /** @type {string} */
        /** @type {unknown} */
        badStringifier
      );
    } catch (ie) {
      return ie === isRegexMarker;
    }
  };
} else {
  var $toString$1 = callBound$3("Object.prototype.toString"), regexClass = "[object RegExp]";
  fn = function(z) {
    return !z || typeof z != "object" && typeof z != "function" ? !1 : $toString$1(z) === regexClass;
  };
}
var isRegex$1 = fn, callBound$2 = callBound$5, isRegex = isRegex$1, $exec = callBound$2("RegExp.prototype.exec"), $TypeError$2 = type, safeRegexTest$1 = function(z) {
  if (!isRegex(z))
    throw new $TypeError$2("`regex` must be a RegExp");
  return function(ne) {
    return $exec(z, ne) !== null;
  };
}, callBound$1 = callBound$5, safeRegexTest = safeRegexTest$1, isFnRegex = safeRegexTest(/^\s*(?:function)?\*/), hasToStringTag$2 = shams(), getProto = requireGetProto(), toStr$2 = callBound$1("Object.prototype.toString"), fnToStr$1 = callBound$1("Function.prototype.toString"), getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function(z) {
  if (typeof z != "function")
    return !1;
  if (isFnRegex(fnToStr$1(z)))
    return !0;
  if (!hasToStringTag$2) {
    var Y = toStr$2(z);
    return Y === "[object GeneratorFunction]";
  }
  if (!getProto)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var ne = getGeneratorFunc();
    GeneratorFunction = ne ? (
      /** @type {GeneratorFunctionConstructor} */
      getProto(ne)
    ) : !1;
  }
  return getProto(z) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (B) {
    B !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function(z) {
  try {
    var Y = fnToStr.call(z);
    return constructorRegex.test(Y);
  } catch {
    return !1;
  }
}, tryFunctionObject = function(z) {
  try {
    return isES6ClassFn(z) ? !1 : (fnToStr.call(z), !0);
  } catch {
    return !1;
  }
}, toStr$1 = Object.prototype.toString, objectClass = "[object Object]", fnClass = "[object Function]", genClass = "[object GeneratorFunction]", ddaClass = "[object HTMLAllCollection]", ddaClass2 = "[object HTML document.all class]", ddaClass3 = "[object HTMLCollection]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, isIE68 = !(0 in [,]), isDDA = function() {
  return !1;
};
if (typeof document == "object") {
  var all = document.all;
  toStr$1.call(all) === toStr$1.call(document.all) && (isDDA = function(z) {
    if ((isIE68 || !z) && (typeof z > "u" || typeof z == "object"))
      try {
        var Y = toStr$1.call(z);
        return (Y === ddaClass || Y === ddaClass2 || Y === ddaClass3 || Y === objectClass) && z("") == null;
      } catch {
      }
    return !1;
  });
}
var isCallable$1 = reflectApply ? function(z) {
  if (isDDA(z))
    return !0;
  if (!z || typeof z != "function" && typeof z != "object")
    return !1;
  try {
    reflectApply(z, null, badArrayLike);
  } catch (Y) {
    if (Y !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(z) && tryFunctionObject(z);
} : function(z) {
  if (isDDA(z))
    return !0;
  if (!z || typeof z != "function" && typeof z != "object")
    return !1;
  if (hasToStringTag$1)
    return tryFunctionObject(z);
  if (isES6ClassFn(z))
    return !1;
  var Y = toStr$1.call(z);
  return Y !== fnClass && Y !== genClass && !/^\[object HTML/.test(Y) ? !1 : tryFunctionObject(z);
}, isCallable = isCallable$1, toStr = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, forEachArray = function(z, Y, ne) {
  for (var ie = 0, oe = z.length; ie < oe; ie++)
    hasOwnProperty.call(z, ie) && (ne == null ? Y(z[ie], ie, z) : Y.call(ne, z[ie], ie, z));
}, forEachString = function(z, Y, ne) {
  for (var ie = 0, oe = z.length; ie < oe; ie++)
    ne == null ? Y(z.charAt(ie), ie, z) : Y.call(ne, z.charAt(ie), ie, z);
}, forEachObject = function(z, Y, ne) {
  for (var ie in z)
    hasOwnProperty.call(z, ie) && (ne == null ? Y(z[ie], ie, z) : Y.call(ne, z[ie], ie, z));
};
function isArray$1(B) {
  return toStr.call(B) === "[object Array]";
}
var forEach$1 = function(z, Y, ne) {
  if (!isCallable(Y))
    throw new TypeError("iterator must be a function");
  var ie;
  arguments.length >= 3 && (ie = ne), isArray$1(z) ? forEachArray(z, Y, ie) : typeof z == "string" ? forEachString(z, Y, ie) : forEachObject(z, Y, ie);
}, possibleTypedArrayNames = [
  "Float16Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], possibleNames = possibleTypedArrayNames, g$1 = typeof globalThis > "u" ? commonjsGlobal : globalThis, availableTypedArrays$1 = function() {
  for (var z = [], Y = 0; Y < possibleNames.length; Y++)
    typeof g$1[possibleNames[Y]] == "function" && (z[z.length] = possibleNames[Y]);
  return z;
}, callBind$1 = { exports: {} }, $defineProperty$1 = esDefineProperty, $SyntaxError = syntax, $TypeError$1 = type, gopd = gopd$1, defineDataProperty = function(z, Y, ne) {
  if (!z || typeof z != "object" && typeof z != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof Y != "string" && typeof Y != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var ie = arguments.length > 3 ? arguments[3] : null, oe = arguments.length > 4 ? arguments[4] : null, se = arguments.length > 5 ? arguments[5] : null, ae = arguments.length > 6 ? arguments[6] : !1, ve = !!gopd && gopd(z, Y);
  if ($defineProperty$1)
    $defineProperty$1(z, Y, {
      configurable: se === null && ve ? ve.configurable : !se,
      enumerable: ie === null && ve ? ve.enumerable : !ie,
      value: ne,
      writable: oe === null && ve ? ve.writable : !oe
    });
  else if (ae || !ie && !oe && !se)
    z[Y] = ne;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = esDefineProperty, hasPropertyDescriptors = function() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type, $floor = GetIntrinsic("%Math.floor%"), setFunctionLength = function(z, Y) {
  if (typeof z != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof Y != "number" || Y < 0 || Y > 4294967295 || $floor(Y) !== Y)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var ne = arguments.length > 2 && !!arguments[2], ie = !0, oe = !0;
  if ("length" in z && gOPD$1) {
    var se = gOPD$1(z, "length");
    se && !se.configurable && (ie = !1), se && !se.writable && (oe = !1);
  }
  return (ie || oe || !ne) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    z,
    "length",
    Y,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    z,
    "length",
    Y
  )), z;
}, bind = functionBind, $apply = functionApply, actualApply = actualApply$1, applyBind = function() {
  return actualApply(bind, $apply, arguments);
};
(function(B) {
  var z = setFunctionLength, Y = esDefineProperty, ne = callBindApplyHelpers, ie = applyBind;
  B.exports = function(se) {
    var ae = ne(arguments), ve = se.length - (arguments.length - 1);
    return z(
      ae,
      1 + (ve > 0 ? ve : 0),
      !0
    );
  }, Y ? Y(B.exports, "apply", { value: ie }) : B.exports.apply = ie;
})(callBind$1);
var callBindExports = callBind$1.exports, forEach = forEach$1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound = callBound$5, gOPD = gopd$1, $toString = callBound("Object.prototype.toString"), hasToStringTag = shams(), g = typeof globalThis > "u" ? commonjsGlobal : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), getPrototypeOf = Object.getPrototypeOf, $indexOf = callBound("Array.prototype.indexOf", !0) || function(z, Y) {
  for (var ne = 0; ne < z.length; ne += 1)
    if (z[ne] === Y)
      return ne;
  return -1;
}, cache = { __proto__: null };
hasToStringTag && gOPD && getPrototypeOf ? forEach(typedArrays, function(B) {
  var z = new g[B]();
  if (Symbol.toStringTag in z) {
    var Y = getPrototypeOf(z), ne = gOPD(Y, Symbol.toStringTag);
    if (!ne) {
      var ie = getPrototypeOf(Y);
      ne = gOPD(ie, Symbol.toStringTag);
    }
    cache["$" + B] = callBind(ne.get);
  }
}) : forEach(typedArrays, function(B) {
  var z = new g[B](), Y = z.slice || z.set;
  Y && (cache["$" + B] = callBind(Y));
});
var tryTypedArrays = function(z) {
  var Y = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(ne, ie) {
      if (!Y)
        try {
          "$" + ne(z) === ie && (Y = $slice(ie, 1));
        } catch {
        }
    }
  ), Y;
}, trySlices = function(z) {
  var Y = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(ne, ie) {
      if (!Y)
        try {
          ne(z), Y = $slice(ie, 1);
        } catch {
        }
    }
  ), Y;
}, whichTypedArray$1 = function(z) {
  if (!z || typeof z != "object")
    return !1;
  if (!hasToStringTag) {
    var Y = $slice($toString(z), 8, -1);
    return $indexOf(typedArrays, Y) > -1 ? Y : Y !== "Object" ? !1 : trySlices(z);
  }
  return gOPD ? tryTypedArrays(z) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray = function(z) {
  return !!whichTypedArray(z);
};
(function(B) {
  var z = isArguments, Y = isGeneratorFunction, ne = whichTypedArray$1, ie = isTypedArray;
  function oe(br) {
    return br.call.bind(br);
  }
  var se = typeof BigInt < "u", ae = typeof Symbol < "u", ve = oe(Object.prototype.toString), Pe = oe(Number.prototype.valueOf), le = oe(String.prototype.valueOf), Ee = oe(Boolean.prototype.valueOf);
  if (se)
    var Je = oe(BigInt.prototype.valueOf);
  if (ae)
    var Ce = oe(Symbol.prototype.valueOf);
  function _t(br, Yr) {
    if (typeof br != "object")
      return !1;
    try {
      return Yr(br), !0;
    } catch {
      return !1;
    }
  }
  B.isArgumentsObject = z, B.isGeneratorFunction = Y, B.isTypedArray = ie;
  function kt(br) {
    return typeof Promise < "u" && br instanceof Promise || br !== null && typeof br == "object" && typeof br.then == "function" && typeof br.catch == "function";
  }
  B.isPromise = kt;
  function Ct(br) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(br) : ie(br) || Dt(br);
  }
  B.isArrayBufferView = Ct;
  function Lt(br) {
    return ne(br) === "Uint8Array";
  }
  B.isUint8Array = Lt;
  function Pt(br) {
    return ne(br) === "Uint8ClampedArray";
  }
  B.isUint8ClampedArray = Pt;
  function Ft(br) {
    return ne(br) === "Uint16Array";
  }
  B.isUint16Array = Ft;
  function Ut(br) {
    return ne(br) === "Uint32Array";
  }
  B.isUint32Array = Ut;
  function Jt(br) {
    return ne(br) === "Int8Array";
  }
  B.isInt8Array = Jt;
  function Vt(br) {
    return ne(br) === "Int16Array";
  }
  B.isInt16Array = Vt;
  function ir(br) {
    return ne(br) === "Int32Array";
  }
  B.isInt32Array = ir;
  function jt(br) {
    return ne(br) === "Float32Array";
  }
  B.isFloat32Array = jt;
  function Rt(br) {
    return ne(br) === "Float64Array";
  }
  B.isFloat64Array = Rt;
  function Kt(br) {
    return ne(br) === "BigInt64Array";
  }
  B.isBigInt64Array = Kt;
  function Bt(br) {
    return ne(br) === "BigUint64Array";
  }
  B.isBigUint64Array = Bt;
  function Xe(br) {
    return ve(br) === "[object Map]";
  }
  Xe.working = typeof Map < "u" && Xe(/* @__PURE__ */ new Map());
  function Ve(br) {
    return typeof Map > "u" ? !1 : Xe.working ? Xe(br) : br instanceof Map;
  }
  B.isMap = Ve;
  function ge(br) {
    return ve(br) === "[object Set]";
  }
  ge.working = typeof Set < "u" && ge(/* @__PURE__ */ new Set());
  function Ke(br) {
    return typeof Set > "u" ? !1 : ge.working ? ge(br) : br instanceof Set;
  }
  B.isSet = Ke;
  function ht(br) {
    return ve(br) === "[object WeakMap]";
  }
  ht.working = typeof WeakMap < "u" && ht(/* @__PURE__ */ new WeakMap());
  function wt(br) {
    return typeof WeakMap > "u" ? !1 : ht.working ? ht(br) : br instanceof WeakMap;
  }
  B.isWeakMap = wt;
  function vt(br) {
    return ve(br) === "[object WeakSet]";
  }
  vt.working = typeof WeakSet < "u" && vt(/* @__PURE__ */ new WeakSet());
  function $t(br) {
    return vt(br);
  }
  B.isWeakSet = $t;
  function Qe(br) {
    return ve(br) === "[object ArrayBuffer]";
  }
  Qe.working = typeof ArrayBuffer < "u" && Qe(new ArrayBuffer());
  function xt(br) {
    return typeof ArrayBuffer > "u" ? !1 : Qe.working ? Qe(br) : br instanceof ArrayBuffer;
  }
  B.isArrayBuffer = xt;
  function bt(br) {
    return ve(br) === "[object DataView]";
  }
  bt.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && bt(new DataView(new ArrayBuffer(1), 0, 1));
  function Dt(br) {
    return typeof DataView > "u" ? !1 : bt.working ? bt(br) : br instanceof DataView;
  }
  B.isDataView = Dt;
  var er = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function fr(br) {
    return ve(br) === "[object SharedArrayBuffer]";
  }
  function Qt(br) {
    return typeof er > "u" ? !1 : (typeof fr.working > "u" && (fr.working = fr(new er())), fr.working ? fr(br) : br instanceof er);
  }
  B.isSharedArrayBuffer = Qt;
  function Ht(br) {
    return ve(br) === "[object AsyncFunction]";
  }
  B.isAsyncFunction = Ht;
  function qt(br) {
    return ve(br) === "[object Map Iterator]";
  }
  B.isMapIterator = qt;
  function nr(br) {
    return ve(br) === "[object Set Iterator]";
  }
  B.isSetIterator = nr;
  function ur(br) {
    return ve(br) === "[object Generator]";
  }
  B.isGeneratorObject = ur;
  function zt(br) {
    return ve(br) === "[object WebAssembly.Module]";
  }
  B.isWebAssemblyCompiledModule = zt;
  function Gt(br) {
    return _t(br, Pe);
  }
  B.isNumberObject = Gt;
  function cr(br) {
    return _t(br, le);
  }
  B.isStringObject = cr;
  function gr(br) {
    return _t(br, Ee);
  }
  B.isBooleanObject = gr;
  function $r(br) {
    return se && _t(br, Je);
  }
  B.isBigIntObject = $r;
  function xr(br) {
    return ae && _t(br, Ce);
  }
  B.isSymbolObject = xr;
  function Mr(br) {
    return Gt(br) || cr(br) || gr(br) || $r(br) || xr(br);
  }
  B.isBoxedPrimitive = Mr;
  function kr(br) {
    return typeof Uint8Array < "u" && (xt(br) || Qt(br));
  }
  B.isAnyArrayBuffer = kr, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(br) {
    Object.defineProperty(B, br, {
      enumerable: !1,
      value: function() {
        throw new Error(br + " is not supported in userland");
      }
    });
  });
})(types$5);
var isBufferBrowser = function(z) {
  return z && typeof z == "object" && typeof z.copy == "function" && typeof z.fill == "function" && typeof z.readUInt8 == "function";
};
(function(B) {
  var z = Object.getOwnPropertyDescriptors || function(Dt) {
    for (var er = Object.keys(Dt), fr = {}, Qt = 0; Qt < er.length; Qt++)
      fr[er[Qt]] = Object.getOwnPropertyDescriptor(Dt, er[Qt]);
    return fr;
  }, Y = /%[sdj%]/g;
  B.format = function(bt) {
    if (!Jt(bt)) {
      for (var Dt = [], er = 0; er < arguments.length; er++)
        Dt.push(se(arguments[er]));
      return Dt.join(" ");
    }
    for (var er = 1, fr = arguments, Qt = fr.length, Ht = String(bt).replace(Y, function(nr) {
      if (nr === "%%") return "%";
      if (er >= Qt) return nr;
      switch (nr) {
        case "%s":
          return String(fr[er++]);
        case "%d":
          return Number(fr[er++]);
        case "%j":
          try {
            return JSON.stringify(fr[er++]);
          } catch {
            return "[Circular]";
          }
        default:
          return nr;
      }
    }), qt = fr[er]; er < Qt; qt = fr[++er])
      Pt(qt) || !Rt(qt) ? Ht += " " + qt : Ht += " " + se(qt);
    return Ht;
  }, B.deprecate = function(bt, Dt) {
    if (typeof process$1 < "u" && process$1.noDeprecation === !0)
      return bt;
    if (typeof process$1 > "u")
      return function() {
        return B.deprecate(bt, Dt).apply(this, arguments);
      };
    var er = !1;
    function fr() {
      if (!er) {
        if (process$1.throwDeprecation)
          throw new Error(Dt);
        process$1.traceDeprecation ? console.trace(Dt) : console.error(Dt), er = !0;
      }
      return bt.apply(this, arguments);
    }
    return fr;
  };
  var ne = {}, ie = /^$/;
  if (process$1.env.NODE_DEBUG) {
    var oe = process$1.env.NODE_DEBUG;
    oe = oe.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ie = new RegExp("^" + oe + "$", "i");
  }
  B.debuglog = function(bt) {
    if (bt = bt.toUpperCase(), !ne[bt])
      if (ie.test(bt)) {
        var Dt = process$1.pid;
        ne[bt] = function() {
          var er = B.format.apply(B, arguments);
          console.error("%s %d: %s", bt, Dt, er);
        };
      } else
        ne[bt] = function() {
        };
    return ne[bt];
  };
  function se(bt, Dt) {
    var er = {
      seen: [],
      stylize: ve
    };
    return arguments.length >= 3 && (er.depth = arguments[2]), arguments.length >= 4 && (er.colors = arguments[3]), Lt(Dt) ? er.showHidden = Dt : Dt && B._extend(er, Dt), ir(er.showHidden) && (er.showHidden = !1), ir(er.depth) && (er.depth = 2), ir(er.colors) && (er.colors = !1), ir(er.customInspect) && (er.customInspect = !0), er.colors && (er.stylize = ae), le(er, bt, er.depth);
  }
  B.inspect = se, se.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, se.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function ae(bt, Dt) {
    var er = se.styles[Dt];
    return er ? "\x1B[" + se.colors[er][0] + "m" + bt + "\x1B[" + se.colors[er][1] + "m" : bt;
  }
  function ve(bt, Dt) {
    return bt;
  }
  function Pe(bt) {
    var Dt = {};
    return bt.forEach(function(er, fr) {
      Dt[er] = !0;
    }), Dt;
  }
  function le(bt, Dt, er) {
    if (bt.customInspect && Dt && Xe(Dt.inspect) && // Filter out the util module, it's inspect function is special
    Dt.inspect !== B.inspect && // Also filter out any prototype objects using the circular check.
    !(Dt.constructor && Dt.constructor.prototype === Dt)) {
      var fr = Dt.inspect(er, bt);
      return Jt(fr) || (fr = le(bt, fr, er)), fr;
    }
    var Qt = Ee(bt, Dt);
    if (Qt)
      return Qt;
    var Ht = Object.keys(Dt), qt = Pe(Ht);
    if (bt.showHidden && (Ht = Object.getOwnPropertyNames(Dt)), Bt(Dt) && (Ht.indexOf("message") >= 0 || Ht.indexOf("description") >= 0))
      return Je(Dt);
    if (Ht.length === 0) {
      if (Xe(Dt)) {
        var nr = Dt.name ? ": " + Dt.name : "";
        return bt.stylize("[Function" + nr + "]", "special");
      }
      if (jt(Dt))
        return bt.stylize(RegExp.prototype.toString.call(Dt), "regexp");
      if (Kt(Dt))
        return bt.stylize(Date.prototype.toString.call(Dt), "date");
      if (Bt(Dt))
        return Je(Dt);
    }
    var ur = "", zt = !1, Gt = ["{", "}"];
    if (Ct(Dt) && (zt = !0, Gt = ["[", "]"]), Xe(Dt)) {
      var cr = Dt.name ? ": " + Dt.name : "";
      ur = " [Function" + cr + "]";
    }
    if (jt(Dt) && (ur = " " + RegExp.prototype.toString.call(Dt)), Kt(Dt) && (ur = " " + Date.prototype.toUTCString.call(Dt)), Bt(Dt) && (ur = " " + Je(Dt)), Ht.length === 0 && (!zt || Dt.length == 0))
      return Gt[0] + ur + Gt[1];
    if (er < 0)
      return jt(Dt) ? bt.stylize(RegExp.prototype.toString.call(Dt), "regexp") : bt.stylize("[Object]", "special");
    bt.seen.push(Dt);
    var gr;
    return zt ? gr = Ce(bt, Dt, er, qt, Ht) : gr = Ht.map(function($r) {
      return _t(bt, Dt, er, qt, $r, zt);
    }), bt.seen.pop(), kt(gr, ur, Gt);
  }
  function Ee(bt, Dt) {
    if (ir(Dt))
      return bt.stylize("undefined", "undefined");
    if (Jt(Dt)) {
      var er = "'" + JSON.stringify(Dt).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return bt.stylize(er, "string");
    }
    if (Ut(Dt))
      return bt.stylize("" + Dt, "number");
    if (Lt(Dt))
      return bt.stylize("" + Dt, "boolean");
    if (Pt(Dt))
      return bt.stylize("null", "null");
  }
  function Je(bt) {
    return "[" + Error.prototype.toString.call(bt) + "]";
  }
  function Ce(bt, Dt, er, fr, Qt) {
    for (var Ht = [], qt = 0, nr = Dt.length; qt < nr; ++qt)
      vt(Dt, String(qt)) ? Ht.push(_t(
        bt,
        Dt,
        er,
        fr,
        String(qt),
        !0
      )) : Ht.push("");
    return Qt.forEach(function(ur) {
      ur.match(/^\d+$/) || Ht.push(_t(
        bt,
        Dt,
        er,
        fr,
        ur,
        !0
      ));
    }), Ht;
  }
  function _t(bt, Dt, er, fr, Qt, Ht) {
    var qt, nr, ur;
    if (ur = Object.getOwnPropertyDescriptor(Dt, Qt) || { value: Dt[Qt] }, ur.get ? ur.set ? nr = bt.stylize("[Getter/Setter]", "special") : nr = bt.stylize("[Getter]", "special") : ur.set && (nr = bt.stylize("[Setter]", "special")), vt(fr, Qt) || (qt = "[" + Qt + "]"), nr || (bt.seen.indexOf(ur.value) < 0 ? (Pt(er) ? nr = le(bt, ur.value, null) : nr = le(bt, ur.value, er - 1), nr.indexOf(`
`) > -1 && (Ht ? nr = nr.split(`
`).map(function(zt) {
      return "  " + zt;
    }).join(`
`).slice(2) : nr = `
` + nr.split(`
`).map(function(zt) {
      return "   " + zt;
    }).join(`
`))) : nr = bt.stylize("[Circular]", "special")), ir(qt)) {
      if (Ht && Qt.match(/^\d+$/))
        return nr;
      qt = JSON.stringify("" + Qt), qt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (qt = qt.slice(1, -1), qt = bt.stylize(qt, "name")) : (qt = qt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), qt = bt.stylize(qt, "string"));
    }
    return qt + ": " + nr;
  }
  function kt(bt, Dt, er) {
    var fr = bt.reduce(function(Qt, Ht) {
      return Ht.indexOf(`
`) >= 0, Qt + Ht.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return fr > 60 ? er[0] + (Dt === "" ? "" : Dt + `
 `) + " " + bt.join(`,
  `) + " " + er[1] : er[0] + Dt + " " + bt.join(", ") + " " + er[1];
  }
  B.types = types$5;
  function Ct(bt) {
    return Array.isArray(bt);
  }
  B.isArray = Ct;
  function Lt(bt) {
    return typeof bt == "boolean";
  }
  B.isBoolean = Lt;
  function Pt(bt) {
    return bt === null;
  }
  B.isNull = Pt;
  function Ft(bt) {
    return bt == null;
  }
  B.isNullOrUndefined = Ft;
  function Ut(bt) {
    return typeof bt == "number";
  }
  B.isNumber = Ut;
  function Jt(bt) {
    return typeof bt == "string";
  }
  B.isString = Jt;
  function Vt(bt) {
    return typeof bt == "symbol";
  }
  B.isSymbol = Vt;
  function ir(bt) {
    return bt === void 0;
  }
  B.isUndefined = ir;
  function jt(bt) {
    return Rt(bt) && ge(bt) === "[object RegExp]";
  }
  B.isRegExp = jt, B.types.isRegExp = jt;
  function Rt(bt) {
    return typeof bt == "object" && bt !== null;
  }
  B.isObject = Rt;
  function Kt(bt) {
    return Rt(bt) && ge(bt) === "[object Date]";
  }
  B.isDate = Kt, B.types.isDate = Kt;
  function Bt(bt) {
    return Rt(bt) && (ge(bt) === "[object Error]" || bt instanceof Error);
  }
  B.isError = Bt, B.types.isNativeError = Bt;
  function Xe(bt) {
    return typeof bt == "function";
  }
  B.isFunction = Xe;
  function Ve(bt) {
    return bt === null || typeof bt == "boolean" || typeof bt == "number" || typeof bt == "string" || typeof bt == "symbol" || // ES6 symbol
    typeof bt > "u";
  }
  B.isPrimitive = Ve, B.isBuffer = isBufferBrowser;
  function ge(bt) {
    return Object.prototype.toString.call(bt);
  }
  function Ke(bt) {
    return bt < 10 ? "0" + bt.toString(10) : bt.toString(10);
  }
  var ht = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function wt() {
    var bt = /* @__PURE__ */ new Date(), Dt = [
      Ke(bt.getHours()),
      Ke(bt.getMinutes()),
      Ke(bt.getSeconds())
    ].join(":");
    return [bt.getDate(), ht[bt.getMonth()], Dt].join(" ");
  }
  B.log = function() {
    console.log("%s - %s", wt(), B.format.apply(B, arguments));
  }, B.inherits = inherits_browserExports, B._extend = function(bt, Dt) {
    if (!Dt || !Rt(Dt)) return bt;
    for (var er = Object.keys(Dt), fr = er.length; fr--; )
      bt[er[fr]] = Dt[er[fr]];
    return bt;
  };
  function vt(bt, Dt) {
    return Object.prototype.hasOwnProperty.call(bt, Dt);
  }
  var $t = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  B.promisify = function(Dt) {
    if (typeof Dt != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if ($t && Dt[$t]) {
      var er = Dt[$t];
      if (typeof er != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(er, $t, {
        value: er,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), er;
    }
    function er() {
      for (var fr, Qt, Ht = new Promise(function(ur, zt) {
        fr = ur, Qt = zt;
      }), qt = [], nr = 0; nr < arguments.length; nr++)
        qt.push(arguments[nr]);
      qt.push(function(ur, zt) {
        ur ? Qt(ur) : fr(zt);
      });
      try {
        Dt.apply(this, qt);
      } catch (ur) {
        Qt(ur);
      }
      return Ht;
    }
    return Object.setPrototypeOf(er, Object.getPrototypeOf(Dt)), $t && Object.defineProperty(er, $t, {
      value: er,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      er,
      z(Dt)
    );
  }, B.promisify.custom = $t;
  function Qe(bt, Dt) {
    if (!bt) {
      var er = new Error("Promise was rejected with a falsy value");
      er.reason = bt, bt = er;
    }
    return Dt(bt);
  }
  function xt(bt) {
    if (typeof bt != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function Dt() {
      for (var er = [], fr = 0; fr < arguments.length; fr++)
        er.push(arguments[fr]);
      var Qt = er.pop();
      if (typeof Qt != "function")
        throw new TypeError("The last argument must be of type Function");
      var Ht = this, qt = function() {
        return Qt.apply(Ht, arguments);
      };
      bt.apply(this, er).then(
        function(nr) {
          process$1.nextTick(qt.bind(null, null, nr));
        },
        function(nr) {
          process$1.nextTick(Qe.bind(null, nr, qt));
        }
      );
    }
    return Object.setPrototypeOf(Dt, Object.getPrototypeOf(bt)), Object.defineProperties(
      Dt,
      z(bt)
    ), Dt;
  }
  B.callbackify = xt;
})(util$3);
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function B(_t, kt) {
    var Ct = Object.keys(_t);
    if (Object.getOwnPropertySymbols) {
      var Lt = Object.getOwnPropertySymbols(_t);
      kt && (Lt = Lt.filter(function(Pt) {
        return Object.getOwnPropertyDescriptor(_t, Pt).enumerable;
      })), Ct.push.apply(Ct, Lt);
    }
    return Ct;
  }
  function z(_t) {
    for (var kt = 1; kt < arguments.length; kt++) {
      var Ct = arguments[kt] != null ? arguments[kt] : {};
      kt % 2 ? B(Object(Ct), !0).forEach(function(Lt) {
        Y(_t, Lt, Ct[Lt]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_t, Object.getOwnPropertyDescriptors(Ct)) : B(Object(Ct)).forEach(function(Lt) {
        Object.defineProperty(_t, Lt, Object.getOwnPropertyDescriptor(Ct, Lt));
      });
    }
    return _t;
  }
  function Y(_t, kt, Ct) {
    return kt = se(kt), kt in _t ? Object.defineProperty(_t, kt, { value: Ct, enumerable: !0, configurable: !0, writable: !0 }) : _t[kt] = Ct, _t;
  }
  function ne(_t, kt) {
    if (!(_t instanceof kt))
      throw new TypeError("Cannot call a class as a function");
  }
  function ie(_t, kt) {
    for (var Ct = 0; Ct < kt.length; Ct++) {
      var Lt = kt[Ct];
      Lt.enumerable = Lt.enumerable || !1, Lt.configurable = !0, "value" in Lt && (Lt.writable = !0), Object.defineProperty(_t, se(Lt.key), Lt);
    }
  }
  function oe(_t, kt, Ct) {
    return kt && ie(_t.prototype, kt), Object.defineProperty(_t, "prototype", { writable: !1 }), _t;
  }
  function se(_t) {
    var kt = ae(_t, "string");
    return typeof kt == "symbol" ? kt : String(kt);
  }
  function ae(_t, kt) {
    if (typeof _t != "object" || _t === null) return _t;
    var Ct = _t[Symbol.toPrimitive];
    if (Ct !== void 0) {
      var Lt = Ct.call(_t, kt);
      if (typeof Lt != "object") return Lt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(_t);
  }
  var ve = require$$0$1, Pe = ve.Buffer, le = util$3, Ee = le.inspect, Je = Ee && Ee.custom || "inspect";
  function Ce(_t, kt, Ct) {
    Pe.prototype.copy.call(_t, kt, Ct);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function _t() {
      ne(this, _t), this.head = null, this.tail = null, this.length = 0;
    }
    return oe(_t, [{
      key: "push",
      value: function(Ct) {
        var Lt = {
          data: Ct,
          next: null
        };
        this.length > 0 ? this.tail.next = Lt : this.head = Lt, this.tail = Lt, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Ct) {
        var Lt = {
          data: Ct,
          next: this.head
        };
        this.length === 0 && (this.tail = Lt), this.head = Lt, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Ct = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Ct;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Ct) {
        if (this.length === 0) return "";
        for (var Lt = this.head, Pt = "" + Lt.data; Lt = Lt.next; ) Pt += Ct + Lt.data;
        return Pt;
      }
    }, {
      key: "concat",
      value: function(Ct) {
        if (this.length === 0) return Pe.alloc(0);
        for (var Lt = Pe.allocUnsafe(Ct >>> 0), Pt = this.head, Ft = 0; Pt; )
          Ce(Pt.data, Lt, Ft), Ft += Pt.data.length, Pt = Pt.next;
        return Lt;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Ct, Lt) {
        var Pt;
        return Ct < this.head.data.length ? (Pt = this.head.data.slice(0, Ct), this.head.data = this.head.data.slice(Ct)) : Ct === this.head.data.length ? Pt = this.shift() : Pt = Lt ? this._getString(Ct) : this._getBuffer(Ct), Pt;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Ct) {
        var Lt = this.head, Pt = 1, Ft = Lt.data;
        for (Ct -= Ft.length; Lt = Lt.next; ) {
          var Ut = Lt.data, Jt = Ct > Ut.length ? Ut.length : Ct;
          if (Jt === Ut.length ? Ft += Ut : Ft += Ut.slice(0, Ct), Ct -= Jt, Ct === 0) {
            Jt === Ut.length ? (++Pt, Lt.next ? this.head = Lt.next : this.head = this.tail = null) : (this.head = Lt, Lt.data = Ut.slice(Jt));
            break;
          }
          ++Pt;
        }
        return this.length -= Pt, Ft;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Ct) {
        var Lt = Pe.allocUnsafe(Ct), Pt = this.head, Ft = 1;
        for (Pt.data.copy(Lt), Ct -= Pt.data.length; Pt = Pt.next; ) {
          var Ut = Pt.data, Jt = Ct > Ut.length ? Ut.length : Ct;
          if (Ut.copy(Lt, Lt.length - Ct, 0, Jt), Ct -= Jt, Ct === 0) {
            Jt === Ut.length ? (++Ft, Pt.next ? this.head = Pt.next : this.head = this.tail = null) : (this.head = Pt, Pt.data = Ut.slice(Jt));
            break;
          }
          ++Ft;
        }
        return this.length -= Ft, Lt;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: Je,
      value: function(Ct, Lt) {
        return Ee(this, z(z({}, Lt), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), _t;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1$1;
  hasRequiredDestroy = 1;
  function B(se, ae) {
    var ve = this, Pe = this._readableState && this._readableState.destroyed, le = this._writableState && this._writableState.destroyed;
    return Pe || le ? (ae ? ae(se) : se && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(ie, this, se)) : process$1.nextTick(ie, this, se)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(se || null, function(Ee) {
      !ae && Ee ? ve._writableState ? ve._writableState.errorEmitted ? process$1.nextTick(Y, ve) : (ve._writableState.errorEmitted = !0, process$1.nextTick(z, ve, Ee)) : process$1.nextTick(z, ve, Ee) : ae ? (process$1.nextTick(Y, ve), ae(Ee)) : process$1.nextTick(Y, ve);
    }), this);
  }
  function z(se, ae) {
    ie(se, ae), Y(se);
  }
  function Y(se) {
    se._writableState && !se._writableState.emitClose || se._readableState && !se._readableState.emitClose || se.emit("close");
  }
  function ne() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function ie(se, ae) {
    se.emit("error", ae);
  }
  function oe(se, ae) {
    var ve = se._readableState, Pe = se._writableState;
    ve && ve.autoDestroy || Pe && Pe.autoDestroy ? se.destroy(ae) : se.emit("error", ae);
  }
  return destroy_1$1 = {
    destroy: B,
    undestroy: ne,
    errorOrDestroy: oe
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function B(ae, ve) {
    ae.prototype = Object.create(ve.prototype), ae.prototype.constructor = ae, ae.__proto__ = ve;
  }
  var z = {};
  function Y(ae, ve, Pe) {
    Pe || (Pe = Error);
    function le(Je, Ce, _t) {
      return typeof ve == "string" ? ve : ve(Je, Ce, _t);
    }
    var Ee = /* @__PURE__ */ function(Je) {
      B(Ce, Je);
      function Ce(_t, kt, Ct) {
        return Je.call(this, le(_t, kt, Ct)) || this;
      }
      return Ce;
    }(Pe);
    Ee.prototype.name = Pe.name, Ee.prototype.code = ae, z[ae] = Ee;
  }
  function ne(ae, ve) {
    if (Array.isArray(ae)) {
      var Pe = ae.length;
      return ae = ae.map(function(le) {
        return String(le);
      }), Pe > 2 ? "one of ".concat(ve, " ").concat(ae.slice(0, Pe - 1).join(", "), ", or ") + ae[Pe - 1] : Pe === 2 ? "one of ".concat(ve, " ").concat(ae[0], " or ").concat(ae[1]) : "of ".concat(ve, " ").concat(ae[0]);
    } else
      return "of ".concat(ve, " ").concat(String(ae));
  }
  function ie(ae, ve, Pe) {
    return ae.substr(0, ve.length) === ve;
  }
  function oe(ae, ve, Pe) {
    return (Pe === void 0 || Pe > ae.length) && (Pe = ae.length), ae.substring(Pe - ve.length, Pe) === ve;
  }
  function se(ae, ve, Pe) {
    return typeof Pe != "number" && (Pe = 0), Pe + ve.length > ae.length ? !1 : ae.indexOf(ve, Pe) !== -1;
  }
  return Y("ERR_INVALID_OPT_VALUE", function(ae, ve) {
    return 'The value "' + ve + '" is invalid for option "' + ae + '"';
  }, TypeError), Y("ERR_INVALID_ARG_TYPE", function(ae, ve, Pe) {
    var le;
    typeof ve == "string" && ie(ve, "not ") ? (le = "must not be", ve = ve.replace(/^not /, "")) : le = "must be";
    var Ee;
    if (oe(ae, " argument"))
      Ee = "The ".concat(ae, " ").concat(le, " ").concat(ne(ve, "type"));
    else {
      var Je = se(ae, ".") ? "property" : "argument";
      Ee = 'The "'.concat(ae, '" ').concat(Je, " ").concat(le, " ").concat(ne(ve, "type"));
    }
    return Ee += ". Received type ".concat(typeof Pe), Ee;
  }, TypeError), Y("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), Y("ERR_METHOD_NOT_IMPLEMENTED", function(ae) {
    return "The " + ae + " method is not implemented";
  }), Y("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), Y("ERR_STREAM_DESTROYED", function(ae) {
    return "Cannot call " + ae + " after a stream was destroyed";
  }), Y("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), Y("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), Y("ERR_STREAM_WRITE_AFTER_END", "write after end"), Y("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), Y("ERR_UNKNOWN_ENCODING", function(ae) {
    return "Unknown encoding: " + ae;
  }, TypeError), Y("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = z, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var B = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function z(ne, ie, oe) {
    return ne.highWaterMark != null ? ne.highWaterMark : ie ? ne[oe] : null;
  }
  function Y(ne, ie, oe, se) {
    var ae = z(ie, se, oe);
    if (ae != null) {
      if (!(isFinite(ae) && Math.floor(ae) === ae) || ae < 0) {
        var ve = se ? oe : "highWaterMark";
        throw new B(ve, ae);
      }
      return Math.floor(ae);
    }
    return ne.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: Y
  }, state;
}
var browser$a = deprecate;
function deprecate(B, z) {
  if (config("noDeprecation"))
    return B;
  var Y = !1;
  function ne() {
    if (!Y) {
      if (config("throwDeprecation"))
        throw new Error(z);
      config("traceDeprecation") ? console.trace(z) : console.warn(z), Y = !0;
    }
    return B.apply(this, arguments);
  }
  return ne;
}
function config(B) {
  try {
    if (!commonjsGlobal.localStorage) return !1;
  } catch {
    return !1;
  }
  var z = commonjsGlobal.localStorage[B];
  return z == null ? !1 : String(z).toLowerCase() === "true";
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = jt;
  function B(Qt) {
    var Ht = this;
    this.next = null, this.entry = null, this.finish = function() {
      fr(Ht, Qt);
    };
  }
  var z;
  jt.WritableState = Vt;
  var Y = {
    deprecate: browser$a
  }, ne = requireStreamBrowser(), ie = require$$0$1.Buffer, oe = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function se(Qt) {
    return ie.from(Qt);
  }
  function ae(Qt) {
    return ie.isBuffer(Qt) || Qt instanceof oe;
  }
  var ve = requireDestroy(), Pe = requireState(), le = Pe.getHighWaterMark, Ee = requireErrorsBrowser().codes, Je = Ee.ERR_INVALID_ARG_TYPE, Ce = Ee.ERR_METHOD_NOT_IMPLEMENTED, _t = Ee.ERR_MULTIPLE_CALLBACK, kt = Ee.ERR_STREAM_CANNOT_PIPE, Ct = Ee.ERR_STREAM_DESTROYED, Lt = Ee.ERR_STREAM_NULL_VALUES, Pt = Ee.ERR_STREAM_WRITE_AFTER_END, Ft = Ee.ERR_UNKNOWN_ENCODING, Ut = ve.errorOrDestroy;
  inherits_browserExports(jt, ne);
  function Jt() {
  }
  function Vt(Qt, Ht, qt) {
    z = z || require_stream_duplex$1(), Qt = Qt || {}, typeof qt != "boolean" && (qt = Ht instanceof z), this.objectMode = !!Qt.objectMode, qt && (this.objectMode = this.objectMode || !!Qt.writableObjectMode), this.highWaterMark = le(this, Qt, "writableHighWaterMark", qt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var nr = Qt.decodeStrings === !1;
    this.decodeStrings = !nr, this.defaultEncoding = Qt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ur) {
      ht(Ht, ur);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Qt.emitClose !== !1, this.autoDestroy = !!Qt.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new B(this);
  }
  Vt.prototype.getBuffer = function() {
    for (var Ht = this.bufferedRequest, qt = []; Ht; )
      qt.push(Ht), Ht = Ht.next;
    return qt;
  }, function() {
    try {
      Object.defineProperty(Vt.prototype, "buffer", {
        get: Y.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ir;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ir = Function.prototype[Symbol.hasInstance], Object.defineProperty(jt, Symbol.hasInstance, {
    value: function(Ht) {
      return ir.call(this, Ht) ? !0 : this !== jt ? !1 : Ht && Ht._writableState instanceof Vt;
    }
  })) : ir = function(Ht) {
    return Ht instanceof this;
  };
  function jt(Qt) {
    z = z || require_stream_duplex$1();
    var Ht = this instanceof z;
    if (!Ht && !ir.call(jt, this)) return new jt(Qt);
    this._writableState = new Vt(Qt, this, Ht), this.writable = !0, Qt && (typeof Qt.write == "function" && (this._write = Qt.write), typeof Qt.writev == "function" && (this._writev = Qt.writev), typeof Qt.destroy == "function" && (this._destroy = Qt.destroy), typeof Qt.final == "function" && (this._final = Qt.final)), ne.call(this);
  }
  jt.prototype.pipe = function() {
    Ut(this, new kt());
  };
  function Rt(Qt, Ht) {
    var qt = new Pt();
    Ut(Qt, qt), process$1.nextTick(Ht, qt);
  }
  function Kt(Qt, Ht, qt, nr) {
    var ur;
    return qt === null ? ur = new Lt() : typeof qt != "string" && !Ht.objectMode && (ur = new Je("chunk", ["string", "Buffer"], qt)), ur ? (Ut(Qt, ur), process$1.nextTick(nr, ur), !1) : !0;
  }
  jt.prototype.write = function(Qt, Ht, qt) {
    var nr = this._writableState, ur = !1, zt = !nr.objectMode && ae(Qt);
    return zt && !ie.isBuffer(Qt) && (Qt = se(Qt)), typeof Ht == "function" && (qt = Ht, Ht = null), zt ? Ht = "buffer" : Ht || (Ht = nr.defaultEncoding), typeof qt != "function" && (qt = Jt), nr.ending ? Rt(this, qt) : (zt || Kt(this, nr, Qt, qt)) && (nr.pendingcb++, ur = Xe(this, nr, zt, Qt, Ht, qt)), ur;
  }, jt.prototype.cork = function() {
    this._writableState.corked++;
  }, jt.prototype.uncork = function() {
    var Qt = this._writableState;
    Qt.corked && (Qt.corked--, !Qt.writing && !Qt.corked && !Qt.bufferProcessing && Qt.bufferedRequest && $t(this, Qt));
  }, jt.prototype.setDefaultEncoding = function(Ht) {
    if (typeof Ht == "string" && (Ht = Ht.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Ht + "").toLowerCase()) > -1)) throw new Ft(Ht);
    return this._writableState.defaultEncoding = Ht, this;
  }, Object.defineProperty(jt.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function Bt(Qt, Ht, qt) {
    return !Qt.objectMode && Qt.decodeStrings !== !1 && typeof Ht == "string" && (Ht = ie.from(Ht, qt)), Ht;
  }
  Object.defineProperty(jt.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Xe(Qt, Ht, qt, nr, ur, zt) {
    if (!qt) {
      var Gt = Bt(Ht, nr, ur);
      nr !== Gt && (qt = !0, ur = "buffer", nr = Gt);
    }
    var cr = Ht.objectMode ? 1 : nr.length;
    Ht.length += cr;
    var gr = Ht.length < Ht.highWaterMark;
    if (gr || (Ht.needDrain = !0), Ht.writing || Ht.corked) {
      var $r = Ht.lastBufferedRequest;
      Ht.lastBufferedRequest = {
        chunk: nr,
        encoding: ur,
        isBuf: qt,
        callback: zt,
        next: null
      }, $r ? $r.next = Ht.lastBufferedRequest : Ht.bufferedRequest = Ht.lastBufferedRequest, Ht.bufferedRequestCount += 1;
    } else
      Ve(Qt, Ht, !1, cr, nr, ur, zt);
    return gr;
  }
  function Ve(Qt, Ht, qt, nr, ur, zt, Gt) {
    Ht.writelen = nr, Ht.writecb = Gt, Ht.writing = !0, Ht.sync = !0, Ht.destroyed ? Ht.onwrite(new Ct("write")) : qt ? Qt._writev(ur, Ht.onwrite) : Qt._write(ur, zt, Ht.onwrite), Ht.sync = !1;
  }
  function ge(Qt, Ht, qt, nr, ur) {
    --Ht.pendingcb, qt ? (process$1.nextTick(ur, nr), process$1.nextTick(Dt, Qt, Ht), Qt._writableState.errorEmitted = !0, Ut(Qt, nr)) : (ur(nr), Qt._writableState.errorEmitted = !0, Ut(Qt, nr), Dt(Qt, Ht));
  }
  function Ke(Qt) {
    Qt.writing = !1, Qt.writecb = null, Qt.length -= Qt.writelen, Qt.writelen = 0;
  }
  function ht(Qt, Ht) {
    var qt = Qt._writableState, nr = qt.sync, ur = qt.writecb;
    if (typeof ur != "function") throw new _t();
    if (Ke(qt), Ht) ge(Qt, qt, nr, Ht, ur);
    else {
      var zt = Qe(qt) || Qt.destroyed;
      !zt && !qt.corked && !qt.bufferProcessing && qt.bufferedRequest && $t(Qt, qt), nr ? process$1.nextTick(wt, Qt, qt, zt, ur) : wt(Qt, qt, zt, ur);
    }
  }
  function wt(Qt, Ht, qt, nr) {
    qt || vt(Qt, Ht), Ht.pendingcb--, nr(), Dt(Qt, Ht);
  }
  function vt(Qt, Ht) {
    Ht.length === 0 && Ht.needDrain && (Ht.needDrain = !1, Qt.emit("drain"));
  }
  function $t(Qt, Ht) {
    Ht.bufferProcessing = !0;
    var qt = Ht.bufferedRequest;
    if (Qt._writev && qt && qt.next) {
      var nr = Ht.bufferedRequestCount, ur = new Array(nr), zt = Ht.corkedRequestsFree;
      zt.entry = qt;
      for (var Gt = 0, cr = !0; qt; )
        ur[Gt] = qt, qt.isBuf || (cr = !1), qt = qt.next, Gt += 1;
      ur.allBuffers = cr, Ve(Qt, Ht, !0, Ht.length, ur, "", zt.finish), Ht.pendingcb++, Ht.lastBufferedRequest = null, zt.next ? (Ht.corkedRequestsFree = zt.next, zt.next = null) : Ht.corkedRequestsFree = new B(Ht), Ht.bufferedRequestCount = 0;
    } else {
      for (; qt; ) {
        var gr = qt.chunk, $r = qt.encoding, xr = qt.callback, Mr = Ht.objectMode ? 1 : gr.length;
        if (Ve(Qt, Ht, !1, Mr, gr, $r, xr), qt = qt.next, Ht.bufferedRequestCount--, Ht.writing)
          break;
      }
      qt === null && (Ht.lastBufferedRequest = null);
    }
    Ht.bufferedRequest = qt, Ht.bufferProcessing = !1;
  }
  jt.prototype._write = function(Qt, Ht, qt) {
    qt(new Ce("_write()"));
  }, jt.prototype._writev = null, jt.prototype.end = function(Qt, Ht, qt) {
    var nr = this._writableState;
    return typeof Qt == "function" ? (qt = Qt, Qt = null, Ht = null) : typeof Ht == "function" && (qt = Ht, Ht = null), Qt != null && this.write(Qt, Ht), nr.corked && (nr.corked = 1, this.uncork()), nr.ending || er(this, nr, qt), this;
  }, Object.defineProperty(jt.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function Qe(Qt) {
    return Qt.ending && Qt.length === 0 && Qt.bufferedRequest === null && !Qt.finished && !Qt.writing;
  }
  function xt(Qt, Ht) {
    Qt._final(function(qt) {
      Ht.pendingcb--, qt && Ut(Qt, qt), Ht.prefinished = !0, Qt.emit("prefinish"), Dt(Qt, Ht);
    });
  }
  function bt(Qt, Ht) {
    !Ht.prefinished && !Ht.finalCalled && (typeof Qt._final == "function" && !Ht.destroyed ? (Ht.pendingcb++, Ht.finalCalled = !0, process$1.nextTick(xt, Qt, Ht)) : (Ht.prefinished = !0, Qt.emit("prefinish")));
  }
  function Dt(Qt, Ht) {
    var qt = Qe(Ht);
    if (qt && (bt(Qt, Ht), Ht.pendingcb === 0 && (Ht.finished = !0, Qt.emit("finish"), Ht.autoDestroy))) {
      var nr = Qt._readableState;
      (!nr || nr.autoDestroy && nr.endEmitted) && Qt.destroy();
    }
    return qt;
  }
  function er(Qt, Ht, qt) {
    Ht.ending = !0, Dt(Qt, Ht), qt && (Ht.finished ? process$1.nextTick(qt) : Qt.once("finish", qt)), Ht.ended = !0, Qt.writable = !1;
  }
  function fr(Qt, Ht, qt) {
    var nr = Qt.entry;
    for (Qt.entry = null; nr; ) {
      var ur = nr.callback;
      Ht.pendingcb--, ur(qt), nr = nr.next;
    }
    Ht.corkedRequestsFree.next = Qt;
  }
  return Object.defineProperty(jt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Ht) {
      this._writableState && (this._writableState.destroyed = Ht);
    }
  }), jt.prototype.destroy = ve.destroy, jt.prototype._undestroy = ve.undestroy, jt.prototype._destroy = function(Qt, Ht) {
    Ht(Qt);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var B = Object.keys || function(Pe) {
    var le = [];
    for (var Ee in Pe) le.push(Ee);
    return le;
  };
  _stream_duplex$1 = se;
  var z = require_stream_readable$1(), Y = require_stream_writable$1();
  inherits_browserExports(se, z);
  for (var ne = B(Y.prototype), ie = 0; ie < ne.length; ie++) {
    var oe = ne[ie];
    se.prototype[oe] || (se.prototype[oe] = Y.prototype[oe]);
  }
  function se(Pe) {
    if (!(this instanceof se)) return new se(Pe);
    z.call(this, Pe), Y.call(this, Pe), this.allowHalfOpen = !0, Pe && (Pe.readable === !1 && (this.readable = !1), Pe.writable === !1 && (this.writable = !1), Pe.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", ae)));
  }
  Object.defineProperty(se.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(se.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(se.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ae() {
    this._writableState.ended || process$1.nextTick(ve, this);
  }
  function ve(Pe) {
    Pe.end();
  }
  return Object.defineProperty(se.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(le) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = le, this._writableState.destroyed = le);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, Buffer$B = safeBufferExports$1.Buffer, isEncoding = Buffer$B.isEncoding || function(B) {
  switch (B = "" + B, B && B.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(B) {
  if (!B) return "utf8";
  for (var z; ; )
    switch (B) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return B;
      default:
        if (z) return;
        B = ("" + B).toLowerCase(), z = !0;
    }
}
function normalizeEncoding(B) {
  var z = _normalizeEncoding(B);
  if (typeof z != "string" && (Buffer$B.isEncoding === isEncoding || !isEncoding(B))) throw new Error("Unknown encoding: " + B);
  return z || B;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(B) {
  this.encoding = normalizeEncoding(B);
  var z;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, z = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, z = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, z = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer$B.allocUnsafe(z);
}
StringDecoder$1.prototype.write = function(B) {
  if (B.length === 0) return "";
  var z, Y;
  if (this.lastNeed) {
    if (z = this.fillLast(B), z === void 0) return "";
    Y = this.lastNeed, this.lastNeed = 0;
  } else
    Y = 0;
  return Y < B.length ? z ? z + this.text(B, Y) : this.text(B, Y) : z || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(B) {
  if (this.lastNeed <= B.length)
    return B.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  B.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, B.length), this.lastNeed -= B.length;
};
function utf8CheckByte(B) {
  return B <= 127 ? 0 : B >> 5 === 6 ? 2 : B >> 4 === 14 ? 3 : B >> 3 === 30 ? 4 : B >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(B, z, Y) {
  var ne = z.length - 1;
  if (ne < Y) return 0;
  var ie = utf8CheckByte(z[ne]);
  return ie >= 0 ? (ie > 0 && (B.lastNeed = ie - 1), ie) : --ne < Y || ie === -2 ? 0 : (ie = utf8CheckByte(z[ne]), ie >= 0 ? (ie > 0 && (B.lastNeed = ie - 2), ie) : --ne < Y || ie === -2 ? 0 : (ie = utf8CheckByte(z[ne]), ie >= 0 ? (ie > 0 && (ie === 2 ? ie = 0 : B.lastNeed = ie - 3), ie) : 0));
}
function utf8CheckExtraBytes(B, z, Y) {
  if ((z[0] & 192) !== 128)
    return B.lastNeed = 0, "";
  if (B.lastNeed > 1 && z.length > 1) {
    if ((z[1] & 192) !== 128)
      return B.lastNeed = 1, "";
    if (B.lastNeed > 2 && z.length > 2 && (z[2] & 192) !== 128)
      return B.lastNeed = 2, "";
  }
}
function utf8FillLast(B) {
  var z = this.lastTotal - this.lastNeed, Y = utf8CheckExtraBytes(this, B);
  if (Y !== void 0) return Y;
  if (this.lastNeed <= B.length)
    return B.copy(this.lastChar, z, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  B.copy(this.lastChar, z, 0, B.length), this.lastNeed -= B.length;
}
function utf8Text(B, z) {
  var Y = utf8CheckIncomplete(this, B, z);
  if (!this.lastNeed) return B.toString("utf8", z);
  this.lastTotal = Y;
  var ne = B.length - (Y - this.lastNeed);
  return B.copy(this.lastChar, 0, ne), B.toString("utf8", z, ne);
}
function utf8End(B) {
  var z = B && B.length ? this.write(B) : "";
  return this.lastNeed ? z + "" : z;
}
function utf16Text(B, z) {
  if ((B.length - z) % 2 === 0) {
    var Y = B.toString("utf16le", z);
    if (Y) {
      var ne = Y.charCodeAt(Y.length - 1);
      if (ne >= 55296 && ne <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = B[B.length - 2], this.lastChar[1] = B[B.length - 1], Y.slice(0, -1);
    }
    return Y;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = B[B.length - 1], B.toString("utf16le", z, B.length - 1);
}
function utf16End(B) {
  var z = B && B.length ? this.write(B) : "";
  if (this.lastNeed) {
    var Y = this.lastTotal - this.lastNeed;
    return z + this.lastChar.toString("utf16le", 0, Y);
  }
  return z;
}
function base64Text(B, z) {
  var Y = (B.length - z) % 3;
  return Y === 0 ? B.toString("base64", z) : (this.lastNeed = 3 - Y, this.lastTotal = 3, Y === 1 ? this.lastChar[0] = B[B.length - 1] : (this.lastChar[0] = B[B.length - 2], this.lastChar[1] = B[B.length - 1]), B.toString("base64", z, B.length - Y));
}
function base64End(B) {
  var z = B && B.length ? this.write(B) : "";
  return this.lastNeed ? z + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : z;
}
function simpleWrite(B) {
  return B.toString(this.encoding);
}
function simpleEnd(B) {
  return B && B.length ? this.write(B) : "";
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var B = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function z(oe) {
    var se = !1;
    return function() {
      if (!se) {
        se = !0;
        for (var ae = arguments.length, ve = new Array(ae), Pe = 0; Pe < ae; Pe++)
          ve[Pe] = arguments[Pe];
        oe.apply(this, ve);
      }
    };
  }
  function Y() {
  }
  function ne(oe) {
    return oe.setHeader && typeof oe.abort == "function";
  }
  function ie(oe, se, ae) {
    if (typeof se == "function") return ie(oe, null, se);
    se || (se = {}), ae = z(ae || Y);
    var ve = se.readable || se.readable !== !1 && oe.readable, Pe = se.writable || se.writable !== !1 && oe.writable, le = function() {
      oe.writable || Je();
    }, Ee = oe._writableState && oe._writableState.finished, Je = function() {
      Pe = !1, Ee = !0, ve || ae.call(oe);
    }, Ce = oe._readableState && oe._readableState.endEmitted, _t = function() {
      ve = !1, Ce = !0, Pe || ae.call(oe);
    }, kt = function(Ft) {
      ae.call(oe, Ft);
    }, Ct = function() {
      var Ft;
      if (ve && !Ce)
        return (!oe._readableState || !oe._readableState.ended) && (Ft = new B()), ae.call(oe, Ft);
      if (Pe && !Ee)
        return (!oe._writableState || !oe._writableState.ended) && (Ft = new B()), ae.call(oe, Ft);
    }, Lt = function() {
      oe.req.on("finish", Je);
    };
    return ne(oe) ? (oe.on("complete", Je), oe.on("abort", Ct), oe.req ? Lt() : oe.on("request", Lt)) : Pe && !oe._writableState && (oe.on("end", le), oe.on("close", le)), oe.on("end", _t), oe.on("finish", Je), se.error !== !1 && oe.on("error", kt), oe.on("close", Ct), function() {
      oe.removeListener("complete", Je), oe.removeListener("abort", Ct), oe.removeListener("request", Lt), oe.req && oe.req.removeListener("finish", Je), oe.removeListener("end", le), oe.removeListener("close", le), oe.removeListener("finish", Je), oe.removeListener("end", _t), oe.removeListener("error", kt), oe.removeListener("close", Ct);
    };
  }
  return endOfStream = ie, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var B;
  function z(Ft, Ut, Jt) {
    return Ut = Y(Ut), Ut in Ft ? Object.defineProperty(Ft, Ut, { value: Jt, enumerable: !0, configurable: !0, writable: !0 }) : Ft[Ut] = Jt, Ft;
  }
  function Y(Ft) {
    var Ut = ne(Ft, "string");
    return typeof Ut == "symbol" ? Ut : String(Ut);
  }
  function ne(Ft, Ut) {
    if (typeof Ft != "object" || Ft === null) return Ft;
    var Jt = Ft[Symbol.toPrimitive];
    if (Jt !== void 0) {
      var Vt = Jt.call(Ft, Ut);
      if (typeof Vt != "object") return Vt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Ut === "string" ? String : Number)(Ft);
  }
  var ie = requireEndOfStream(), oe = Symbol("lastResolve"), se = Symbol("lastReject"), ae = Symbol("error"), ve = Symbol("ended"), Pe = Symbol("lastPromise"), le = Symbol("handlePromise"), Ee = Symbol("stream");
  function Je(Ft, Ut) {
    return {
      value: Ft,
      done: Ut
    };
  }
  function Ce(Ft) {
    var Ut = Ft[oe];
    if (Ut !== null) {
      var Jt = Ft[Ee].read();
      Jt !== null && (Ft[Pe] = null, Ft[oe] = null, Ft[se] = null, Ut(Je(Jt, !1)));
    }
  }
  function _t(Ft) {
    process$1.nextTick(Ce, Ft);
  }
  function kt(Ft, Ut) {
    return function(Jt, Vt) {
      Ft.then(function() {
        if (Ut[ve]) {
          Jt(Je(void 0, !0));
          return;
        }
        Ut[le](Jt, Vt);
      }, Vt);
    };
  }
  var Ct = Object.getPrototypeOf(function() {
  }), Lt = Object.setPrototypeOf((B = {
    get stream() {
      return this[Ee];
    },
    next: function() {
      var Ut = this, Jt = this[ae];
      if (Jt !== null)
        return Promise.reject(Jt);
      if (this[ve])
        return Promise.resolve(Je(void 0, !0));
      if (this[Ee].destroyed)
        return new Promise(function(Rt, Kt) {
          process$1.nextTick(function() {
            Ut[ae] ? Kt(Ut[ae]) : Rt(Je(void 0, !0));
          });
        });
      var Vt = this[Pe], ir;
      if (Vt)
        ir = new Promise(kt(Vt, this));
      else {
        var jt = this[Ee].read();
        if (jt !== null)
          return Promise.resolve(Je(jt, !1));
        ir = new Promise(this[le]);
      }
      return this[Pe] = ir, ir;
    }
  }, z(B, Symbol.asyncIterator, function() {
    return this;
  }), z(B, "return", function() {
    var Ut = this;
    return new Promise(function(Jt, Vt) {
      Ut[Ee].destroy(null, function(ir) {
        if (ir) {
          Vt(ir);
          return;
        }
        Jt(Je(void 0, !0));
      });
    });
  }), B), Ct), Pt = function(Ut) {
    var Jt, Vt = Object.create(Lt, (Jt = {}, z(Jt, Ee, {
      value: Ut,
      writable: !0
    }), z(Jt, oe, {
      value: null,
      writable: !0
    }), z(Jt, se, {
      value: null,
      writable: !0
    }), z(Jt, ae, {
      value: null,
      writable: !0
    }), z(Jt, ve, {
      value: Ut._readableState.endEmitted,
      writable: !0
    }), z(Jt, le, {
      value: function(jt, Rt) {
        var Kt = Vt[Ee].read();
        Kt ? (Vt[Pe] = null, Vt[oe] = null, Vt[se] = null, jt(Je(Kt, !1))) : (Vt[oe] = jt, Vt[se] = Rt);
      },
      writable: !0
    }), Jt));
    return Vt[Pe] = null, ie(Ut, function(ir) {
      if (ir && ir.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var jt = Vt[se];
        jt !== null && (Vt[Pe] = null, Vt[oe] = null, Vt[se] = null, jt(ir)), Vt[ae] = ir;
        return;
      }
      var Rt = Vt[oe];
      Rt !== null && (Vt[Pe] = null, Vt[oe] = null, Vt[se] = null, Rt(Je(void 0, !0))), Vt[ve] = !0;
    }), Ut.on("readable", _t.bind(null, Vt)), Vt;
  };
  return async_iterator = Pt, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = Rt;
  var B;
  Rt.ReadableState = jt, eventsExports.EventEmitter;
  var z = function(Gt, cr) {
    return Gt.listeners(cr).length;
  }, Y = requireStreamBrowser(), ne = require$$0$1.Buffer, ie = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function oe(zt) {
    return ne.from(zt);
  }
  function se(zt) {
    return ne.isBuffer(zt) || zt instanceof ie;
  }
  var ae = util$3, ve;
  ae && ae.debuglog ? ve = ae.debuglog("stream") : ve = function() {
  };
  var Pe = requireBuffer_list(), le = requireDestroy(), Ee = requireState(), Je = Ee.getHighWaterMark, Ce = requireErrorsBrowser().codes, _t = Ce.ERR_INVALID_ARG_TYPE, kt = Ce.ERR_STREAM_PUSH_AFTER_EOF, Ct = Ce.ERR_METHOD_NOT_IMPLEMENTED, Lt = Ce.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Pt, Ft, Ut;
  inherits_browserExports(Rt, Y);
  var Jt = le.errorOrDestroy, Vt = ["error", "close", "destroy", "pause", "resume"];
  function ir(zt, Gt, cr) {
    if (typeof zt.prependListener == "function") return zt.prependListener(Gt, cr);
    !zt._events || !zt._events[Gt] ? zt.on(Gt, cr) : Array.isArray(zt._events[Gt]) ? zt._events[Gt].unshift(cr) : zt._events[Gt] = [cr, zt._events[Gt]];
  }
  function jt(zt, Gt, cr) {
    B = B || require_stream_duplex$1(), zt = zt || {}, typeof cr != "boolean" && (cr = Gt instanceof B), this.objectMode = !!zt.objectMode, cr && (this.objectMode = this.objectMode || !!zt.readableObjectMode), this.highWaterMark = Je(this, zt, "readableHighWaterMark", cr), this.buffer = new Pe(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = zt.emitClose !== !1, this.autoDestroy = !!zt.autoDestroy, this.destroyed = !1, this.defaultEncoding = zt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, zt.encoding && (Pt || (Pt = string_decoder.StringDecoder), this.decoder = new Pt(zt.encoding), this.encoding = zt.encoding);
  }
  function Rt(zt) {
    if (B = B || require_stream_duplex$1(), !(this instanceof Rt)) return new Rt(zt);
    var Gt = this instanceof B;
    this._readableState = new jt(zt, this, Gt), this.readable = !0, zt && (typeof zt.read == "function" && (this._read = zt.read), typeof zt.destroy == "function" && (this._destroy = zt.destroy)), Y.call(this);
  }
  Object.defineProperty(Rt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Gt) {
      this._readableState && (this._readableState.destroyed = Gt);
    }
  }), Rt.prototype.destroy = le.destroy, Rt.prototype._undestroy = le.undestroy, Rt.prototype._destroy = function(zt, Gt) {
    Gt(zt);
  }, Rt.prototype.push = function(zt, Gt) {
    var cr = this._readableState, gr;
    return cr.objectMode ? gr = !0 : typeof zt == "string" && (Gt = Gt || cr.defaultEncoding, Gt !== cr.encoding && (zt = ne.from(zt, Gt), Gt = ""), gr = !0), Kt(this, zt, Gt, !1, gr);
  }, Rt.prototype.unshift = function(zt) {
    return Kt(this, zt, null, !0, !1);
  };
  function Kt(zt, Gt, cr, gr, $r) {
    ve("readableAddChunk", Gt);
    var xr = zt._readableState;
    if (Gt === null)
      xr.reading = !1, ht(zt, xr);
    else {
      var Mr;
      if ($r || (Mr = Xe(xr, Gt)), Mr)
        Jt(zt, Mr);
      else if (xr.objectMode || Gt && Gt.length > 0)
        if (typeof Gt != "string" && !xr.objectMode && Object.getPrototypeOf(Gt) !== ne.prototype && (Gt = oe(Gt)), gr)
          xr.endEmitted ? Jt(zt, new Lt()) : Bt(zt, xr, Gt, !0);
        else if (xr.ended)
          Jt(zt, new kt());
        else {
          if (xr.destroyed)
            return !1;
          xr.reading = !1, xr.decoder && !cr ? (Gt = xr.decoder.write(Gt), xr.objectMode || Gt.length !== 0 ? Bt(zt, xr, Gt, !1) : $t(zt, xr)) : Bt(zt, xr, Gt, !1);
        }
      else gr || (xr.reading = !1, $t(zt, xr));
    }
    return !xr.ended && (xr.length < xr.highWaterMark || xr.length === 0);
  }
  function Bt(zt, Gt, cr, gr) {
    Gt.flowing && Gt.length === 0 && !Gt.sync ? (Gt.awaitDrain = 0, zt.emit("data", cr)) : (Gt.length += Gt.objectMode ? 1 : cr.length, gr ? Gt.buffer.unshift(cr) : Gt.buffer.push(cr), Gt.needReadable && wt(zt)), $t(zt, Gt);
  }
  function Xe(zt, Gt) {
    var cr;
    return !se(Gt) && typeof Gt != "string" && Gt !== void 0 && !zt.objectMode && (cr = new _t("chunk", ["string", "Buffer", "Uint8Array"], Gt)), cr;
  }
  Rt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Rt.prototype.setEncoding = function(zt) {
    Pt || (Pt = string_decoder.StringDecoder);
    var Gt = new Pt(zt);
    this._readableState.decoder = Gt, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var cr = this._readableState.buffer.head, gr = ""; cr !== null; )
      gr += Gt.write(cr.data), cr = cr.next;
    return this._readableState.buffer.clear(), gr !== "" && this._readableState.buffer.push(gr), this._readableState.length = gr.length, this;
  };
  var Ve = 1073741824;
  function ge(zt) {
    return zt >= Ve ? zt = Ve : (zt--, zt |= zt >>> 1, zt |= zt >>> 2, zt |= zt >>> 4, zt |= zt >>> 8, zt |= zt >>> 16, zt++), zt;
  }
  function Ke(zt, Gt) {
    return zt <= 0 || Gt.length === 0 && Gt.ended ? 0 : Gt.objectMode ? 1 : zt !== zt ? Gt.flowing && Gt.length ? Gt.buffer.head.data.length : Gt.length : (zt > Gt.highWaterMark && (Gt.highWaterMark = ge(zt)), zt <= Gt.length ? zt : Gt.ended ? Gt.length : (Gt.needReadable = !0, 0));
  }
  Rt.prototype.read = function(zt) {
    ve("read", zt), zt = parseInt(zt, 10);
    var Gt = this._readableState, cr = zt;
    if (zt !== 0 && (Gt.emittedReadable = !1), zt === 0 && Gt.needReadable && ((Gt.highWaterMark !== 0 ? Gt.length >= Gt.highWaterMark : Gt.length > 0) || Gt.ended))
      return ve("read: emitReadable", Gt.length, Gt.ended), Gt.length === 0 && Gt.ended ? qt(this) : wt(this), null;
    if (zt = Ke(zt, Gt), zt === 0 && Gt.ended)
      return Gt.length === 0 && qt(this), null;
    var gr = Gt.needReadable;
    ve("need readable", gr), (Gt.length === 0 || Gt.length - zt < Gt.highWaterMark) && (gr = !0, ve("length less than watermark", gr)), Gt.ended || Gt.reading ? (gr = !1, ve("reading or ended", gr)) : gr && (ve("do read"), Gt.reading = !0, Gt.sync = !0, Gt.length === 0 && (Gt.needReadable = !0), this._read(Gt.highWaterMark), Gt.sync = !1, Gt.reading || (zt = Ke(cr, Gt)));
    var $r;
    return zt > 0 ? $r = Ht(zt, Gt) : $r = null, $r === null ? (Gt.needReadable = Gt.length <= Gt.highWaterMark, zt = 0) : (Gt.length -= zt, Gt.awaitDrain = 0), Gt.length === 0 && (Gt.ended || (Gt.needReadable = !0), cr !== zt && Gt.ended && qt(this)), $r !== null && this.emit("data", $r), $r;
  };
  function ht(zt, Gt) {
    if (ve("onEofChunk"), !Gt.ended) {
      if (Gt.decoder) {
        var cr = Gt.decoder.end();
        cr && cr.length && (Gt.buffer.push(cr), Gt.length += Gt.objectMode ? 1 : cr.length);
      }
      Gt.ended = !0, Gt.sync ? wt(zt) : (Gt.needReadable = !1, Gt.emittedReadable || (Gt.emittedReadable = !0, vt(zt)));
    }
  }
  function wt(zt) {
    var Gt = zt._readableState;
    ve("emitReadable", Gt.needReadable, Gt.emittedReadable), Gt.needReadable = !1, Gt.emittedReadable || (ve("emitReadable", Gt.flowing), Gt.emittedReadable = !0, process$1.nextTick(vt, zt));
  }
  function vt(zt) {
    var Gt = zt._readableState;
    ve("emitReadable_", Gt.destroyed, Gt.length, Gt.ended), !Gt.destroyed && (Gt.length || Gt.ended) && (zt.emit("readable"), Gt.emittedReadable = !1), Gt.needReadable = !Gt.flowing && !Gt.ended && Gt.length <= Gt.highWaterMark, Qt(zt);
  }
  function $t(zt, Gt) {
    Gt.readingMore || (Gt.readingMore = !0, process$1.nextTick(Qe, zt, Gt));
  }
  function Qe(zt, Gt) {
    for (; !Gt.reading && !Gt.ended && (Gt.length < Gt.highWaterMark || Gt.flowing && Gt.length === 0); ) {
      var cr = Gt.length;
      if (ve("maybeReadMore read 0"), zt.read(0), cr === Gt.length)
        break;
    }
    Gt.readingMore = !1;
  }
  Rt.prototype._read = function(zt) {
    Jt(this, new Ct("_read()"));
  }, Rt.prototype.pipe = function(zt, Gt) {
    var cr = this, gr = this._readableState;
    switch (gr.pipesCount) {
      case 0:
        gr.pipes = zt;
        break;
      case 1:
        gr.pipes = [gr.pipes, zt];
        break;
      default:
        gr.pipes.push(zt);
        break;
    }
    gr.pipesCount += 1, ve("pipe count=%d opts=%j", gr.pipesCount, Gt);
    var $r = (!Gt || Gt.end !== !1) && zt !== process$1.stdout && zt !== process$1.stderr, xr = $r ? kr : Jr;
    gr.endEmitted ? process$1.nextTick(xr) : cr.once("end", xr), zt.on("unpipe", Mr);
    function Mr(Hr, Vr) {
      ve("onunpipe"), Hr === cr && Vr && Vr.hasUnpiped === !1 && (Vr.hasUnpiped = !0, jr());
    }
    function kr() {
      ve("onend"), zt.end();
    }
    var br = xt(cr);
    zt.on("drain", br);
    var Yr = !1;
    function jr() {
      ve("cleanup"), zt.removeListener("close", Or), zt.removeListener("finish", Wr), zt.removeListener("drain", br), zt.removeListener("error", Xr), zt.removeListener("unpipe", Mr), cr.removeListener("end", kr), cr.removeListener("end", Jr), cr.removeListener("data", Qr), Yr = !0, gr.awaitDrain && (!zt._writableState || zt._writableState.needDrain) && br();
    }
    cr.on("data", Qr);
    function Qr(Hr) {
      ve("ondata");
      var Vr = zt.write(Hr);
      ve("dest.write", Vr), Vr === !1 && ((gr.pipesCount === 1 && gr.pipes === zt || gr.pipesCount > 1 && ur(gr.pipes, zt) !== -1) && !Yr && (ve("false write response, pause", gr.awaitDrain), gr.awaitDrain++), cr.pause());
    }
    function Xr(Hr) {
      ve("onerror", Hr), Jr(), zt.removeListener("error", Xr), z(zt, "error") === 0 && Jt(zt, Hr);
    }
    ir(zt, "error", Xr);
    function Or() {
      zt.removeListener("finish", Wr), Jr();
    }
    zt.once("close", Or);
    function Wr() {
      ve("onfinish"), zt.removeListener("close", Or), Jr();
    }
    zt.once("finish", Wr);
    function Jr() {
      ve("unpipe"), cr.unpipe(zt);
    }
    return zt.emit("pipe", cr), gr.flowing || (ve("pipe resume"), cr.resume()), zt;
  };
  function xt(zt) {
    return function() {
      var cr = zt._readableState;
      ve("pipeOnDrain", cr.awaitDrain), cr.awaitDrain && cr.awaitDrain--, cr.awaitDrain === 0 && z(zt, "data") && (cr.flowing = !0, Qt(zt));
    };
  }
  Rt.prototype.unpipe = function(zt) {
    var Gt = this._readableState, cr = {
      hasUnpiped: !1
    };
    if (Gt.pipesCount === 0) return this;
    if (Gt.pipesCount === 1)
      return zt && zt !== Gt.pipes ? this : (zt || (zt = Gt.pipes), Gt.pipes = null, Gt.pipesCount = 0, Gt.flowing = !1, zt && zt.emit("unpipe", this, cr), this);
    if (!zt) {
      var gr = Gt.pipes, $r = Gt.pipesCount;
      Gt.pipes = null, Gt.pipesCount = 0, Gt.flowing = !1;
      for (var xr = 0; xr < $r; xr++) gr[xr].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var Mr = ur(Gt.pipes, zt);
    return Mr === -1 ? this : (Gt.pipes.splice(Mr, 1), Gt.pipesCount -= 1, Gt.pipesCount === 1 && (Gt.pipes = Gt.pipes[0]), zt.emit("unpipe", this, cr), this);
  }, Rt.prototype.on = function(zt, Gt) {
    var cr = Y.prototype.on.call(this, zt, Gt), gr = this._readableState;
    return zt === "data" ? (gr.readableListening = this.listenerCount("readable") > 0, gr.flowing !== !1 && this.resume()) : zt === "readable" && !gr.endEmitted && !gr.readableListening && (gr.readableListening = gr.needReadable = !0, gr.flowing = !1, gr.emittedReadable = !1, ve("on readable", gr.length, gr.reading), gr.length ? wt(this) : gr.reading || process$1.nextTick(Dt, this)), cr;
  }, Rt.prototype.addListener = Rt.prototype.on, Rt.prototype.removeListener = function(zt, Gt) {
    var cr = Y.prototype.removeListener.call(this, zt, Gt);
    return zt === "readable" && process$1.nextTick(bt, this), cr;
  }, Rt.prototype.removeAllListeners = function(zt) {
    var Gt = Y.prototype.removeAllListeners.apply(this, arguments);
    return (zt === "readable" || zt === void 0) && process$1.nextTick(bt, this), Gt;
  };
  function bt(zt) {
    var Gt = zt._readableState;
    Gt.readableListening = zt.listenerCount("readable") > 0, Gt.resumeScheduled && !Gt.paused ? Gt.flowing = !0 : zt.listenerCount("data") > 0 && zt.resume();
  }
  function Dt(zt) {
    ve("readable nexttick read 0"), zt.read(0);
  }
  Rt.prototype.resume = function() {
    var zt = this._readableState;
    return zt.flowing || (ve("resume"), zt.flowing = !zt.readableListening, er(this, zt)), zt.paused = !1, this;
  };
  function er(zt, Gt) {
    Gt.resumeScheduled || (Gt.resumeScheduled = !0, process$1.nextTick(fr, zt, Gt));
  }
  function fr(zt, Gt) {
    ve("resume", Gt.reading), Gt.reading || zt.read(0), Gt.resumeScheduled = !1, zt.emit("resume"), Qt(zt), Gt.flowing && !Gt.reading && zt.read(0);
  }
  Rt.prototype.pause = function() {
    return ve("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ve("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Qt(zt) {
    var Gt = zt._readableState;
    for (ve("flow", Gt.flowing); Gt.flowing && zt.read() !== null; ) ;
  }
  Rt.prototype.wrap = function(zt) {
    var Gt = this, cr = this._readableState, gr = !1;
    zt.on("end", function() {
      if (ve("wrapped end"), cr.decoder && !cr.ended) {
        var Mr = cr.decoder.end();
        Mr && Mr.length && Gt.push(Mr);
      }
      Gt.push(null);
    }), zt.on("data", function(Mr) {
      if (ve("wrapped data"), cr.decoder && (Mr = cr.decoder.write(Mr)), !(cr.objectMode && Mr == null) && !(!cr.objectMode && (!Mr || !Mr.length))) {
        var kr = Gt.push(Mr);
        kr || (gr = !0, zt.pause());
      }
    });
    for (var $r in zt)
      this[$r] === void 0 && typeof zt[$r] == "function" && (this[$r] = /* @__PURE__ */ function(kr) {
        return function() {
          return zt[kr].apply(zt, arguments);
        };
      }($r));
    for (var xr = 0; xr < Vt.length; xr++)
      zt.on(Vt[xr], this.emit.bind(this, Vt[xr]));
    return this._read = function(Mr) {
      ve("wrapped _read", Mr), gr && (gr = !1, zt.resume());
    }, this;
  }, typeof Symbol == "function" && (Rt.prototype[Symbol.asyncIterator] = function() {
    return Ft === void 0 && (Ft = requireAsync_iterator()), Ft(this);
  }), Object.defineProperty(Rt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Rt.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Rt.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Gt) {
      this._readableState && (this._readableState.flowing = Gt);
    }
  }), Rt._fromList = Ht, Object.defineProperty(Rt.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Ht(zt, Gt) {
    if (Gt.length === 0) return null;
    var cr;
    return Gt.objectMode ? cr = Gt.buffer.shift() : !zt || zt >= Gt.length ? (Gt.decoder ? cr = Gt.buffer.join("") : Gt.buffer.length === 1 ? cr = Gt.buffer.first() : cr = Gt.buffer.concat(Gt.length), Gt.buffer.clear()) : cr = Gt.buffer.consume(zt, Gt.decoder), cr;
  }
  function qt(zt) {
    var Gt = zt._readableState;
    ve("endReadable", Gt.endEmitted), Gt.endEmitted || (Gt.ended = !0, process$1.nextTick(nr, Gt, zt));
  }
  function nr(zt, Gt) {
    if (ve("endReadableNT", zt.endEmitted, zt.length), !zt.endEmitted && zt.length === 0 && (zt.endEmitted = !0, Gt.readable = !1, Gt.emit("end"), zt.autoDestroy)) {
      var cr = Gt._writableState;
      (!cr || cr.autoDestroy && cr.finished) && Gt.destroy();
    }
  }
  typeof Symbol == "function" && (Rt.from = function(zt, Gt) {
    return Ut === void 0 && (Ut = requireFromBrowser()), Ut(Rt, zt, Gt);
  });
  function ur(zt, Gt) {
    for (var cr = 0, gr = zt.length; cr < gr; cr++)
      if (zt[cr] === Gt) return cr;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform$1;
  hasRequired_stream_transform = 1, _stream_transform$1 = ae;
  var B = requireErrorsBrowser().codes, z = B.ERR_METHOD_NOT_IMPLEMENTED, Y = B.ERR_MULTIPLE_CALLBACK, ne = B.ERR_TRANSFORM_ALREADY_TRANSFORMING, ie = B.ERR_TRANSFORM_WITH_LENGTH_0, oe = require_stream_duplex$1();
  inherits_browserExports(ae, oe);
  function se(le, Ee) {
    var Je = this._transformState;
    Je.transforming = !1;
    var Ce = Je.writecb;
    if (Ce === null)
      return this.emit("error", new Y());
    Je.writechunk = null, Je.writecb = null, Ee != null && this.push(Ee), Ce(le);
    var _t = this._readableState;
    _t.reading = !1, (_t.needReadable || _t.length < _t.highWaterMark) && this._read(_t.highWaterMark);
  }
  function ae(le) {
    if (!(this instanceof ae)) return new ae(le);
    oe.call(this, le), this._transformState = {
      afterTransform: se.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, le && (typeof le.transform == "function" && (this._transform = le.transform), typeof le.flush == "function" && (this._flush = le.flush)), this.on("prefinish", ve);
  }
  function ve() {
    var le = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(Ee, Je) {
      Pe(le, Ee, Je);
    }) : Pe(this, null, null);
  }
  ae.prototype.push = function(le, Ee) {
    return this._transformState.needTransform = !1, oe.prototype.push.call(this, le, Ee);
  }, ae.prototype._transform = function(le, Ee, Je) {
    Je(new z("_transform()"));
  }, ae.prototype._write = function(le, Ee, Je) {
    var Ce = this._transformState;
    if (Ce.writecb = Je, Ce.writechunk = le, Ce.writeencoding = Ee, !Ce.transforming) {
      var _t = this._readableState;
      (Ce.needTransform || _t.needReadable || _t.length < _t.highWaterMark) && this._read(_t.highWaterMark);
    }
  }, ae.prototype._read = function(le) {
    var Ee = this._transformState;
    Ee.writechunk !== null && !Ee.transforming ? (Ee.transforming = !0, this._transform(Ee.writechunk, Ee.writeencoding, Ee.afterTransform)) : Ee.needTransform = !0;
  }, ae.prototype._destroy = function(le, Ee) {
    oe.prototype._destroy.call(this, le, function(Je) {
      Ee(Je);
    });
  };
  function Pe(le, Ee, Je) {
    if (Ee) return le.emit("error", Ee);
    if (Je != null && le.push(Je), le._writableState.length) throw new ie();
    if (le._transformState.transforming) throw new ne();
    return le.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough$1;
  hasRequired_stream_passthrough = 1, _stream_passthrough$1 = z;
  var B = require_stream_transform();
  inherits_browserExports(z, B);
  function z(Y) {
    if (!(this instanceof z)) return new z(Y);
    B.call(this, Y);
  }
  return z.prototype._transform = function(Y, ne, ie) {
    ie(null, Y);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var B;
  function z(Je) {
    var Ce = !1;
    return function() {
      Ce || (Ce = !0, Je.apply(void 0, arguments));
    };
  }
  var Y = requireErrorsBrowser().codes, ne = Y.ERR_MISSING_ARGS, ie = Y.ERR_STREAM_DESTROYED;
  function oe(Je) {
    if (Je) throw Je;
  }
  function se(Je) {
    return Je.setHeader && typeof Je.abort == "function";
  }
  function ae(Je, Ce, _t, kt) {
    kt = z(kt);
    var Ct = !1;
    Je.on("close", function() {
      Ct = !0;
    }), B === void 0 && (B = requireEndOfStream()), B(Je, {
      readable: Ce,
      writable: _t
    }, function(Pt) {
      if (Pt) return kt(Pt);
      Ct = !0, kt();
    });
    var Lt = !1;
    return function(Pt) {
      if (!Ct && !Lt) {
        if (Lt = !0, se(Je)) return Je.abort();
        if (typeof Je.destroy == "function") return Je.destroy();
        kt(Pt || new ie("pipe"));
      }
    };
  }
  function ve(Je) {
    Je();
  }
  function Pe(Je, Ce) {
    return Je.pipe(Ce);
  }
  function le(Je) {
    return !Je.length || typeof Je[Je.length - 1] != "function" ? oe : Je.pop();
  }
  function Ee() {
    for (var Je = arguments.length, Ce = new Array(Je), _t = 0; _t < Je; _t++)
      Ce[_t] = arguments[_t];
    var kt = le(Ce);
    if (Array.isArray(Ce[0]) && (Ce = Ce[0]), Ce.length < 2)
      throw new ne("streams");
    var Ct, Lt = Ce.map(function(Pt, Ft) {
      var Ut = Ft < Ce.length - 1, Jt = Ft > 0;
      return ae(Pt, Ut, Jt, function(Vt) {
        Ct || (Ct = Vt), Vt && Lt.forEach(ve), !Ut && (Lt.forEach(ve), kt(Ct));
      });
    });
    return Ce.reduce(Pe);
  }
  return pipeline_1 = Ee, pipeline_1;
}
(function(B, z) {
  z = B.exports = require_stream_readable$1(), z.Stream = z, z.Readable = z, z.Writable = require_stream_writable$1(), z.Duplex = require_stream_duplex$1(), z.Transform = require_stream_transform(), z.PassThrough = require_stream_passthrough(), z.finished = requireEndOfStream(), z.pipeline = requirePipeline();
})(readableBrowser$1, readableBrowser$1.exports);
var readableBrowserExports$1 = readableBrowser$1.exports, Buffer$A = safeBufferExports$1.Buffer, Transform$7 = readableBrowserExports$1.Transform, inherits$q = inherits_browserExports;
function throwIfNotStringOrBuffer(B, z) {
  if (!Buffer$A.isBuffer(B) && typeof B != "string")
    throw new TypeError(z + " must be a string or a buffer");
}
function HashBase$2(B) {
  Transform$7.call(this), this._block = Buffer$A.allocUnsafe(B), this._blockSize = B, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
inherits$q(HashBase$2, Transform$7);
HashBase$2.prototype._transform = function(B, z, Y) {
  var ne = null;
  try {
    this.update(B, z);
  } catch (ie) {
    ne = ie;
  }
  Y(ne);
};
HashBase$2.prototype._flush = function(B) {
  var z = null;
  try {
    this.push(this.digest());
  } catch (Y) {
    z = Y;
  }
  B(z);
};
HashBase$2.prototype.update = function(B, z) {
  if (throwIfNotStringOrBuffer(B, "Data"), this._finalized) throw new Error("Digest already called");
  Buffer$A.isBuffer(B) || (B = Buffer$A.from(B, z));
  for (var Y = this._block, ne = 0; this._blockOffset + B.length - ne >= this._blockSize; ) {
    for (var ie = this._blockOffset; ie < this._blockSize; ) Y[ie++] = B[ne++];
    this._update(), this._blockOffset = 0;
  }
  for (; ne < B.length; ) Y[this._blockOffset++] = B[ne++];
  for (var oe = 0, se = B.length * 8; se > 0; ++oe)
    this._length[oe] += se, se = this._length[oe] / 4294967296 | 0, se > 0 && (this._length[oe] -= 4294967296 * se);
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(B) {
  if (this._finalized) throw new Error("Digest already called");
  this._finalized = !0;
  var z = this._digest();
  B !== void 0 && (z = z.toString(B)), this._block.fill(0), this._blockOffset = 0;
  for (var Y = 0; Y < 4; ++Y) this._length[Y] = 0;
  return z;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2, inherits$p = inherits_browserExports, HashBase$1 = hashBase, Buffer$z = safeBufferExports$1.Buffer, ARRAY16$1 = new Array(16);
function MD5$3() {
  HashBase$1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
inherits$p(MD5$3, HashBase$1);
MD5$3.prototype._update = function() {
  for (var B = ARRAY16$1, z = 0; z < 16; ++z) B[z] = this._block.readInt32LE(z * 4);
  var Y = this._a, ne = this._b, ie = this._c, oe = this._d;
  Y = fnF(Y, ne, ie, oe, B[0], 3614090360, 7), oe = fnF(oe, Y, ne, ie, B[1], 3905402710, 12), ie = fnF(ie, oe, Y, ne, B[2], 606105819, 17), ne = fnF(ne, ie, oe, Y, B[3], 3250441966, 22), Y = fnF(Y, ne, ie, oe, B[4], 4118548399, 7), oe = fnF(oe, Y, ne, ie, B[5], 1200080426, 12), ie = fnF(ie, oe, Y, ne, B[6], 2821735955, 17), ne = fnF(ne, ie, oe, Y, B[7], 4249261313, 22), Y = fnF(Y, ne, ie, oe, B[8], 1770035416, 7), oe = fnF(oe, Y, ne, ie, B[9], 2336552879, 12), ie = fnF(ie, oe, Y, ne, B[10], 4294925233, 17), ne = fnF(ne, ie, oe, Y, B[11], 2304563134, 22), Y = fnF(Y, ne, ie, oe, B[12], 1804603682, 7), oe = fnF(oe, Y, ne, ie, B[13], 4254626195, 12), ie = fnF(ie, oe, Y, ne, B[14], 2792965006, 17), ne = fnF(ne, ie, oe, Y, B[15], 1236535329, 22), Y = fnG(Y, ne, ie, oe, B[1], 4129170786, 5), oe = fnG(oe, Y, ne, ie, B[6], 3225465664, 9), ie = fnG(ie, oe, Y, ne, B[11], 643717713, 14), ne = fnG(ne, ie, oe, Y, B[0], 3921069994, 20), Y = fnG(Y, ne, ie, oe, B[5], 3593408605, 5), oe = fnG(oe, Y, ne, ie, B[10], 38016083, 9), ie = fnG(ie, oe, Y, ne, B[15], 3634488961, 14), ne = fnG(ne, ie, oe, Y, B[4], 3889429448, 20), Y = fnG(Y, ne, ie, oe, B[9], 568446438, 5), oe = fnG(oe, Y, ne, ie, B[14], 3275163606, 9), ie = fnG(ie, oe, Y, ne, B[3], 4107603335, 14), ne = fnG(ne, ie, oe, Y, B[8], 1163531501, 20), Y = fnG(Y, ne, ie, oe, B[13], 2850285829, 5), oe = fnG(oe, Y, ne, ie, B[2], 4243563512, 9), ie = fnG(ie, oe, Y, ne, B[7], 1735328473, 14), ne = fnG(ne, ie, oe, Y, B[12], 2368359562, 20), Y = fnH(Y, ne, ie, oe, B[5], 4294588738, 4), oe = fnH(oe, Y, ne, ie, B[8], 2272392833, 11), ie = fnH(ie, oe, Y, ne, B[11], 1839030562, 16), ne = fnH(ne, ie, oe, Y, B[14], 4259657740, 23), Y = fnH(Y, ne, ie, oe, B[1], 2763975236, 4), oe = fnH(oe, Y, ne, ie, B[4], 1272893353, 11), ie = fnH(ie, oe, Y, ne, B[7], 4139469664, 16), ne = fnH(ne, ie, oe, Y, B[10], 3200236656, 23), Y = fnH(Y, ne, ie, oe, B[13], 681279174, 4), oe = fnH(oe, Y, ne, ie, B[0], 3936430074, 11), ie = fnH(ie, oe, Y, ne, B[3], 3572445317, 16), ne = fnH(ne, ie, oe, Y, B[6], 76029189, 23), Y = fnH(Y, ne, ie, oe, B[9], 3654602809, 4), oe = fnH(oe, Y, ne, ie, B[12], 3873151461, 11), ie = fnH(ie, oe, Y, ne, B[15], 530742520, 16), ne = fnH(ne, ie, oe, Y, B[2], 3299628645, 23), Y = fnI(Y, ne, ie, oe, B[0], 4096336452, 6), oe = fnI(oe, Y, ne, ie, B[7], 1126891415, 10), ie = fnI(ie, oe, Y, ne, B[14], 2878612391, 15), ne = fnI(ne, ie, oe, Y, B[5], 4237533241, 21), Y = fnI(Y, ne, ie, oe, B[12], 1700485571, 6), oe = fnI(oe, Y, ne, ie, B[3], 2399980690, 10), ie = fnI(ie, oe, Y, ne, B[10], 4293915773, 15), ne = fnI(ne, ie, oe, Y, B[1], 2240044497, 21), Y = fnI(Y, ne, ie, oe, B[8], 1873313359, 6), oe = fnI(oe, Y, ne, ie, B[15], 4264355552, 10), ie = fnI(ie, oe, Y, ne, B[6], 2734768916, 15), ne = fnI(ne, ie, oe, Y, B[13], 1309151649, 21), Y = fnI(Y, ne, ie, oe, B[4], 4149444226, 6), oe = fnI(oe, Y, ne, ie, B[11], 3174756917, 10), ie = fnI(ie, oe, Y, ne, B[2], 718787259, 15), ne = fnI(ne, ie, oe, Y, B[9], 3951481745, 21), this._a = this._a + Y | 0, this._b = this._b + ne | 0, this._c = this._c + ie | 0, this._d = this._d + oe | 0;
};
MD5$3.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var B = Buffer$z.allocUnsafe(16);
  return B.writeInt32LE(this._a, 0), B.writeInt32LE(this._b, 4), B.writeInt32LE(this._c, 8), B.writeInt32LE(this._d, 12), B;
};
function rotl$1(B, z) {
  return B << z | B >>> 32 - z;
}
function fnF(B, z, Y, ne, ie, oe, se) {
  return rotl$1(B + (z & Y | ~z & ne) + ie + oe | 0, se) + z | 0;
}
function fnG(B, z, Y, ne, ie, oe, se) {
  return rotl$1(B + (z & ne | Y & ~ne) + ie + oe | 0, se) + z | 0;
}
function fnH(B, z, Y, ne, ie, oe, se) {
  return rotl$1(B + (z ^ Y ^ ne) + ie + oe | 0, se) + z | 0;
}
function fnI(B, z, Y, ne, ie, oe, se) {
  return rotl$1(B + (Y ^ (z | ~ne)) + ie + oe | 0, se) + z | 0;
}
var md5_js = MD5$3, Buffer$y = require$$0$1.Buffer, inherits$o = inherits_browserExports, HashBase = hashBase, ARRAY16 = new Array(16), zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$5() {
  HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
inherits$o(RIPEMD160$5, HashBase);
RIPEMD160$5.prototype._update = function() {
  for (var B = ARRAY16, z = 0; z < 16; ++z) B[z] = this._block.readInt32LE(z * 4);
  for (var Y = this._a | 0, ne = this._b | 0, ie = this._c | 0, oe = this._d | 0, se = this._e | 0, ae = this._a | 0, ve = this._b | 0, Pe = this._c | 0, le = this._d | 0, Ee = this._e | 0, Je = 0; Je < 80; Je += 1) {
    var Ce, _t;
    Je < 16 ? (Ce = fn1(Y, ne, ie, oe, se, B[zl[Je]], hl[0], sl[Je]), _t = fn5(ae, ve, Pe, le, Ee, B[zr[Je]], hr[0], sr[Je])) : Je < 32 ? (Ce = fn2(Y, ne, ie, oe, se, B[zl[Je]], hl[1], sl[Je]), _t = fn4(ae, ve, Pe, le, Ee, B[zr[Je]], hr[1], sr[Je])) : Je < 48 ? (Ce = fn3(Y, ne, ie, oe, se, B[zl[Je]], hl[2], sl[Je]), _t = fn3(ae, ve, Pe, le, Ee, B[zr[Je]], hr[2], sr[Je])) : Je < 64 ? (Ce = fn4(Y, ne, ie, oe, se, B[zl[Je]], hl[3], sl[Je]), _t = fn2(ae, ve, Pe, le, Ee, B[zr[Je]], hr[3], sr[Je])) : (Ce = fn5(Y, ne, ie, oe, se, B[zl[Je]], hl[4], sl[Je]), _t = fn1(ae, ve, Pe, le, Ee, B[zr[Je]], hr[4], sr[Je])), Y = se, se = oe, oe = rotl(ie, 10), ie = ne, ne = Ce, ae = Ee, Ee = le, le = rotl(Pe, 10), Pe = ve, ve = _t;
  }
  var kt = this._b + ie + le | 0;
  this._b = this._c + oe + Ee | 0, this._c = this._d + se + ae | 0, this._d = this._e + Y + ve | 0, this._e = this._a + ne + Pe | 0, this._a = kt;
};
RIPEMD160$5.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var B = Buffer$y.alloc ? Buffer$y.alloc(20) : new Buffer$y(20);
  return B.writeInt32LE(this._a, 0), B.writeInt32LE(this._b, 4), B.writeInt32LE(this._c, 8), B.writeInt32LE(this._d, 12), B.writeInt32LE(this._e, 16), B;
};
function rotl(B, z) {
  return B << z | B >>> 32 - z;
}
function fn1(B, z, Y, ne, ie, oe, se, ae) {
  return rotl(B + (z ^ Y ^ ne) + oe + se | 0, ae) + ie | 0;
}
function fn2(B, z, Y, ne, ie, oe, se, ae) {
  return rotl(B + (z & Y | ~z & ne) + oe + se | 0, ae) + ie | 0;
}
function fn3(B, z, Y, ne, ie, oe, se, ae) {
  return rotl(B + ((z | ~Y) ^ ne) + oe + se | 0, ae) + ie | 0;
}
function fn4(B, z, Y, ne, ie, oe, se, ae) {
  return rotl(B + (z & ne | Y & ~ne) + oe + se | 0, ae) + ie | 0;
}
function fn5(B, z, Y, ne, ie, oe, se, ae) {
  return rotl(B + (z ^ (Y | ~ne)) + oe + se | 0, ae) + ie | 0;
}
var ripemd160$1 = RIPEMD160$5, sha_js = { exports: {} }, Buffer$x = safeBufferExports$1.Buffer;
function Hash$7(B, z) {
  this._block = Buffer$x.alloc(B), this._finalSize = z, this._blockSize = B, this._len = 0;
}
Hash$7.prototype.update = function(B, z) {
  typeof B == "string" && (z = z || "utf8", B = Buffer$x.from(B, z));
  for (var Y = this._block, ne = this._blockSize, ie = B.length, oe = this._len, se = 0; se < ie; ) {
    for (var ae = oe % ne, ve = Math.min(ie - se, ne - ae), Pe = 0; Pe < ve; Pe++)
      Y[ae + Pe] = B[se + Pe];
    oe += ve, se += ve, oe % ne === 0 && this._update(Y);
  }
  return this._len += ie, this;
};
Hash$7.prototype.digest = function(B) {
  var z = this._len % this._blockSize;
  this._block[z] = 128, this._block.fill(0, z + 1), z >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var Y = this._len * 8;
  if (Y <= 4294967295)
    this._block.writeUInt32BE(Y, this._blockSize - 4);
  else {
    var ne = (Y & 4294967295) >>> 0, ie = (Y - ne) / 4294967296;
    this._block.writeUInt32BE(ie, this._blockSize - 8), this._block.writeUInt32BE(ne, this._blockSize - 4);
  }
  this._update(this._block);
  var oe = this._hash();
  return B ? oe.toString(B) : oe;
};
Hash$7.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$3 = Hash$7, inherits$n = inherits_browserExports, Hash$6 = hash$3, Buffer$w = safeBufferExports$1.Buffer, K$4 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$5 = new Array(80);
function Sha() {
  this.init(), this._w = W$5, Hash$6.call(this, 64, 56);
}
inherits$n(Sha, Hash$6);
Sha.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl5$1(B) {
  return B << 5 | B >>> 27;
}
function rotl30$1(B) {
  return B << 30 | B >>> 2;
}
function ft$1(B, z, Y, ne) {
  return B === 0 ? z & Y | ~z & ne : B === 2 ? z & Y | z & ne | Y & ne : z ^ Y ^ ne;
}
Sha.prototype._update = function(B) {
  for (var z = this._w, Y = this._a | 0, ne = this._b | 0, ie = this._c | 0, oe = this._d | 0, se = this._e | 0, ae = 0; ae < 16; ++ae) z[ae] = B.readInt32BE(ae * 4);
  for (; ae < 80; ++ae) z[ae] = z[ae - 3] ^ z[ae - 8] ^ z[ae - 14] ^ z[ae - 16];
  for (var ve = 0; ve < 80; ++ve) {
    var Pe = ~~(ve / 20), le = rotl5$1(Y) + ft$1(Pe, ne, ie, oe) + se + z[ve] + K$4[Pe] | 0;
    se = oe, oe = ie, ie = rotl30$1(ne), ne = Y, Y = le;
  }
  this._a = Y + this._a | 0, this._b = ne + this._b | 0, this._c = ie + this._c | 0, this._d = oe + this._d | 0, this._e = se + this._e | 0;
};
Sha.prototype._hash = function() {
  var B = Buffer$w.allocUnsafe(20);
  return B.writeInt32BE(this._a | 0, 0), B.writeInt32BE(this._b | 0, 4), B.writeInt32BE(this._c | 0, 8), B.writeInt32BE(this._d | 0, 12), B.writeInt32BE(this._e | 0, 16), B;
};
var sha$4 = Sha, inherits$m = inherits_browserExports, Hash$5 = hash$3, Buffer$v = safeBufferExports$1.Buffer, K$3 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$4 = new Array(80);
function Sha1() {
  this.init(), this._w = W$4, Hash$5.call(this, 64, 56);
}
inherits$m(Sha1, Hash$5);
Sha1.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl1(B) {
  return B << 1 | B >>> 31;
}
function rotl5(B) {
  return B << 5 | B >>> 27;
}
function rotl30(B) {
  return B << 30 | B >>> 2;
}
function ft(B, z, Y, ne) {
  return B === 0 ? z & Y | ~z & ne : B === 2 ? z & Y | z & ne | Y & ne : z ^ Y ^ ne;
}
Sha1.prototype._update = function(B) {
  for (var z = this._w, Y = this._a | 0, ne = this._b | 0, ie = this._c | 0, oe = this._d | 0, se = this._e | 0, ae = 0; ae < 16; ++ae) z[ae] = B.readInt32BE(ae * 4);
  for (; ae < 80; ++ae) z[ae] = rotl1(z[ae - 3] ^ z[ae - 8] ^ z[ae - 14] ^ z[ae - 16]);
  for (var ve = 0; ve < 80; ++ve) {
    var Pe = ~~(ve / 20), le = rotl5(Y) + ft(Pe, ne, ie, oe) + se + z[ve] + K$3[Pe] | 0;
    se = oe, oe = ie, ie = rotl30(ne), ne = Y, Y = le;
  }
  this._a = Y + this._a | 0, this._b = ne + this._b | 0, this._c = ie + this._c | 0, this._d = oe + this._d | 0, this._e = se + this._e | 0;
};
Sha1.prototype._hash = function() {
  var B = Buffer$v.allocUnsafe(20);
  return B.writeInt32BE(this._a | 0, 0), B.writeInt32BE(this._b | 0, 4), B.writeInt32BE(this._c | 0, 8), B.writeInt32BE(this._d | 0, 12), B.writeInt32BE(this._e | 0, 16), B;
};
var sha1$1 = Sha1, inherits$l = inherits_browserExports, Hash$4 = hash$3, Buffer$u = safeBufferExports$1.Buffer, K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], W$3 = new Array(64);
function Sha256$1() {
  this.init(), this._w = W$3, Hash$4.call(this, 64, 56);
}
inherits$l(Sha256$1, Hash$4);
Sha256$1.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function ch(B, z, Y) {
  return Y ^ B & (z ^ Y);
}
function maj$1(B, z, Y) {
  return B & z | Y & (B | z);
}
function sigma0$1(B) {
  return (B >>> 2 | B << 30) ^ (B >>> 13 | B << 19) ^ (B >>> 22 | B << 10);
}
function sigma1$1(B) {
  return (B >>> 6 | B << 26) ^ (B >>> 11 | B << 21) ^ (B >>> 25 | B << 7);
}
function gamma0(B) {
  return (B >>> 7 | B << 25) ^ (B >>> 18 | B << 14) ^ B >>> 3;
}
function gamma1(B) {
  return (B >>> 17 | B << 15) ^ (B >>> 19 | B << 13) ^ B >>> 10;
}
Sha256$1.prototype._update = function(B) {
  for (var z = this._w, Y = this._a | 0, ne = this._b | 0, ie = this._c | 0, oe = this._d | 0, se = this._e | 0, ae = this._f | 0, ve = this._g | 0, Pe = this._h | 0, le = 0; le < 16; ++le) z[le] = B.readInt32BE(le * 4);
  for (; le < 64; ++le) z[le] = gamma1(z[le - 2]) + z[le - 7] + gamma0(z[le - 15]) + z[le - 16] | 0;
  for (var Ee = 0; Ee < 64; ++Ee) {
    var Je = Pe + sigma1$1(se) + ch(se, ae, ve) + K$2[Ee] + z[Ee] | 0, Ce = sigma0$1(Y) + maj$1(Y, ne, ie) | 0;
    Pe = ve, ve = ae, ae = se, se = oe + Je | 0, oe = ie, ie = ne, ne = Y, Y = Je + Ce | 0;
  }
  this._a = Y + this._a | 0, this._b = ne + this._b | 0, this._c = ie + this._c | 0, this._d = oe + this._d | 0, this._e = se + this._e | 0, this._f = ae + this._f | 0, this._g = ve + this._g | 0, this._h = Pe + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var B = Buffer$u.allocUnsafe(32);
  return B.writeInt32BE(this._a, 0), B.writeInt32BE(this._b, 4), B.writeInt32BE(this._c, 8), B.writeInt32BE(this._d, 12), B.writeInt32BE(this._e, 16), B.writeInt32BE(this._f, 20), B.writeInt32BE(this._g, 24), B.writeInt32BE(this._h, 28), B;
};
var sha256$3 = Sha256$1, inherits$k = inherits_browserExports, Sha256 = sha256$3, Hash$3 = hash$3, Buffer$t = safeBufferExports$1.Buffer, W$2 = new Array(64);
function Sha224() {
  this.init(), this._w = W$2, Hash$3.call(this, 64, 56);
}
inherits$k(Sha224, Sha256);
Sha224.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Sha224.prototype._hash = function() {
  var B = Buffer$t.allocUnsafe(28);
  return B.writeInt32BE(this._a, 0), B.writeInt32BE(this._b, 4), B.writeInt32BE(this._c, 8), B.writeInt32BE(this._d, 12), B.writeInt32BE(this._e, 16), B.writeInt32BE(this._f, 20), B.writeInt32BE(this._g, 24), B;
};
var sha224$1 = Sha224, inherits$j = inherits_browserExports, Hash$2 = hash$3, Buffer$s = safeBufferExports$1.Buffer, K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], W$1 = new Array(160);
function Sha512() {
  this.init(), this._w = W$1, Hash$2.call(this, 128, 112);
}
inherits$j(Sha512, Hash$2);
Sha512.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Ch(B, z, Y) {
  return Y ^ B & (z ^ Y);
}
function maj(B, z, Y) {
  return B & z | Y & (B | z);
}
function sigma0(B, z) {
  return (B >>> 28 | z << 4) ^ (z >>> 2 | B << 30) ^ (z >>> 7 | B << 25);
}
function sigma1(B, z) {
  return (B >>> 14 | z << 18) ^ (B >>> 18 | z << 14) ^ (z >>> 9 | B << 23);
}
function Gamma0(B, z) {
  return (B >>> 1 | z << 31) ^ (B >>> 8 | z << 24) ^ B >>> 7;
}
function Gamma0l(B, z) {
  return (B >>> 1 | z << 31) ^ (B >>> 8 | z << 24) ^ (B >>> 7 | z << 25);
}
function Gamma1(B, z) {
  return (B >>> 19 | z << 13) ^ (z >>> 29 | B << 3) ^ B >>> 6;
}
function Gamma1l(B, z) {
  return (B >>> 19 | z << 13) ^ (z >>> 29 | B << 3) ^ (B >>> 6 | z << 26);
}
function getCarry(B, z) {
  return B >>> 0 < z >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(B) {
  for (var z = this._w, Y = this._ah | 0, ne = this._bh | 0, ie = this._ch | 0, oe = this._dh | 0, se = this._eh | 0, ae = this._fh | 0, ve = this._gh | 0, Pe = this._hh | 0, le = this._al | 0, Ee = this._bl | 0, Je = this._cl | 0, Ce = this._dl | 0, _t = this._el | 0, kt = this._fl | 0, Ct = this._gl | 0, Lt = this._hl | 0, Pt = 0; Pt < 32; Pt += 2)
    z[Pt] = B.readInt32BE(Pt * 4), z[Pt + 1] = B.readInt32BE(Pt * 4 + 4);
  for (; Pt < 160; Pt += 2) {
    var Ft = z[Pt - 30], Ut = z[Pt - 15 * 2 + 1], Jt = Gamma0(Ft, Ut), Vt = Gamma0l(Ut, Ft);
    Ft = z[Pt - 2 * 2], Ut = z[Pt - 2 * 2 + 1];
    var ir = Gamma1(Ft, Ut), jt = Gamma1l(Ut, Ft), Rt = z[Pt - 7 * 2], Kt = z[Pt - 7 * 2 + 1], Bt = z[Pt - 16 * 2], Xe = z[Pt - 16 * 2 + 1], Ve = Vt + Kt | 0, ge = Jt + Rt + getCarry(Ve, Vt) | 0;
    Ve = Ve + jt | 0, ge = ge + ir + getCarry(Ve, jt) | 0, Ve = Ve + Xe | 0, ge = ge + Bt + getCarry(Ve, Xe) | 0, z[Pt] = ge, z[Pt + 1] = Ve;
  }
  for (var Ke = 0; Ke < 160; Ke += 2) {
    ge = z[Ke], Ve = z[Ke + 1];
    var ht = maj(Y, ne, ie), wt = maj(le, Ee, Je), vt = sigma0(Y, le), $t = sigma0(le, Y), Qe = sigma1(se, _t), xt = sigma1(_t, se), bt = K$1[Ke], Dt = K$1[Ke + 1], er = Ch(se, ae, ve), fr = Ch(_t, kt, Ct), Qt = Lt + xt | 0, Ht = Pe + Qe + getCarry(Qt, Lt) | 0;
    Qt = Qt + fr | 0, Ht = Ht + er + getCarry(Qt, fr) | 0, Qt = Qt + Dt | 0, Ht = Ht + bt + getCarry(Qt, Dt) | 0, Qt = Qt + Ve | 0, Ht = Ht + ge + getCarry(Qt, Ve) | 0;
    var qt = $t + wt | 0, nr = vt + ht + getCarry(qt, $t) | 0;
    Pe = ve, Lt = Ct, ve = ae, Ct = kt, ae = se, kt = _t, _t = Ce + Qt | 0, se = oe + Ht + getCarry(_t, Ce) | 0, oe = ie, Ce = Je, ie = ne, Je = Ee, ne = Y, Ee = le, le = Qt + qt | 0, Y = Ht + nr + getCarry(le, Qt) | 0;
  }
  this._al = this._al + le | 0, this._bl = this._bl + Ee | 0, this._cl = this._cl + Je | 0, this._dl = this._dl + Ce | 0, this._el = this._el + _t | 0, this._fl = this._fl + kt | 0, this._gl = this._gl + Ct | 0, this._hl = this._hl + Lt | 0, this._ah = this._ah + Y + getCarry(this._al, le) | 0, this._bh = this._bh + ne + getCarry(this._bl, Ee) | 0, this._ch = this._ch + ie + getCarry(this._cl, Je) | 0, this._dh = this._dh + oe + getCarry(this._dl, Ce) | 0, this._eh = this._eh + se + getCarry(this._el, _t) | 0, this._fh = this._fh + ae + getCarry(this._fl, kt) | 0, this._gh = this._gh + ve + getCarry(this._gl, Ct) | 0, this._hh = this._hh + Pe + getCarry(this._hl, Lt) | 0;
};
Sha512.prototype._hash = function() {
  var B = Buffer$s.allocUnsafe(64);
  function z(Y, ne, ie) {
    B.writeInt32BE(Y, ie), B.writeInt32BE(ne, ie + 4);
  }
  return z(this._ah, this._al, 0), z(this._bh, this._bl, 8), z(this._ch, this._cl, 16), z(this._dh, this._dl, 24), z(this._eh, this._el, 32), z(this._fh, this._fl, 40), z(this._gh, this._gl, 48), z(this._hh, this._hl, 56), B;
};
var sha512$1 = Sha512, inherits$i = inherits_browserExports, SHA512$2 = sha512$1, Hash$1 = hash$3, Buffer$r = safeBufferExports$1.Buffer, W = new Array(160);
function Sha384() {
  this.init(), this._w = W, Hash$1.call(this, 128, 112);
}
inherits$i(Sha384, SHA512$2);
Sha384.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Sha384.prototype._hash = function() {
  var B = Buffer$r.allocUnsafe(48);
  function z(Y, ne, ie) {
    B.writeInt32BE(Y, ie), B.writeInt32BE(ne, ie + 4);
  }
  return z(this._ah, this._al, 0), z(this._bh, this._bl, 8), z(this._ch, this._cl, 16), z(this._dh, this._dl, 24), z(this._eh, this._el, 32), z(this._fh, this._fl, 40), B;
};
var sha384$1 = Sha384, exports = sha_js.exports = function(z) {
  z = z.toLowerCase();
  var Y = exports[z];
  if (!Y) throw new Error(z + " is not supported (we accept pull requests)");
  return new Y();
};
exports.sha = sha$4;
exports.sha1 = sha1$1;
exports.sha224 = sha224$1;
exports.sha256 = sha256$3;
exports.sha384 = sha384$1;
exports.sha512 = sha512$1;
var sha_jsExports = sha_js.exports, streamBrowserify = Stream, EE = eventsExports.EventEmitter, inherits$h = inherits_browserExports;
inherits$h(Stream, EE);
Stream.Readable = require_stream_readable$1();
Stream.Writable = require_stream_writable$1();
Stream.Duplex = require_stream_duplex$1();
Stream.Transform = require_stream_transform();
Stream.PassThrough = require_stream_passthrough();
Stream.finished = requireEndOfStream();
Stream.pipeline = requirePipeline();
Stream.Stream = Stream;
function Stream() {
  EE.call(this);
}
Stream.prototype.pipe = function(B, z) {
  var Y = this;
  function ne(le) {
    B.writable && B.write(le) === !1 && Y.pause && Y.pause();
  }
  Y.on("data", ne);
  function ie() {
    Y.readable && Y.resume && Y.resume();
  }
  B.on("drain", ie), !B._isStdio && (!z || z.end !== !1) && (Y.on("end", se), Y.on("close", ae));
  var oe = !1;
  function se() {
    oe || (oe = !0, B.end());
  }
  function ae() {
    oe || (oe = !0, typeof B.destroy == "function" && B.destroy());
  }
  function ve(le) {
    if (Pe(), EE.listenerCount(this, "error") === 0)
      throw le;
  }
  Y.on("error", ve), B.on("error", ve);
  function Pe() {
    Y.removeListener("data", ne), B.removeListener("drain", ie), Y.removeListener("end", se), Y.removeListener("close", ae), Y.removeListener("error", ve), B.removeListener("error", ve), Y.removeListener("end", Pe), Y.removeListener("close", Pe), B.removeListener("close", Pe);
  }
  return Y.on("end", Pe), Y.on("close", Pe), B.on("close", Pe), B.emit("pipe", Y), B;
};
var Buffer$q = safeBufferExports$1.Buffer, Transform$6 = streamBrowserify.Transform, StringDecoder = string_decoder.StringDecoder, inherits$g = inherits_browserExports;
function CipherBase$1(B) {
  Transform$6.call(this), this.hashMode = typeof B == "string", this.hashMode ? this[B] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
inherits$g(CipherBase$1, Transform$6);
var useUint8Array = typeof Uint8Array < "u", useArrayBuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (Buffer$q.prototype instanceof Uint8Array || Buffer$q.TYPED_ARRAY_SUPPORT);
function toBuffer$4(B, z) {
  if (B instanceof Buffer$q)
    return B;
  if (typeof B == "string")
    return Buffer$q.from(B, z);
  if (useArrayBuffer && ArrayBuffer.isView(B)) {
    if (B.byteLength === 0)
      return Buffer$q.alloc(0);
    var Y = Buffer$q.from(B.buffer, B.byteOffset, B.byteLength);
    if (Y.byteLength === B.byteLength)
      return Y;
  }
  if (useUint8Array && B instanceof Uint8Array || Buffer$q.isBuffer(B) && B.constructor && typeof B.constructor.isBuffer == "function" && B.constructor.isBuffer(B))
    return Buffer$q.from(B);
  throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
}
CipherBase$1.prototype.update = function(B, z, Y) {
  var ne = toBuffer$4(B, z), ie = this._update(ne);
  return this.hashMode ? this : (Y && (ie = this._toString(ie, Y)), ie);
};
CipherBase$1.prototype.setAutoPadding = function() {
};
CipherBase$1.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase$1.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase$1.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase$1.prototype._transform = function(B, z, Y) {
  var ne;
  try {
    this.hashMode ? this._update(B) : this.push(this._update(B));
  } catch (ie) {
    ne = ie;
  } finally {
    Y(ne);
  }
};
CipherBase$1.prototype._flush = function(B) {
  var z;
  try {
    this.push(this.__final());
  } catch (Y) {
    z = Y;
  }
  B(z);
};
CipherBase$1.prototype._finalOrDigest = function(B) {
  var z = this.__final() || Buffer$q.alloc(0);
  return B && (z = this._toString(z, B, !0)), z;
};
CipherBase$1.prototype._toString = function(B, z, Y) {
  if (this._decoder || (this._decoder = new StringDecoder(z), this._encoding = z), this._encoding !== z)
    throw new Error("cant switch encodings");
  var ne = this._decoder.write(B);
  return Y && (ne += this._decoder.end()), ne;
};
var cipherBase = CipherBase$1, inherits$f = inherits_browserExports, MD5$2 = md5_js, RIPEMD160$4 = ripemd160$1, sha$3 = sha_jsExports, Base$5 = cipherBase;
function Hash(B) {
  Base$5.call(this, "digest"), this._hash = B;
}
inherits$f(Hash, Base$5);
Hash.prototype._update = function(B) {
  this._hash.update(B);
};
Hash.prototype._final = function() {
  return this._hash.digest();
};
var browser$9 = function(z) {
  return z = z.toLowerCase(), z === "md5" ? new MD5$2() : z === "rmd160" || z === "ripemd160" ? new RIPEMD160$4() : new Hash(sha$3(z));
}, inherits$e = inherits_browserExports, Buffer$p = safeBufferExports$1.Buffer, Base$4 = cipherBase, ZEROS$2 = Buffer$p.alloc(128), blocksize = 64;
function Hmac$3(B, z) {
  Base$4.call(this, "digest"), typeof z == "string" && (z = Buffer$p.from(z)), this._alg = B, this._key = z, z.length > blocksize ? z = B(z) : z.length < blocksize && (z = Buffer$p.concat([z, ZEROS$2], blocksize));
  for (var Y = this._ipad = Buffer$p.allocUnsafe(blocksize), ne = this._opad = Buffer$p.allocUnsafe(blocksize), ie = 0; ie < blocksize; ie++)
    Y[ie] = z[ie] ^ 54, ne[ie] = z[ie] ^ 92;
  this._hash = [Y];
}
inherits$e(Hmac$3, Base$4);
Hmac$3.prototype._update = function(B) {
  this._hash.push(B);
};
Hmac$3.prototype._final = function() {
  var B = this._alg(Buffer$p.concat(this._hash));
  return this._alg(Buffer$p.concat([this._opad, B]));
};
var legacy = Hmac$3, MD5$1 = md5_js, md5$2 = function(B) {
  return new MD5$1().update(B).digest();
}, inherits$d = inherits_browserExports, Legacy = legacy, Base$3 = cipherBase, Buffer$o = safeBufferExports$1.Buffer, md5$1 = md5$2, RIPEMD160$3 = ripemd160$1, sha$2 = sha_jsExports, ZEROS$1 = Buffer$o.alloc(128);
function Hmac$2(B, z) {
  Base$3.call(this, "digest"), typeof z == "string" && (z = Buffer$o.from(z));
  var Y = B === "sha512" || B === "sha384" ? 128 : 64;
  if (this._alg = B, this._key = z, z.length > Y) {
    var ne = B === "rmd160" ? new RIPEMD160$3() : sha$2(B);
    z = ne.update(z).digest();
  } else z.length < Y && (z = Buffer$o.concat([z, ZEROS$1], Y));
  for (var ie = this._ipad = Buffer$o.allocUnsafe(Y), oe = this._opad = Buffer$o.allocUnsafe(Y), se = 0; se < Y; se++)
    ie[se] = z[se] ^ 54, oe[se] = z[se] ^ 92;
  this._hash = B === "rmd160" ? new RIPEMD160$3() : sha$2(B), this._hash.update(ie);
}
inherits$d(Hmac$2, Base$3);
Hmac$2.prototype._update = function(B) {
  this._hash.update(B);
};
Hmac$2.prototype._final = function() {
  var B = this._hash.digest(), z = this._alg === "rmd160" ? new RIPEMD160$3() : sha$2(this._alg);
  return z.update(this._opad).update(B).digest();
};
var browser$8 = function(z, Y) {
  return z = z.toLowerCase(), z === "rmd160" || z === "ripemd160" ? new Hmac$2("rmd160", Y) : z === "md5" ? new Legacy(md5$1, Y) : new Hmac$2(z, Y);
};
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$2 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$2,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos = require$$6, browser$7 = {}, MAX_ALLOC = Math.pow(2, 30) - 1, precondition = function(B, z) {
  if (typeof B != "number")
    throw new TypeError("Iterations not a number");
  if (B < 0)
    throw new TypeError("Bad iterations");
  if (typeof z != "number")
    throw new TypeError("Key length not a number");
  if (z < 0 || z > MAX_ALLOC || z !== z)
    throw new TypeError("Bad key length");
}, defaultEncoding$2;
if (commonjsGlobal.process && commonjsGlobal.process.browser)
  defaultEncoding$2 = "utf-8";
else if (commonjsGlobal.process && commonjsGlobal.process.version) {
  var pVersionMajor = parseInt(process$1.version.split(".")[0].slice(1), 10);
  defaultEncoding$2 = pVersionMajor >= 6 ? "utf-8" : "binary";
} else
  defaultEncoding$2 = "utf-8";
var defaultEncoding_1 = defaultEncoding$2, Buffer$n = safeBufferExports$1.Buffer, toBuffer$3 = function(B, z, Y) {
  if (Buffer$n.isBuffer(B))
    return B;
  if (typeof B == "string")
    return Buffer$n.from(B, z);
  if (ArrayBuffer.isView(B))
    return Buffer$n.from(B.buffer);
  throw new TypeError(Y + " must be a string, a Buffer, a typed array or a DataView");
}, md5 = md5$2, RIPEMD160$2 = ripemd160$1, sha$1 = sha_jsExports, Buffer$m = safeBufferExports$1.Buffer, checkParameters$1 = precondition, defaultEncoding$1 = defaultEncoding_1, toBuffer$2 = toBuffer$3, ZEROS = Buffer$m.alloc(128), sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function Hmac$1(B, z, Y) {
  var ne = getDigest(B), ie = B === "sha512" || B === "sha384" ? 128 : 64;
  z.length > ie ? z = ne(z) : z.length < ie && (z = Buffer$m.concat([z, ZEROS], ie));
  for (var oe = Buffer$m.allocUnsafe(ie + sizes[B]), se = Buffer$m.allocUnsafe(ie + sizes[B]), ae = 0; ae < ie; ae++)
    oe[ae] = z[ae] ^ 54, se[ae] = z[ae] ^ 92;
  var ve = Buffer$m.allocUnsafe(ie + Y + 4);
  oe.copy(ve, 0, 0, ie), this.ipad1 = ve, this.ipad2 = oe, this.opad = se, this.alg = B, this.blocksize = ie, this.hash = ne, this.size = sizes[B];
}
Hmac$1.prototype.run = function(B, z) {
  B.copy(z, this.blocksize);
  var Y = this.hash(z);
  return Y.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function getDigest(B) {
  function z(ne) {
    return sha$1(B).update(ne).digest();
  }
  function Y(ne) {
    return new RIPEMD160$2().update(ne).digest();
  }
  return B === "rmd160" || B === "ripemd160" ? Y : B === "md5" ? md5 : z;
}
function pbkdf2(B, z, Y, ne, ie) {
  checkParameters$1(Y, ne), B = toBuffer$2(B, defaultEncoding$1, "Password"), z = toBuffer$2(z, defaultEncoding$1, "Salt"), ie = ie || "sha1";
  var oe = new Hmac$1(ie, B, z.length), se = Buffer$m.allocUnsafe(ne), ae = Buffer$m.allocUnsafe(z.length + 4);
  z.copy(ae, 0, 0, z.length);
  for (var ve = 0, Pe = sizes[ie], le = Math.ceil(ne / Pe), Ee = 1; Ee <= le; Ee++) {
    ae.writeUInt32BE(Ee, z.length);
    for (var Je = oe.run(ae, oe.ipad1), Ce = Je, _t = 1; _t < Y; _t++) {
      Ce = oe.run(Ce, oe.ipad2);
      for (var kt = 0; kt < Pe; kt++) Je[kt] ^= Ce[kt];
    }
    Je.copy(se, ve), ve += Pe;
  }
  return se;
}
var syncBrowser = pbkdf2, Buffer$l = safeBufferExports$1.Buffer, checkParameters = precondition, defaultEncoding = defaultEncoding_1, sync = syncBrowser, toBuffer$1 = toBuffer$3, ZERO_BUF, subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, toBrowser = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, checks = [];
function checkNative(B) {
  if (commonjsGlobal.process && !commonjsGlobal.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)
    return Promise.resolve(!1);
  if (checks[B] !== void 0)
    return checks[B];
  ZERO_BUF = ZERO_BUF || Buffer$l.alloc(8);
  var z = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, B).then(function() {
    return !0;
  }).catch(function() {
    return !1;
  });
  return checks[B] = z, z;
}
var nextTick$1;
function getNextTick() {
  return nextTick$1 || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? nextTick$1 = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? nextTick$1 = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? nextTick$1 = commonjsGlobal.setImmediate : nextTick$1 = commonjsGlobal.setTimeout, nextTick$1);
}
function browserPbkdf2(B, z, Y, ne, ie) {
  return subtle.importKey(
    "raw",
    B,
    { name: "PBKDF2" },
    !1,
    ["deriveBits"]
  ).then(function(oe) {
    return subtle.deriveBits({
      name: "PBKDF2",
      salt: z,
      iterations: Y,
      hash: {
        name: ie
      }
    }, oe, ne << 3);
  }).then(function(oe) {
    return Buffer$l.from(oe);
  });
}
function resolvePromise(B, z) {
  B.then(function(Y) {
    getNextTick()(function() {
      z(null, Y);
    });
  }, function(Y) {
    getNextTick()(function() {
      z(Y);
    });
  });
}
var async = function(B, z, Y, ne, ie, oe) {
  typeof ie == "function" && (oe = ie, ie = void 0), ie = ie || "sha1";
  var se = toBrowser[ie.toLowerCase()];
  if (!se || typeof commonjsGlobal.Promise != "function") {
    getNextTick()(function() {
      var ae;
      try {
        ae = sync(B, z, Y, ne, ie);
      } catch (ve) {
        return oe(ve);
      }
      oe(null, ae);
    });
    return;
  }
  if (checkParameters(Y, ne), B = toBuffer$1(B, defaultEncoding, "Password"), z = toBuffer$1(z, defaultEncoding, "Salt"), typeof oe != "function") throw new Error("No callback provided to pbkdf2");
  resolvePromise(checkNative(se).then(function(ae) {
    return ae ? browserPbkdf2(B, z, Y, ne, se) : sync(B, z, Y, ne, ie);
  }), oe);
};
browser$7.pbkdf2 = async;
browser$7.pbkdf2Sync = syncBrowser;
var browser$6 = {}, des$2 = {}, utils$o = {};
utils$o.readUInt32BE = function(z, Y) {
  var ne = z[0 + Y] << 24 | z[1 + Y] << 16 | z[2 + Y] << 8 | z[3 + Y];
  return ne >>> 0;
};
utils$o.writeUInt32BE = function(z, Y, ne) {
  z[0 + ne] = Y >>> 24, z[1 + ne] = Y >>> 16 & 255, z[2 + ne] = Y >>> 8 & 255, z[3 + ne] = Y & 255;
};
utils$o.ip = function(z, Y, ne, ie) {
  for (var oe = 0, se = 0, ae = 6; ae >= 0; ae -= 2) {
    for (var ve = 0; ve <= 24; ve += 8)
      oe <<= 1, oe |= Y >>> ve + ae & 1;
    for (var ve = 0; ve <= 24; ve += 8)
      oe <<= 1, oe |= z >>> ve + ae & 1;
  }
  for (var ae = 6; ae >= 0; ae -= 2) {
    for (var ve = 1; ve <= 25; ve += 8)
      se <<= 1, se |= Y >>> ve + ae & 1;
    for (var ve = 1; ve <= 25; ve += 8)
      se <<= 1, se |= z >>> ve + ae & 1;
  }
  ne[ie + 0] = oe >>> 0, ne[ie + 1] = se >>> 0;
};
utils$o.rip = function(z, Y, ne, ie) {
  for (var oe = 0, se = 0, ae = 0; ae < 4; ae++)
    for (var ve = 24; ve >= 0; ve -= 8)
      oe <<= 1, oe |= Y >>> ve + ae & 1, oe <<= 1, oe |= z >>> ve + ae & 1;
  for (var ae = 4; ae < 8; ae++)
    for (var ve = 24; ve >= 0; ve -= 8)
      se <<= 1, se |= Y >>> ve + ae & 1, se <<= 1, se |= z >>> ve + ae & 1;
  ne[ie + 0] = oe >>> 0, ne[ie + 1] = se >>> 0;
};
utils$o.pc1 = function(z, Y, ne, ie) {
  for (var oe = 0, se = 0, ae = 7; ae >= 5; ae--) {
    for (var ve = 0; ve <= 24; ve += 8)
      oe <<= 1, oe |= Y >> ve + ae & 1;
    for (var ve = 0; ve <= 24; ve += 8)
      oe <<= 1, oe |= z >> ve + ae & 1;
  }
  for (var ve = 0; ve <= 24; ve += 8)
    oe <<= 1, oe |= Y >> ve + ae & 1;
  for (var ae = 1; ae <= 3; ae++) {
    for (var ve = 0; ve <= 24; ve += 8)
      se <<= 1, se |= Y >> ve + ae & 1;
    for (var ve = 0; ve <= 24; ve += 8)
      se <<= 1, se |= z >> ve + ae & 1;
  }
  for (var ve = 0; ve <= 24; ve += 8)
    se <<= 1, se |= z >> ve + ae & 1;
  ne[ie + 0] = oe >>> 0, ne[ie + 1] = se >>> 0;
};
utils$o.r28shl = function(z, Y) {
  return z << Y & 268435455 | z >>> 28 - Y;
};
var pc2table = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
utils$o.pc2 = function(z, Y, ne, ie) {
  for (var oe = 0, se = 0, ae = pc2table.length >>> 1, ve = 0; ve < ae; ve++)
    oe <<= 1, oe |= z >>> pc2table[ve] & 1;
  for (var ve = ae; ve < pc2table.length; ve++)
    se <<= 1, se |= Y >>> pc2table[ve] & 1;
  ne[ie + 0] = oe >>> 0, ne[ie + 1] = se >>> 0;
};
utils$o.expand = function(z, Y, ne) {
  var ie = 0, oe = 0;
  ie = (z & 1) << 5 | z >>> 27;
  for (var se = 23; se >= 15; se -= 4)
    ie <<= 6, ie |= z >>> se & 63;
  for (var se = 11; se >= 3; se -= 4)
    oe |= z >>> se & 63, oe <<= 6;
  oe |= (z & 31) << 1 | z >>> 31, Y[ne + 0] = ie >>> 0, Y[ne + 1] = oe >>> 0;
};
var sTable = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
utils$o.substitute = function(z, Y) {
  for (var ne = 0, ie = 0; ie < 4; ie++) {
    var oe = z >>> 18 - ie * 6 & 63, se = sTable[ie * 64 + oe];
    ne <<= 4, ne |= se;
  }
  for (var ie = 0; ie < 4; ie++) {
    var oe = Y >>> 18 - ie * 6 & 63, se = sTable[4 * 64 + ie * 64 + oe];
    ne <<= 4, ne |= se;
  }
  return ne >>> 0;
};
var permuteTable = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
utils$o.permute = function(z) {
  for (var Y = 0, ne = 0; ne < permuteTable.length; ne++)
    Y <<= 1, Y |= z >>> permuteTable[ne] & 1;
  return Y >>> 0;
};
utils$o.padSplit = function(z, Y, ne) {
  for (var ie = z.toString(2); ie.length < Y; )
    ie = "0" + ie;
  for (var oe = [], se = 0; se < Y; se += ne)
    oe.push(ie.slice(se, se + ne));
  return oe.join(" ");
};
var minimalisticAssert = assert$j;
function assert$j(B, z) {
  if (!B)
    throw new Error(z || "Assertion failed");
}
assert$j.equal = function(z, Y, ne) {
  if (z != Y)
    throw new Error(ne || "Assertion failed: " + z + " != " + Y);
};
var assert$i = minimalisticAssert;
function Cipher$3(B) {
  this.options = B, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = B.padding !== !1;
}
var cipher = Cipher$3;
Cipher$3.prototype._init = function() {
};
Cipher$3.prototype.update = function(z) {
  return z.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(z) : this._updateEncrypt(z);
};
Cipher$3.prototype._buffer = function(z, Y) {
  for (var ne = Math.min(this.buffer.length - this.bufferOff, z.length - Y), ie = 0; ie < ne; ie++)
    this.buffer[this.bufferOff + ie] = z[Y + ie];
  return this.bufferOff += ne, ne;
};
Cipher$3.prototype._flushBuffer = function(z, Y) {
  return this._update(this.buffer, 0, z, Y), this.bufferOff = 0, this.blockSize;
};
Cipher$3.prototype._updateEncrypt = function(z) {
  var Y = 0, ne = 0, ie = (this.bufferOff + z.length) / this.blockSize | 0, oe = new Array(ie * this.blockSize);
  this.bufferOff !== 0 && (Y += this._buffer(z, Y), this.bufferOff === this.buffer.length && (ne += this._flushBuffer(oe, ne)));
  for (var se = z.length - (z.length - Y) % this.blockSize; Y < se; Y += this.blockSize)
    this._update(z, Y, oe, ne), ne += this.blockSize;
  for (; Y < z.length; Y++, this.bufferOff++)
    this.buffer[this.bufferOff] = z[Y];
  return oe;
};
Cipher$3.prototype._updateDecrypt = function(z) {
  for (var Y = 0, ne = 0, ie = Math.ceil((this.bufferOff + z.length) / this.blockSize) - 1, oe = new Array(ie * this.blockSize); ie > 0; ie--)
    Y += this._buffer(z, Y), ne += this._flushBuffer(oe, ne);
  return Y += this._buffer(z, Y), oe;
};
Cipher$3.prototype.final = function(z) {
  var Y;
  z && (Y = this.update(z));
  var ne;
  return this.type === "encrypt" ? ne = this._finalEncrypt() : ne = this._finalDecrypt(), Y ? Y.concat(ne) : ne;
};
Cipher$3.prototype._pad = function(z, Y) {
  if (Y === 0)
    return !1;
  for (; Y < z.length; )
    z[Y++] = 0;
  return !0;
};
Cipher$3.prototype._finalEncrypt = function() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var z = new Array(this.blockSize);
  return this._update(this.buffer, 0, z, 0), z;
};
Cipher$3.prototype._unpad = function(z) {
  return z;
};
Cipher$3.prototype._finalDecrypt = function() {
  assert$i.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var z = new Array(this.blockSize);
  return this._flushBuffer(z, 0), this._unpad(z);
};
var assert$h = minimalisticAssert, inherits$c = inherits_browserExports, utils$n = utils$o, Cipher$2 = cipher;
function DESState() {
  this.tmp = new Array(2), this.keys = null;
}
function DES$3(B) {
  Cipher$2.call(this, B);
  var z = new DESState();
  this._desState = z, this.deriveKeys(z, B.key);
}
inherits$c(DES$3, Cipher$2);
var des$1 = DES$3;
DES$3.create = function(z) {
  return new DES$3(z);
};
var shiftTable = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
DES$3.prototype.deriveKeys = function(z, Y) {
  z.keys = new Array(16 * 2), assert$h.equal(Y.length, this.blockSize, "Invalid key length");
  var ne = utils$n.readUInt32BE(Y, 0), ie = utils$n.readUInt32BE(Y, 4);
  utils$n.pc1(ne, ie, z.tmp, 0), ne = z.tmp[0], ie = z.tmp[1];
  for (var oe = 0; oe < z.keys.length; oe += 2) {
    var se = shiftTable[oe >>> 1];
    ne = utils$n.r28shl(ne, se), ie = utils$n.r28shl(ie, se), utils$n.pc2(ne, ie, z.keys, oe);
  }
};
DES$3.prototype._update = function(z, Y, ne, ie) {
  var oe = this._desState, se = utils$n.readUInt32BE(z, Y), ae = utils$n.readUInt32BE(z, Y + 4);
  utils$n.ip(se, ae, oe.tmp, 0), se = oe.tmp[0], ae = oe.tmp[1], this.type === "encrypt" ? this._encrypt(oe, se, ae, oe.tmp, 0) : this._decrypt(oe, se, ae, oe.tmp, 0), se = oe.tmp[0], ae = oe.tmp[1], utils$n.writeUInt32BE(ne, se, ie), utils$n.writeUInt32BE(ne, ae, ie + 4);
};
DES$3.prototype._pad = function(z, Y) {
  if (this.padding === !1)
    return !1;
  for (var ne = z.length - Y, ie = Y; ie < z.length; ie++)
    z[ie] = ne;
  return !0;
};
DES$3.prototype._unpad = function(z) {
  if (this.padding === !1)
    return z;
  for (var Y = z[z.length - 1], ne = z.length - Y; ne < z.length; ne++)
    assert$h.equal(z[ne], Y);
  return z.slice(0, z.length - Y);
};
DES$3.prototype._encrypt = function(z, Y, ne, ie, oe) {
  for (var se = Y, ae = ne, ve = 0; ve < z.keys.length; ve += 2) {
    var Pe = z.keys[ve], le = z.keys[ve + 1];
    utils$n.expand(ae, z.tmp, 0), Pe ^= z.tmp[0], le ^= z.tmp[1];
    var Ee = utils$n.substitute(Pe, le), Je = utils$n.permute(Ee), Ce = ae;
    ae = (se ^ Je) >>> 0, se = Ce;
  }
  utils$n.rip(ae, se, ie, oe);
};
DES$3.prototype._decrypt = function(z, Y, ne, ie, oe) {
  for (var se = ne, ae = Y, ve = z.keys.length - 2; ve >= 0; ve -= 2) {
    var Pe = z.keys[ve], le = z.keys[ve + 1];
    utils$n.expand(se, z.tmp, 0), Pe ^= z.tmp[0], le ^= z.tmp[1];
    var Ee = utils$n.substitute(Pe, le), Je = utils$n.permute(Ee), Ce = se;
    se = (ae ^ Je) >>> 0, ae = Ce;
  }
  utils$n.rip(se, ae, ie, oe);
};
var cbc$1 = {}, assert$g = minimalisticAssert, inherits$b = inherits_browserExports, proto = {};
function CBCState(B) {
  assert$g.equal(B.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var z = 0; z < this.iv.length; z++)
    this.iv[z] = B[z];
}
function instantiate(B) {
  function z(oe) {
    B.call(this, oe), this._cbcInit();
  }
  inherits$b(z, B);
  for (var Y = Object.keys(proto), ne = 0; ne < Y.length; ne++) {
    var ie = Y[ne];
    z.prototype[ie] = proto[ie];
  }
  return z.create = function(se) {
    return new z(se);
  }, z;
}
cbc$1.instantiate = instantiate;
proto._cbcInit = function() {
  var z = new CBCState(this.options.iv);
  this._cbcState = z;
};
proto._update = function(z, Y, ne, ie) {
  var oe = this._cbcState, se = this.constructor.super_.prototype, ae = oe.iv;
  if (this.type === "encrypt") {
    for (var ve = 0; ve < this.blockSize; ve++)
      ae[ve] ^= z[Y + ve];
    se._update.call(this, ae, 0, ne, ie);
    for (var ve = 0; ve < this.blockSize; ve++)
      ae[ve] = ne[ie + ve];
  } else {
    se._update.call(this, z, Y, ne, ie);
    for (var ve = 0; ve < this.blockSize; ve++)
      ne[ie + ve] ^= ae[ve];
    for (var ve = 0; ve < this.blockSize; ve++)
      ae[ve] = z[Y + ve];
  }
};
var assert$f = minimalisticAssert, inherits$a = inherits_browserExports, Cipher$1 = cipher, DES$2 = des$1;
function EDEState(B, z) {
  assert$f.equal(z.length, 24, "Invalid key length");
  var Y = z.slice(0, 8), ne = z.slice(8, 16), ie = z.slice(16, 24);
  B === "encrypt" ? this.ciphers = [
    DES$2.create({ type: "encrypt", key: Y }),
    DES$2.create({ type: "decrypt", key: ne }),
    DES$2.create({ type: "encrypt", key: ie })
  ] : this.ciphers = [
    DES$2.create({ type: "decrypt", key: ie }),
    DES$2.create({ type: "encrypt", key: ne }),
    DES$2.create({ type: "decrypt", key: Y })
  ];
}
function EDE(B) {
  Cipher$1.call(this, B);
  var z = new EDEState(this.type, this.options.key);
  this._edeState = z;
}
inherits$a(EDE, Cipher$1);
var ede = EDE;
EDE.create = function(z) {
  return new EDE(z);
};
EDE.prototype._update = function(z, Y, ne, ie) {
  var oe = this._edeState;
  oe.ciphers[0]._update(z, Y, ne, ie), oe.ciphers[1]._update(ne, ie, ne, ie), oe.ciphers[2]._update(ne, ie, ne, ie);
};
EDE.prototype._pad = DES$2.prototype._pad;
EDE.prototype._unpad = DES$2.prototype._unpad;
des$2.utils = utils$o;
des$2.Cipher = cipher;
des$2.DES = des$1;
des$2.CBC = cbc$1;
des$2.EDE = ede;
var CipherBase = cipherBase, des = des$2, inherits$9 = inherits_browserExports, Buffer$k = safeBufferExports$1.Buffer, modes$3 = {
  "des-ede3-cbc": des.CBC.instantiate(des.EDE),
  "des-ede3": des.EDE,
  "des-ede-cbc": des.CBC.instantiate(des.EDE),
  "des-ede": des.EDE,
  "des-cbc": des.CBC.instantiate(des.DES),
  "des-ecb": des.DES
};
modes$3.des = modes$3["des-cbc"];
modes$3.des3 = modes$3["des-ede3-cbc"];
var browserifyDes = DES$1;
inherits$9(DES$1, CipherBase);
function DES$1(B) {
  CipherBase.call(this);
  var z = B.mode.toLowerCase(), Y = modes$3[z], ne;
  B.decrypt ? ne = "decrypt" : ne = "encrypt";
  var ie = B.key;
  Buffer$k.isBuffer(ie) || (ie = Buffer$k.from(ie)), (z === "des-ede" || z === "des-ede-cbc") && (ie = Buffer$k.concat([ie, ie.slice(0, 8)]));
  var oe = B.iv;
  Buffer$k.isBuffer(oe) || (oe = Buffer$k.from(oe)), this._des = Y.create({
    key: ie,
    iv: oe,
    type: ne
  });
}
DES$1.prototype._update = function(B) {
  return Buffer$k.from(this._des.update(B));
};
DES$1.prototype._final = function() {
  return Buffer$k.from(this._des.final());
};
var browser$5 = {}, encrypter = {}, ecb = {};
ecb.encrypt = function(B, z) {
  return B._cipher.encryptBlock(z);
};
ecb.decrypt = function(B, z) {
  return B._cipher.decryptBlock(z);
};
var cbc = {}, bufferXor = function(z, Y) {
  for (var ne = Math.min(z.length, Y.length), ie = new Buffer$D(ne), oe = 0; oe < ne; ++oe)
    ie[oe] = z[oe] ^ Y[oe];
  return ie;
}, xor$7 = bufferXor;
cbc.encrypt = function(B, z) {
  var Y = xor$7(z, B._prev);
  return B._prev = B._cipher.encryptBlock(Y), B._prev;
};
cbc.decrypt = function(B, z) {
  var Y = B._prev;
  B._prev = z;
  var ne = B._cipher.decryptBlock(z);
  return xor$7(ne, Y);
};
var cfb = {}, Buffer$j = safeBufferExports$1.Buffer, xor$6 = bufferXor;
function encryptStart(B, z, Y) {
  var ne = z.length, ie = xor$6(z, B._cache);
  return B._cache = B._cache.slice(ne), B._prev = Buffer$j.concat([B._prev, Y ? z : ie]), ie;
}
cfb.encrypt = function(B, z, Y) {
  for (var ne = Buffer$j.allocUnsafe(0), ie; z.length; )
    if (B._cache.length === 0 && (B._cache = B._cipher.encryptBlock(B._prev), B._prev = Buffer$j.allocUnsafe(0)), B._cache.length <= z.length)
      ie = B._cache.length, ne = Buffer$j.concat([ne, encryptStart(B, z.slice(0, ie), Y)]), z = z.slice(ie);
    else {
      ne = Buffer$j.concat([ne, encryptStart(B, z, Y)]);
      break;
    }
  return ne;
};
var cfb8 = {}, Buffer$i = safeBufferExports$1.Buffer;
function encryptByte$1(B, z, Y) {
  var ne = B._cipher.encryptBlock(B._prev), ie = ne[0] ^ z;
  return B._prev = Buffer$i.concat([
    B._prev.slice(1),
    Buffer$i.from([Y ? z : ie])
  ]), ie;
}
cfb8.encrypt = function(B, z, Y) {
  for (var ne = z.length, ie = Buffer$i.allocUnsafe(ne), oe = -1; ++oe < ne; )
    ie[oe] = encryptByte$1(B, z[oe], Y);
  return ie;
};
var cfb1 = {}, Buffer$h = safeBufferExports$1.Buffer;
function encryptByte(B, z, Y) {
  for (var ne, ie = -1, oe = 8, se = 0, ae, ve; ++ie < oe; )
    ne = B._cipher.encryptBlock(B._prev), ae = z & 1 << 7 - ie ? 128 : 0, ve = ne[0] ^ ae, se += (ve & 128) >> ie % 8, B._prev = shiftIn(B._prev, Y ? ae : ve);
  return se;
}
function shiftIn(B, z) {
  var Y = B.length, ne = -1, ie = Buffer$h.allocUnsafe(B.length);
  for (B = Buffer$h.concat([B, Buffer$h.from([z])]); ++ne < Y; )
    ie[ne] = B[ne] << 1 | B[ne + 1] >> 7;
  return ie;
}
cfb1.encrypt = function(B, z, Y) {
  for (var ne = z.length, ie = Buffer$h.allocUnsafe(ne), oe = -1; ++oe < ne; )
    ie[oe] = encryptByte(B, z[oe], Y);
  return ie;
};
var ofb = {}, xor$5 = bufferXor;
function getBlock$1(B) {
  return B._prev = B._cipher.encryptBlock(B._prev), B._prev;
}
ofb.encrypt = function(B, z) {
  for (; B._cache.length < z.length; )
    B._cache = Buffer$D.concat([B._cache, getBlock$1(B)]);
  var Y = B._cache.slice(0, z.length);
  return B._cache = B._cache.slice(z.length), xor$5(z, Y);
};
var ctr = {};
function incr32$2(B) {
  for (var z = B.length, Y; z--; )
    if (Y = B.readUInt8(z), Y === 255)
      B.writeUInt8(0, z);
    else {
      Y++, B.writeUInt8(Y, z);
      break;
    }
}
var incr32_1 = incr32$2, xor$4 = bufferXor, Buffer$g = safeBufferExports$1.Buffer, incr32$1 = incr32_1;
function getBlock(B) {
  var z = B._cipher.encryptBlockRaw(B._prev);
  return incr32$1(B._prev), z;
}
var blockSize = 16;
ctr.encrypt = function(B, z) {
  var Y = Math.ceil(z.length / blockSize), ne = B._cache.length;
  B._cache = Buffer$g.concat([
    B._cache,
    Buffer$g.allocUnsafe(Y * blockSize)
  ]);
  for (var ie = 0; ie < Y; ie++) {
    var oe = getBlock(B), se = ne + ie * blockSize;
    B._cache.writeUInt32BE(oe[0], se + 0), B._cache.writeUInt32BE(oe[1], se + 4), B._cache.writeUInt32BE(oe[2], se + 8), B._cache.writeUInt32BE(oe[3], se + 12);
  }
  var ae = B._cache.slice(0, z.length);
  return B._cache = B._cache.slice(z.length), xor$4(z, ae);
};
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modeModules = {
  ECB: ecb,
  CBC: cbc,
  CFB: cfb,
  CFB8: cfb8,
  CFB1: cfb1,
  OFB: ofb,
  CTR: ctr,
  GCM: ctr
}, modes$2 = require$$2;
for (var key$2 in modes$2)
  modes$2[key$2].module = modeModules[modes$2[key$2].mode];
var modes_1 = modes$2, aes$5 = {}, Buffer$f = safeBufferExports$1.Buffer;
function asUInt32Array(B) {
  Buffer$f.isBuffer(B) || (B = Buffer$f.from(B));
  for (var z = B.length / 4 | 0, Y = new Array(z), ne = 0; ne < z; ne++)
    Y[ne] = B.readUInt32BE(ne * 4);
  return Y;
}
function scrubVec(B) {
  for (var z = 0; z < B.length; B++)
    B[z] = 0;
}
function cryptBlock(B, z, Y, ne, ie) {
  for (var oe = Y[0], se = Y[1], ae = Y[2], ve = Y[3], Pe = B[0] ^ z[0], le = B[1] ^ z[1], Ee = B[2] ^ z[2], Je = B[3] ^ z[3], Ce, _t, kt, Ct, Lt = 4, Pt = 1; Pt < ie; Pt++)
    Ce = oe[Pe >>> 24] ^ se[le >>> 16 & 255] ^ ae[Ee >>> 8 & 255] ^ ve[Je & 255] ^ z[Lt++], _t = oe[le >>> 24] ^ se[Ee >>> 16 & 255] ^ ae[Je >>> 8 & 255] ^ ve[Pe & 255] ^ z[Lt++], kt = oe[Ee >>> 24] ^ se[Je >>> 16 & 255] ^ ae[Pe >>> 8 & 255] ^ ve[le & 255] ^ z[Lt++], Ct = oe[Je >>> 24] ^ se[Pe >>> 16 & 255] ^ ae[le >>> 8 & 255] ^ ve[Ee & 255] ^ z[Lt++], Pe = Ce, le = _t, Ee = kt, Je = Ct;
  return Ce = (ne[Pe >>> 24] << 24 | ne[le >>> 16 & 255] << 16 | ne[Ee >>> 8 & 255] << 8 | ne[Je & 255]) ^ z[Lt++], _t = (ne[le >>> 24] << 24 | ne[Ee >>> 16 & 255] << 16 | ne[Je >>> 8 & 255] << 8 | ne[Pe & 255]) ^ z[Lt++], kt = (ne[Ee >>> 24] << 24 | ne[Je >>> 16 & 255] << 16 | ne[Pe >>> 8 & 255] << 8 | ne[le & 255]) ^ z[Lt++], Ct = (ne[Je >>> 24] << 24 | ne[Pe >>> 16 & 255] << 16 | ne[le >>> 8 & 255] << 8 | ne[Ee & 255]) ^ z[Lt++], Ce = Ce >>> 0, _t = _t >>> 0, kt = kt >>> 0, Ct = Ct >>> 0, [Ce, _t, kt, Ct];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G = function() {
  for (var B = new Array(256), z = 0; z < 256; z++)
    z < 128 ? B[z] = z << 1 : B[z] = z << 1 ^ 283;
  for (var Y = [], ne = [], ie = [[], [], [], []], oe = [[], [], [], []], se = 0, ae = 0, ve = 0; ve < 256; ++ve) {
    var Pe = ae ^ ae << 1 ^ ae << 2 ^ ae << 3 ^ ae << 4;
    Pe = Pe >>> 8 ^ Pe & 255 ^ 99, Y[se] = Pe, ne[Pe] = se;
    var le = B[se], Ee = B[le], Je = B[Ee], Ce = B[Pe] * 257 ^ Pe * 16843008;
    ie[0][se] = Ce << 24 | Ce >>> 8, ie[1][se] = Ce << 16 | Ce >>> 16, ie[2][se] = Ce << 8 | Ce >>> 24, ie[3][se] = Ce, Ce = Je * 16843009 ^ Ee * 65537 ^ le * 257 ^ se * 16843008, oe[0][Pe] = Ce << 24 | Ce >>> 8, oe[1][Pe] = Ce << 16 | Ce >>> 16, oe[2][Pe] = Ce << 8 | Ce >>> 24, oe[3][Pe] = Ce, se === 0 ? se = ae = 1 : (se = le ^ B[B[B[Je ^ le]]], ae ^= B[B[ae]]);
  }
  return {
    SBOX: Y,
    INV_SBOX: ne,
    SUB_MIX: ie,
    INV_SUB_MIX: oe
  };
}();
function AES(B) {
  this._key = asUInt32Array(B), this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  for (var B = this._key, z = B.length, Y = z + 6, ne = (Y + 1) * 4, ie = [], oe = 0; oe < z; oe++)
    ie[oe] = B[oe];
  for (oe = z; oe < ne; oe++) {
    var se = ie[oe - 1];
    oe % z === 0 ? (se = se << 8 | se >>> 24, se = G.SBOX[se >>> 24] << 24 | G.SBOX[se >>> 16 & 255] << 16 | G.SBOX[se >>> 8 & 255] << 8 | G.SBOX[se & 255], se ^= RCON[oe / z | 0] << 24) : z > 6 && oe % z === 4 && (se = G.SBOX[se >>> 24] << 24 | G.SBOX[se >>> 16 & 255] << 16 | G.SBOX[se >>> 8 & 255] << 8 | G.SBOX[se & 255]), ie[oe] = ie[oe - z] ^ se;
  }
  for (var ae = [], ve = 0; ve < ne; ve++) {
    var Pe = ne - ve, le = ie[Pe - (ve % 4 ? 0 : 4)];
    ve < 4 || Pe <= 4 ? ae[ve] = le : ae[ve] = G.INV_SUB_MIX[0][G.SBOX[le >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[le >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[le >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[le & 255]];
  }
  this._nRounds = Y, this._keySchedule = ie, this._invKeySchedule = ae;
};
AES.prototype.encryptBlockRaw = function(B) {
  return B = asUInt32Array(B), cryptBlock(B, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(B) {
  var z = this.encryptBlockRaw(B), Y = Buffer$f.allocUnsafe(16);
  return Y.writeUInt32BE(z[0], 0), Y.writeUInt32BE(z[1], 4), Y.writeUInt32BE(z[2], 8), Y.writeUInt32BE(z[3], 12), Y;
};
AES.prototype.decryptBlock = function(B) {
  B = asUInt32Array(B);
  var z = B[1];
  B[1] = B[3], B[3] = z;
  var Y = cryptBlock(B, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds), ne = Buffer$f.allocUnsafe(16);
  return ne.writeUInt32BE(Y[0], 0), ne.writeUInt32BE(Y[3], 4), ne.writeUInt32BE(Y[2], 8), ne.writeUInt32BE(Y[1], 12), ne;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);
};
aes$5.AES = AES;
var Buffer$e = safeBufferExports$1.Buffer, ZEROES = Buffer$e.alloc(16, 0);
function toArray$1(B) {
  return [
    B.readUInt32BE(0),
    B.readUInt32BE(4),
    B.readUInt32BE(8),
    B.readUInt32BE(12)
  ];
}
function fromArray(B) {
  var z = Buffer$e.allocUnsafe(16);
  return z.writeUInt32BE(B[0] >>> 0, 0), z.writeUInt32BE(B[1] >>> 0, 4), z.writeUInt32BE(B[2] >>> 0, 8), z.writeUInt32BE(B[3] >>> 0, 12), z;
}
function GHASH$1(B) {
  this.h = B, this.state = Buffer$e.alloc(16, 0), this.cache = Buffer$e.allocUnsafe(0);
}
GHASH$1.prototype.ghash = function(B) {
  for (var z = -1; ++z < B.length; )
    this.state[z] ^= B[z];
  this._multiply();
};
GHASH$1.prototype._multiply = function() {
  for (var B = toArray$1(this.h), z = [0, 0, 0, 0], Y, ne, ie, oe = -1; ++oe < 128; ) {
    for (ne = (this.state[~~(oe / 8)] & 1 << 7 - oe % 8) !== 0, ne && (z[0] ^= B[0], z[1] ^= B[1], z[2] ^= B[2], z[3] ^= B[3]), ie = (B[3] & 1) !== 0, Y = 3; Y > 0; Y--)
      B[Y] = B[Y] >>> 1 | (B[Y - 1] & 1) << 31;
    B[0] = B[0] >>> 1, ie && (B[0] = B[0] ^ 225 << 24);
  }
  this.state = fromArray(z);
};
GHASH$1.prototype.update = function(B) {
  this.cache = Buffer$e.concat([this.cache, B]);
  for (var z; this.cache.length >= 16; )
    z = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(z);
};
GHASH$1.prototype.final = function(B, z) {
  return this.cache.length && this.ghash(Buffer$e.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, B, 0, z])), this.state;
};
var ghash = GHASH$1, aes$4 = aes$5, Buffer$d = safeBufferExports$1.Buffer, Transform$5 = cipherBase, inherits$8 = inherits_browserExports, GHASH = ghash, xor$3 = bufferXor, incr32 = incr32_1;
function xorTest(B, z) {
  var Y = 0;
  B.length !== z.length && Y++;
  for (var ne = Math.min(B.length, z.length), ie = 0; ie < ne; ++ie)
    Y += B[ie] ^ z[ie];
  return Y;
}
function calcIv(B, z, Y) {
  if (z.length === 12)
    return B._finID = Buffer$d.concat([z, Buffer$d.from([0, 0, 0, 1])]), Buffer$d.concat([z, Buffer$d.from([0, 0, 0, 2])]);
  var ne = new GHASH(Y), ie = z.length, oe = ie % 16;
  ne.update(z), oe && (oe = 16 - oe, ne.update(Buffer$d.alloc(oe, 0))), ne.update(Buffer$d.alloc(8, 0));
  var se = ie * 8, ae = Buffer$d.alloc(8);
  ae.writeUIntBE(se, 0, 8), ne.update(ae), B._finID = ne.state;
  var ve = Buffer$d.from(B._finID);
  return incr32(ve), ve;
}
function StreamCipher$3(B, z, Y, ne) {
  Transform$5.call(this);
  var ie = Buffer$d.alloc(4, 0);
  this._cipher = new aes$4.AES(z);
  var oe = this._cipher.encryptBlock(ie);
  this._ghash = new GHASH(oe), Y = calcIv(this, Y, oe), this._prev = Buffer$d.from(Y), this._cache = Buffer$d.allocUnsafe(0), this._secCache = Buffer$d.allocUnsafe(0), this._decrypt = ne, this._alen = 0, this._len = 0, this._mode = B, this._authTag = null, this._called = !1;
}
inherits$8(StreamCipher$3, Transform$5);
StreamCipher$3.prototype._update = function(B) {
  if (!this._called && this._alen) {
    var z = 16 - this._alen % 16;
    z < 16 && (z = Buffer$d.alloc(z, 0), this._ghash.update(z));
  }
  this._called = !0;
  var Y = this._mode.encrypt(this, B);
  return this._decrypt ? this._ghash.update(B) : this._ghash.update(Y), this._len += B.length, Y;
};
StreamCipher$3.prototype._final = function() {
  if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
  var B = xor$3(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(B, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = B, this._cipher.scrub();
};
StreamCipher$3.prototype.getAuthTag = function() {
  if (this._decrypt || !Buffer$d.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
StreamCipher$3.prototype.setAuthTag = function(z) {
  if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = z;
};
StreamCipher$3.prototype.setAAD = function(z) {
  if (this._called) throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(z), this._alen += z.length;
};
var authCipher = StreamCipher$3, aes$3 = aes$5, Buffer$c = safeBufferExports$1.Buffer, Transform$4 = cipherBase, inherits$7 = inherits_browserExports;
function StreamCipher$2(B, z, Y, ne) {
  Transform$4.call(this), this._cipher = new aes$3.AES(z), this._prev = Buffer$c.from(Y), this._cache = Buffer$c.allocUnsafe(0), this._secCache = Buffer$c.allocUnsafe(0), this._decrypt = ne, this._mode = B;
}
inherits$7(StreamCipher$2, Transform$4);
StreamCipher$2.prototype._update = function(B) {
  return this._mode.encrypt(this, B, this._decrypt);
};
StreamCipher$2.prototype._final = function() {
  this._cipher.scrub();
};
var streamCipher = StreamCipher$2, Buffer$b = safeBufferExports$1.Buffer, MD5 = md5_js;
function EVP_BytesToKey(B, z, Y, ne) {
  if (Buffer$b.isBuffer(B) || (B = Buffer$b.from(B, "binary")), z && (Buffer$b.isBuffer(z) || (z = Buffer$b.from(z, "binary")), z.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var ie = Y / 8, oe = Buffer$b.alloc(ie), se = Buffer$b.alloc(ne || 0), ae = Buffer$b.alloc(0); ie > 0 || ne > 0; ) {
    var ve = new MD5();
    ve.update(ae), ve.update(B), z && ve.update(z), ae = ve.digest();
    var Pe = 0;
    if (ie > 0) {
      var le = oe.length - ie;
      Pe = Math.min(ie, ae.length), ae.copy(oe, le, 0, Pe), ie -= Pe;
    }
    if (Pe < ae.length && ne > 0) {
      var Ee = se.length - ne, Je = Math.min(ne, ae.length - Pe);
      ae.copy(se, Ee, Pe, Pe + Je), ne -= Je;
    }
  }
  return ae.fill(0), { key: oe, iv: se };
}
var evp_bytestokey = EVP_BytesToKey, MODES$1 = modes_1, AuthCipher$1 = authCipher, Buffer$a = safeBufferExports$1.Buffer, StreamCipher$1 = streamCipher, Transform$3 = cipherBase, aes$2 = aes$5, ebtk$2 = evp_bytestokey, inherits$6 = inherits_browserExports;
function Cipher(B, z, Y) {
  Transform$3.call(this), this._cache = new Splitter$1(), this._cipher = new aes$2.AES(z), this._prev = Buffer$a.from(Y), this._mode = B, this._autopadding = !0;
}
inherits$6(Cipher, Transform$3);
Cipher.prototype._update = function(B) {
  this._cache.add(B);
  for (var z, Y, ne = []; z = this._cache.get(); )
    Y = this._mode.encrypt(this, z), ne.push(Y);
  return Buffer$a.concat(ne);
};
var PADDING = Buffer$a.alloc(16, 16);
Cipher.prototype._final = function() {
  var B = this._cache.flush();
  if (this._autopadding)
    return B = this._mode.encrypt(this, B), this._cipher.scrub(), B;
  if (!B.equals(PADDING))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
Cipher.prototype.setAutoPadding = function(B) {
  return this._autopadding = !!B, this;
};
function Splitter$1() {
  this.cache = Buffer$a.allocUnsafe(0);
}
Splitter$1.prototype.add = function(B) {
  this.cache = Buffer$a.concat([this.cache, B]);
};
Splitter$1.prototype.get = function() {
  if (this.cache.length > 15) {
    var B = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), B;
  }
  return null;
};
Splitter$1.prototype.flush = function() {
  for (var B = 16 - this.cache.length, z = Buffer$a.allocUnsafe(B), Y = -1; ++Y < B; )
    z.writeUInt8(B, Y);
  return Buffer$a.concat([this.cache, z]);
};
function createCipheriv$1(B, z, Y) {
  var ne = MODES$1[B.toLowerCase()];
  if (!ne) throw new TypeError("invalid suite type");
  if (typeof z == "string" && (z = Buffer$a.from(z)), z.length !== ne.key / 8) throw new TypeError("invalid key length " + z.length);
  if (typeof Y == "string" && (Y = Buffer$a.from(Y)), ne.mode !== "GCM" && Y.length !== ne.iv) throw new TypeError("invalid iv length " + Y.length);
  return ne.type === "stream" ? new StreamCipher$1(ne.module, z, Y) : ne.type === "auth" ? new AuthCipher$1(ne.module, z, Y) : new Cipher(ne.module, z, Y);
}
function createCipher$1(B, z) {
  var Y = MODES$1[B.toLowerCase()];
  if (!Y) throw new TypeError("invalid suite type");
  var ne = ebtk$2(z, !1, Y.key, Y.iv);
  return createCipheriv$1(B, ne.key, ne.iv);
}
encrypter.createCipheriv = createCipheriv$1;
encrypter.createCipher = createCipher$1;
var decrypter = {}, AuthCipher = authCipher, Buffer$9 = safeBufferExports$1.Buffer, MODES = modes_1, StreamCipher = streamCipher, Transform$2 = cipherBase, aes$1 = aes$5, ebtk$1 = evp_bytestokey, inherits$5 = inherits_browserExports;
function Decipher(B, z, Y) {
  Transform$2.call(this), this._cache = new Splitter(), this._last = void 0, this._cipher = new aes$1.AES(z), this._prev = Buffer$9.from(Y), this._mode = B, this._autopadding = !0;
}
inherits$5(Decipher, Transform$2);
Decipher.prototype._update = function(B) {
  this._cache.add(B);
  for (var z, Y, ne = []; z = this._cache.get(this._autopadding); )
    Y = this._mode.decrypt(this, z), ne.push(Y);
  return Buffer$9.concat(ne);
};
Decipher.prototype._final = function() {
  var B = this._cache.flush();
  if (this._autopadding)
    return unpad(this._mode.decrypt(this, B));
  if (B)
    throw new Error("data not multiple of block length");
};
Decipher.prototype.setAutoPadding = function(B) {
  return this._autopadding = !!B, this;
};
function Splitter() {
  this.cache = Buffer$9.allocUnsafe(0);
}
Splitter.prototype.add = function(B) {
  this.cache = Buffer$9.concat([this.cache, B]);
};
Splitter.prototype.get = function(B) {
  var z;
  if (B) {
    if (this.cache.length > 16)
      return z = this.cache.slice(0, 16), this.cache = this.cache.slice(16), z;
  } else if (this.cache.length >= 16)
    return z = this.cache.slice(0, 16), this.cache = this.cache.slice(16), z;
  return null;
};
Splitter.prototype.flush = function() {
  if (this.cache.length) return this.cache;
};
function unpad(B) {
  var z = B[15];
  if (z < 1 || z > 16)
    throw new Error("unable to decrypt data");
  for (var Y = -1; ++Y < z; )
    if (B[Y + (16 - z)] !== z)
      throw new Error("unable to decrypt data");
  if (z !== 16)
    return B.slice(0, 16 - z);
}
function createDecipheriv$1(B, z, Y) {
  var ne = MODES[B.toLowerCase()];
  if (!ne) throw new TypeError("invalid suite type");
  if (typeof Y == "string" && (Y = Buffer$9.from(Y)), ne.mode !== "GCM" && Y.length !== ne.iv) throw new TypeError("invalid iv length " + Y.length);
  if (typeof z == "string" && (z = Buffer$9.from(z)), z.length !== ne.key / 8) throw new TypeError("invalid key length " + z.length);
  return ne.type === "stream" ? new StreamCipher(ne.module, z, Y, !0) : ne.type === "auth" ? new AuthCipher(ne.module, z, Y, !0) : new Decipher(ne.module, z, Y);
}
function createDecipher$1(B, z) {
  var Y = MODES[B.toLowerCase()];
  if (!Y) throw new TypeError("invalid suite type");
  var ne = ebtk$1(z, !1, Y.key, Y.iv);
  return createDecipheriv$1(B, ne.key, ne.iv);
}
decrypter.createDecipher = createDecipher$1;
decrypter.createDecipheriv = createDecipheriv$1;
var ciphers$2 = encrypter, deciphers = decrypter, modes$1 = require$$2;
function getCiphers$1() {
  return Object.keys(modes$1);
}
browser$5.createCipher = browser$5.Cipher = ciphers$2.createCipher;
browser$5.createCipheriv = browser$5.Cipheriv = ciphers$2.createCipheriv;
browser$5.createDecipher = browser$5.Decipher = deciphers.createDecipher;
browser$5.createDecipheriv = browser$5.Decipheriv = deciphers.createDecipheriv;
browser$5.listCiphers = browser$5.getCiphers = getCiphers$1;
var modes = {};
(function(B) {
  B["des-ecb"] = {
    key: 8,
    iv: 0
  }, B["des-cbc"] = B.des = {
    key: 8,
    iv: 8
  }, B["des-ede3-cbc"] = B.des3 = {
    key: 24,
    iv: 8
  }, B["des-ede3"] = {
    key: 24,
    iv: 0
  }, B["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, B["des-ede"] = {
    key: 16,
    iv: 0
  };
})(modes);
var DES = browserifyDes, aes = browser$5, aesModes = modes_1, desModes = modes, ebtk = evp_bytestokey;
function createCipher(B, z) {
  B = B.toLowerCase();
  var Y, ne;
  if (aesModes[B])
    Y = aesModes[B].key, ne = aesModes[B].iv;
  else if (desModes[B])
    Y = desModes[B].key * 8, ne = desModes[B].iv;
  else
    throw new TypeError("invalid suite type");
  var ie = ebtk(z, !1, Y, ne);
  return createCipheriv(B, ie.key, ie.iv);
}
function createDecipher(B, z) {
  B = B.toLowerCase();
  var Y, ne;
  if (aesModes[B])
    Y = aesModes[B].key, ne = aesModes[B].iv;
  else if (desModes[B])
    Y = desModes[B].key * 8, ne = desModes[B].iv;
  else
    throw new TypeError("invalid suite type");
  var ie = ebtk(z, !1, Y, ne);
  return createDecipheriv(B, ie.key, ie.iv);
}
function createCipheriv(B, z, Y) {
  if (B = B.toLowerCase(), aesModes[B]) return aes.createCipheriv(B, z, Y);
  if (desModes[B]) return new DES({ key: z, iv: Y, mode: B });
  throw new TypeError("invalid suite type");
}
function createDecipheriv(B, z, Y) {
  if (B = B.toLowerCase(), aesModes[B]) return aes.createDecipheriv(B, z, Y);
  if (desModes[B]) return new DES({ key: z, iv: Y, mode: B, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function getCiphers() {
  return Object.keys(desModes).concat(aes.getCiphers());
}
browser$6.createCipher = browser$6.Cipher = createCipher;
browser$6.createCipheriv = browser$6.Cipheriv = createCipheriv;
browser$6.createDecipher = browser$6.Decipher = createDecipher;
browser$6.createDecipheriv = browser$6.Decipheriv = createDecipheriv;
browser$6.listCiphers = browser$6.getCiphers = getCiphers;
var browser$4 = {}, bn$1 = { exports: {} };
bn$1.exports;
(function(B) {
  (function(z, Y) {
    function ne(Bt, Xe) {
      if (!Bt) throw new Error(Xe || "Assertion failed");
    }
    function ie(Bt, Xe) {
      Bt.super_ = Xe;
      var Ve = function() {
      };
      Ve.prototype = Xe.prototype, Bt.prototype = new Ve(), Bt.prototype.constructor = Bt;
    }
    function oe(Bt, Xe, Ve) {
      if (oe.isBN(Bt))
        return Bt;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Bt !== null && ((Xe === "le" || Xe === "be") && (Ve = Xe, Xe = 10), this._init(Bt || 0, Xe || 10, Ve || "be"));
    }
    typeof z == "object" ? z.exports = oe : Y.BN = oe, oe.BN = oe, oe.wordSize = 26;
    var se;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? se = window.Buffer : se = require$$0$1.Buffer;
    } catch {
    }
    oe.isBN = function(Xe) {
      return Xe instanceof oe ? !0 : Xe !== null && typeof Xe == "object" && Xe.constructor.wordSize === oe.wordSize && Array.isArray(Xe.words);
    }, oe.max = function(Xe, Ve) {
      return Xe.cmp(Ve) > 0 ? Xe : Ve;
    }, oe.min = function(Xe, Ve) {
      return Xe.cmp(Ve) < 0 ? Xe : Ve;
    }, oe.prototype._init = function(Xe, Ve, ge) {
      if (typeof Xe == "number")
        return this._initNumber(Xe, Ve, ge);
      if (typeof Xe == "object")
        return this._initArray(Xe, Ve, ge);
      Ve === "hex" && (Ve = 16), ne(Ve === (Ve | 0) && Ve >= 2 && Ve <= 36), Xe = Xe.toString().replace(/\s+/g, "");
      var Ke = 0;
      Xe[0] === "-" && (Ke++, this.negative = 1), Ke < Xe.length && (Ve === 16 ? this._parseHex(Xe, Ke, ge) : (this._parseBase(Xe, Ve, Ke), ge === "le" && this._initArray(this.toArray(), Ve, ge)));
    }, oe.prototype._initNumber = function(Xe, Ve, ge) {
      Xe < 0 && (this.negative = 1, Xe = -Xe), Xe < 67108864 ? (this.words = [Xe & 67108863], this.length = 1) : Xe < 4503599627370496 ? (this.words = [
        Xe & 67108863,
        Xe / 67108864 & 67108863
      ], this.length = 2) : (ne(Xe < 9007199254740992), this.words = [
        Xe & 67108863,
        Xe / 67108864 & 67108863,
        1
      ], this.length = 3), ge === "le" && this._initArray(this.toArray(), Ve, ge);
    }, oe.prototype._initArray = function(Xe, Ve, ge) {
      if (ne(typeof Xe.length == "number"), Xe.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(Xe.length / 3), this.words = new Array(this.length);
      for (var Ke = 0; Ke < this.length; Ke++)
        this.words[Ke] = 0;
      var ht, wt, vt = 0;
      if (ge === "be")
        for (Ke = Xe.length - 1, ht = 0; Ke >= 0; Ke -= 3)
          wt = Xe[Ke] | Xe[Ke - 1] << 8 | Xe[Ke - 2] << 16, this.words[ht] |= wt << vt & 67108863, this.words[ht + 1] = wt >>> 26 - vt & 67108863, vt += 24, vt >= 26 && (vt -= 26, ht++);
      else if (ge === "le")
        for (Ke = 0, ht = 0; Ke < Xe.length; Ke += 3)
          wt = Xe[Ke] | Xe[Ke + 1] << 8 | Xe[Ke + 2] << 16, this.words[ht] |= wt << vt & 67108863, this.words[ht + 1] = wt >>> 26 - vt & 67108863, vt += 24, vt >= 26 && (vt -= 26, ht++);
      return this.strip();
    };
    function ae(Bt, Xe) {
      var Ve = Bt.charCodeAt(Xe);
      return Ve >= 65 && Ve <= 70 ? Ve - 55 : Ve >= 97 && Ve <= 102 ? Ve - 87 : Ve - 48 & 15;
    }
    function ve(Bt, Xe, Ve) {
      var ge = ae(Bt, Ve);
      return Ve - 1 >= Xe && (ge |= ae(Bt, Ve - 1) << 4), ge;
    }
    oe.prototype._parseHex = function(Xe, Ve, ge) {
      this.length = Math.ceil((Xe.length - Ve) / 6), this.words = new Array(this.length);
      for (var Ke = 0; Ke < this.length; Ke++)
        this.words[Ke] = 0;
      var ht = 0, wt = 0, vt;
      if (ge === "be")
        for (Ke = Xe.length - 1; Ke >= Ve; Ke -= 2)
          vt = ve(Xe, Ve, Ke) << ht, this.words[wt] |= vt & 67108863, ht >= 18 ? (ht -= 18, wt += 1, this.words[wt] |= vt >>> 26) : ht += 8;
      else {
        var $t = Xe.length - Ve;
        for (Ke = $t % 2 === 0 ? Ve + 1 : Ve; Ke < Xe.length; Ke += 2)
          vt = ve(Xe, Ve, Ke) << ht, this.words[wt] |= vt & 67108863, ht >= 18 ? (ht -= 18, wt += 1, this.words[wt] |= vt >>> 26) : ht += 8;
      }
      this.strip();
    };
    function Pe(Bt, Xe, Ve, ge) {
      for (var Ke = 0, ht = Math.min(Bt.length, Ve), wt = Xe; wt < ht; wt++) {
        var vt = Bt.charCodeAt(wt) - 48;
        Ke *= ge, vt >= 49 ? Ke += vt - 49 + 10 : vt >= 17 ? Ke += vt - 17 + 10 : Ke += vt;
      }
      return Ke;
    }
    oe.prototype._parseBase = function(Xe, Ve, ge) {
      this.words = [0], this.length = 1;
      for (var Ke = 0, ht = 1; ht <= 67108863; ht *= Ve)
        Ke++;
      Ke--, ht = ht / Ve | 0;
      for (var wt = Xe.length - ge, vt = wt % Ke, $t = Math.min(wt, wt - vt) + ge, Qe = 0, xt = ge; xt < $t; xt += Ke)
        Qe = Pe(Xe, xt, xt + Ke, Ve), this.imuln(ht), this.words[0] + Qe < 67108864 ? this.words[0] += Qe : this._iaddn(Qe);
      if (vt !== 0) {
        var bt = 1;
        for (Qe = Pe(Xe, xt, Xe.length, Ve), xt = 0; xt < vt; xt++)
          bt *= Ve;
        this.imuln(bt), this.words[0] + Qe < 67108864 ? this.words[0] += Qe : this._iaddn(Qe);
      }
      this.strip();
    }, oe.prototype.copy = function(Xe) {
      Xe.words = new Array(this.length);
      for (var Ve = 0; Ve < this.length; Ve++)
        Xe.words[Ve] = this.words[Ve];
      Xe.length = this.length, Xe.negative = this.negative, Xe.red = this.red;
    }, oe.prototype.clone = function() {
      var Xe = new oe(null);
      return this.copy(Xe), Xe;
    }, oe.prototype._expand = function(Xe) {
      for (; this.length < Xe; )
        this.words[this.length++] = 0;
      return this;
    }, oe.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, oe.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, oe.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var le = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Ee = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Je = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    oe.prototype.toString = function(Xe, Ve) {
      Xe = Xe || 10, Ve = Ve | 0 || 1;
      var ge;
      if (Xe === 16 || Xe === "hex") {
        ge = "";
        for (var Ke = 0, ht = 0, wt = 0; wt < this.length; wt++) {
          var vt = this.words[wt], $t = ((vt << Ke | ht) & 16777215).toString(16);
          ht = vt >>> 24 - Ke & 16777215, Ke += 2, Ke >= 26 && (Ke -= 26, wt--), ht !== 0 || wt !== this.length - 1 ? ge = le[6 - $t.length] + $t + ge : ge = $t + ge;
        }
        for (ht !== 0 && (ge = ht.toString(16) + ge); ge.length % Ve !== 0; )
          ge = "0" + ge;
        return this.negative !== 0 && (ge = "-" + ge), ge;
      }
      if (Xe === (Xe | 0) && Xe >= 2 && Xe <= 36) {
        var Qe = Ee[Xe], xt = Je[Xe];
        ge = "";
        var bt = this.clone();
        for (bt.negative = 0; !bt.isZero(); ) {
          var Dt = bt.modn(xt).toString(Xe);
          bt = bt.idivn(xt), bt.isZero() ? ge = Dt + ge : ge = le[Qe - Dt.length] + Dt + ge;
        }
        for (this.isZero() && (ge = "0" + ge); ge.length % Ve !== 0; )
          ge = "0" + ge;
        return this.negative !== 0 && (ge = "-" + ge), ge;
      }
      ne(!1, "Base should be between 2 and 36");
    }, oe.prototype.toNumber = function() {
      var Xe = this.words[0];
      return this.length === 2 ? Xe += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Xe += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ne(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Xe : Xe;
    }, oe.prototype.toJSON = function() {
      return this.toString(16);
    }, oe.prototype.toBuffer = function(Xe, Ve) {
      return ne(typeof se < "u"), this.toArrayLike(se, Xe, Ve);
    }, oe.prototype.toArray = function(Xe, Ve) {
      return this.toArrayLike(Array, Xe, Ve);
    }, oe.prototype.toArrayLike = function(Xe, Ve, ge) {
      var Ke = this.byteLength(), ht = ge || Math.max(1, Ke);
      ne(Ke <= ht, "byte array longer than desired length"), ne(ht > 0, "Requested array length <= 0"), this.strip();
      var wt = Ve === "le", vt = new Xe(ht), $t, Qe, xt = this.clone();
      if (wt) {
        for (Qe = 0; !xt.isZero(); Qe++)
          $t = xt.andln(255), xt.iushrn(8), vt[Qe] = $t;
        for (; Qe < ht; Qe++)
          vt[Qe] = 0;
      } else {
        for (Qe = 0; Qe < ht - Ke; Qe++)
          vt[Qe] = 0;
        for (Qe = 0; !xt.isZero(); Qe++)
          $t = xt.andln(255), xt.iushrn(8), vt[ht - Qe - 1] = $t;
      }
      return vt;
    }, Math.clz32 ? oe.prototype._countBits = function(Xe) {
      return 32 - Math.clz32(Xe);
    } : oe.prototype._countBits = function(Xe) {
      var Ve = Xe, ge = 0;
      return Ve >= 4096 && (ge += 13, Ve >>>= 13), Ve >= 64 && (ge += 7, Ve >>>= 7), Ve >= 8 && (ge += 4, Ve >>>= 4), Ve >= 2 && (ge += 2, Ve >>>= 2), ge + Ve;
    }, oe.prototype._zeroBits = function(Xe) {
      if (Xe === 0) return 26;
      var Ve = Xe, ge = 0;
      return Ve & 8191 || (ge += 13, Ve >>>= 13), Ve & 127 || (ge += 7, Ve >>>= 7), Ve & 15 || (ge += 4, Ve >>>= 4), Ve & 3 || (ge += 2, Ve >>>= 2), Ve & 1 || ge++, ge;
    }, oe.prototype.bitLength = function() {
      var Xe = this.words[this.length - 1], Ve = this._countBits(Xe);
      return (this.length - 1) * 26 + Ve;
    };
    function Ce(Bt) {
      for (var Xe = new Array(Bt.bitLength()), Ve = 0; Ve < Xe.length; Ve++) {
        var ge = Ve / 26 | 0, Ke = Ve % 26;
        Xe[Ve] = (Bt.words[ge] & 1 << Ke) >>> Ke;
      }
      return Xe;
    }
    oe.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var Xe = 0, Ve = 0; Ve < this.length; Ve++) {
        var ge = this._zeroBits(this.words[Ve]);
        if (Xe += ge, ge !== 26) break;
      }
      return Xe;
    }, oe.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, oe.prototype.toTwos = function(Xe) {
      return this.negative !== 0 ? this.abs().inotn(Xe).iaddn(1) : this.clone();
    }, oe.prototype.fromTwos = function(Xe) {
      return this.testn(Xe - 1) ? this.notn(Xe).iaddn(1).ineg() : this.clone();
    }, oe.prototype.isNeg = function() {
      return this.negative !== 0;
    }, oe.prototype.neg = function() {
      return this.clone().ineg();
    }, oe.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, oe.prototype.iuor = function(Xe) {
      for (; this.length < Xe.length; )
        this.words[this.length++] = 0;
      for (var Ve = 0; Ve < Xe.length; Ve++)
        this.words[Ve] = this.words[Ve] | Xe.words[Ve];
      return this.strip();
    }, oe.prototype.ior = function(Xe) {
      return ne((this.negative | Xe.negative) === 0), this.iuor(Xe);
    }, oe.prototype.or = function(Xe) {
      return this.length > Xe.length ? this.clone().ior(Xe) : Xe.clone().ior(this);
    }, oe.prototype.uor = function(Xe) {
      return this.length > Xe.length ? this.clone().iuor(Xe) : Xe.clone().iuor(this);
    }, oe.prototype.iuand = function(Xe) {
      var Ve;
      this.length > Xe.length ? Ve = Xe : Ve = this;
      for (var ge = 0; ge < Ve.length; ge++)
        this.words[ge] = this.words[ge] & Xe.words[ge];
      return this.length = Ve.length, this.strip();
    }, oe.prototype.iand = function(Xe) {
      return ne((this.negative | Xe.negative) === 0), this.iuand(Xe);
    }, oe.prototype.and = function(Xe) {
      return this.length > Xe.length ? this.clone().iand(Xe) : Xe.clone().iand(this);
    }, oe.prototype.uand = function(Xe) {
      return this.length > Xe.length ? this.clone().iuand(Xe) : Xe.clone().iuand(this);
    }, oe.prototype.iuxor = function(Xe) {
      var Ve, ge;
      this.length > Xe.length ? (Ve = this, ge = Xe) : (Ve = Xe, ge = this);
      for (var Ke = 0; Ke < ge.length; Ke++)
        this.words[Ke] = Ve.words[Ke] ^ ge.words[Ke];
      if (this !== Ve)
        for (; Ke < Ve.length; Ke++)
          this.words[Ke] = Ve.words[Ke];
      return this.length = Ve.length, this.strip();
    }, oe.prototype.ixor = function(Xe) {
      return ne((this.negative | Xe.negative) === 0), this.iuxor(Xe);
    }, oe.prototype.xor = function(Xe) {
      return this.length > Xe.length ? this.clone().ixor(Xe) : Xe.clone().ixor(this);
    }, oe.prototype.uxor = function(Xe) {
      return this.length > Xe.length ? this.clone().iuxor(Xe) : Xe.clone().iuxor(this);
    }, oe.prototype.inotn = function(Xe) {
      ne(typeof Xe == "number" && Xe >= 0);
      var Ve = Math.ceil(Xe / 26) | 0, ge = Xe % 26;
      this._expand(Ve), ge > 0 && Ve--;
      for (var Ke = 0; Ke < Ve; Ke++)
        this.words[Ke] = ~this.words[Ke] & 67108863;
      return ge > 0 && (this.words[Ke] = ~this.words[Ke] & 67108863 >> 26 - ge), this.strip();
    }, oe.prototype.notn = function(Xe) {
      return this.clone().inotn(Xe);
    }, oe.prototype.setn = function(Xe, Ve) {
      ne(typeof Xe == "number" && Xe >= 0);
      var ge = Xe / 26 | 0, Ke = Xe % 26;
      return this._expand(ge + 1), Ve ? this.words[ge] = this.words[ge] | 1 << Ke : this.words[ge] = this.words[ge] & ~(1 << Ke), this.strip();
    }, oe.prototype.iadd = function(Xe) {
      var Ve;
      if (this.negative !== 0 && Xe.negative === 0)
        return this.negative = 0, Ve = this.isub(Xe), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && Xe.negative !== 0)
        return Xe.negative = 0, Ve = this.isub(Xe), Xe.negative = 1, Ve._normSign();
      var ge, Ke;
      this.length > Xe.length ? (ge = this, Ke = Xe) : (ge = Xe, Ke = this);
      for (var ht = 0, wt = 0; wt < Ke.length; wt++)
        Ve = (ge.words[wt] | 0) + (Ke.words[wt] | 0) + ht, this.words[wt] = Ve & 67108863, ht = Ve >>> 26;
      for (; ht !== 0 && wt < ge.length; wt++)
        Ve = (ge.words[wt] | 0) + ht, this.words[wt] = Ve & 67108863, ht = Ve >>> 26;
      if (this.length = ge.length, ht !== 0)
        this.words[this.length] = ht, this.length++;
      else if (ge !== this)
        for (; wt < ge.length; wt++)
          this.words[wt] = ge.words[wt];
      return this;
    }, oe.prototype.add = function(Xe) {
      var Ve;
      return Xe.negative !== 0 && this.negative === 0 ? (Xe.negative = 0, Ve = this.sub(Xe), Xe.negative ^= 1, Ve) : Xe.negative === 0 && this.negative !== 0 ? (this.negative = 0, Ve = Xe.sub(this), this.negative = 1, Ve) : this.length > Xe.length ? this.clone().iadd(Xe) : Xe.clone().iadd(this);
    }, oe.prototype.isub = function(Xe) {
      if (Xe.negative !== 0) {
        Xe.negative = 0;
        var Ve = this.iadd(Xe);
        return Xe.negative = 1, Ve._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(Xe), this.negative = 1, this._normSign();
      var ge = this.cmp(Xe);
      if (ge === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var Ke, ht;
      ge > 0 ? (Ke = this, ht = Xe) : (Ke = Xe, ht = this);
      for (var wt = 0, vt = 0; vt < ht.length; vt++)
        Ve = (Ke.words[vt] | 0) - (ht.words[vt] | 0) + wt, wt = Ve >> 26, this.words[vt] = Ve & 67108863;
      for (; wt !== 0 && vt < Ke.length; vt++)
        Ve = (Ke.words[vt] | 0) + wt, wt = Ve >> 26, this.words[vt] = Ve & 67108863;
      if (wt === 0 && vt < Ke.length && Ke !== this)
        for (; vt < Ke.length; vt++)
          this.words[vt] = Ke.words[vt];
      return this.length = Math.max(this.length, vt), Ke !== this && (this.negative = 1), this.strip();
    }, oe.prototype.sub = function(Xe) {
      return this.clone().isub(Xe);
    };
    function _t(Bt, Xe, Ve) {
      Ve.negative = Xe.negative ^ Bt.negative;
      var ge = Bt.length + Xe.length | 0;
      Ve.length = ge, ge = ge - 1 | 0;
      var Ke = Bt.words[0] | 0, ht = Xe.words[0] | 0, wt = Ke * ht, vt = wt & 67108863, $t = wt / 67108864 | 0;
      Ve.words[0] = vt;
      for (var Qe = 1; Qe < ge; Qe++) {
        for (var xt = $t >>> 26, bt = $t & 67108863, Dt = Math.min(Qe, Xe.length - 1), er = Math.max(0, Qe - Bt.length + 1); er <= Dt; er++) {
          var fr = Qe - er | 0;
          Ke = Bt.words[fr] | 0, ht = Xe.words[er] | 0, wt = Ke * ht + bt, xt += wt / 67108864 | 0, bt = wt & 67108863;
        }
        Ve.words[Qe] = bt | 0, $t = xt | 0;
      }
      return $t !== 0 ? Ve.words[Qe] = $t | 0 : Ve.length--, Ve.strip();
    }
    var kt = function(Xe, Ve, ge) {
      var Ke = Xe.words, ht = Ve.words, wt = ge.words, vt = 0, $t, Qe, xt, bt = Ke[0] | 0, Dt = bt & 8191, er = bt >>> 13, fr = Ke[1] | 0, Qt = fr & 8191, Ht = fr >>> 13, qt = Ke[2] | 0, nr = qt & 8191, ur = qt >>> 13, zt = Ke[3] | 0, Gt = zt & 8191, cr = zt >>> 13, gr = Ke[4] | 0, $r = gr & 8191, xr = gr >>> 13, Mr = Ke[5] | 0, kr = Mr & 8191, br = Mr >>> 13, Yr = Ke[6] | 0, jr = Yr & 8191, Qr = Yr >>> 13, Xr = Ke[7] | 0, Or = Xr & 8191, Wr = Xr >>> 13, Jr = Ke[8] | 0, Hr = Jr & 8191, Vr = Jr >>> 13, tn = Ke[9] | 0, Wt = tn & 8191, Ot = tn >>> 13, Nt = ht[0] | 0, Yt = Nt & 8191, ar = Nt >>> 13, lr = ht[1] | 0, dr = lr & 8191, Ir = lr >>> 13, qr = ht[2] | 0, Br = qr & 8191, Ur = qr >>> 13, Lr = ht[3] | 0, Dr = Lr & 8191, Zr = Lr >>> 13, nn = ht[4] | 0, tr = nn & 8191, Xt = nn >>> 13, rr = ht[5] | 0, or = rr & 8191, pr = rr >>> 13, vr = ht[6] | 0, wr = vr & 8191, Er = vr >>> 13, Pr = ht[7] | 0, Ar = Pr & 8191, Tr = Pr >>> 13, Nr = ht[8] | 0, Zt = Nr & 8191, yr = Nr >>> 13, _r = ht[9] | 0, Sr = _r & 8191, Cr = _r >>> 13;
      ge.negative = Xe.negative ^ Ve.negative, ge.length = 19, $t = Math.imul(Dt, Yt), Qe = Math.imul(Dt, ar), Qe = Qe + Math.imul(er, Yt) | 0, xt = Math.imul(er, ar);
      var Fr = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, $t = Math.imul(Qt, Yt), Qe = Math.imul(Qt, ar), Qe = Qe + Math.imul(Ht, Yt) | 0, xt = Math.imul(Ht, ar), $t = $t + Math.imul(Dt, dr) | 0, Qe = Qe + Math.imul(Dt, Ir) | 0, Qe = Qe + Math.imul(er, dr) | 0, xt = xt + Math.imul(er, Ir) | 0;
      var Rr = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, $t = Math.imul(nr, Yt), Qe = Math.imul(nr, ar), Qe = Qe + Math.imul(ur, Yt) | 0, xt = Math.imul(ur, ar), $t = $t + Math.imul(Qt, dr) | 0, Qe = Qe + Math.imul(Qt, Ir) | 0, Qe = Qe + Math.imul(Ht, dr) | 0, xt = xt + Math.imul(Ht, Ir) | 0, $t = $t + Math.imul(Dt, Br) | 0, Qe = Qe + Math.imul(Dt, Ur) | 0, Qe = Qe + Math.imul(er, Br) | 0, xt = xt + Math.imul(er, Ur) | 0;
      var Gr = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, $t = Math.imul(Gt, Yt), Qe = Math.imul(Gt, ar), Qe = Qe + Math.imul(cr, Yt) | 0, xt = Math.imul(cr, ar), $t = $t + Math.imul(nr, dr) | 0, Qe = Qe + Math.imul(nr, Ir) | 0, Qe = Qe + Math.imul(ur, dr) | 0, xt = xt + Math.imul(ur, Ir) | 0, $t = $t + Math.imul(Qt, Br) | 0, Qe = Qe + Math.imul(Qt, Ur) | 0, Qe = Qe + Math.imul(Ht, Br) | 0, xt = xt + Math.imul(Ht, Ur) | 0, $t = $t + Math.imul(Dt, Dr) | 0, Qe = Qe + Math.imul(Dt, Zr) | 0, Qe = Qe + Math.imul(er, Dr) | 0, xt = xt + Math.imul(er, Zr) | 0;
      var sn = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, $t = Math.imul($r, Yt), Qe = Math.imul($r, ar), Qe = Qe + Math.imul(xr, Yt) | 0, xt = Math.imul(xr, ar), $t = $t + Math.imul(Gt, dr) | 0, Qe = Qe + Math.imul(Gt, Ir) | 0, Qe = Qe + Math.imul(cr, dr) | 0, xt = xt + Math.imul(cr, Ir) | 0, $t = $t + Math.imul(nr, Br) | 0, Qe = Qe + Math.imul(nr, Ur) | 0, Qe = Qe + Math.imul(ur, Br) | 0, xt = xt + Math.imul(ur, Ur) | 0, $t = $t + Math.imul(Qt, Dr) | 0, Qe = Qe + Math.imul(Qt, Zr) | 0, Qe = Qe + Math.imul(Ht, Dr) | 0, xt = xt + Math.imul(Ht, Zr) | 0, $t = $t + Math.imul(Dt, tr) | 0, Qe = Qe + Math.imul(Dt, Xt) | 0, Qe = Qe + Math.imul(er, tr) | 0, xt = xt + Math.imul(er, Xt) | 0;
      var en = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, $t = Math.imul(kr, Yt), Qe = Math.imul(kr, ar), Qe = Qe + Math.imul(br, Yt) | 0, xt = Math.imul(br, ar), $t = $t + Math.imul($r, dr) | 0, Qe = Qe + Math.imul($r, Ir) | 0, Qe = Qe + Math.imul(xr, dr) | 0, xt = xt + Math.imul(xr, Ir) | 0, $t = $t + Math.imul(Gt, Br) | 0, Qe = Qe + Math.imul(Gt, Ur) | 0, Qe = Qe + Math.imul(cr, Br) | 0, xt = xt + Math.imul(cr, Ur) | 0, $t = $t + Math.imul(nr, Dr) | 0, Qe = Qe + Math.imul(nr, Zr) | 0, Qe = Qe + Math.imul(ur, Dr) | 0, xt = xt + Math.imul(ur, Zr) | 0, $t = $t + Math.imul(Qt, tr) | 0, Qe = Qe + Math.imul(Qt, Xt) | 0, Qe = Qe + Math.imul(Ht, tr) | 0, xt = xt + Math.imul(Ht, Xt) | 0, $t = $t + Math.imul(Dt, or) | 0, Qe = Qe + Math.imul(Dt, pr) | 0, Qe = Qe + Math.imul(er, or) | 0, xt = xt + Math.imul(er, pr) | 0;
      var on = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, $t = Math.imul(jr, Yt), Qe = Math.imul(jr, ar), Qe = Qe + Math.imul(Qr, Yt) | 0, xt = Math.imul(Qr, ar), $t = $t + Math.imul(kr, dr) | 0, Qe = Qe + Math.imul(kr, Ir) | 0, Qe = Qe + Math.imul(br, dr) | 0, xt = xt + Math.imul(br, Ir) | 0, $t = $t + Math.imul($r, Br) | 0, Qe = Qe + Math.imul($r, Ur) | 0, Qe = Qe + Math.imul(xr, Br) | 0, xt = xt + Math.imul(xr, Ur) | 0, $t = $t + Math.imul(Gt, Dr) | 0, Qe = Qe + Math.imul(Gt, Zr) | 0, Qe = Qe + Math.imul(cr, Dr) | 0, xt = xt + Math.imul(cr, Zr) | 0, $t = $t + Math.imul(nr, tr) | 0, Qe = Qe + Math.imul(nr, Xt) | 0, Qe = Qe + Math.imul(ur, tr) | 0, xt = xt + Math.imul(ur, Xt) | 0, $t = $t + Math.imul(Qt, or) | 0, Qe = Qe + Math.imul(Qt, pr) | 0, Qe = Qe + Math.imul(Ht, or) | 0, xt = xt + Math.imul(Ht, pr) | 0, $t = $t + Math.imul(Dt, wr) | 0, Qe = Qe + Math.imul(Dt, Er) | 0, Qe = Qe + Math.imul(er, wr) | 0, xt = xt + Math.imul(er, Er) | 0;
      var cn = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, $t = Math.imul(Or, Yt), Qe = Math.imul(Or, ar), Qe = Qe + Math.imul(Wr, Yt) | 0, xt = Math.imul(Wr, ar), $t = $t + Math.imul(jr, dr) | 0, Qe = Qe + Math.imul(jr, Ir) | 0, Qe = Qe + Math.imul(Qr, dr) | 0, xt = xt + Math.imul(Qr, Ir) | 0, $t = $t + Math.imul(kr, Br) | 0, Qe = Qe + Math.imul(kr, Ur) | 0, Qe = Qe + Math.imul(br, Br) | 0, xt = xt + Math.imul(br, Ur) | 0, $t = $t + Math.imul($r, Dr) | 0, Qe = Qe + Math.imul($r, Zr) | 0, Qe = Qe + Math.imul(xr, Dr) | 0, xt = xt + Math.imul(xr, Zr) | 0, $t = $t + Math.imul(Gt, tr) | 0, Qe = Qe + Math.imul(Gt, Xt) | 0, Qe = Qe + Math.imul(cr, tr) | 0, xt = xt + Math.imul(cr, Xt) | 0, $t = $t + Math.imul(nr, or) | 0, Qe = Qe + Math.imul(nr, pr) | 0, Qe = Qe + Math.imul(ur, or) | 0, xt = xt + Math.imul(ur, pr) | 0, $t = $t + Math.imul(Qt, wr) | 0, Qe = Qe + Math.imul(Qt, Er) | 0, Qe = Qe + Math.imul(Ht, wr) | 0, xt = xt + Math.imul(Ht, Er) | 0, $t = $t + Math.imul(Dt, Ar) | 0, Qe = Qe + Math.imul(Dt, Tr) | 0, Qe = Qe + Math.imul(er, Ar) | 0, xt = xt + Math.imul(er, Tr) | 0;
      var ln = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, $t = Math.imul(Hr, Yt), Qe = Math.imul(Hr, ar), Qe = Qe + Math.imul(Vr, Yt) | 0, xt = Math.imul(Vr, ar), $t = $t + Math.imul(Or, dr) | 0, Qe = Qe + Math.imul(Or, Ir) | 0, Qe = Qe + Math.imul(Wr, dr) | 0, xt = xt + Math.imul(Wr, Ir) | 0, $t = $t + Math.imul(jr, Br) | 0, Qe = Qe + Math.imul(jr, Ur) | 0, Qe = Qe + Math.imul(Qr, Br) | 0, xt = xt + Math.imul(Qr, Ur) | 0, $t = $t + Math.imul(kr, Dr) | 0, Qe = Qe + Math.imul(kr, Zr) | 0, Qe = Qe + Math.imul(br, Dr) | 0, xt = xt + Math.imul(br, Zr) | 0, $t = $t + Math.imul($r, tr) | 0, Qe = Qe + Math.imul($r, Xt) | 0, Qe = Qe + Math.imul(xr, tr) | 0, xt = xt + Math.imul(xr, Xt) | 0, $t = $t + Math.imul(Gt, or) | 0, Qe = Qe + Math.imul(Gt, pr) | 0, Qe = Qe + Math.imul(cr, or) | 0, xt = xt + Math.imul(cr, pr) | 0, $t = $t + Math.imul(nr, wr) | 0, Qe = Qe + Math.imul(nr, Er) | 0, Qe = Qe + Math.imul(ur, wr) | 0, xt = xt + Math.imul(ur, Er) | 0, $t = $t + Math.imul(Qt, Ar) | 0, Qe = Qe + Math.imul(Qt, Tr) | 0, Qe = Qe + Math.imul(Ht, Ar) | 0, xt = xt + Math.imul(Ht, Tr) | 0, $t = $t + Math.imul(Dt, Zt) | 0, Qe = Qe + Math.imul(Dt, yr) | 0, Qe = Qe + Math.imul(er, Zt) | 0, xt = xt + Math.imul(er, yr) | 0;
      var un = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, $t = Math.imul(Wt, Yt), Qe = Math.imul(Wt, ar), Qe = Qe + Math.imul(Ot, Yt) | 0, xt = Math.imul(Ot, ar), $t = $t + Math.imul(Hr, dr) | 0, Qe = Qe + Math.imul(Hr, Ir) | 0, Qe = Qe + Math.imul(Vr, dr) | 0, xt = xt + Math.imul(Vr, Ir) | 0, $t = $t + Math.imul(Or, Br) | 0, Qe = Qe + Math.imul(Or, Ur) | 0, Qe = Qe + Math.imul(Wr, Br) | 0, xt = xt + Math.imul(Wr, Ur) | 0, $t = $t + Math.imul(jr, Dr) | 0, Qe = Qe + Math.imul(jr, Zr) | 0, Qe = Qe + Math.imul(Qr, Dr) | 0, xt = xt + Math.imul(Qr, Zr) | 0, $t = $t + Math.imul(kr, tr) | 0, Qe = Qe + Math.imul(kr, Xt) | 0, Qe = Qe + Math.imul(br, tr) | 0, xt = xt + Math.imul(br, Xt) | 0, $t = $t + Math.imul($r, or) | 0, Qe = Qe + Math.imul($r, pr) | 0, Qe = Qe + Math.imul(xr, or) | 0, xt = xt + Math.imul(xr, pr) | 0, $t = $t + Math.imul(Gt, wr) | 0, Qe = Qe + Math.imul(Gt, Er) | 0, Qe = Qe + Math.imul(cr, wr) | 0, xt = xt + Math.imul(cr, Er) | 0, $t = $t + Math.imul(nr, Ar) | 0, Qe = Qe + Math.imul(nr, Tr) | 0, Qe = Qe + Math.imul(ur, Ar) | 0, xt = xt + Math.imul(ur, Tr) | 0, $t = $t + Math.imul(Qt, Zt) | 0, Qe = Qe + Math.imul(Qt, yr) | 0, Qe = Qe + Math.imul(Ht, Zt) | 0, xt = xt + Math.imul(Ht, yr) | 0, $t = $t + Math.imul(Dt, Sr) | 0, Qe = Qe + Math.imul(Dt, Cr) | 0, Qe = Qe + Math.imul(er, Sr) | 0, xt = xt + Math.imul(er, Cr) | 0;
      var an = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, $t = Math.imul(Wt, dr), Qe = Math.imul(Wt, Ir), Qe = Qe + Math.imul(Ot, dr) | 0, xt = Math.imul(Ot, Ir), $t = $t + Math.imul(Hr, Br) | 0, Qe = Qe + Math.imul(Hr, Ur) | 0, Qe = Qe + Math.imul(Vr, Br) | 0, xt = xt + Math.imul(Vr, Ur) | 0, $t = $t + Math.imul(Or, Dr) | 0, Qe = Qe + Math.imul(Or, Zr) | 0, Qe = Qe + Math.imul(Wr, Dr) | 0, xt = xt + Math.imul(Wr, Zr) | 0, $t = $t + Math.imul(jr, tr) | 0, Qe = Qe + Math.imul(jr, Xt) | 0, Qe = Qe + Math.imul(Qr, tr) | 0, xt = xt + Math.imul(Qr, Xt) | 0, $t = $t + Math.imul(kr, or) | 0, Qe = Qe + Math.imul(kr, pr) | 0, Qe = Qe + Math.imul(br, or) | 0, xt = xt + Math.imul(br, pr) | 0, $t = $t + Math.imul($r, wr) | 0, Qe = Qe + Math.imul($r, Er) | 0, Qe = Qe + Math.imul(xr, wr) | 0, xt = xt + Math.imul(xr, Er) | 0, $t = $t + Math.imul(Gt, Ar) | 0, Qe = Qe + Math.imul(Gt, Tr) | 0, Qe = Qe + Math.imul(cr, Ar) | 0, xt = xt + Math.imul(cr, Tr) | 0, $t = $t + Math.imul(nr, Zt) | 0, Qe = Qe + Math.imul(nr, yr) | 0, Qe = Qe + Math.imul(ur, Zt) | 0, xt = xt + Math.imul(ur, yr) | 0, $t = $t + Math.imul(Qt, Sr) | 0, Qe = Qe + Math.imul(Qt, Cr) | 0, Qe = Qe + Math.imul(Ht, Sr) | 0, xt = xt + Math.imul(Ht, Cr) | 0;
      var dn = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (dn >>> 26) | 0, dn &= 67108863, $t = Math.imul(Wt, Br), Qe = Math.imul(Wt, Ur), Qe = Qe + Math.imul(Ot, Br) | 0, xt = Math.imul(Ot, Ur), $t = $t + Math.imul(Hr, Dr) | 0, Qe = Qe + Math.imul(Hr, Zr) | 0, Qe = Qe + Math.imul(Vr, Dr) | 0, xt = xt + Math.imul(Vr, Zr) | 0, $t = $t + Math.imul(Or, tr) | 0, Qe = Qe + Math.imul(Or, Xt) | 0, Qe = Qe + Math.imul(Wr, tr) | 0, xt = xt + Math.imul(Wr, Xt) | 0, $t = $t + Math.imul(jr, or) | 0, Qe = Qe + Math.imul(jr, pr) | 0, Qe = Qe + Math.imul(Qr, or) | 0, xt = xt + Math.imul(Qr, pr) | 0, $t = $t + Math.imul(kr, wr) | 0, Qe = Qe + Math.imul(kr, Er) | 0, Qe = Qe + Math.imul(br, wr) | 0, xt = xt + Math.imul(br, Er) | 0, $t = $t + Math.imul($r, Ar) | 0, Qe = Qe + Math.imul($r, Tr) | 0, Qe = Qe + Math.imul(xr, Ar) | 0, xt = xt + Math.imul(xr, Tr) | 0, $t = $t + Math.imul(Gt, Zt) | 0, Qe = Qe + Math.imul(Gt, yr) | 0, Qe = Qe + Math.imul(cr, Zt) | 0, xt = xt + Math.imul(cr, yr) | 0, $t = $t + Math.imul(nr, Sr) | 0, Qe = Qe + Math.imul(nr, Cr) | 0, Qe = Qe + Math.imul(ur, Sr) | 0, xt = xt + Math.imul(ur, Cr) | 0;
      var hn = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (hn >>> 26) | 0, hn &= 67108863, $t = Math.imul(Wt, Dr), Qe = Math.imul(Wt, Zr), Qe = Qe + Math.imul(Ot, Dr) | 0, xt = Math.imul(Ot, Zr), $t = $t + Math.imul(Hr, tr) | 0, Qe = Qe + Math.imul(Hr, Xt) | 0, Qe = Qe + Math.imul(Vr, tr) | 0, xt = xt + Math.imul(Vr, Xt) | 0, $t = $t + Math.imul(Or, or) | 0, Qe = Qe + Math.imul(Or, pr) | 0, Qe = Qe + Math.imul(Wr, or) | 0, xt = xt + Math.imul(Wr, pr) | 0, $t = $t + Math.imul(jr, wr) | 0, Qe = Qe + Math.imul(jr, Er) | 0, Qe = Qe + Math.imul(Qr, wr) | 0, xt = xt + Math.imul(Qr, Er) | 0, $t = $t + Math.imul(kr, Ar) | 0, Qe = Qe + Math.imul(kr, Tr) | 0, Qe = Qe + Math.imul(br, Ar) | 0, xt = xt + Math.imul(br, Tr) | 0, $t = $t + Math.imul($r, Zt) | 0, Qe = Qe + Math.imul($r, yr) | 0, Qe = Qe + Math.imul(xr, Zt) | 0, xt = xt + Math.imul(xr, yr) | 0, $t = $t + Math.imul(Gt, Sr) | 0, Qe = Qe + Math.imul(Gt, Cr) | 0, Qe = Qe + Math.imul(cr, Sr) | 0, xt = xt + Math.imul(cr, Cr) | 0;
      var pn = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, $t = Math.imul(Wt, tr), Qe = Math.imul(Wt, Xt), Qe = Qe + Math.imul(Ot, tr) | 0, xt = Math.imul(Ot, Xt), $t = $t + Math.imul(Hr, or) | 0, Qe = Qe + Math.imul(Hr, pr) | 0, Qe = Qe + Math.imul(Vr, or) | 0, xt = xt + Math.imul(Vr, pr) | 0, $t = $t + Math.imul(Or, wr) | 0, Qe = Qe + Math.imul(Or, Er) | 0, Qe = Qe + Math.imul(Wr, wr) | 0, xt = xt + Math.imul(Wr, Er) | 0, $t = $t + Math.imul(jr, Ar) | 0, Qe = Qe + Math.imul(jr, Tr) | 0, Qe = Qe + Math.imul(Qr, Ar) | 0, xt = xt + Math.imul(Qr, Tr) | 0, $t = $t + Math.imul(kr, Zt) | 0, Qe = Qe + Math.imul(kr, yr) | 0, Qe = Qe + Math.imul(br, Zt) | 0, xt = xt + Math.imul(br, yr) | 0, $t = $t + Math.imul($r, Sr) | 0, Qe = Qe + Math.imul($r, Cr) | 0, Qe = Qe + Math.imul(xr, Sr) | 0, xt = xt + Math.imul(xr, Cr) | 0;
      var yn = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (yn >>> 26) | 0, yn &= 67108863, $t = Math.imul(Wt, or), Qe = Math.imul(Wt, pr), Qe = Qe + Math.imul(Ot, or) | 0, xt = Math.imul(Ot, pr), $t = $t + Math.imul(Hr, wr) | 0, Qe = Qe + Math.imul(Hr, Er) | 0, Qe = Qe + Math.imul(Vr, wr) | 0, xt = xt + Math.imul(Vr, Er) | 0, $t = $t + Math.imul(Or, Ar) | 0, Qe = Qe + Math.imul(Or, Tr) | 0, Qe = Qe + Math.imul(Wr, Ar) | 0, xt = xt + Math.imul(Wr, Tr) | 0, $t = $t + Math.imul(jr, Zt) | 0, Qe = Qe + Math.imul(jr, yr) | 0, Qe = Qe + Math.imul(Qr, Zt) | 0, xt = xt + Math.imul(Qr, yr) | 0, $t = $t + Math.imul(kr, Sr) | 0, Qe = Qe + Math.imul(kr, Cr) | 0, Qe = Qe + Math.imul(br, Sr) | 0, xt = xt + Math.imul(br, Cr) | 0;
      var mn = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (mn >>> 26) | 0, mn &= 67108863, $t = Math.imul(Wt, wr), Qe = Math.imul(Wt, Er), Qe = Qe + Math.imul(Ot, wr) | 0, xt = Math.imul(Ot, Er), $t = $t + Math.imul(Hr, Ar) | 0, Qe = Qe + Math.imul(Hr, Tr) | 0, Qe = Qe + Math.imul(Vr, Ar) | 0, xt = xt + Math.imul(Vr, Tr) | 0, $t = $t + Math.imul(Or, Zt) | 0, Qe = Qe + Math.imul(Or, yr) | 0, Qe = Qe + Math.imul(Wr, Zt) | 0, xt = xt + Math.imul(Wr, yr) | 0, $t = $t + Math.imul(jr, Sr) | 0, Qe = Qe + Math.imul(jr, Cr) | 0, Qe = Qe + Math.imul(Qr, Sr) | 0, xt = xt + Math.imul(Qr, Cr) | 0;
      var vn = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (vn >>> 26) | 0, vn &= 67108863, $t = Math.imul(Wt, Ar), Qe = Math.imul(Wt, Tr), Qe = Qe + Math.imul(Ot, Ar) | 0, xt = Math.imul(Ot, Tr), $t = $t + Math.imul(Hr, Zt) | 0, Qe = Qe + Math.imul(Hr, yr) | 0, Qe = Qe + Math.imul(Vr, Zt) | 0, xt = xt + Math.imul(Vr, yr) | 0, $t = $t + Math.imul(Or, Sr) | 0, Qe = Qe + Math.imul(Or, Cr) | 0, Qe = Qe + Math.imul(Wr, Sr) | 0, xt = xt + Math.imul(Wr, Cr) | 0;
      var gn = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (gn >>> 26) | 0, gn &= 67108863, $t = Math.imul(Wt, Zt), Qe = Math.imul(Wt, yr), Qe = Qe + Math.imul(Ot, Zt) | 0, xt = Math.imul(Ot, yr), $t = $t + Math.imul(Hr, Sr) | 0, Qe = Qe + Math.imul(Hr, Cr) | 0, Qe = Qe + Math.imul(Vr, Sr) | 0, xt = xt + Math.imul(Vr, Cr) | 0;
      var wn = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      vt = (xt + (Qe >>> 13) | 0) + (wn >>> 26) | 0, wn &= 67108863, $t = Math.imul(Wt, Sr), Qe = Math.imul(Wt, Cr), Qe = Qe + Math.imul(Ot, Sr) | 0, xt = Math.imul(Ot, Cr);
      var _n = (vt + $t | 0) + ((Qe & 8191) << 13) | 0;
      return vt = (xt + (Qe >>> 13) | 0) + (_n >>> 26) | 0, _n &= 67108863, wt[0] = Fr, wt[1] = Rr, wt[2] = Gr, wt[3] = sn, wt[4] = en, wt[5] = on, wt[6] = cn, wt[7] = ln, wt[8] = un, wt[9] = an, wt[10] = dn, wt[11] = hn, wt[12] = pn, wt[13] = yn, wt[14] = mn, wt[15] = vn, wt[16] = gn, wt[17] = wn, wt[18] = _n, vt !== 0 && (wt[19] = vt, ge.length++), ge;
    };
    Math.imul || (kt = _t);
    function Ct(Bt, Xe, Ve) {
      Ve.negative = Xe.negative ^ Bt.negative, Ve.length = Bt.length + Xe.length;
      for (var ge = 0, Ke = 0, ht = 0; ht < Ve.length - 1; ht++) {
        var wt = Ke;
        Ke = 0;
        for (var vt = ge & 67108863, $t = Math.min(ht, Xe.length - 1), Qe = Math.max(0, ht - Bt.length + 1); Qe <= $t; Qe++) {
          var xt = ht - Qe, bt = Bt.words[xt] | 0, Dt = Xe.words[Qe] | 0, er = bt * Dt, fr = er & 67108863;
          wt = wt + (er / 67108864 | 0) | 0, fr = fr + vt | 0, vt = fr & 67108863, wt = wt + (fr >>> 26) | 0, Ke += wt >>> 26, wt &= 67108863;
        }
        Ve.words[ht] = vt, ge = wt, wt = Ke;
      }
      return ge !== 0 ? Ve.words[ht] = ge : Ve.length--, Ve.strip();
    }
    function Lt(Bt, Xe, Ve) {
      var ge = new Pt();
      return ge.mulp(Bt, Xe, Ve);
    }
    oe.prototype.mulTo = function(Xe, Ve) {
      var ge, Ke = this.length + Xe.length;
      return this.length === 10 && Xe.length === 10 ? ge = kt(this, Xe, Ve) : Ke < 63 ? ge = _t(this, Xe, Ve) : Ke < 1024 ? ge = Ct(this, Xe, Ve) : ge = Lt(this, Xe, Ve), ge;
    };
    function Pt(Bt, Xe) {
      this.x = Bt, this.y = Xe;
    }
    Pt.prototype.makeRBT = function(Xe) {
      for (var Ve = new Array(Xe), ge = oe.prototype._countBits(Xe) - 1, Ke = 0; Ke < Xe; Ke++)
        Ve[Ke] = this.revBin(Ke, ge, Xe);
      return Ve;
    }, Pt.prototype.revBin = function(Xe, Ve, ge) {
      if (Xe === 0 || Xe === ge - 1) return Xe;
      for (var Ke = 0, ht = 0; ht < Ve; ht++)
        Ke |= (Xe & 1) << Ve - ht - 1, Xe >>= 1;
      return Ke;
    }, Pt.prototype.permute = function(Xe, Ve, ge, Ke, ht, wt) {
      for (var vt = 0; vt < wt; vt++)
        Ke[vt] = Ve[Xe[vt]], ht[vt] = ge[Xe[vt]];
    }, Pt.prototype.transform = function(Xe, Ve, ge, Ke, ht, wt) {
      this.permute(wt, Xe, Ve, ge, Ke, ht);
      for (var vt = 1; vt < ht; vt <<= 1)
        for (var $t = vt << 1, Qe = Math.cos(2 * Math.PI / $t), xt = Math.sin(2 * Math.PI / $t), bt = 0; bt < ht; bt += $t)
          for (var Dt = Qe, er = xt, fr = 0; fr < vt; fr++) {
            var Qt = ge[bt + fr], Ht = Ke[bt + fr], qt = ge[bt + fr + vt], nr = Ke[bt + fr + vt], ur = Dt * qt - er * nr;
            nr = Dt * nr + er * qt, qt = ur, ge[bt + fr] = Qt + qt, Ke[bt + fr] = Ht + nr, ge[bt + fr + vt] = Qt - qt, Ke[bt + fr + vt] = Ht - nr, fr !== $t && (ur = Qe * Dt - xt * er, er = Qe * er + xt * Dt, Dt = ur);
          }
    }, Pt.prototype.guessLen13b = function(Xe, Ve) {
      var ge = Math.max(Ve, Xe) | 1, Ke = ge & 1, ht = 0;
      for (ge = ge / 2 | 0; ge; ge = ge >>> 1)
        ht++;
      return 1 << ht + 1 + Ke;
    }, Pt.prototype.conjugate = function(Xe, Ve, ge) {
      if (!(ge <= 1))
        for (var Ke = 0; Ke < ge / 2; Ke++) {
          var ht = Xe[Ke];
          Xe[Ke] = Xe[ge - Ke - 1], Xe[ge - Ke - 1] = ht, ht = Ve[Ke], Ve[Ke] = -Ve[ge - Ke - 1], Ve[ge - Ke - 1] = -ht;
        }
    }, Pt.prototype.normalize13b = function(Xe, Ve) {
      for (var ge = 0, Ke = 0; Ke < Ve / 2; Ke++) {
        var ht = Math.round(Xe[2 * Ke + 1] / Ve) * 8192 + Math.round(Xe[2 * Ke] / Ve) + ge;
        Xe[Ke] = ht & 67108863, ht < 67108864 ? ge = 0 : ge = ht / 67108864 | 0;
      }
      return Xe;
    }, Pt.prototype.convert13b = function(Xe, Ve, ge, Ke) {
      for (var ht = 0, wt = 0; wt < Ve; wt++)
        ht = ht + (Xe[wt] | 0), ge[2 * wt] = ht & 8191, ht = ht >>> 13, ge[2 * wt + 1] = ht & 8191, ht = ht >>> 13;
      for (wt = 2 * Ve; wt < Ke; ++wt)
        ge[wt] = 0;
      ne(ht === 0), ne((ht & -8192) === 0);
    }, Pt.prototype.stub = function(Xe) {
      for (var Ve = new Array(Xe), ge = 0; ge < Xe; ge++)
        Ve[ge] = 0;
      return Ve;
    }, Pt.prototype.mulp = function(Xe, Ve, ge) {
      var Ke = 2 * this.guessLen13b(Xe.length, Ve.length), ht = this.makeRBT(Ke), wt = this.stub(Ke), vt = new Array(Ke), $t = new Array(Ke), Qe = new Array(Ke), xt = new Array(Ke), bt = new Array(Ke), Dt = new Array(Ke), er = ge.words;
      er.length = Ke, this.convert13b(Xe.words, Xe.length, vt, Ke), this.convert13b(Ve.words, Ve.length, xt, Ke), this.transform(vt, wt, $t, Qe, Ke, ht), this.transform(xt, wt, bt, Dt, Ke, ht);
      for (var fr = 0; fr < Ke; fr++) {
        var Qt = $t[fr] * bt[fr] - Qe[fr] * Dt[fr];
        Qe[fr] = $t[fr] * Dt[fr] + Qe[fr] * bt[fr], $t[fr] = Qt;
      }
      return this.conjugate($t, Qe, Ke), this.transform($t, Qe, er, wt, Ke, ht), this.conjugate(er, wt, Ke), this.normalize13b(er, Ke), ge.negative = Xe.negative ^ Ve.negative, ge.length = Xe.length + Ve.length, ge.strip();
    }, oe.prototype.mul = function(Xe) {
      var Ve = new oe(null);
      return Ve.words = new Array(this.length + Xe.length), this.mulTo(Xe, Ve);
    }, oe.prototype.mulf = function(Xe) {
      var Ve = new oe(null);
      return Ve.words = new Array(this.length + Xe.length), Lt(this, Xe, Ve);
    }, oe.prototype.imul = function(Xe) {
      return this.clone().mulTo(Xe, this);
    }, oe.prototype.imuln = function(Xe) {
      ne(typeof Xe == "number"), ne(Xe < 67108864);
      for (var Ve = 0, ge = 0; ge < this.length; ge++) {
        var Ke = (this.words[ge] | 0) * Xe, ht = (Ke & 67108863) + (Ve & 67108863);
        Ve >>= 26, Ve += Ke / 67108864 | 0, Ve += ht >>> 26, this.words[ge] = ht & 67108863;
      }
      return Ve !== 0 && (this.words[ge] = Ve, this.length++), this;
    }, oe.prototype.muln = function(Xe) {
      return this.clone().imuln(Xe);
    }, oe.prototype.sqr = function() {
      return this.mul(this);
    }, oe.prototype.isqr = function() {
      return this.imul(this.clone());
    }, oe.prototype.pow = function(Xe) {
      var Ve = Ce(Xe);
      if (Ve.length === 0) return new oe(1);
      for (var ge = this, Ke = 0; Ke < Ve.length && Ve[Ke] === 0; Ke++, ge = ge.sqr())
        ;
      if (++Ke < Ve.length)
        for (var ht = ge.sqr(); Ke < Ve.length; Ke++, ht = ht.sqr())
          Ve[Ke] !== 0 && (ge = ge.mul(ht));
      return ge;
    }, oe.prototype.iushln = function(Xe) {
      ne(typeof Xe == "number" && Xe >= 0);
      var Ve = Xe % 26, ge = (Xe - Ve) / 26, Ke = 67108863 >>> 26 - Ve << 26 - Ve, ht;
      if (Ve !== 0) {
        var wt = 0;
        for (ht = 0; ht < this.length; ht++) {
          var vt = this.words[ht] & Ke, $t = (this.words[ht] | 0) - vt << Ve;
          this.words[ht] = $t | wt, wt = vt >>> 26 - Ve;
        }
        wt && (this.words[ht] = wt, this.length++);
      }
      if (ge !== 0) {
        for (ht = this.length - 1; ht >= 0; ht--)
          this.words[ht + ge] = this.words[ht];
        for (ht = 0; ht < ge; ht++)
          this.words[ht] = 0;
        this.length += ge;
      }
      return this.strip();
    }, oe.prototype.ishln = function(Xe) {
      return ne(this.negative === 0), this.iushln(Xe);
    }, oe.prototype.iushrn = function(Xe, Ve, ge) {
      ne(typeof Xe == "number" && Xe >= 0);
      var Ke;
      Ve ? Ke = (Ve - Ve % 26) / 26 : Ke = 0;
      var ht = Xe % 26, wt = Math.min((Xe - ht) / 26, this.length), vt = 67108863 ^ 67108863 >>> ht << ht, $t = ge;
      if (Ke -= wt, Ke = Math.max(0, Ke), $t) {
        for (var Qe = 0; Qe < wt; Qe++)
          $t.words[Qe] = this.words[Qe];
        $t.length = wt;
      }
      if (wt !== 0) if (this.length > wt)
        for (this.length -= wt, Qe = 0; Qe < this.length; Qe++)
          this.words[Qe] = this.words[Qe + wt];
      else
        this.words[0] = 0, this.length = 1;
      var xt = 0;
      for (Qe = this.length - 1; Qe >= 0 && (xt !== 0 || Qe >= Ke); Qe--) {
        var bt = this.words[Qe] | 0;
        this.words[Qe] = xt << 26 - ht | bt >>> ht, xt = bt & vt;
      }
      return $t && xt !== 0 && ($t.words[$t.length++] = xt), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, oe.prototype.ishrn = function(Xe, Ve, ge) {
      return ne(this.negative === 0), this.iushrn(Xe, Ve, ge);
    }, oe.prototype.shln = function(Xe) {
      return this.clone().ishln(Xe);
    }, oe.prototype.ushln = function(Xe) {
      return this.clone().iushln(Xe);
    }, oe.prototype.shrn = function(Xe) {
      return this.clone().ishrn(Xe);
    }, oe.prototype.ushrn = function(Xe) {
      return this.clone().iushrn(Xe);
    }, oe.prototype.testn = function(Xe) {
      ne(typeof Xe == "number" && Xe >= 0);
      var Ve = Xe % 26, ge = (Xe - Ve) / 26, Ke = 1 << Ve;
      if (this.length <= ge) return !1;
      var ht = this.words[ge];
      return !!(ht & Ke);
    }, oe.prototype.imaskn = function(Xe) {
      ne(typeof Xe == "number" && Xe >= 0);
      var Ve = Xe % 26, ge = (Xe - Ve) / 26;
      if (ne(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ge)
        return this;
      if (Ve !== 0 && ge++, this.length = Math.min(ge, this.length), Ve !== 0) {
        var Ke = 67108863 ^ 67108863 >>> Ve << Ve;
        this.words[this.length - 1] &= Ke;
      }
      return this.strip();
    }, oe.prototype.maskn = function(Xe) {
      return this.clone().imaskn(Xe);
    }, oe.prototype.iaddn = function(Xe) {
      return ne(typeof Xe == "number"), ne(Xe < 67108864), Xe < 0 ? this.isubn(-Xe) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < Xe ? (this.words[0] = Xe - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(Xe), this.negative = 1, this) : this._iaddn(Xe);
    }, oe.prototype._iaddn = function(Xe) {
      this.words[0] += Xe;
      for (var Ve = 0; Ve < this.length && this.words[Ve] >= 67108864; Ve++)
        this.words[Ve] -= 67108864, Ve === this.length - 1 ? this.words[Ve + 1] = 1 : this.words[Ve + 1]++;
      return this.length = Math.max(this.length, Ve + 1), this;
    }, oe.prototype.isubn = function(Xe) {
      if (ne(typeof Xe == "number"), ne(Xe < 67108864), Xe < 0) return this.iaddn(-Xe);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(Xe), this.negative = 1, this;
      if (this.words[0] -= Xe, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var Ve = 0; Ve < this.length && this.words[Ve] < 0; Ve++)
          this.words[Ve] += 67108864, this.words[Ve + 1] -= 1;
      return this.strip();
    }, oe.prototype.addn = function(Xe) {
      return this.clone().iaddn(Xe);
    }, oe.prototype.subn = function(Xe) {
      return this.clone().isubn(Xe);
    }, oe.prototype.iabs = function() {
      return this.negative = 0, this;
    }, oe.prototype.abs = function() {
      return this.clone().iabs();
    }, oe.prototype._ishlnsubmul = function(Xe, Ve, ge) {
      var Ke = Xe.length + ge, ht;
      this._expand(Ke);
      var wt, vt = 0;
      for (ht = 0; ht < Xe.length; ht++) {
        wt = (this.words[ht + ge] | 0) + vt;
        var $t = (Xe.words[ht] | 0) * Ve;
        wt -= $t & 67108863, vt = (wt >> 26) - ($t / 67108864 | 0), this.words[ht + ge] = wt & 67108863;
      }
      for (; ht < this.length - ge; ht++)
        wt = (this.words[ht + ge] | 0) + vt, vt = wt >> 26, this.words[ht + ge] = wt & 67108863;
      if (vt === 0) return this.strip();
      for (ne(vt === -1), vt = 0, ht = 0; ht < this.length; ht++)
        wt = -(this.words[ht] | 0) + vt, vt = wt >> 26, this.words[ht] = wt & 67108863;
      return this.negative = 1, this.strip();
    }, oe.prototype._wordDiv = function(Xe, Ve) {
      var ge = this.length - Xe.length, Ke = this.clone(), ht = Xe, wt = ht.words[ht.length - 1] | 0, vt = this._countBits(wt);
      ge = 26 - vt, ge !== 0 && (ht = ht.ushln(ge), Ke.iushln(ge), wt = ht.words[ht.length - 1] | 0);
      var $t = Ke.length - ht.length, Qe;
      if (Ve !== "mod") {
        Qe = new oe(null), Qe.length = $t + 1, Qe.words = new Array(Qe.length);
        for (var xt = 0; xt < Qe.length; xt++)
          Qe.words[xt] = 0;
      }
      var bt = Ke.clone()._ishlnsubmul(ht, 1, $t);
      bt.negative === 0 && (Ke = bt, Qe && (Qe.words[$t] = 1));
      for (var Dt = $t - 1; Dt >= 0; Dt--) {
        var er = (Ke.words[ht.length + Dt] | 0) * 67108864 + (Ke.words[ht.length + Dt - 1] | 0);
        for (er = Math.min(er / wt | 0, 67108863), Ke._ishlnsubmul(ht, er, Dt); Ke.negative !== 0; )
          er--, Ke.negative = 0, Ke._ishlnsubmul(ht, 1, Dt), Ke.isZero() || (Ke.negative ^= 1);
        Qe && (Qe.words[Dt] = er);
      }
      return Qe && Qe.strip(), Ke.strip(), Ve !== "div" && ge !== 0 && Ke.iushrn(ge), {
        div: Qe || null,
        mod: Ke
      };
    }, oe.prototype.divmod = function(Xe, Ve, ge) {
      if (ne(!Xe.isZero()), this.isZero())
        return {
          div: new oe(0),
          mod: new oe(0)
        };
      var Ke, ht, wt;
      return this.negative !== 0 && Xe.negative === 0 ? (wt = this.neg().divmod(Xe, Ve), Ve !== "mod" && (Ke = wt.div.neg()), Ve !== "div" && (ht = wt.mod.neg(), ge && ht.negative !== 0 && ht.iadd(Xe)), {
        div: Ke,
        mod: ht
      }) : this.negative === 0 && Xe.negative !== 0 ? (wt = this.divmod(Xe.neg(), Ve), Ve !== "mod" && (Ke = wt.div.neg()), {
        div: Ke,
        mod: wt.mod
      }) : this.negative & Xe.negative ? (wt = this.neg().divmod(Xe.neg(), Ve), Ve !== "div" && (ht = wt.mod.neg(), ge && ht.negative !== 0 && ht.isub(Xe)), {
        div: wt.div,
        mod: ht
      }) : Xe.length > this.length || this.cmp(Xe) < 0 ? {
        div: new oe(0),
        mod: this
      } : Xe.length === 1 ? Ve === "div" ? {
        div: this.divn(Xe.words[0]),
        mod: null
      } : Ve === "mod" ? {
        div: null,
        mod: new oe(this.modn(Xe.words[0]))
      } : {
        div: this.divn(Xe.words[0]),
        mod: new oe(this.modn(Xe.words[0]))
      } : this._wordDiv(Xe, Ve);
    }, oe.prototype.div = function(Xe) {
      return this.divmod(Xe, "div", !1).div;
    }, oe.prototype.mod = function(Xe) {
      return this.divmod(Xe, "mod", !1).mod;
    }, oe.prototype.umod = function(Xe) {
      return this.divmod(Xe, "mod", !0).mod;
    }, oe.prototype.divRound = function(Xe) {
      var Ve = this.divmod(Xe);
      if (Ve.mod.isZero()) return Ve.div;
      var ge = Ve.div.negative !== 0 ? Ve.mod.isub(Xe) : Ve.mod, Ke = Xe.ushrn(1), ht = Xe.andln(1), wt = ge.cmp(Ke);
      return wt < 0 || ht === 1 && wt === 0 ? Ve.div : Ve.div.negative !== 0 ? Ve.div.isubn(1) : Ve.div.iaddn(1);
    }, oe.prototype.modn = function(Xe) {
      ne(Xe <= 67108863);
      for (var Ve = (1 << 26) % Xe, ge = 0, Ke = this.length - 1; Ke >= 0; Ke--)
        ge = (Ve * ge + (this.words[Ke] | 0)) % Xe;
      return ge;
    }, oe.prototype.idivn = function(Xe) {
      ne(Xe <= 67108863);
      for (var Ve = 0, ge = this.length - 1; ge >= 0; ge--) {
        var Ke = (this.words[ge] | 0) + Ve * 67108864;
        this.words[ge] = Ke / Xe | 0, Ve = Ke % Xe;
      }
      return this.strip();
    }, oe.prototype.divn = function(Xe) {
      return this.clone().idivn(Xe);
    }, oe.prototype.egcd = function(Xe) {
      ne(Xe.negative === 0), ne(!Xe.isZero());
      var Ve = this, ge = Xe.clone();
      Ve.negative !== 0 ? Ve = Ve.umod(Xe) : Ve = Ve.clone();
      for (var Ke = new oe(1), ht = new oe(0), wt = new oe(0), vt = new oe(1), $t = 0; Ve.isEven() && ge.isEven(); )
        Ve.iushrn(1), ge.iushrn(1), ++$t;
      for (var Qe = ge.clone(), xt = Ve.clone(); !Ve.isZero(); ) {
        for (var bt = 0, Dt = 1; !(Ve.words[0] & Dt) && bt < 26; ++bt, Dt <<= 1) ;
        if (bt > 0)
          for (Ve.iushrn(bt); bt-- > 0; )
            (Ke.isOdd() || ht.isOdd()) && (Ke.iadd(Qe), ht.isub(xt)), Ke.iushrn(1), ht.iushrn(1);
        for (var er = 0, fr = 1; !(ge.words[0] & fr) && er < 26; ++er, fr <<= 1) ;
        if (er > 0)
          for (ge.iushrn(er); er-- > 0; )
            (wt.isOdd() || vt.isOdd()) && (wt.iadd(Qe), vt.isub(xt)), wt.iushrn(1), vt.iushrn(1);
        Ve.cmp(ge) >= 0 ? (Ve.isub(ge), Ke.isub(wt), ht.isub(vt)) : (ge.isub(Ve), wt.isub(Ke), vt.isub(ht));
      }
      return {
        a: wt,
        b: vt,
        gcd: ge.iushln($t)
      };
    }, oe.prototype._invmp = function(Xe) {
      ne(Xe.negative === 0), ne(!Xe.isZero());
      var Ve = this, ge = Xe.clone();
      Ve.negative !== 0 ? Ve = Ve.umod(Xe) : Ve = Ve.clone();
      for (var Ke = new oe(1), ht = new oe(0), wt = ge.clone(); Ve.cmpn(1) > 0 && ge.cmpn(1) > 0; ) {
        for (var vt = 0, $t = 1; !(Ve.words[0] & $t) && vt < 26; ++vt, $t <<= 1) ;
        if (vt > 0)
          for (Ve.iushrn(vt); vt-- > 0; )
            Ke.isOdd() && Ke.iadd(wt), Ke.iushrn(1);
        for (var Qe = 0, xt = 1; !(ge.words[0] & xt) && Qe < 26; ++Qe, xt <<= 1) ;
        if (Qe > 0)
          for (ge.iushrn(Qe); Qe-- > 0; )
            ht.isOdd() && ht.iadd(wt), ht.iushrn(1);
        Ve.cmp(ge) >= 0 ? (Ve.isub(ge), Ke.isub(ht)) : (ge.isub(Ve), ht.isub(Ke));
      }
      var bt;
      return Ve.cmpn(1) === 0 ? bt = Ke : bt = ht, bt.cmpn(0) < 0 && bt.iadd(Xe), bt;
    }, oe.prototype.gcd = function(Xe) {
      if (this.isZero()) return Xe.abs();
      if (Xe.isZero()) return this.abs();
      var Ve = this.clone(), ge = Xe.clone();
      Ve.negative = 0, ge.negative = 0;
      for (var Ke = 0; Ve.isEven() && ge.isEven(); Ke++)
        Ve.iushrn(1), ge.iushrn(1);
      do {
        for (; Ve.isEven(); )
          Ve.iushrn(1);
        for (; ge.isEven(); )
          ge.iushrn(1);
        var ht = Ve.cmp(ge);
        if (ht < 0) {
          var wt = Ve;
          Ve = ge, ge = wt;
        } else if (ht === 0 || ge.cmpn(1) === 0)
          break;
        Ve.isub(ge);
      } while (!0);
      return ge.iushln(Ke);
    }, oe.prototype.invm = function(Xe) {
      return this.egcd(Xe).a.umod(Xe);
    }, oe.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, oe.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, oe.prototype.andln = function(Xe) {
      return this.words[0] & Xe;
    }, oe.prototype.bincn = function(Xe) {
      ne(typeof Xe == "number");
      var Ve = Xe % 26, ge = (Xe - Ve) / 26, Ke = 1 << Ve;
      if (this.length <= ge)
        return this._expand(ge + 1), this.words[ge] |= Ke, this;
      for (var ht = Ke, wt = ge; ht !== 0 && wt < this.length; wt++) {
        var vt = this.words[wt] | 0;
        vt += ht, ht = vt >>> 26, vt &= 67108863, this.words[wt] = vt;
      }
      return ht !== 0 && (this.words[wt] = ht, this.length++), this;
    }, oe.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, oe.prototype.cmpn = function(Xe) {
      var Ve = Xe < 0;
      if (this.negative !== 0 && !Ve) return -1;
      if (this.negative === 0 && Ve) return 1;
      this.strip();
      var ge;
      if (this.length > 1)
        ge = 1;
      else {
        Ve && (Xe = -Xe), ne(Xe <= 67108863, "Number is too big");
        var Ke = this.words[0] | 0;
        ge = Ke === Xe ? 0 : Ke < Xe ? -1 : 1;
      }
      return this.negative !== 0 ? -ge | 0 : ge;
    }, oe.prototype.cmp = function(Xe) {
      if (this.negative !== 0 && Xe.negative === 0) return -1;
      if (this.negative === 0 && Xe.negative !== 0) return 1;
      var Ve = this.ucmp(Xe);
      return this.negative !== 0 ? -Ve | 0 : Ve;
    }, oe.prototype.ucmp = function(Xe) {
      if (this.length > Xe.length) return 1;
      if (this.length < Xe.length) return -1;
      for (var Ve = 0, ge = this.length - 1; ge >= 0; ge--) {
        var Ke = this.words[ge] | 0, ht = Xe.words[ge] | 0;
        if (Ke !== ht) {
          Ke < ht ? Ve = -1 : Ke > ht && (Ve = 1);
          break;
        }
      }
      return Ve;
    }, oe.prototype.gtn = function(Xe) {
      return this.cmpn(Xe) === 1;
    }, oe.prototype.gt = function(Xe) {
      return this.cmp(Xe) === 1;
    }, oe.prototype.gten = function(Xe) {
      return this.cmpn(Xe) >= 0;
    }, oe.prototype.gte = function(Xe) {
      return this.cmp(Xe) >= 0;
    }, oe.prototype.ltn = function(Xe) {
      return this.cmpn(Xe) === -1;
    }, oe.prototype.lt = function(Xe) {
      return this.cmp(Xe) === -1;
    }, oe.prototype.lten = function(Xe) {
      return this.cmpn(Xe) <= 0;
    }, oe.prototype.lte = function(Xe) {
      return this.cmp(Xe) <= 0;
    }, oe.prototype.eqn = function(Xe) {
      return this.cmpn(Xe) === 0;
    }, oe.prototype.eq = function(Xe) {
      return this.cmp(Xe) === 0;
    }, oe.red = function(Xe) {
      return new Rt(Xe);
    }, oe.prototype.toRed = function(Xe) {
      return ne(!this.red, "Already a number in reduction context"), ne(this.negative === 0, "red works only with positives"), Xe.convertTo(this)._forceRed(Xe);
    }, oe.prototype.fromRed = function() {
      return ne(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, oe.prototype._forceRed = function(Xe) {
      return this.red = Xe, this;
    }, oe.prototype.forceRed = function(Xe) {
      return ne(!this.red, "Already a number in reduction context"), this._forceRed(Xe);
    }, oe.prototype.redAdd = function(Xe) {
      return ne(this.red, "redAdd works only with red numbers"), this.red.add(this, Xe);
    }, oe.prototype.redIAdd = function(Xe) {
      return ne(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Xe);
    }, oe.prototype.redSub = function(Xe) {
      return ne(this.red, "redSub works only with red numbers"), this.red.sub(this, Xe);
    }, oe.prototype.redISub = function(Xe) {
      return ne(this.red, "redISub works only with red numbers"), this.red.isub(this, Xe);
    }, oe.prototype.redShl = function(Xe) {
      return ne(this.red, "redShl works only with red numbers"), this.red.shl(this, Xe);
    }, oe.prototype.redMul = function(Xe) {
      return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, Xe), this.red.mul(this, Xe);
    }, oe.prototype.redIMul = function(Xe) {
      return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, Xe), this.red.imul(this, Xe);
    }, oe.prototype.redSqr = function() {
      return ne(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, oe.prototype.redISqr = function() {
      return ne(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, oe.prototype.redSqrt = function() {
      return ne(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, oe.prototype.redInvm = function() {
      return ne(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, oe.prototype.redNeg = function() {
      return ne(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, oe.prototype.redPow = function(Xe) {
      return ne(this.red && !Xe.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Xe);
    };
    var Ft = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ut(Bt, Xe) {
      this.name = Bt, this.p = new oe(Xe, 16), this.n = this.p.bitLength(), this.k = new oe(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Ut.prototype._tmp = function() {
      var Xe = new oe(null);
      return Xe.words = new Array(Math.ceil(this.n / 13)), Xe;
    }, Ut.prototype.ireduce = function(Xe) {
      var Ve = Xe, ge;
      do
        this.split(Ve, this.tmp), Ve = this.imulK(Ve), Ve = Ve.iadd(this.tmp), ge = Ve.bitLength();
      while (ge > this.n);
      var Ke = ge < this.n ? -1 : Ve.ucmp(this.p);
      return Ke === 0 ? (Ve.words[0] = 0, Ve.length = 1) : Ke > 0 ? Ve.isub(this.p) : Ve.strip !== void 0 ? Ve.strip() : Ve._strip(), Ve;
    }, Ut.prototype.split = function(Xe, Ve) {
      Xe.iushrn(this.n, 0, Ve);
    }, Ut.prototype.imulK = function(Xe) {
      return Xe.imul(this.k);
    };
    function Jt() {
      Ut.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    ie(Jt, Ut), Jt.prototype.split = function(Xe, Ve) {
      for (var ge = 4194303, Ke = Math.min(Xe.length, 9), ht = 0; ht < Ke; ht++)
        Ve.words[ht] = Xe.words[ht];
      if (Ve.length = Ke, Xe.length <= 9) {
        Xe.words[0] = 0, Xe.length = 1;
        return;
      }
      var wt = Xe.words[9];
      for (Ve.words[Ve.length++] = wt & ge, ht = 10; ht < Xe.length; ht++) {
        var vt = Xe.words[ht] | 0;
        Xe.words[ht - 10] = (vt & ge) << 4 | wt >>> 22, wt = vt;
      }
      wt >>>= 22, Xe.words[ht - 10] = wt, wt === 0 && Xe.length > 10 ? Xe.length -= 10 : Xe.length -= 9;
    }, Jt.prototype.imulK = function(Xe) {
      Xe.words[Xe.length] = 0, Xe.words[Xe.length + 1] = 0, Xe.length += 2;
      for (var Ve = 0, ge = 0; ge < Xe.length; ge++) {
        var Ke = Xe.words[ge] | 0;
        Ve += Ke * 977, Xe.words[ge] = Ve & 67108863, Ve = Ke * 64 + (Ve / 67108864 | 0);
      }
      return Xe.words[Xe.length - 1] === 0 && (Xe.length--, Xe.words[Xe.length - 1] === 0 && Xe.length--), Xe;
    };
    function Vt() {
      Ut.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    ie(Vt, Ut);
    function ir() {
      Ut.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    ie(ir, Ut);
    function jt() {
      Ut.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    ie(jt, Ut), jt.prototype.imulK = function(Xe) {
      for (var Ve = 0, ge = 0; ge < Xe.length; ge++) {
        var Ke = (Xe.words[ge] | 0) * 19 + Ve, ht = Ke & 67108863;
        Ke >>>= 26, Xe.words[ge] = ht, Ve = Ke;
      }
      return Ve !== 0 && (Xe.words[Xe.length++] = Ve), Xe;
    }, oe._prime = function(Xe) {
      if (Ft[Xe]) return Ft[Xe];
      var Ve;
      if (Xe === "k256")
        Ve = new Jt();
      else if (Xe === "p224")
        Ve = new Vt();
      else if (Xe === "p192")
        Ve = new ir();
      else if (Xe === "p25519")
        Ve = new jt();
      else
        throw new Error("Unknown prime " + Xe);
      return Ft[Xe] = Ve, Ve;
    };
    function Rt(Bt) {
      if (typeof Bt == "string") {
        var Xe = oe._prime(Bt);
        this.m = Xe.p, this.prime = Xe;
      } else
        ne(Bt.gtn(1), "modulus must be greater than 1"), this.m = Bt, this.prime = null;
    }
    Rt.prototype._verify1 = function(Xe) {
      ne(Xe.negative === 0, "red works only with positives"), ne(Xe.red, "red works only with red numbers");
    }, Rt.prototype._verify2 = function(Xe, Ve) {
      ne((Xe.negative | Ve.negative) === 0, "red works only with positives"), ne(
        Xe.red && Xe.red === Ve.red,
        "red works only with red numbers"
      );
    }, Rt.prototype.imod = function(Xe) {
      return this.prime ? this.prime.ireduce(Xe)._forceRed(this) : Xe.umod(this.m)._forceRed(this);
    }, Rt.prototype.neg = function(Xe) {
      return Xe.isZero() ? Xe.clone() : this.m.sub(Xe)._forceRed(this);
    }, Rt.prototype.add = function(Xe, Ve) {
      this._verify2(Xe, Ve);
      var ge = Xe.add(Ve);
      return ge.cmp(this.m) >= 0 && ge.isub(this.m), ge._forceRed(this);
    }, Rt.prototype.iadd = function(Xe, Ve) {
      this._verify2(Xe, Ve);
      var ge = Xe.iadd(Ve);
      return ge.cmp(this.m) >= 0 && ge.isub(this.m), ge;
    }, Rt.prototype.sub = function(Xe, Ve) {
      this._verify2(Xe, Ve);
      var ge = Xe.sub(Ve);
      return ge.cmpn(0) < 0 && ge.iadd(this.m), ge._forceRed(this);
    }, Rt.prototype.isub = function(Xe, Ve) {
      this._verify2(Xe, Ve);
      var ge = Xe.isub(Ve);
      return ge.cmpn(0) < 0 && ge.iadd(this.m), ge;
    }, Rt.prototype.shl = function(Xe, Ve) {
      return this._verify1(Xe), this.imod(Xe.ushln(Ve));
    }, Rt.prototype.imul = function(Xe, Ve) {
      return this._verify2(Xe, Ve), this.imod(Xe.imul(Ve));
    }, Rt.prototype.mul = function(Xe, Ve) {
      return this._verify2(Xe, Ve), this.imod(Xe.mul(Ve));
    }, Rt.prototype.isqr = function(Xe) {
      return this.imul(Xe, Xe.clone());
    }, Rt.prototype.sqr = function(Xe) {
      return this.mul(Xe, Xe);
    }, Rt.prototype.sqrt = function(Xe) {
      if (Xe.isZero()) return Xe.clone();
      var Ve = this.m.andln(3);
      if (ne(Ve % 2 === 1), Ve === 3) {
        var ge = this.m.add(new oe(1)).iushrn(2);
        return this.pow(Xe, ge);
      }
      for (var Ke = this.m.subn(1), ht = 0; !Ke.isZero() && Ke.andln(1) === 0; )
        ht++, Ke.iushrn(1);
      ne(!Ke.isZero());
      var wt = new oe(1).toRed(this), vt = wt.redNeg(), $t = this.m.subn(1).iushrn(1), Qe = this.m.bitLength();
      for (Qe = new oe(2 * Qe * Qe).toRed(this); this.pow(Qe, $t).cmp(vt) !== 0; )
        Qe.redIAdd(vt);
      for (var xt = this.pow(Qe, Ke), bt = this.pow(Xe, Ke.addn(1).iushrn(1)), Dt = this.pow(Xe, Ke), er = ht; Dt.cmp(wt) !== 0; ) {
        for (var fr = Dt, Qt = 0; fr.cmp(wt) !== 0; Qt++)
          fr = fr.redSqr();
        ne(Qt < er);
        var Ht = this.pow(xt, new oe(1).iushln(er - Qt - 1));
        bt = bt.redMul(Ht), xt = Ht.redSqr(), Dt = Dt.redMul(xt), er = Qt;
      }
      return bt;
    }, Rt.prototype.invm = function(Xe) {
      var Ve = Xe._invmp(this.m);
      return Ve.negative !== 0 ? (Ve.negative = 0, this.imod(Ve).redNeg()) : this.imod(Ve);
    }, Rt.prototype.pow = function(Xe, Ve) {
      if (Ve.isZero()) return new oe(1).toRed(this);
      if (Ve.cmpn(1) === 0) return Xe.clone();
      var ge = 4, Ke = new Array(1 << ge);
      Ke[0] = new oe(1).toRed(this), Ke[1] = Xe;
      for (var ht = 2; ht < Ke.length; ht++)
        Ke[ht] = this.mul(Ke[ht - 1], Xe);
      var wt = Ke[0], vt = 0, $t = 0, Qe = Ve.bitLength() % 26;
      for (Qe === 0 && (Qe = 26), ht = Ve.length - 1; ht >= 0; ht--) {
        for (var xt = Ve.words[ht], bt = Qe - 1; bt >= 0; bt--) {
          var Dt = xt >> bt & 1;
          if (wt !== Ke[0] && (wt = this.sqr(wt)), Dt === 0 && vt === 0) {
            $t = 0;
            continue;
          }
          vt <<= 1, vt |= Dt, $t++, !($t !== ge && (ht !== 0 || bt !== 0)) && (wt = this.mul(wt, Ke[vt]), $t = 0, vt = 0);
        }
        Qe = 26;
      }
      return wt;
    }, Rt.prototype.convertTo = function(Xe) {
      var Ve = Xe.umod(this.m);
      return Ve === Xe ? Ve.clone() : Ve;
    }, Rt.prototype.convertFrom = function(Xe) {
      var Ve = Xe.clone();
      return Ve.red = null, Ve;
    }, oe.mont = function(Xe) {
      return new Kt(Xe);
    };
    function Kt(Bt) {
      Rt.call(this, Bt), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new oe(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    ie(Kt, Rt), Kt.prototype.convertTo = function(Xe) {
      return this.imod(Xe.ushln(this.shift));
    }, Kt.prototype.convertFrom = function(Xe) {
      var Ve = this.imod(Xe.mul(this.rinv));
      return Ve.red = null, Ve;
    }, Kt.prototype.imul = function(Xe, Ve) {
      if (Xe.isZero() || Ve.isZero())
        return Xe.words[0] = 0, Xe.length = 1, Xe;
      var ge = Xe.imul(Ve), Ke = ge.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ht = ge.isub(Ke).iushrn(this.shift), wt = ht;
      return ht.cmp(this.m) >= 0 ? wt = ht.isub(this.m) : ht.cmpn(0) < 0 && (wt = ht.iadd(this.m)), wt._forceRed(this);
    }, Kt.prototype.mul = function(Xe, Ve) {
      if (Xe.isZero() || Ve.isZero()) return new oe(0)._forceRed(this);
      var ge = Xe.mul(Ve), Ke = ge.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ht = ge.isub(Ke).iushrn(this.shift), wt = ht;
      return ht.cmp(this.m) >= 0 ? wt = ht.isub(this.m) : ht.cmpn(0) < 0 && (wt = ht.iadd(this.m)), wt._forceRed(this);
    }, Kt.prototype.invm = function(Xe) {
      var Ve = this.imod(Xe._invmp(this.m).mul(this.r2));
      return Ve._forceRed(this);
    };
  })(B, commonjsGlobal);
})(bn$1);
var bnExports$1 = bn$1.exports, brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var B;
  brorand.exports = function(ie) {
    return B || (B = new z(null)), B.generate(ie);
  };
  function z(ne) {
    this.rand = ne;
  }
  if (brorand.exports.Rand = z, z.prototype.generate = function(ie) {
    return this._rand(ie);
  }, z.prototype._rand = function(ie) {
    if (this.rand.getBytes)
      return this.rand.getBytes(ie);
    for (var oe = new Uint8Array(ie), se = 0; se < oe.length; se++)
      oe[se] = this.rand.getByte();
    return oe;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? z.prototype._rand = function(ie) {
      var oe = new Uint8Array(ie);
      return self.crypto.getRandomValues(oe), oe;
    } : self.msCrypto && self.msCrypto.getRandomValues ? z.prototype._rand = function(ie) {
      var oe = new Uint8Array(ie);
      return self.msCrypto.getRandomValues(oe), oe;
    } : typeof window == "object" && (z.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var Y = requireCryptoBrowserify();
      if (typeof Y.randomBytes != "function")
        throw new Error("Not supported");
      z.prototype._rand = function(ie) {
        return Y.randomBytes(ie);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var B = bnExports$1, z = requireBrorand();
  function Y(ne) {
    this.rand = ne || new z.Rand();
  }
  return mr = Y, Y.create = function(ie) {
    return new Y(ie);
  }, Y.prototype._randbelow = function(ie) {
    var oe = ie.bitLength(), se = Math.ceil(oe / 8);
    do
      var ae = new B(this.rand.generate(se));
    while (ae.cmp(ie) >= 0);
    return ae;
  }, Y.prototype._randrange = function(ie, oe) {
    var se = oe.sub(ie);
    return ie.add(this._randbelow(se));
  }, Y.prototype.test = function(ie, oe, se) {
    var ae = ie.bitLength(), ve = B.mont(ie), Pe = new B(1).toRed(ve);
    oe || (oe = Math.max(1, ae / 48 | 0));
    for (var le = ie.subn(1), Ee = 0; !le.testn(Ee); Ee++)
      ;
    for (var Je = ie.shrn(Ee), Ce = le.toRed(ve), _t = !0; oe > 0; oe--) {
      var kt = this._randrange(new B(2), le);
      se && se(kt);
      var Ct = kt.toRed(ve).redPow(Je);
      if (!(Ct.cmp(Pe) === 0 || Ct.cmp(Ce) === 0)) {
        for (var Lt = 1; Lt < Ee; Lt++) {
          if (Ct = Ct.redSqr(), Ct.cmp(Pe) === 0)
            return !1;
          if (Ct.cmp(Ce) === 0)
            break;
        }
        if (Lt === Ee)
          return !1;
      }
    }
    return _t;
  }, Y.prototype.getDivisor = function(ie, oe) {
    var se = ie.bitLength(), ae = B.mont(ie), ve = new B(1).toRed(ae);
    oe || (oe = Math.max(1, se / 48 | 0));
    for (var Pe = ie.subn(1), le = 0; !Pe.testn(le); le++)
      ;
    for (var Ee = ie.shrn(le), Je = Pe.toRed(ae); oe > 0; oe--) {
      var Ce = this._randrange(new B(2), Pe), _t = ie.gcd(Ce);
      if (_t.cmpn(1) !== 0)
        return _t;
      var kt = Ce.toRed(ae).redPow(Ee);
      if (!(kt.cmp(ve) === 0 || kt.cmp(Je) === 0)) {
        for (var Ct = 1; Ct < le; Ct++) {
          if (kt = kt.redSqr(), kt.cmp(ve) === 0)
            return kt.fromRed().subn(1).gcd(ie);
          if (kt.cmp(Je) === 0)
            break;
        }
        if (Ct === le)
          return kt = kt.redSqr(), kt.fromRed().subn(1).gcd(ie);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var B = browserExports;
  generatePrime = Ct, Ct.simpleSieve = _t, Ct.fermatTest = kt;
  var z = bnExports$1, Y = new z(24), ne = requireMr(), ie = new ne(), oe = new z(1), se = new z(2), ae = new z(5);
  new z(16), new z(8);
  var ve = new z(10), Pe = new z(3);
  new z(7);
  var le = new z(11), Ee = new z(4);
  new z(12);
  var Je = null;
  function Ce() {
    if (Je !== null)
      return Je;
    var Lt = 1048576, Pt = [];
    Pt[0] = 2;
    for (var Ft = 1, Ut = 3; Ut < Lt; Ut += 2) {
      for (var Jt = Math.ceil(Math.sqrt(Ut)), Vt = 0; Vt < Ft && Pt[Vt] <= Jt && Ut % Pt[Vt] !== 0; Vt++)
        ;
      Ft !== Vt && Pt[Vt] <= Jt || (Pt[Ft++] = Ut);
    }
    return Je = Pt, Pt;
  }
  function _t(Lt) {
    for (var Pt = Ce(), Ft = 0; Ft < Pt.length; Ft++)
      if (Lt.modn(Pt[Ft]) === 0)
        return Lt.cmpn(Pt[Ft]) === 0;
    return !0;
  }
  function kt(Lt) {
    var Pt = z.mont(Lt);
    return se.toRed(Pt).redPow(Lt.subn(1)).fromRed().cmpn(1) === 0;
  }
  function Ct(Lt, Pt) {
    if (Lt < 16)
      return Pt === 2 || Pt === 5 ? new z([140, 123]) : new z([140, 39]);
    Pt = new z(Pt);
    for (var Ft, Ut; ; ) {
      for (Ft = new z(B(Math.ceil(Lt / 8))); Ft.bitLength() > Lt; )
        Ft.ishrn(1);
      if (Ft.isEven() && Ft.iadd(oe), Ft.testn(1) || Ft.iadd(se), Pt.cmp(se)) {
        if (!Pt.cmp(ae))
          for (; Ft.mod(ve).cmp(Pe); )
            Ft.iadd(Ee);
      } else for (; Ft.mod(Y).cmp(le); )
        Ft.iadd(Ee);
      if (Ut = Ft.shrn(1), _t(Ut) && _t(Ft) && kt(Ut) && kt(Ft) && ie.test(Ut) && ie.test(Ft))
        return Ft;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var B = bnExports$1, z = requireMr(), Y = new z(), ne = new B(24), ie = new B(11), oe = new B(10), se = new B(3), ae = new B(7), ve = requireGeneratePrime(), Pe = browserExports;
  dh = _t;
  function le(Ct, Lt) {
    return Lt = Lt || "utf8", Buffer$D.isBuffer(Ct) || (Ct = new Buffer$D(Ct, Lt)), this._pub = new B(Ct), this;
  }
  function Ee(Ct, Lt) {
    return Lt = Lt || "utf8", Buffer$D.isBuffer(Ct) || (Ct = new Buffer$D(Ct, Lt)), this._priv = new B(Ct), this;
  }
  var Je = {};
  function Ce(Ct, Lt) {
    var Pt = Lt.toString("hex"), Ft = [Pt, Ct.toString(16)].join("_");
    if (Ft in Je)
      return Je[Ft];
    var Ut = 0;
    if (Ct.isEven() || !ve.simpleSieve || !ve.fermatTest(Ct) || !Y.test(Ct))
      return Ut += 1, Pt === "02" || Pt === "05" ? Ut += 8 : Ut += 4, Je[Ft] = Ut, Ut;
    Y.test(Ct.shrn(1)) || (Ut += 2);
    var Jt;
    switch (Pt) {
      case "02":
        Ct.mod(ne).cmp(ie) && (Ut += 8);
        break;
      case "05":
        Jt = Ct.mod(oe), Jt.cmp(se) && Jt.cmp(ae) && (Ut += 8);
        break;
      default:
        Ut += 4;
    }
    return Je[Ft] = Ut, Ut;
  }
  function _t(Ct, Lt, Pt) {
    this.setGenerator(Lt), this.__prime = new B(Ct), this._prime = B.mont(this.__prime), this._primeLen = Ct.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, Pt ? (this.setPublicKey = le, this.setPrivateKey = Ee) : this._primeCode = 8;
  }
  Object.defineProperty(_t.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = Ce(this.__prime, this.__gen)), this._primeCode;
    }
  }), _t.prototype.generateKeys = function() {
    return this._priv || (this._priv = new B(Pe(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, _t.prototype.computeSecret = function(Ct) {
    Ct = new B(Ct), Ct = Ct.toRed(this._prime);
    var Lt = Ct.redPow(this._priv).fromRed(), Pt = new Buffer$D(Lt.toArray()), Ft = this.getPrime();
    if (Pt.length < Ft.length) {
      var Ut = new Buffer$D(Ft.length - Pt.length);
      Ut.fill(0), Pt = Buffer$D.concat([Ut, Pt]);
    }
    return Pt;
  }, _t.prototype.getPublicKey = function(Lt) {
    return kt(this._pub, Lt);
  }, _t.prototype.getPrivateKey = function(Lt) {
    return kt(this._priv, Lt);
  }, _t.prototype.getPrime = function(Ct) {
    return kt(this.__prime, Ct);
  }, _t.prototype.getGenerator = function(Ct) {
    return kt(this._gen, Ct);
  }, _t.prototype.setGenerator = function(Ct, Lt) {
    return Lt = Lt || "utf8", Buffer$D.isBuffer(Ct) || (Ct = new Buffer$D(Ct, Lt)), this.__gen = Ct, this._gen = new B(Ct), this;
  };
  function kt(Ct, Lt) {
    var Pt = new Buffer$D(Ct.toArray());
    return Lt ? Pt.toString(Lt) : Pt;
  }
  return dh;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$4;
  hasRequiredBrowser$2 = 1;
  var B = requireGeneratePrime(), z = require$$1$1, Y = requireDh();
  function ne(se) {
    var ae = new Buffer$D(z[se].prime, "hex"), ve = new Buffer$D(z[se].gen, "hex");
    return new Y(ae, ve);
  }
  var ie = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function oe(se, ae, ve, Pe) {
    return Buffer$D.isBuffer(ae) || ie[ae] === void 0 ? oe(se, "binary", ae, ve) : (ae = ae || "binary", Pe = Pe || "binary", ve = ve || new Buffer$D([2]), Buffer$D.isBuffer(ve) || (ve = new Buffer$D(ve, Pe)), typeof se == "number" ? new Y(B(se, ve), ve, !0) : (Buffer$D.isBuffer(se) || (se = new Buffer$D(se, ae)), new Y(se, ve, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = ne, browser$4.createDiffieHellman = browser$4.DiffieHellman = oe, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} };
typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick } : processNextickArgs.exports = process$1;
function nextTick(B, z, Y, ne) {
  if (typeof B != "function")
    throw new TypeError('"callback" argument must be a function');
  var ie = arguments.length, oe, se;
  switch (ie) {
    case 0:
    case 1:
      return process$1.nextTick(B);
    case 2:
      return process$1.nextTick(function() {
        B.call(null, z);
      });
    case 3:
      return process$1.nextTick(function() {
        B.call(null, z, Y);
      });
    case 4:
      return process$1.nextTick(function() {
        B.call(null, z, Y, ne);
      });
    default:
      for (oe = new Array(ie - 1), se = 0; se < oe.length; )
        oe[se++] = arguments[se];
      return process$1.nextTick(function() {
        B.apply(null, oe);
      });
  }
}
var processNextickArgsExports = processNextickArgs.exports, toString = {}.toString, isarray = Array.isArray || function(B) {
  return toString.call(B) == "[object Array]";
}, streamBrowser = eventsExports.EventEmitter, safeBuffer$1 = { exports: {} };
(function(B, z) {
  var Y = require$$0$1, ne = Y.Buffer;
  function ie(se, ae) {
    for (var ve in se)
      ae[ve] = se[ve];
  }
  ne.from && ne.alloc && ne.allocUnsafe && ne.allocUnsafeSlow ? B.exports = Y : (ie(Y, z), z.Buffer = oe);
  function oe(se, ae, ve) {
    return ne(se, ae, ve);
  }
  ie(ne, oe), oe.from = function(se, ae, ve) {
    if (typeof se == "number")
      throw new TypeError("Argument must not be a number");
    return ne(se, ae, ve);
  }, oe.alloc = function(se, ae, ve) {
    if (typeof se != "number")
      throw new TypeError("Argument must be a number");
    var Pe = ne(se);
    return ae !== void 0 ? typeof ve == "string" ? Pe.fill(ae, ve) : Pe.fill(ae) : Pe.fill(0), Pe;
  }, oe.allocUnsafe = function(se) {
    if (typeof se != "number")
      throw new TypeError("Argument must be a number");
    return ne(se);
  }, oe.allocUnsafeSlow = function(se) {
    if (typeof se != "number")
      throw new TypeError("Argument must be a number");
    return Y.SlowBuffer(se);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, util$2 = {};
function isArray(B) {
  return Array.isArray ? Array.isArray(B) : objectToString(B) === "[object Array]";
}
util$2.isArray = isArray;
function isBoolean(B) {
  return typeof B == "boolean";
}
util$2.isBoolean = isBoolean;
function isNull(B) {
  return B === null;
}
util$2.isNull = isNull;
function isNullOrUndefined(B) {
  return B == null;
}
util$2.isNullOrUndefined = isNullOrUndefined;
function isNumber(B) {
  return typeof B == "number";
}
util$2.isNumber = isNumber;
function isString(B) {
  return typeof B == "string";
}
util$2.isString = isString;
function isSymbol(B) {
  return typeof B == "symbol";
}
util$2.isSymbol = isSymbol;
function isUndefined(B) {
  return B === void 0;
}
util$2.isUndefined = isUndefined;
function isRegExp(B) {
  return objectToString(B) === "[object RegExp]";
}
util$2.isRegExp = isRegExp;
function isObject(B) {
  return typeof B == "object" && B !== null;
}
util$2.isObject = isObject;
function isDate(B) {
  return objectToString(B) === "[object Date]";
}
util$2.isDate = isDate;
function isError(B) {
  return objectToString(B) === "[object Error]" || B instanceof Error;
}
util$2.isError = isError;
function isFunction(B) {
  return typeof B == "function";
}
util$2.isFunction = isFunction;
function isPrimitive(B) {
  return B === null || typeof B == "boolean" || typeof B == "number" || typeof B == "string" || typeof B == "symbol" || // ES6 symbol
  typeof B > "u";
}
util$2.isPrimitive = isPrimitive;
util$2.isBuffer = require$$0$1.Buffer.isBuffer;
function objectToString(B) {
  return Object.prototype.toString.call(B);
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(B) {
    function z(oe, se) {
      if (!(oe instanceof se))
        throw new TypeError("Cannot call a class as a function");
    }
    var Y = safeBufferExports.Buffer, ne = util$3;
    function ie(oe, se, ae) {
      oe.copy(se, ae);
    }
    B.exports = function() {
      function oe() {
        z(this, oe), this.head = null, this.tail = null, this.length = 0;
      }
      return oe.prototype.push = function(ae) {
        var ve = { data: ae, next: null };
        this.length > 0 ? this.tail.next = ve : this.head = ve, this.tail = ve, ++this.length;
      }, oe.prototype.unshift = function(ae) {
        var ve = { data: ae, next: this.head };
        this.length === 0 && (this.tail = ve), this.head = ve, ++this.length;
      }, oe.prototype.shift = function() {
        if (this.length !== 0) {
          var ae = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ae;
        }
      }, oe.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, oe.prototype.join = function(ae) {
        if (this.length === 0) return "";
        for (var ve = this.head, Pe = "" + ve.data; ve = ve.next; )
          Pe += ae + ve.data;
        return Pe;
      }, oe.prototype.concat = function(ae) {
        if (this.length === 0) return Y.alloc(0);
        for (var ve = Y.allocUnsafe(ae >>> 0), Pe = this.head, le = 0; Pe; )
          ie(Pe.data, ve, le), le += Pe.data.length, Pe = Pe.next;
        return ve;
      }, oe;
    }(), ne && ne.inspect && ne.inspect.custom && (B.exports.prototype[ne.inspect.custom] = function() {
      var oe = ne.inspect({ length: this.length });
      return this.constructor.name + " " + oe;
    });
  }(BufferList)), BufferList.exports;
}
var pna = processNextickArgsExports;
function destroy(B, z) {
  var Y = this, ne = this._readableState && this._readableState.destroyed, ie = this._writableState && this._writableState.destroyed;
  return ne || ie ? (z ? z(B) : B && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, this, B)) : pna.nextTick(emitErrorNT, this, B)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(B || null, function(oe) {
    !z && oe ? Y._writableState ? Y._writableState.errorEmitted || (Y._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, Y, oe)) : pna.nextTick(emitErrorNT, Y, oe) : z && z(oe);
  }), this);
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(B, z) {
  B.emit("error", z);
}
var destroy_1 = {
  destroy,
  undestroy
}, _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var B = processNextickArgsExports;
  _stream_writable = kt;
  function z(wt) {
    var vt = this;
    this.next = null, this.entry = null, this.finish = function() {
      ht(vt, wt);
    };
  }
  var Y = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : B.nextTick, ne;
  kt.WritableState = Ce;
  var ie = Object.create(util$2);
  ie.inherits = inherits_browserExports;
  var oe = {
    deprecate: browser$a
  }, se = streamBrowser, ae = safeBufferExports.Buffer, ve = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function Pe(wt) {
    return ae.from(wt);
  }
  function le(wt) {
    return ae.isBuffer(wt) || wt instanceof ve;
  }
  var Ee = destroy_1;
  ie.inherits(kt, se);
  function Je() {
  }
  function Ce(wt, vt) {
    ne = ne || require_stream_duplex(), wt = wt || {};
    var $t = vt instanceof ne;
    this.objectMode = !!wt.objectMode, $t && (this.objectMode = this.objectMode || !!wt.writableObjectMode);
    var Qe = wt.highWaterMark, xt = wt.writableHighWaterMark, bt = this.objectMode ? 16 : 16 * 1024;
    Qe || Qe === 0 ? this.highWaterMark = Qe : $t && (xt || xt === 0) ? this.highWaterMark = xt : this.highWaterMark = bt, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Dt = wt.decodeStrings === !1;
    this.decodeStrings = !Dt, this.defaultEncoding = wt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(er) {
      ir(vt, er);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new z(this);
  }
  Ce.prototype.getBuffer = function() {
    for (var vt = this.bufferedRequest, $t = []; vt; )
      $t.push(vt), vt = vt.next;
    return $t;
  }, function() {
    try {
      Object.defineProperty(Ce.prototype, "buffer", {
        get: oe.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var _t;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (_t = Function.prototype[Symbol.hasInstance], Object.defineProperty(kt, Symbol.hasInstance, {
    value: function(wt) {
      return _t.call(this, wt) ? !0 : this !== kt ? !1 : wt && wt._writableState instanceof Ce;
    }
  })) : _t = function(wt) {
    return wt instanceof this;
  };
  function kt(wt) {
    if (ne = ne || require_stream_duplex(), !_t.call(kt, this) && !(this instanceof ne))
      return new kt(wt);
    this._writableState = new Ce(wt, this), this.writable = !0, wt && (typeof wt.write == "function" && (this._write = wt.write), typeof wt.writev == "function" && (this._writev = wt.writev), typeof wt.destroy == "function" && (this._destroy = wt.destroy), typeof wt.final == "function" && (this._final = wt.final)), se.call(this);
  }
  kt.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function Ct(wt, vt) {
    var $t = new Error("write after end");
    wt.emit("error", $t), B.nextTick(vt, $t);
  }
  function Lt(wt, vt, $t, Qe) {
    var xt = !0, bt = !1;
    return $t === null ? bt = new TypeError("May not write null values to stream") : typeof $t != "string" && $t !== void 0 && !vt.objectMode && (bt = new TypeError("Invalid non-string/buffer chunk")), bt && (wt.emit("error", bt), B.nextTick(Qe, bt), xt = !1), xt;
  }
  kt.prototype.write = function(wt, vt, $t) {
    var Qe = this._writableState, xt = !1, bt = !Qe.objectMode && le(wt);
    return bt && !ae.isBuffer(wt) && (wt = Pe(wt)), typeof vt == "function" && ($t = vt, vt = null), bt ? vt = "buffer" : vt || (vt = Qe.defaultEncoding), typeof $t != "function" && ($t = Je), Qe.ended ? Ct(this, $t) : (bt || Lt(this, Qe, wt, $t)) && (Qe.pendingcb++, xt = Ft(this, Qe, bt, wt, vt, $t)), xt;
  }, kt.prototype.cork = function() {
    var wt = this._writableState;
    wt.corked++;
  }, kt.prototype.uncork = function() {
    var wt = this._writableState;
    wt.corked && (wt.corked--, !wt.writing && !wt.corked && !wt.bufferProcessing && wt.bufferedRequest && Kt(this, wt));
  }, kt.prototype.setDefaultEncoding = function(vt) {
    if (typeof vt == "string" && (vt = vt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((vt + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + vt);
    return this._writableState.defaultEncoding = vt, this;
  };
  function Pt(wt, vt, $t) {
    return !wt.objectMode && wt.decodeStrings !== !1 && typeof vt == "string" && (vt = ae.from(vt, $t)), vt;
  }
  Object.defineProperty(kt.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Ft(wt, vt, $t, Qe, xt, bt) {
    if (!$t) {
      var Dt = Pt(vt, Qe, xt);
      Qe !== Dt && ($t = !0, xt = "buffer", Qe = Dt);
    }
    var er = vt.objectMode ? 1 : Qe.length;
    vt.length += er;
    var fr = vt.length < vt.highWaterMark;
    if (fr || (vt.needDrain = !0), vt.writing || vt.corked) {
      var Qt = vt.lastBufferedRequest;
      vt.lastBufferedRequest = {
        chunk: Qe,
        encoding: xt,
        isBuf: $t,
        callback: bt,
        next: null
      }, Qt ? Qt.next = vt.lastBufferedRequest : vt.bufferedRequest = vt.lastBufferedRequest, vt.bufferedRequestCount += 1;
    } else
      Ut(wt, vt, !1, er, Qe, xt, bt);
    return fr;
  }
  function Ut(wt, vt, $t, Qe, xt, bt, Dt) {
    vt.writelen = Qe, vt.writecb = Dt, vt.writing = !0, vt.sync = !0, $t ? wt._writev(xt, vt.onwrite) : wt._write(xt, bt, vt.onwrite), vt.sync = !1;
  }
  function Jt(wt, vt, $t, Qe, xt) {
    --vt.pendingcb, $t ? (B.nextTick(xt, Qe), B.nextTick(ge, wt, vt), wt._writableState.errorEmitted = !0, wt.emit("error", Qe)) : (xt(Qe), wt._writableState.errorEmitted = !0, wt.emit("error", Qe), ge(wt, vt));
  }
  function Vt(wt) {
    wt.writing = !1, wt.writecb = null, wt.length -= wt.writelen, wt.writelen = 0;
  }
  function ir(wt, vt) {
    var $t = wt._writableState, Qe = $t.sync, xt = $t.writecb;
    if (Vt($t), vt) Jt(wt, $t, Qe, vt, xt);
    else {
      var bt = Bt($t);
      !bt && !$t.corked && !$t.bufferProcessing && $t.bufferedRequest && Kt(wt, $t), Qe ? Y(jt, wt, $t, bt, xt) : jt(wt, $t, bt, xt);
    }
  }
  function jt(wt, vt, $t, Qe) {
    $t || Rt(wt, vt), vt.pendingcb--, Qe(), ge(wt, vt);
  }
  function Rt(wt, vt) {
    vt.length === 0 && vt.needDrain && (vt.needDrain = !1, wt.emit("drain"));
  }
  function Kt(wt, vt) {
    vt.bufferProcessing = !0;
    var $t = vt.bufferedRequest;
    if (wt._writev && $t && $t.next) {
      var Qe = vt.bufferedRequestCount, xt = new Array(Qe), bt = vt.corkedRequestsFree;
      bt.entry = $t;
      for (var Dt = 0, er = !0; $t; )
        xt[Dt] = $t, $t.isBuf || (er = !1), $t = $t.next, Dt += 1;
      xt.allBuffers = er, Ut(wt, vt, !0, vt.length, xt, "", bt.finish), vt.pendingcb++, vt.lastBufferedRequest = null, bt.next ? (vt.corkedRequestsFree = bt.next, bt.next = null) : vt.corkedRequestsFree = new z(vt), vt.bufferedRequestCount = 0;
    } else {
      for (; $t; ) {
        var fr = $t.chunk, Qt = $t.encoding, Ht = $t.callback, qt = vt.objectMode ? 1 : fr.length;
        if (Ut(wt, vt, !1, qt, fr, Qt, Ht), $t = $t.next, vt.bufferedRequestCount--, vt.writing)
          break;
      }
      $t === null && (vt.lastBufferedRequest = null);
    }
    vt.bufferedRequest = $t, vt.bufferProcessing = !1;
  }
  kt.prototype._write = function(wt, vt, $t) {
    $t(new Error("_write() is not implemented"));
  }, kt.prototype._writev = null, kt.prototype.end = function(wt, vt, $t) {
    var Qe = this._writableState;
    typeof wt == "function" ? ($t = wt, wt = null, vt = null) : typeof vt == "function" && ($t = vt, vt = null), wt != null && this.write(wt, vt), Qe.corked && (Qe.corked = 1, this.uncork()), Qe.ending || Ke(this, Qe, $t);
  };
  function Bt(wt) {
    return wt.ending && wt.length === 0 && wt.bufferedRequest === null && !wt.finished && !wt.writing;
  }
  function Xe(wt, vt) {
    wt._final(function($t) {
      vt.pendingcb--, $t && wt.emit("error", $t), vt.prefinished = !0, wt.emit("prefinish"), ge(wt, vt);
    });
  }
  function Ve(wt, vt) {
    !vt.prefinished && !vt.finalCalled && (typeof wt._final == "function" ? (vt.pendingcb++, vt.finalCalled = !0, B.nextTick(Xe, wt, vt)) : (vt.prefinished = !0, wt.emit("prefinish")));
  }
  function ge(wt, vt) {
    var $t = Bt(vt);
    return $t && (Ve(wt, vt), vt.pendingcb === 0 && (vt.finished = !0, wt.emit("finish"))), $t;
  }
  function Ke(wt, vt, $t) {
    vt.ending = !0, ge(wt, vt), $t && (vt.finished ? B.nextTick($t) : wt.once("finish", $t)), vt.ended = !0, wt.writable = !1;
  }
  function ht(wt, vt, $t) {
    var Qe = wt.entry;
    for (wt.entry = null; Qe; ) {
      var xt = Qe.callback;
      vt.pendingcb--, xt($t), Qe = Qe.next;
    }
    vt.corkedRequestsFree.next = wt;
  }
  return Object.defineProperty(kt.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(wt) {
      this._writableState && (this._writableState.destroyed = wt);
    }
  }), kt.prototype.destroy = Ee.destroy, kt.prototype._undestroy = Ee.undestroy, kt.prototype._destroy = function(wt, vt) {
    this.end(), vt(wt);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var B = processNextickArgsExports, z = Object.keys || function(Ee) {
    var Je = [];
    for (var Ce in Ee)
      Je.push(Ce);
    return Je;
  };
  _stream_duplex = ve;
  var Y = Object.create(util$2);
  Y.inherits = inherits_browserExports;
  var ne = require_stream_readable(), ie = require_stream_writable();
  Y.inherits(ve, ne);
  for (var oe = z(ie.prototype), se = 0; se < oe.length; se++) {
    var ae = oe[se];
    ve.prototype[ae] || (ve.prototype[ae] = ie.prototype[ae]);
  }
  function ve(Ee) {
    if (!(this instanceof ve)) return new ve(Ee);
    ne.call(this, Ee), ie.call(this, Ee), Ee && Ee.readable === !1 && (this.readable = !1), Ee && Ee.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, Ee && Ee.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", Pe);
  }
  Object.defineProperty(ve.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Pe() {
    this.allowHalfOpen || this._writableState.ended || B.nextTick(le, this);
  }
  function le(Ee) {
    Ee.end();
  }
  return Object.defineProperty(ve.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(Ee) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = Ee, this._writableState.destroyed = Ee);
    }
  }), ve.prototype._destroy = function(Ee, Je) {
    this.push(null), this.end(), B.nextTick(Je, Ee);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var B = processNextickArgsExports;
  _stream_readable = Pt;
  var z = isarray, Y;
  Pt.ReadableState = Lt, eventsExports.EventEmitter;
  var ne = function(Ht, qt) {
    return Ht.listeners(qt).length;
  }, ie = streamBrowser, oe = safeBufferExports.Buffer, se = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ae(Ht) {
    return oe.from(Ht);
  }
  function ve(Ht) {
    return oe.isBuffer(Ht) || Ht instanceof se;
  }
  var Pe = Object.create(util$2);
  Pe.inherits = inherits_browserExports;
  var le = util$3, Ee = void 0;
  le && le.debuglog ? Ee = le.debuglog("stream") : Ee = function() {
  };
  var Je = requireBufferList(), Ce = destroy_1, _t;
  Pe.inherits(Pt, ie);
  var kt = ["error", "close", "destroy", "pause", "resume"];
  function Ct(Ht, qt, nr) {
    if (typeof Ht.prependListener == "function") return Ht.prependListener(qt, nr);
    !Ht._events || !Ht._events[qt] ? Ht.on(qt, nr) : z(Ht._events[qt]) ? Ht._events[qt].unshift(nr) : Ht._events[qt] = [nr, Ht._events[qt]];
  }
  function Lt(Ht, qt) {
    Y = Y || require_stream_duplex(), Ht = Ht || {};
    var nr = qt instanceof Y;
    this.objectMode = !!Ht.objectMode, nr && (this.objectMode = this.objectMode || !!Ht.readableObjectMode);
    var ur = Ht.highWaterMark, zt = Ht.readableHighWaterMark, Gt = this.objectMode ? 16 : 16 * 1024;
    ur || ur === 0 ? this.highWaterMark = ur : nr && (zt || zt === 0) ? this.highWaterMark = zt : this.highWaterMark = Gt, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new Je(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Ht.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Ht.encoding && (_t || (_t = string_decoder.StringDecoder), this.decoder = new _t(Ht.encoding), this.encoding = Ht.encoding);
  }
  function Pt(Ht) {
    if (Y = Y || require_stream_duplex(), !(this instanceof Pt)) return new Pt(Ht);
    this._readableState = new Lt(Ht, this), this.readable = !0, Ht && (typeof Ht.read == "function" && (this._read = Ht.read), typeof Ht.destroy == "function" && (this._destroy = Ht.destroy)), ie.call(this);
  }
  Object.defineProperty(Pt.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Ht) {
      this._readableState && (this._readableState.destroyed = Ht);
    }
  }), Pt.prototype.destroy = Ce.destroy, Pt.prototype._undestroy = Ce.undestroy, Pt.prototype._destroy = function(Ht, qt) {
    this.push(null), qt(Ht);
  }, Pt.prototype.push = function(Ht, qt) {
    var nr = this._readableState, ur;
    return nr.objectMode ? ur = !0 : typeof Ht == "string" && (qt = qt || nr.defaultEncoding, qt !== nr.encoding && (Ht = oe.from(Ht, qt), qt = ""), ur = !0), Ft(this, Ht, qt, !1, ur);
  }, Pt.prototype.unshift = function(Ht) {
    return Ft(this, Ht, null, !0, !1);
  };
  function Ft(Ht, qt, nr, ur, zt) {
    var Gt = Ht._readableState;
    if (qt === null)
      Gt.reading = !1, Kt(Ht, Gt);
    else {
      var cr;
      zt || (cr = Jt(Gt, qt)), cr ? Ht.emit("error", cr) : Gt.objectMode || qt && qt.length > 0 ? (typeof qt != "string" && !Gt.objectMode && Object.getPrototypeOf(qt) !== oe.prototype && (qt = ae(qt)), ur ? Gt.endEmitted ? Ht.emit("error", new Error("stream.unshift() after end event")) : Ut(Ht, Gt, qt, !0) : Gt.ended ? Ht.emit("error", new Error("stream.push() after EOF")) : (Gt.reading = !1, Gt.decoder && !nr ? (qt = Gt.decoder.write(qt), Gt.objectMode || qt.length !== 0 ? Ut(Ht, Gt, qt, !1) : Ve(Ht, Gt)) : Ut(Ht, Gt, qt, !1))) : ur || (Gt.reading = !1);
    }
    return Vt(Gt);
  }
  function Ut(Ht, qt, nr, ur) {
    qt.flowing && qt.length === 0 && !qt.sync ? (Ht.emit("data", nr), Ht.read(0)) : (qt.length += qt.objectMode ? 1 : nr.length, ur ? qt.buffer.unshift(nr) : qt.buffer.push(nr), qt.needReadable && Bt(Ht)), Ve(Ht, qt);
  }
  function Jt(Ht, qt) {
    var nr;
    return !ve(qt) && typeof qt != "string" && qt !== void 0 && !Ht.objectMode && (nr = new TypeError("Invalid non-string/buffer chunk")), nr;
  }
  function Vt(Ht) {
    return !Ht.ended && (Ht.needReadable || Ht.length < Ht.highWaterMark || Ht.length === 0);
  }
  Pt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Pt.prototype.setEncoding = function(Ht) {
    return _t || (_t = string_decoder.StringDecoder), this._readableState.decoder = new _t(Ht), this._readableState.encoding = Ht, this;
  };
  var ir = 8388608;
  function jt(Ht) {
    return Ht >= ir ? Ht = ir : (Ht--, Ht |= Ht >>> 1, Ht |= Ht >>> 2, Ht |= Ht >>> 4, Ht |= Ht >>> 8, Ht |= Ht >>> 16, Ht++), Ht;
  }
  function Rt(Ht, qt) {
    return Ht <= 0 || qt.length === 0 && qt.ended ? 0 : qt.objectMode ? 1 : Ht !== Ht ? qt.flowing && qt.length ? qt.buffer.head.data.length : qt.length : (Ht > qt.highWaterMark && (qt.highWaterMark = jt(Ht)), Ht <= qt.length ? Ht : qt.ended ? qt.length : (qt.needReadable = !0, 0));
  }
  Pt.prototype.read = function(Ht) {
    Ee("read", Ht), Ht = parseInt(Ht, 10);
    var qt = this._readableState, nr = Ht;
    if (Ht !== 0 && (qt.emittedReadable = !1), Ht === 0 && qt.needReadable && (qt.length >= qt.highWaterMark || qt.ended))
      return Ee("read: emitReadable", qt.length, qt.ended), qt.length === 0 && qt.ended ? er(this) : Bt(this), null;
    if (Ht = Rt(Ht, qt), Ht === 0 && qt.ended)
      return qt.length === 0 && er(this), null;
    var ur = qt.needReadable;
    Ee("need readable", ur), (qt.length === 0 || qt.length - Ht < qt.highWaterMark) && (ur = !0, Ee("length less than watermark", ur)), qt.ended || qt.reading ? (ur = !1, Ee("reading or ended", ur)) : ur && (Ee("do read"), qt.reading = !0, qt.sync = !0, qt.length === 0 && (qt.needReadable = !0), this._read(qt.highWaterMark), qt.sync = !1, qt.reading || (Ht = Rt(nr, qt)));
    var zt;
    return Ht > 0 ? zt = Qe(Ht, qt) : zt = null, zt === null ? (qt.needReadable = !0, Ht = 0) : qt.length -= Ht, qt.length === 0 && (qt.ended || (qt.needReadable = !0), nr !== Ht && qt.ended && er(this)), zt !== null && this.emit("data", zt), zt;
  };
  function Kt(Ht, qt) {
    if (!qt.ended) {
      if (qt.decoder) {
        var nr = qt.decoder.end();
        nr && nr.length && (qt.buffer.push(nr), qt.length += qt.objectMode ? 1 : nr.length);
      }
      qt.ended = !0, Bt(Ht);
    }
  }
  function Bt(Ht) {
    var qt = Ht._readableState;
    qt.needReadable = !1, qt.emittedReadable || (Ee("emitReadable", qt.flowing), qt.emittedReadable = !0, qt.sync ? B.nextTick(Xe, Ht) : Xe(Ht));
  }
  function Xe(Ht) {
    Ee("emit readable"), Ht.emit("readable"), $t(Ht);
  }
  function Ve(Ht, qt) {
    qt.readingMore || (qt.readingMore = !0, B.nextTick(ge, Ht, qt));
  }
  function ge(Ht, qt) {
    for (var nr = qt.length; !qt.reading && !qt.flowing && !qt.ended && qt.length < qt.highWaterMark && (Ee("maybeReadMore read 0"), Ht.read(0), nr !== qt.length); )
      nr = qt.length;
    qt.readingMore = !1;
  }
  Pt.prototype._read = function(Ht) {
    this.emit("error", new Error("_read() is not implemented"));
  }, Pt.prototype.pipe = function(Ht, qt) {
    var nr = this, ur = this._readableState;
    switch (ur.pipesCount) {
      case 0:
        ur.pipes = Ht;
        break;
      case 1:
        ur.pipes = [ur.pipes, Ht];
        break;
      default:
        ur.pipes.push(Ht);
        break;
    }
    ur.pipesCount += 1, Ee("pipe count=%d opts=%j", ur.pipesCount, qt);
    var zt = (!qt || qt.end !== !1) && Ht !== process$1.stdout && Ht !== process$1.stderr, Gt = zt ? gr : Xr;
    ur.endEmitted ? B.nextTick(Gt) : nr.once("end", Gt), Ht.on("unpipe", cr);
    function cr(Or, Wr) {
      Ee("onunpipe"), Or === nr && Wr && Wr.hasUnpiped === !1 && (Wr.hasUnpiped = !0, Mr());
    }
    function gr() {
      Ee("onend"), Ht.end();
    }
    var $r = Ke(nr);
    Ht.on("drain", $r);
    var xr = !1;
    function Mr() {
      Ee("cleanup"), Ht.removeListener("close", jr), Ht.removeListener("finish", Qr), Ht.removeListener("drain", $r), Ht.removeListener("error", Yr), Ht.removeListener("unpipe", cr), nr.removeListener("end", gr), nr.removeListener("end", Xr), nr.removeListener("data", br), xr = !0, ur.awaitDrain && (!Ht._writableState || Ht._writableState.needDrain) && $r();
    }
    var kr = !1;
    nr.on("data", br);
    function br(Or) {
      Ee("ondata"), kr = !1;
      var Wr = Ht.write(Or);
      Wr === !1 && !kr && ((ur.pipesCount === 1 && ur.pipes === Ht || ur.pipesCount > 1 && Qt(ur.pipes, Ht) !== -1) && !xr && (Ee("false write response, pause", ur.awaitDrain), ur.awaitDrain++, kr = !0), nr.pause());
    }
    function Yr(Or) {
      Ee("onerror", Or), Xr(), Ht.removeListener("error", Yr), ne(Ht, "error") === 0 && Ht.emit("error", Or);
    }
    Ct(Ht, "error", Yr);
    function jr() {
      Ht.removeListener("finish", Qr), Xr();
    }
    Ht.once("close", jr);
    function Qr() {
      Ee("onfinish"), Ht.removeListener("close", jr), Xr();
    }
    Ht.once("finish", Qr);
    function Xr() {
      Ee("unpipe"), nr.unpipe(Ht);
    }
    return Ht.emit("pipe", nr), ur.flowing || (Ee("pipe resume"), nr.resume()), Ht;
  };
  function Ke(Ht) {
    return function() {
      var qt = Ht._readableState;
      Ee("pipeOnDrain", qt.awaitDrain), qt.awaitDrain && qt.awaitDrain--, qt.awaitDrain === 0 && ne(Ht, "data") && (qt.flowing = !0, $t(Ht));
    };
  }
  Pt.prototype.unpipe = function(Ht) {
    var qt = this._readableState, nr = { hasUnpiped: !1 };
    if (qt.pipesCount === 0) return this;
    if (qt.pipesCount === 1)
      return Ht && Ht !== qt.pipes ? this : (Ht || (Ht = qt.pipes), qt.pipes = null, qt.pipesCount = 0, qt.flowing = !1, Ht && Ht.emit("unpipe", this, nr), this);
    if (!Ht) {
      var ur = qt.pipes, zt = qt.pipesCount;
      qt.pipes = null, qt.pipesCount = 0, qt.flowing = !1;
      for (var Gt = 0; Gt < zt; Gt++)
        ur[Gt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var cr = Qt(qt.pipes, Ht);
    return cr === -1 ? this : (qt.pipes.splice(cr, 1), qt.pipesCount -= 1, qt.pipesCount === 1 && (qt.pipes = qt.pipes[0]), Ht.emit("unpipe", this, nr), this);
  }, Pt.prototype.on = function(Ht, qt) {
    var nr = ie.prototype.on.call(this, Ht, qt);
    if (Ht === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Ht === "readable") {
      var ur = this._readableState;
      !ur.endEmitted && !ur.readableListening && (ur.readableListening = ur.needReadable = !0, ur.emittedReadable = !1, ur.reading ? ur.length && Bt(this) : B.nextTick(ht, this));
    }
    return nr;
  }, Pt.prototype.addListener = Pt.prototype.on;
  function ht(Ht) {
    Ee("readable nexttick read 0"), Ht.read(0);
  }
  Pt.prototype.resume = function() {
    var Ht = this._readableState;
    return Ht.flowing || (Ee("resume"), Ht.flowing = !0, wt(this, Ht)), this;
  };
  function wt(Ht, qt) {
    qt.resumeScheduled || (qt.resumeScheduled = !0, B.nextTick(vt, Ht, qt));
  }
  function vt(Ht, qt) {
    qt.reading || (Ee("resume read 0"), Ht.read(0)), qt.resumeScheduled = !1, qt.awaitDrain = 0, Ht.emit("resume"), $t(Ht), qt.flowing && !qt.reading && Ht.read(0);
  }
  Pt.prototype.pause = function() {
    return Ee("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Ee("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function $t(Ht) {
    var qt = Ht._readableState;
    for (Ee("flow", qt.flowing); qt.flowing && Ht.read() !== null; )
      ;
  }
  Pt.prototype.wrap = function(Ht) {
    var qt = this, nr = this._readableState, ur = !1;
    Ht.on("end", function() {
      if (Ee("wrapped end"), nr.decoder && !nr.ended) {
        var cr = nr.decoder.end();
        cr && cr.length && qt.push(cr);
      }
      qt.push(null);
    }), Ht.on("data", function(cr) {
      if (Ee("wrapped data"), nr.decoder && (cr = nr.decoder.write(cr)), !(nr.objectMode && cr == null) && !(!nr.objectMode && (!cr || !cr.length))) {
        var gr = qt.push(cr);
        gr || (ur = !0, Ht.pause());
      }
    });
    for (var zt in Ht)
      this[zt] === void 0 && typeof Ht[zt] == "function" && (this[zt] = /* @__PURE__ */ function(cr) {
        return function() {
          return Ht[cr].apply(Ht, arguments);
        };
      }(zt));
    for (var Gt = 0; Gt < kt.length; Gt++)
      Ht.on(kt[Gt], this.emit.bind(this, kt[Gt]));
    return this._read = function(cr) {
      Ee("wrapped _read", cr), ur && (ur = !1, Ht.resume());
    }, this;
  }, Object.defineProperty(Pt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Pt._fromList = Qe;
  function Qe(Ht, qt) {
    if (qt.length === 0) return null;
    var nr;
    return qt.objectMode ? nr = qt.buffer.shift() : !Ht || Ht >= qt.length ? (qt.decoder ? nr = qt.buffer.join("") : qt.buffer.length === 1 ? nr = qt.buffer.head.data : nr = qt.buffer.concat(qt.length), qt.buffer.clear()) : nr = xt(Ht, qt.buffer, qt.decoder), nr;
  }
  function xt(Ht, qt, nr) {
    var ur;
    return Ht < qt.head.data.length ? (ur = qt.head.data.slice(0, Ht), qt.head.data = qt.head.data.slice(Ht)) : Ht === qt.head.data.length ? ur = qt.shift() : ur = nr ? bt(Ht, qt) : Dt(Ht, qt), ur;
  }
  function bt(Ht, qt) {
    var nr = qt.head, ur = 1, zt = nr.data;
    for (Ht -= zt.length; nr = nr.next; ) {
      var Gt = nr.data, cr = Ht > Gt.length ? Gt.length : Ht;
      if (cr === Gt.length ? zt += Gt : zt += Gt.slice(0, Ht), Ht -= cr, Ht === 0) {
        cr === Gt.length ? (++ur, nr.next ? qt.head = nr.next : qt.head = qt.tail = null) : (qt.head = nr, nr.data = Gt.slice(cr));
        break;
      }
      ++ur;
    }
    return qt.length -= ur, zt;
  }
  function Dt(Ht, qt) {
    var nr = oe.allocUnsafe(Ht), ur = qt.head, zt = 1;
    for (ur.data.copy(nr), Ht -= ur.data.length; ur = ur.next; ) {
      var Gt = ur.data, cr = Ht > Gt.length ? Gt.length : Ht;
      if (Gt.copy(nr, nr.length - Ht, 0, cr), Ht -= cr, Ht === 0) {
        cr === Gt.length ? (++zt, ur.next ? qt.head = ur.next : qt.head = qt.tail = null) : (qt.head = ur, ur.data = Gt.slice(cr));
        break;
      }
      ++zt;
    }
    return qt.length -= zt, nr;
  }
  function er(Ht) {
    var qt = Ht._readableState;
    if (qt.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    qt.endEmitted || (qt.ended = !0, B.nextTick(fr, qt, Ht));
  }
  function fr(Ht, qt) {
    !Ht.endEmitted && Ht.length === 0 && (Ht.endEmitted = !0, qt.readable = !1, qt.emit("end"));
  }
  function Qt(Ht, qt) {
    for (var nr = 0, ur = Ht.length; nr < ur; nr++)
      if (Ht[nr] === qt) return nr;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1, Duplex = require_stream_duplex(), util$1 = Object.create(util$2);
util$1.inherits = inherits_browserExports;
util$1.inherits(Transform$1, Duplex);
function afterTransform(B, z) {
  var Y = this._transformState;
  Y.transforming = !1;
  var ne = Y.writecb;
  if (!ne)
    return this.emit("error", new Error("write callback called multiple times"));
  Y.writechunk = null, Y.writecb = null, z != null && this.push(z), ne(B);
  var ie = this._readableState;
  ie.reading = !1, (ie.needReadable || ie.length < ie.highWaterMark) && this._read(ie.highWaterMark);
}
function Transform$1(B) {
  if (!(this instanceof Transform$1)) return new Transform$1(B);
  Duplex.call(this, B), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, B && (typeof B.transform == "function" && (this._transform = B.transform), typeof B.flush == "function" && (this._flush = B.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var B = this;
  typeof this._flush == "function" ? this._flush(function(z, Y) {
    done(B, z, Y);
  }) : done(this, null, null);
}
Transform$1.prototype.push = function(B, z) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, B, z);
};
Transform$1.prototype._transform = function(B, z, Y) {
  throw new Error("_transform() is not implemented");
};
Transform$1.prototype._write = function(B, z, Y) {
  var ne = this._transformState;
  if (ne.writecb = Y, ne.writechunk = B, ne.writeencoding = z, !ne.transforming) {
    var ie = this._readableState;
    (ne.needTransform || ie.needReadable || ie.length < ie.highWaterMark) && this._read(ie.highWaterMark);
  }
};
Transform$1.prototype._read = function(B) {
  var z = this._transformState;
  z.writechunk !== null && z.writecb && !z.transforming ? (z.transforming = !0, this._transform(z.writechunk, z.writeencoding, z.afterTransform)) : z.needTransform = !0;
};
Transform$1.prototype._destroy = function(B, z) {
  var Y = this;
  Duplex.prototype._destroy.call(this, B, function(ne) {
    z(ne), Y.emit("close");
  });
};
function done(B, z, Y) {
  if (z) return B.emit("error", z);
  if (Y != null && B.push(Y), B._writableState.length) throw new Error("Calling transform done when ws.length != 0");
  if (B._transformState.transforming) throw new Error("Calling transform done when still transforming");
  return B.push(null);
}
var _stream_passthrough = PassThrough, Transform = _stream_transform, util = Object.create(util$2);
util.inherits = inherits_browserExports;
util.inherits(PassThrough, Transform);
function PassThrough(B) {
  if (!(this instanceof PassThrough)) return new PassThrough(B);
  Transform.call(this, B);
}
PassThrough.prototype._transform = function(B, z, Y) {
  Y(null, B);
};
(function(B, z) {
  z = B.exports = require_stream_readable(), z.Stream = z, z.Readable = z, z.Writable = require_stream_writable(), z.Duplex = require_stream_duplex(), z.Transform = _stream_transform, z.PassThrough = _stream_passthrough;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports, sign = { exports: {} }, bn = { exports: {} };
bn.exports;
(function(B) {
  (function(z, Y) {
    function ne(Ve, ge) {
      if (!Ve) throw new Error(ge || "Assertion failed");
    }
    function ie(Ve, ge) {
      Ve.super_ = ge;
      var Ke = function() {
      };
      Ke.prototype = ge.prototype, Ve.prototype = new Ke(), Ve.prototype.constructor = Ve;
    }
    function oe(Ve, ge, Ke) {
      if (oe.isBN(Ve))
        return Ve;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Ve !== null && ((ge === "le" || ge === "be") && (Ke = ge, ge = 10), this._init(Ve || 0, ge || 10, Ke || "be"));
    }
    typeof z == "object" ? z.exports = oe : Y.BN = oe, oe.BN = oe, oe.wordSize = 26;
    var se;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? se = window.Buffer : se = require$$0$1.Buffer;
    } catch {
    }
    oe.isBN = function(ge) {
      return ge instanceof oe ? !0 : ge !== null && typeof ge == "object" && ge.constructor.wordSize === oe.wordSize && Array.isArray(ge.words);
    }, oe.max = function(ge, Ke) {
      return ge.cmp(Ke) > 0 ? ge : Ke;
    }, oe.min = function(ge, Ke) {
      return ge.cmp(Ke) < 0 ? ge : Ke;
    }, oe.prototype._init = function(ge, Ke, ht) {
      if (typeof ge == "number")
        return this._initNumber(ge, Ke, ht);
      if (typeof ge == "object")
        return this._initArray(ge, Ke, ht);
      Ke === "hex" && (Ke = 16), ne(Ke === (Ke | 0) && Ke >= 2 && Ke <= 36), ge = ge.toString().replace(/\s+/g, "");
      var wt = 0;
      ge[0] === "-" && (wt++, this.negative = 1), wt < ge.length && (Ke === 16 ? this._parseHex(ge, wt, ht) : (this._parseBase(ge, Ke, wt), ht === "le" && this._initArray(this.toArray(), Ke, ht)));
    }, oe.prototype._initNumber = function(ge, Ke, ht) {
      ge < 0 && (this.negative = 1, ge = -ge), ge < 67108864 ? (this.words = [ge & 67108863], this.length = 1) : ge < 4503599627370496 ? (this.words = [
        ge & 67108863,
        ge / 67108864 & 67108863
      ], this.length = 2) : (ne(ge < 9007199254740992), this.words = [
        ge & 67108863,
        ge / 67108864 & 67108863,
        1
      ], this.length = 3), ht === "le" && this._initArray(this.toArray(), Ke, ht);
    }, oe.prototype._initArray = function(ge, Ke, ht) {
      if (ne(typeof ge.length == "number"), ge.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(ge.length / 3), this.words = new Array(this.length);
      for (var wt = 0; wt < this.length; wt++)
        this.words[wt] = 0;
      var vt, $t, Qe = 0;
      if (ht === "be")
        for (wt = ge.length - 1, vt = 0; wt >= 0; wt -= 3)
          $t = ge[wt] | ge[wt - 1] << 8 | ge[wt - 2] << 16, this.words[vt] |= $t << Qe & 67108863, this.words[vt + 1] = $t >>> 26 - Qe & 67108863, Qe += 24, Qe >= 26 && (Qe -= 26, vt++);
      else if (ht === "le")
        for (wt = 0, vt = 0; wt < ge.length; wt += 3)
          $t = ge[wt] | ge[wt + 1] << 8 | ge[wt + 2] << 16, this.words[vt] |= $t << Qe & 67108863, this.words[vt + 1] = $t >>> 26 - Qe & 67108863, Qe += 24, Qe >= 26 && (Qe -= 26, vt++);
      return this._strip();
    };
    function ae(Ve, ge) {
      var Ke = Ve.charCodeAt(ge);
      if (Ke >= 48 && Ke <= 57)
        return Ke - 48;
      if (Ke >= 65 && Ke <= 70)
        return Ke - 55;
      if (Ke >= 97 && Ke <= 102)
        return Ke - 87;
      ne(!1, "Invalid character in " + Ve);
    }
    function ve(Ve, ge, Ke) {
      var ht = ae(Ve, Ke);
      return Ke - 1 >= ge && (ht |= ae(Ve, Ke - 1) << 4), ht;
    }
    oe.prototype._parseHex = function(ge, Ke, ht) {
      this.length = Math.ceil((ge.length - Ke) / 6), this.words = new Array(this.length);
      for (var wt = 0; wt < this.length; wt++)
        this.words[wt] = 0;
      var vt = 0, $t = 0, Qe;
      if (ht === "be")
        for (wt = ge.length - 1; wt >= Ke; wt -= 2)
          Qe = ve(ge, Ke, wt) << vt, this.words[$t] |= Qe & 67108863, vt >= 18 ? (vt -= 18, $t += 1, this.words[$t] |= Qe >>> 26) : vt += 8;
      else {
        var xt = ge.length - Ke;
        for (wt = xt % 2 === 0 ? Ke + 1 : Ke; wt < ge.length; wt += 2)
          Qe = ve(ge, Ke, wt) << vt, this.words[$t] |= Qe & 67108863, vt >= 18 ? (vt -= 18, $t += 1, this.words[$t] |= Qe >>> 26) : vt += 8;
      }
      this._strip();
    };
    function Pe(Ve, ge, Ke, ht) {
      for (var wt = 0, vt = 0, $t = Math.min(Ve.length, Ke), Qe = ge; Qe < $t; Qe++) {
        var xt = Ve.charCodeAt(Qe) - 48;
        wt *= ht, xt >= 49 ? vt = xt - 49 + 10 : xt >= 17 ? vt = xt - 17 + 10 : vt = xt, ne(xt >= 0 && vt < ht, "Invalid character"), wt += vt;
      }
      return wt;
    }
    oe.prototype._parseBase = function(ge, Ke, ht) {
      this.words = [0], this.length = 1;
      for (var wt = 0, vt = 1; vt <= 67108863; vt *= Ke)
        wt++;
      wt--, vt = vt / Ke | 0;
      for (var $t = ge.length - ht, Qe = $t % wt, xt = Math.min($t, $t - Qe) + ht, bt = 0, Dt = ht; Dt < xt; Dt += wt)
        bt = Pe(ge, Dt, Dt + wt, Ke), this.imuln(vt), this.words[0] + bt < 67108864 ? this.words[0] += bt : this._iaddn(bt);
      if (Qe !== 0) {
        var er = 1;
        for (bt = Pe(ge, Dt, ge.length, Ke), Dt = 0; Dt < Qe; Dt++)
          er *= Ke;
        this.imuln(er), this.words[0] + bt < 67108864 ? this.words[0] += bt : this._iaddn(bt);
      }
      this._strip();
    }, oe.prototype.copy = function(ge) {
      ge.words = new Array(this.length);
      for (var Ke = 0; Ke < this.length; Ke++)
        ge.words[Ke] = this.words[Ke];
      ge.length = this.length, ge.negative = this.negative, ge.red = this.red;
    };
    function le(Ve, ge) {
      Ve.words = ge.words, Ve.length = ge.length, Ve.negative = ge.negative, Ve.red = ge.red;
    }
    if (oe.prototype._move = function(ge) {
      le(ge, this);
    }, oe.prototype.clone = function() {
      var ge = new oe(null);
      return this.copy(ge), ge;
    }, oe.prototype._expand = function(ge) {
      for (; this.length < ge; )
        this.words[this.length++] = 0;
      return this;
    }, oe.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, oe.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        oe.prototype[Symbol.for("nodejs.util.inspect.custom")] = Ee;
      } catch {
        oe.prototype.inspect = Ee;
      }
    else
      oe.prototype.inspect = Ee;
    function Ee() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var Je = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Ce = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], _t = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    oe.prototype.toString = function(ge, Ke) {
      ge = ge || 10, Ke = Ke | 0 || 1;
      var ht;
      if (ge === 16 || ge === "hex") {
        ht = "";
        for (var wt = 0, vt = 0, $t = 0; $t < this.length; $t++) {
          var Qe = this.words[$t], xt = ((Qe << wt | vt) & 16777215).toString(16);
          vt = Qe >>> 24 - wt & 16777215, wt += 2, wt >= 26 && (wt -= 26, $t--), vt !== 0 || $t !== this.length - 1 ? ht = Je[6 - xt.length] + xt + ht : ht = xt + ht;
        }
        for (vt !== 0 && (ht = vt.toString(16) + ht); ht.length % Ke !== 0; )
          ht = "0" + ht;
        return this.negative !== 0 && (ht = "-" + ht), ht;
      }
      if (ge === (ge | 0) && ge >= 2 && ge <= 36) {
        var bt = Ce[ge], Dt = _t[ge];
        ht = "";
        var er = this.clone();
        for (er.negative = 0; !er.isZero(); ) {
          var fr = er.modrn(Dt).toString(ge);
          er = er.idivn(Dt), er.isZero() ? ht = fr + ht : ht = Je[bt - fr.length] + fr + ht;
        }
        for (this.isZero() && (ht = "0" + ht); ht.length % Ke !== 0; )
          ht = "0" + ht;
        return this.negative !== 0 && (ht = "-" + ht), ht;
      }
      ne(!1, "Base should be between 2 and 36");
    }, oe.prototype.toNumber = function() {
      var ge = this.words[0];
      return this.length === 2 ? ge += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? ge += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ne(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -ge : ge;
    }, oe.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, se && (oe.prototype.toBuffer = function(ge, Ke) {
      return this.toArrayLike(se, ge, Ke);
    }), oe.prototype.toArray = function(ge, Ke) {
      return this.toArrayLike(Array, ge, Ke);
    };
    var kt = function(ge, Ke) {
      return ge.allocUnsafe ? ge.allocUnsafe(Ke) : new ge(Ke);
    };
    oe.prototype.toArrayLike = function(ge, Ke, ht) {
      this._strip();
      var wt = this.byteLength(), vt = ht || Math.max(1, wt);
      ne(wt <= vt, "byte array longer than desired length"), ne(vt > 0, "Requested array length <= 0");
      var $t = kt(ge, vt), Qe = Ke === "le" ? "LE" : "BE";
      return this["_toArrayLike" + Qe]($t, wt), $t;
    }, oe.prototype._toArrayLikeLE = function(ge, Ke) {
      for (var ht = 0, wt = 0, vt = 0, $t = 0; vt < this.length; vt++) {
        var Qe = this.words[vt] << $t | wt;
        ge[ht++] = Qe & 255, ht < ge.length && (ge[ht++] = Qe >> 8 & 255), ht < ge.length && (ge[ht++] = Qe >> 16 & 255), $t === 6 ? (ht < ge.length && (ge[ht++] = Qe >> 24 & 255), wt = 0, $t = 0) : (wt = Qe >>> 24, $t += 2);
      }
      if (ht < ge.length)
        for (ge[ht++] = wt; ht < ge.length; )
          ge[ht++] = 0;
    }, oe.prototype._toArrayLikeBE = function(ge, Ke) {
      for (var ht = ge.length - 1, wt = 0, vt = 0, $t = 0; vt < this.length; vt++) {
        var Qe = this.words[vt] << $t | wt;
        ge[ht--] = Qe & 255, ht >= 0 && (ge[ht--] = Qe >> 8 & 255), ht >= 0 && (ge[ht--] = Qe >> 16 & 255), $t === 6 ? (ht >= 0 && (ge[ht--] = Qe >> 24 & 255), wt = 0, $t = 0) : (wt = Qe >>> 24, $t += 2);
      }
      if (ht >= 0)
        for (ge[ht--] = wt; ht >= 0; )
          ge[ht--] = 0;
    }, Math.clz32 ? oe.prototype._countBits = function(ge) {
      return 32 - Math.clz32(ge);
    } : oe.prototype._countBits = function(ge) {
      var Ke = ge, ht = 0;
      return Ke >= 4096 && (ht += 13, Ke >>>= 13), Ke >= 64 && (ht += 7, Ke >>>= 7), Ke >= 8 && (ht += 4, Ke >>>= 4), Ke >= 2 && (ht += 2, Ke >>>= 2), ht + Ke;
    }, oe.prototype._zeroBits = function(ge) {
      if (ge === 0) return 26;
      var Ke = ge, ht = 0;
      return Ke & 8191 || (ht += 13, Ke >>>= 13), Ke & 127 || (ht += 7, Ke >>>= 7), Ke & 15 || (ht += 4, Ke >>>= 4), Ke & 3 || (ht += 2, Ke >>>= 2), Ke & 1 || ht++, ht;
    }, oe.prototype.bitLength = function() {
      var ge = this.words[this.length - 1], Ke = this._countBits(ge);
      return (this.length - 1) * 26 + Ke;
    };
    function Ct(Ve) {
      for (var ge = new Array(Ve.bitLength()), Ke = 0; Ke < ge.length; Ke++) {
        var ht = Ke / 26 | 0, wt = Ke % 26;
        ge[Ke] = Ve.words[ht] >>> wt & 1;
      }
      return ge;
    }
    oe.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var ge = 0, Ke = 0; Ke < this.length; Ke++) {
        var ht = this._zeroBits(this.words[Ke]);
        if (ge += ht, ht !== 26) break;
      }
      return ge;
    }, oe.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, oe.prototype.toTwos = function(ge) {
      return this.negative !== 0 ? this.abs().inotn(ge).iaddn(1) : this.clone();
    }, oe.prototype.fromTwos = function(ge) {
      return this.testn(ge - 1) ? this.notn(ge).iaddn(1).ineg() : this.clone();
    }, oe.prototype.isNeg = function() {
      return this.negative !== 0;
    }, oe.prototype.neg = function() {
      return this.clone().ineg();
    }, oe.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, oe.prototype.iuor = function(ge) {
      for (; this.length < ge.length; )
        this.words[this.length++] = 0;
      for (var Ke = 0; Ke < ge.length; Ke++)
        this.words[Ke] = this.words[Ke] | ge.words[Ke];
      return this._strip();
    }, oe.prototype.ior = function(ge) {
      return ne((this.negative | ge.negative) === 0), this.iuor(ge);
    }, oe.prototype.or = function(ge) {
      return this.length > ge.length ? this.clone().ior(ge) : ge.clone().ior(this);
    }, oe.prototype.uor = function(ge) {
      return this.length > ge.length ? this.clone().iuor(ge) : ge.clone().iuor(this);
    }, oe.prototype.iuand = function(ge) {
      var Ke;
      this.length > ge.length ? Ke = ge : Ke = this;
      for (var ht = 0; ht < Ke.length; ht++)
        this.words[ht] = this.words[ht] & ge.words[ht];
      return this.length = Ke.length, this._strip();
    }, oe.prototype.iand = function(ge) {
      return ne((this.negative | ge.negative) === 0), this.iuand(ge);
    }, oe.prototype.and = function(ge) {
      return this.length > ge.length ? this.clone().iand(ge) : ge.clone().iand(this);
    }, oe.prototype.uand = function(ge) {
      return this.length > ge.length ? this.clone().iuand(ge) : ge.clone().iuand(this);
    }, oe.prototype.iuxor = function(ge) {
      var Ke, ht;
      this.length > ge.length ? (Ke = this, ht = ge) : (Ke = ge, ht = this);
      for (var wt = 0; wt < ht.length; wt++)
        this.words[wt] = Ke.words[wt] ^ ht.words[wt];
      if (this !== Ke)
        for (; wt < Ke.length; wt++)
          this.words[wt] = Ke.words[wt];
      return this.length = Ke.length, this._strip();
    }, oe.prototype.ixor = function(ge) {
      return ne((this.negative | ge.negative) === 0), this.iuxor(ge);
    }, oe.prototype.xor = function(ge) {
      return this.length > ge.length ? this.clone().ixor(ge) : ge.clone().ixor(this);
    }, oe.prototype.uxor = function(ge) {
      return this.length > ge.length ? this.clone().iuxor(ge) : ge.clone().iuxor(this);
    }, oe.prototype.inotn = function(ge) {
      ne(typeof ge == "number" && ge >= 0);
      var Ke = Math.ceil(ge / 26) | 0, ht = ge % 26;
      this._expand(Ke), ht > 0 && Ke--;
      for (var wt = 0; wt < Ke; wt++)
        this.words[wt] = ~this.words[wt] & 67108863;
      return ht > 0 && (this.words[wt] = ~this.words[wt] & 67108863 >> 26 - ht), this._strip();
    }, oe.prototype.notn = function(ge) {
      return this.clone().inotn(ge);
    }, oe.prototype.setn = function(ge, Ke) {
      ne(typeof ge == "number" && ge >= 0);
      var ht = ge / 26 | 0, wt = ge % 26;
      return this._expand(ht + 1), Ke ? this.words[ht] = this.words[ht] | 1 << wt : this.words[ht] = this.words[ht] & ~(1 << wt), this._strip();
    }, oe.prototype.iadd = function(ge) {
      var Ke;
      if (this.negative !== 0 && ge.negative === 0)
        return this.negative = 0, Ke = this.isub(ge), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && ge.negative !== 0)
        return ge.negative = 0, Ke = this.isub(ge), ge.negative = 1, Ke._normSign();
      var ht, wt;
      this.length > ge.length ? (ht = this, wt = ge) : (ht = ge, wt = this);
      for (var vt = 0, $t = 0; $t < wt.length; $t++)
        Ke = (ht.words[$t] | 0) + (wt.words[$t] | 0) + vt, this.words[$t] = Ke & 67108863, vt = Ke >>> 26;
      for (; vt !== 0 && $t < ht.length; $t++)
        Ke = (ht.words[$t] | 0) + vt, this.words[$t] = Ke & 67108863, vt = Ke >>> 26;
      if (this.length = ht.length, vt !== 0)
        this.words[this.length] = vt, this.length++;
      else if (ht !== this)
        for (; $t < ht.length; $t++)
          this.words[$t] = ht.words[$t];
      return this;
    }, oe.prototype.add = function(ge) {
      var Ke;
      return ge.negative !== 0 && this.negative === 0 ? (ge.negative = 0, Ke = this.sub(ge), ge.negative ^= 1, Ke) : ge.negative === 0 && this.negative !== 0 ? (this.negative = 0, Ke = ge.sub(this), this.negative = 1, Ke) : this.length > ge.length ? this.clone().iadd(ge) : ge.clone().iadd(this);
    }, oe.prototype.isub = function(ge) {
      if (ge.negative !== 0) {
        ge.negative = 0;
        var Ke = this.iadd(ge);
        return ge.negative = 1, Ke._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(ge), this.negative = 1, this._normSign();
      var ht = this.cmp(ge);
      if (ht === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var wt, vt;
      ht > 0 ? (wt = this, vt = ge) : (wt = ge, vt = this);
      for (var $t = 0, Qe = 0; Qe < vt.length; Qe++)
        Ke = (wt.words[Qe] | 0) - (vt.words[Qe] | 0) + $t, $t = Ke >> 26, this.words[Qe] = Ke & 67108863;
      for (; $t !== 0 && Qe < wt.length; Qe++)
        Ke = (wt.words[Qe] | 0) + $t, $t = Ke >> 26, this.words[Qe] = Ke & 67108863;
      if ($t === 0 && Qe < wt.length && wt !== this)
        for (; Qe < wt.length; Qe++)
          this.words[Qe] = wt.words[Qe];
      return this.length = Math.max(this.length, Qe), wt !== this && (this.negative = 1), this._strip();
    }, oe.prototype.sub = function(ge) {
      return this.clone().isub(ge);
    };
    function Lt(Ve, ge, Ke) {
      Ke.negative = ge.negative ^ Ve.negative;
      var ht = Ve.length + ge.length | 0;
      Ke.length = ht, ht = ht - 1 | 0;
      var wt = Ve.words[0] | 0, vt = ge.words[0] | 0, $t = wt * vt, Qe = $t & 67108863, xt = $t / 67108864 | 0;
      Ke.words[0] = Qe;
      for (var bt = 1; bt < ht; bt++) {
        for (var Dt = xt >>> 26, er = xt & 67108863, fr = Math.min(bt, ge.length - 1), Qt = Math.max(0, bt - Ve.length + 1); Qt <= fr; Qt++) {
          var Ht = bt - Qt | 0;
          wt = Ve.words[Ht] | 0, vt = ge.words[Qt] | 0, $t = wt * vt + er, Dt += $t / 67108864 | 0, er = $t & 67108863;
        }
        Ke.words[bt] = er | 0, xt = Dt | 0;
      }
      return xt !== 0 ? Ke.words[bt] = xt | 0 : Ke.length--, Ke._strip();
    }
    var Pt = function(ge, Ke, ht) {
      var wt = ge.words, vt = Ke.words, $t = ht.words, Qe = 0, xt, bt, Dt, er = wt[0] | 0, fr = er & 8191, Qt = er >>> 13, Ht = wt[1] | 0, qt = Ht & 8191, nr = Ht >>> 13, ur = wt[2] | 0, zt = ur & 8191, Gt = ur >>> 13, cr = wt[3] | 0, gr = cr & 8191, $r = cr >>> 13, xr = wt[4] | 0, Mr = xr & 8191, kr = xr >>> 13, br = wt[5] | 0, Yr = br & 8191, jr = br >>> 13, Qr = wt[6] | 0, Xr = Qr & 8191, Or = Qr >>> 13, Wr = wt[7] | 0, Jr = Wr & 8191, Hr = Wr >>> 13, Vr = wt[8] | 0, tn = Vr & 8191, Wt = Vr >>> 13, Ot = wt[9] | 0, Nt = Ot & 8191, Yt = Ot >>> 13, ar = vt[0] | 0, lr = ar & 8191, dr = ar >>> 13, Ir = vt[1] | 0, qr = Ir & 8191, Br = Ir >>> 13, Ur = vt[2] | 0, Lr = Ur & 8191, Dr = Ur >>> 13, Zr = vt[3] | 0, nn = Zr & 8191, tr = Zr >>> 13, Xt = vt[4] | 0, rr = Xt & 8191, or = Xt >>> 13, pr = vt[5] | 0, vr = pr & 8191, wr = pr >>> 13, Er = vt[6] | 0, Pr = Er & 8191, Ar = Er >>> 13, Tr = vt[7] | 0, Nr = Tr & 8191, Zt = Tr >>> 13, yr = vt[8] | 0, _r = yr & 8191, Sr = yr >>> 13, Cr = vt[9] | 0, Fr = Cr & 8191, Rr = Cr >>> 13;
      ht.negative = ge.negative ^ Ke.negative, ht.length = 19, xt = Math.imul(fr, lr), bt = Math.imul(fr, dr), bt = bt + Math.imul(Qt, lr) | 0, Dt = Math.imul(Qt, dr);
      var Gr = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, xt = Math.imul(qt, lr), bt = Math.imul(qt, dr), bt = bt + Math.imul(nr, lr) | 0, Dt = Math.imul(nr, dr), xt = xt + Math.imul(fr, qr) | 0, bt = bt + Math.imul(fr, Br) | 0, bt = bt + Math.imul(Qt, qr) | 0, Dt = Dt + Math.imul(Qt, Br) | 0;
      var sn = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, xt = Math.imul(zt, lr), bt = Math.imul(zt, dr), bt = bt + Math.imul(Gt, lr) | 0, Dt = Math.imul(Gt, dr), xt = xt + Math.imul(qt, qr) | 0, bt = bt + Math.imul(qt, Br) | 0, bt = bt + Math.imul(nr, qr) | 0, Dt = Dt + Math.imul(nr, Br) | 0, xt = xt + Math.imul(fr, Lr) | 0, bt = bt + Math.imul(fr, Dr) | 0, bt = bt + Math.imul(Qt, Lr) | 0, Dt = Dt + Math.imul(Qt, Dr) | 0;
      var en = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, xt = Math.imul(gr, lr), bt = Math.imul(gr, dr), bt = bt + Math.imul($r, lr) | 0, Dt = Math.imul($r, dr), xt = xt + Math.imul(zt, qr) | 0, bt = bt + Math.imul(zt, Br) | 0, bt = bt + Math.imul(Gt, qr) | 0, Dt = Dt + Math.imul(Gt, Br) | 0, xt = xt + Math.imul(qt, Lr) | 0, bt = bt + Math.imul(qt, Dr) | 0, bt = bt + Math.imul(nr, Lr) | 0, Dt = Dt + Math.imul(nr, Dr) | 0, xt = xt + Math.imul(fr, nn) | 0, bt = bt + Math.imul(fr, tr) | 0, bt = bt + Math.imul(Qt, nn) | 0, Dt = Dt + Math.imul(Qt, tr) | 0;
      var on = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, xt = Math.imul(Mr, lr), bt = Math.imul(Mr, dr), bt = bt + Math.imul(kr, lr) | 0, Dt = Math.imul(kr, dr), xt = xt + Math.imul(gr, qr) | 0, bt = bt + Math.imul(gr, Br) | 0, bt = bt + Math.imul($r, qr) | 0, Dt = Dt + Math.imul($r, Br) | 0, xt = xt + Math.imul(zt, Lr) | 0, bt = bt + Math.imul(zt, Dr) | 0, bt = bt + Math.imul(Gt, Lr) | 0, Dt = Dt + Math.imul(Gt, Dr) | 0, xt = xt + Math.imul(qt, nn) | 0, bt = bt + Math.imul(qt, tr) | 0, bt = bt + Math.imul(nr, nn) | 0, Dt = Dt + Math.imul(nr, tr) | 0, xt = xt + Math.imul(fr, rr) | 0, bt = bt + Math.imul(fr, or) | 0, bt = bt + Math.imul(Qt, rr) | 0, Dt = Dt + Math.imul(Qt, or) | 0;
      var cn = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, xt = Math.imul(Yr, lr), bt = Math.imul(Yr, dr), bt = bt + Math.imul(jr, lr) | 0, Dt = Math.imul(jr, dr), xt = xt + Math.imul(Mr, qr) | 0, bt = bt + Math.imul(Mr, Br) | 0, bt = bt + Math.imul(kr, qr) | 0, Dt = Dt + Math.imul(kr, Br) | 0, xt = xt + Math.imul(gr, Lr) | 0, bt = bt + Math.imul(gr, Dr) | 0, bt = bt + Math.imul($r, Lr) | 0, Dt = Dt + Math.imul($r, Dr) | 0, xt = xt + Math.imul(zt, nn) | 0, bt = bt + Math.imul(zt, tr) | 0, bt = bt + Math.imul(Gt, nn) | 0, Dt = Dt + Math.imul(Gt, tr) | 0, xt = xt + Math.imul(qt, rr) | 0, bt = bt + Math.imul(qt, or) | 0, bt = bt + Math.imul(nr, rr) | 0, Dt = Dt + Math.imul(nr, or) | 0, xt = xt + Math.imul(fr, vr) | 0, bt = bt + Math.imul(fr, wr) | 0, bt = bt + Math.imul(Qt, vr) | 0, Dt = Dt + Math.imul(Qt, wr) | 0;
      var ln = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, xt = Math.imul(Xr, lr), bt = Math.imul(Xr, dr), bt = bt + Math.imul(Or, lr) | 0, Dt = Math.imul(Or, dr), xt = xt + Math.imul(Yr, qr) | 0, bt = bt + Math.imul(Yr, Br) | 0, bt = bt + Math.imul(jr, qr) | 0, Dt = Dt + Math.imul(jr, Br) | 0, xt = xt + Math.imul(Mr, Lr) | 0, bt = bt + Math.imul(Mr, Dr) | 0, bt = bt + Math.imul(kr, Lr) | 0, Dt = Dt + Math.imul(kr, Dr) | 0, xt = xt + Math.imul(gr, nn) | 0, bt = bt + Math.imul(gr, tr) | 0, bt = bt + Math.imul($r, nn) | 0, Dt = Dt + Math.imul($r, tr) | 0, xt = xt + Math.imul(zt, rr) | 0, bt = bt + Math.imul(zt, or) | 0, bt = bt + Math.imul(Gt, rr) | 0, Dt = Dt + Math.imul(Gt, or) | 0, xt = xt + Math.imul(qt, vr) | 0, bt = bt + Math.imul(qt, wr) | 0, bt = bt + Math.imul(nr, vr) | 0, Dt = Dt + Math.imul(nr, wr) | 0, xt = xt + Math.imul(fr, Pr) | 0, bt = bt + Math.imul(fr, Ar) | 0, bt = bt + Math.imul(Qt, Pr) | 0, Dt = Dt + Math.imul(Qt, Ar) | 0;
      var un = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, xt = Math.imul(Jr, lr), bt = Math.imul(Jr, dr), bt = bt + Math.imul(Hr, lr) | 0, Dt = Math.imul(Hr, dr), xt = xt + Math.imul(Xr, qr) | 0, bt = bt + Math.imul(Xr, Br) | 0, bt = bt + Math.imul(Or, qr) | 0, Dt = Dt + Math.imul(Or, Br) | 0, xt = xt + Math.imul(Yr, Lr) | 0, bt = bt + Math.imul(Yr, Dr) | 0, bt = bt + Math.imul(jr, Lr) | 0, Dt = Dt + Math.imul(jr, Dr) | 0, xt = xt + Math.imul(Mr, nn) | 0, bt = bt + Math.imul(Mr, tr) | 0, bt = bt + Math.imul(kr, nn) | 0, Dt = Dt + Math.imul(kr, tr) | 0, xt = xt + Math.imul(gr, rr) | 0, bt = bt + Math.imul(gr, or) | 0, bt = bt + Math.imul($r, rr) | 0, Dt = Dt + Math.imul($r, or) | 0, xt = xt + Math.imul(zt, vr) | 0, bt = bt + Math.imul(zt, wr) | 0, bt = bt + Math.imul(Gt, vr) | 0, Dt = Dt + Math.imul(Gt, wr) | 0, xt = xt + Math.imul(qt, Pr) | 0, bt = bt + Math.imul(qt, Ar) | 0, bt = bt + Math.imul(nr, Pr) | 0, Dt = Dt + Math.imul(nr, Ar) | 0, xt = xt + Math.imul(fr, Nr) | 0, bt = bt + Math.imul(fr, Zt) | 0, bt = bt + Math.imul(Qt, Nr) | 0, Dt = Dt + Math.imul(Qt, Zt) | 0;
      var an = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, xt = Math.imul(tn, lr), bt = Math.imul(tn, dr), bt = bt + Math.imul(Wt, lr) | 0, Dt = Math.imul(Wt, dr), xt = xt + Math.imul(Jr, qr) | 0, bt = bt + Math.imul(Jr, Br) | 0, bt = bt + Math.imul(Hr, qr) | 0, Dt = Dt + Math.imul(Hr, Br) | 0, xt = xt + Math.imul(Xr, Lr) | 0, bt = bt + Math.imul(Xr, Dr) | 0, bt = bt + Math.imul(Or, Lr) | 0, Dt = Dt + Math.imul(Or, Dr) | 0, xt = xt + Math.imul(Yr, nn) | 0, bt = bt + Math.imul(Yr, tr) | 0, bt = bt + Math.imul(jr, nn) | 0, Dt = Dt + Math.imul(jr, tr) | 0, xt = xt + Math.imul(Mr, rr) | 0, bt = bt + Math.imul(Mr, or) | 0, bt = bt + Math.imul(kr, rr) | 0, Dt = Dt + Math.imul(kr, or) | 0, xt = xt + Math.imul(gr, vr) | 0, bt = bt + Math.imul(gr, wr) | 0, bt = bt + Math.imul($r, vr) | 0, Dt = Dt + Math.imul($r, wr) | 0, xt = xt + Math.imul(zt, Pr) | 0, bt = bt + Math.imul(zt, Ar) | 0, bt = bt + Math.imul(Gt, Pr) | 0, Dt = Dt + Math.imul(Gt, Ar) | 0, xt = xt + Math.imul(qt, Nr) | 0, bt = bt + Math.imul(qt, Zt) | 0, bt = bt + Math.imul(nr, Nr) | 0, Dt = Dt + Math.imul(nr, Zt) | 0, xt = xt + Math.imul(fr, _r) | 0, bt = bt + Math.imul(fr, Sr) | 0, bt = bt + Math.imul(Qt, _r) | 0, Dt = Dt + Math.imul(Qt, Sr) | 0;
      var dn = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (dn >>> 26) | 0, dn &= 67108863, xt = Math.imul(Nt, lr), bt = Math.imul(Nt, dr), bt = bt + Math.imul(Yt, lr) | 0, Dt = Math.imul(Yt, dr), xt = xt + Math.imul(tn, qr) | 0, bt = bt + Math.imul(tn, Br) | 0, bt = bt + Math.imul(Wt, qr) | 0, Dt = Dt + Math.imul(Wt, Br) | 0, xt = xt + Math.imul(Jr, Lr) | 0, bt = bt + Math.imul(Jr, Dr) | 0, bt = bt + Math.imul(Hr, Lr) | 0, Dt = Dt + Math.imul(Hr, Dr) | 0, xt = xt + Math.imul(Xr, nn) | 0, bt = bt + Math.imul(Xr, tr) | 0, bt = bt + Math.imul(Or, nn) | 0, Dt = Dt + Math.imul(Or, tr) | 0, xt = xt + Math.imul(Yr, rr) | 0, bt = bt + Math.imul(Yr, or) | 0, bt = bt + Math.imul(jr, rr) | 0, Dt = Dt + Math.imul(jr, or) | 0, xt = xt + Math.imul(Mr, vr) | 0, bt = bt + Math.imul(Mr, wr) | 0, bt = bt + Math.imul(kr, vr) | 0, Dt = Dt + Math.imul(kr, wr) | 0, xt = xt + Math.imul(gr, Pr) | 0, bt = bt + Math.imul(gr, Ar) | 0, bt = bt + Math.imul($r, Pr) | 0, Dt = Dt + Math.imul($r, Ar) | 0, xt = xt + Math.imul(zt, Nr) | 0, bt = bt + Math.imul(zt, Zt) | 0, bt = bt + Math.imul(Gt, Nr) | 0, Dt = Dt + Math.imul(Gt, Zt) | 0, xt = xt + Math.imul(qt, _r) | 0, bt = bt + Math.imul(qt, Sr) | 0, bt = bt + Math.imul(nr, _r) | 0, Dt = Dt + Math.imul(nr, Sr) | 0, xt = xt + Math.imul(fr, Fr) | 0, bt = bt + Math.imul(fr, Rr) | 0, bt = bt + Math.imul(Qt, Fr) | 0, Dt = Dt + Math.imul(Qt, Rr) | 0;
      var hn = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (hn >>> 26) | 0, hn &= 67108863, xt = Math.imul(Nt, qr), bt = Math.imul(Nt, Br), bt = bt + Math.imul(Yt, qr) | 0, Dt = Math.imul(Yt, Br), xt = xt + Math.imul(tn, Lr) | 0, bt = bt + Math.imul(tn, Dr) | 0, bt = bt + Math.imul(Wt, Lr) | 0, Dt = Dt + Math.imul(Wt, Dr) | 0, xt = xt + Math.imul(Jr, nn) | 0, bt = bt + Math.imul(Jr, tr) | 0, bt = bt + Math.imul(Hr, nn) | 0, Dt = Dt + Math.imul(Hr, tr) | 0, xt = xt + Math.imul(Xr, rr) | 0, bt = bt + Math.imul(Xr, or) | 0, bt = bt + Math.imul(Or, rr) | 0, Dt = Dt + Math.imul(Or, or) | 0, xt = xt + Math.imul(Yr, vr) | 0, bt = bt + Math.imul(Yr, wr) | 0, bt = bt + Math.imul(jr, vr) | 0, Dt = Dt + Math.imul(jr, wr) | 0, xt = xt + Math.imul(Mr, Pr) | 0, bt = bt + Math.imul(Mr, Ar) | 0, bt = bt + Math.imul(kr, Pr) | 0, Dt = Dt + Math.imul(kr, Ar) | 0, xt = xt + Math.imul(gr, Nr) | 0, bt = bt + Math.imul(gr, Zt) | 0, bt = bt + Math.imul($r, Nr) | 0, Dt = Dt + Math.imul($r, Zt) | 0, xt = xt + Math.imul(zt, _r) | 0, bt = bt + Math.imul(zt, Sr) | 0, bt = bt + Math.imul(Gt, _r) | 0, Dt = Dt + Math.imul(Gt, Sr) | 0, xt = xt + Math.imul(qt, Fr) | 0, bt = bt + Math.imul(qt, Rr) | 0, bt = bt + Math.imul(nr, Fr) | 0, Dt = Dt + Math.imul(nr, Rr) | 0;
      var pn = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, xt = Math.imul(Nt, Lr), bt = Math.imul(Nt, Dr), bt = bt + Math.imul(Yt, Lr) | 0, Dt = Math.imul(Yt, Dr), xt = xt + Math.imul(tn, nn) | 0, bt = bt + Math.imul(tn, tr) | 0, bt = bt + Math.imul(Wt, nn) | 0, Dt = Dt + Math.imul(Wt, tr) | 0, xt = xt + Math.imul(Jr, rr) | 0, bt = bt + Math.imul(Jr, or) | 0, bt = bt + Math.imul(Hr, rr) | 0, Dt = Dt + Math.imul(Hr, or) | 0, xt = xt + Math.imul(Xr, vr) | 0, bt = bt + Math.imul(Xr, wr) | 0, bt = bt + Math.imul(Or, vr) | 0, Dt = Dt + Math.imul(Or, wr) | 0, xt = xt + Math.imul(Yr, Pr) | 0, bt = bt + Math.imul(Yr, Ar) | 0, bt = bt + Math.imul(jr, Pr) | 0, Dt = Dt + Math.imul(jr, Ar) | 0, xt = xt + Math.imul(Mr, Nr) | 0, bt = bt + Math.imul(Mr, Zt) | 0, bt = bt + Math.imul(kr, Nr) | 0, Dt = Dt + Math.imul(kr, Zt) | 0, xt = xt + Math.imul(gr, _r) | 0, bt = bt + Math.imul(gr, Sr) | 0, bt = bt + Math.imul($r, _r) | 0, Dt = Dt + Math.imul($r, Sr) | 0, xt = xt + Math.imul(zt, Fr) | 0, bt = bt + Math.imul(zt, Rr) | 0, bt = bt + Math.imul(Gt, Fr) | 0, Dt = Dt + Math.imul(Gt, Rr) | 0;
      var yn = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (yn >>> 26) | 0, yn &= 67108863, xt = Math.imul(Nt, nn), bt = Math.imul(Nt, tr), bt = bt + Math.imul(Yt, nn) | 0, Dt = Math.imul(Yt, tr), xt = xt + Math.imul(tn, rr) | 0, bt = bt + Math.imul(tn, or) | 0, bt = bt + Math.imul(Wt, rr) | 0, Dt = Dt + Math.imul(Wt, or) | 0, xt = xt + Math.imul(Jr, vr) | 0, bt = bt + Math.imul(Jr, wr) | 0, bt = bt + Math.imul(Hr, vr) | 0, Dt = Dt + Math.imul(Hr, wr) | 0, xt = xt + Math.imul(Xr, Pr) | 0, bt = bt + Math.imul(Xr, Ar) | 0, bt = bt + Math.imul(Or, Pr) | 0, Dt = Dt + Math.imul(Or, Ar) | 0, xt = xt + Math.imul(Yr, Nr) | 0, bt = bt + Math.imul(Yr, Zt) | 0, bt = bt + Math.imul(jr, Nr) | 0, Dt = Dt + Math.imul(jr, Zt) | 0, xt = xt + Math.imul(Mr, _r) | 0, bt = bt + Math.imul(Mr, Sr) | 0, bt = bt + Math.imul(kr, _r) | 0, Dt = Dt + Math.imul(kr, Sr) | 0, xt = xt + Math.imul(gr, Fr) | 0, bt = bt + Math.imul(gr, Rr) | 0, bt = bt + Math.imul($r, Fr) | 0, Dt = Dt + Math.imul($r, Rr) | 0;
      var mn = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (mn >>> 26) | 0, mn &= 67108863, xt = Math.imul(Nt, rr), bt = Math.imul(Nt, or), bt = bt + Math.imul(Yt, rr) | 0, Dt = Math.imul(Yt, or), xt = xt + Math.imul(tn, vr) | 0, bt = bt + Math.imul(tn, wr) | 0, bt = bt + Math.imul(Wt, vr) | 0, Dt = Dt + Math.imul(Wt, wr) | 0, xt = xt + Math.imul(Jr, Pr) | 0, bt = bt + Math.imul(Jr, Ar) | 0, bt = bt + Math.imul(Hr, Pr) | 0, Dt = Dt + Math.imul(Hr, Ar) | 0, xt = xt + Math.imul(Xr, Nr) | 0, bt = bt + Math.imul(Xr, Zt) | 0, bt = bt + Math.imul(Or, Nr) | 0, Dt = Dt + Math.imul(Or, Zt) | 0, xt = xt + Math.imul(Yr, _r) | 0, bt = bt + Math.imul(Yr, Sr) | 0, bt = bt + Math.imul(jr, _r) | 0, Dt = Dt + Math.imul(jr, Sr) | 0, xt = xt + Math.imul(Mr, Fr) | 0, bt = bt + Math.imul(Mr, Rr) | 0, bt = bt + Math.imul(kr, Fr) | 0, Dt = Dt + Math.imul(kr, Rr) | 0;
      var vn = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (vn >>> 26) | 0, vn &= 67108863, xt = Math.imul(Nt, vr), bt = Math.imul(Nt, wr), bt = bt + Math.imul(Yt, vr) | 0, Dt = Math.imul(Yt, wr), xt = xt + Math.imul(tn, Pr) | 0, bt = bt + Math.imul(tn, Ar) | 0, bt = bt + Math.imul(Wt, Pr) | 0, Dt = Dt + Math.imul(Wt, Ar) | 0, xt = xt + Math.imul(Jr, Nr) | 0, bt = bt + Math.imul(Jr, Zt) | 0, bt = bt + Math.imul(Hr, Nr) | 0, Dt = Dt + Math.imul(Hr, Zt) | 0, xt = xt + Math.imul(Xr, _r) | 0, bt = bt + Math.imul(Xr, Sr) | 0, bt = bt + Math.imul(Or, _r) | 0, Dt = Dt + Math.imul(Or, Sr) | 0, xt = xt + Math.imul(Yr, Fr) | 0, bt = bt + Math.imul(Yr, Rr) | 0, bt = bt + Math.imul(jr, Fr) | 0, Dt = Dt + Math.imul(jr, Rr) | 0;
      var gn = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (gn >>> 26) | 0, gn &= 67108863, xt = Math.imul(Nt, Pr), bt = Math.imul(Nt, Ar), bt = bt + Math.imul(Yt, Pr) | 0, Dt = Math.imul(Yt, Ar), xt = xt + Math.imul(tn, Nr) | 0, bt = bt + Math.imul(tn, Zt) | 0, bt = bt + Math.imul(Wt, Nr) | 0, Dt = Dt + Math.imul(Wt, Zt) | 0, xt = xt + Math.imul(Jr, _r) | 0, bt = bt + Math.imul(Jr, Sr) | 0, bt = bt + Math.imul(Hr, _r) | 0, Dt = Dt + Math.imul(Hr, Sr) | 0, xt = xt + Math.imul(Xr, Fr) | 0, bt = bt + Math.imul(Xr, Rr) | 0, bt = bt + Math.imul(Or, Fr) | 0, Dt = Dt + Math.imul(Or, Rr) | 0;
      var wn = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (wn >>> 26) | 0, wn &= 67108863, xt = Math.imul(Nt, Nr), bt = Math.imul(Nt, Zt), bt = bt + Math.imul(Yt, Nr) | 0, Dt = Math.imul(Yt, Zt), xt = xt + Math.imul(tn, _r) | 0, bt = bt + Math.imul(tn, Sr) | 0, bt = bt + Math.imul(Wt, _r) | 0, Dt = Dt + Math.imul(Wt, Sr) | 0, xt = xt + Math.imul(Jr, Fr) | 0, bt = bt + Math.imul(Jr, Rr) | 0, bt = bt + Math.imul(Hr, Fr) | 0, Dt = Dt + Math.imul(Hr, Rr) | 0;
      var _n = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + (_n >>> 26) | 0, _n &= 67108863, xt = Math.imul(Nt, _r), bt = Math.imul(Nt, Sr), bt = bt + Math.imul(Yt, _r) | 0, Dt = Math.imul(Yt, Sr), xt = xt + Math.imul(tn, Fr) | 0, bt = bt + Math.imul(tn, Rr) | 0, bt = bt + Math.imul(Wt, Fr) | 0, Dt = Dt + Math.imul(Wt, Rr) | 0;
      var $n = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Dt + (bt >>> 13) | 0) + ($n >>> 26) | 0, $n &= 67108863, xt = Math.imul(Nt, Fr), bt = Math.imul(Nt, Rr), bt = bt + Math.imul(Yt, Fr) | 0, Dt = Math.imul(Yt, Rr);
      var En = (Qe + xt | 0) + ((bt & 8191) << 13) | 0;
      return Qe = (Dt + (bt >>> 13) | 0) + (En >>> 26) | 0, En &= 67108863, $t[0] = Gr, $t[1] = sn, $t[2] = en, $t[3] = on, $t[4] = cn, $t[5] = ln, $t[6] = un, $t[7] = an, $t[8] = dn, $t[9] = hn, $t[10] = pn, $t[11] = yn, $t[12] = mn, $t[13] = vn, $t[14] = gn, $t[15] = wn, $t[16] = _n, $t[17] = $n, $t[18] = En, Qe !== 0 && ($t[19] = Qe, ht.length++), ht;
    };
    Math.imul || (Pt = Lt);
    function Ft(Ve, ge, Ke) {
      Ke.negative = ge.negative ^ Ve.negative, Ke.length = Ve.length + ge.length;
      for (var ht = 0, wt = 0, vt = 0; vt < Ke.length - 1; vt++) {
        var $t = wt;
        wt = 0;
        for (var Qe = ht & 67108863, xt = Math.min(vt, ge.length - 1), bt = Math.max(0, vt - Ve.length + 1); bt <= xt; bt++) {
          var Dt = vt - bt, er = Ve.words[Dt] | 0, fr = ge.words[bt] | 0, Qt = er * fr, Ht = Qt & 67108863;
          $t = $t + (Qt / 67108864 | 0) | 0, Ht = Ht + Qe | 0, Qe = Ht & 67108863, $t = $t + (Ht >>> 26) | 0, wt += $t >>> 26, $t &= 67108863;
        }
        Ke.words[vt] = Qe, ht = $t, $t = wt;
      }
      return ht !== 0 ? Ke.words[vt] = ht : Ke.length--, Ke._strip();
    }
    function Ut(Ve, ge, Ke) {
      return Ft(Ve, ge, Ke);
    }
    oe.prototype.mulTo = function(ge, Ke) {
      var ht, wt = this.length + ge.length;
      return this.length === 10 && ge.length === 10 ? ht = Pt(this, ge, Ke) : wt < 63 ? ht = Lt(this, ge, Ke) : wt < 1024 ? ht = Ft(this, ge, Ke) : ht = Ut(this, ge, Ke), ht;
    }, oe.prototype.mul = function(ge) {
      var Ke = new oe(null);
      return Ke.words = new Array(this.length + ge.length), this.mulTo(ge, Ke);
    }, oe.prototype.mulf = function(ge) {
      var Ke = new oe(null);
      return Ke.words = new Array(this.length + ge.length), Ut(this, ge, Ke);
    }, oe.prototype.imul = function(ge) {
      return this.clone().mulTo(ge, this);
    }, oe.prototype.imuln = function(ge) {
      var Ke = ge < 0;
      Ke && (ge = -ge), ne(typeof ge == "number"), ne(ge < 67108864);
      for (var ht = 0, wt = 0; wt < this.length; wt++) {
        var vt = (this.words[wt] | 0) * ge, $t = (vt & 67108863) + (ht & 67108863);
        ht >>= 26, ht += vt / 67108864 | 0, ht += $t >>> 26, this.words[wt] = $t & 67108863;
      }
      return ht !== 0 && (this.words[wt] = ht, this.length++), Ke ? this.ineg() : this;
    }, oe.prototype.muln = function(ge) {
      return this.clone().imuln(ge);
    }, oe.prototype.sqr = function() {
      return this.mul(this);
    }, oe.prototype.isqr = function() {
      return this.imul(this.clone());
    }, oe.prototype.pow = function(ge) {
      var Ke = Ct(ge);
      if (Ke.length === 0) return new oe(1);
      for (var ht = this, wt = 0; wt < Ke.length && Ke[wt] === 0; wt++, ht = ht.sqr())
        ;
      if (++wt < Ke.length)
        for (var vt = ht.sqr(); wt < Ke.length; wt++, vt = vt.sqr())
          Ke[wt] !== 0 && (ht = ht.mul(vt));
      return ht;
    }, oe.prototype.iushln = function(ge) {
      ne(typeof ge == "number" && ge >= 0);
      var Ke = ge % 26, ht = (ge - Ke) / 26, wt = 67108863 >>> 26 - Ke << 26 - Ke, vt;
      if (Ke !== 0) {
        var $t = 0;
        for (vt = 0; vt < this.length; vt++) {
          var Qe = this.words[vt] & wt, xt = (this.words[vt] | 0) - Qe << Ke;
          this.words[vt] = xt | $t, $t = Qe >>> 26 - Ke;
        }
        $t && (this.words[vt] = $t, this.length++);
      }
      if (ht !== 0) {
        for (vt = this.length - 1; vt >= 0; vt--)
          this.words[vt + ht] = this.words[vt];
        for (vt = 0; vt < ht; vt++)
          this.words[vt] = 0;
        this.length += ht;
      }
      return this._strip();
    }, oe.prototype.ishln = function(ge) {
      return ne(this.negative === 0), this.iushln(ge);
    }, oe.prototype.iushrn = function(ge, Ke, ht) {
      ne(typeof ge == "number" && ge >= 0);
      var wt;
      Ke ? wt = (Ke - Ke % 26) / 26 : wt = 0;
      var vt = ge % 26, $t = Math.min((ge - vt) / 26, this.length), Qe = 67108863 ^ 67108863 >>> vt << vt, xt = ht;
      if (wt -= $t, wt = Math.max(0, wt), xt) {
        for (var bt = 0; bt < $t; bt++)
          xt.words[bt] = this.words[bt];
        xt.length = $t;
      }
      if ($t !== 0) if (this.length > $t)
        for (this.length -= $t, bt = 0; bt < this.length; bt++)
          this.words[bt] = this.words[bt + $t];
      else
        this.words[0] = 0, this.length = 1;
      var Dt = 0;
      for (bt = this.length - 1; bt >= 0 && (Dt !== 0 || bt >= wt); bt--) {
        var er = this.words[bt] | 0;
        this.words[bt] = Dt << 26 - vt | er >>> vt, Dt = er & Qe;
      }
      return xt && Dt !== 0 && (xt.words[xt.length++] = Dt), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, oe.prototype.ishrn = function(ge, Ke, ht) {
      return ne(this.negative === 0), this.iushrn(ge, Ke, ht);
    }, oe.prototype.shln = function(ge) {
      return this.clone().ishln(ge);
    }, oe.prototype.ushln = function(ge) {
      return this.clone().iushln(ge);
    }, oe.prototype.shrn = function(ge) {
      return this.clone().ishrn(ge);
    }, oe.prototype.ushrn = function(ge) {
      return this.clone().iushrn(ge);
    }, oe.prototype.testn = function(ge) {
      ne(typeof ge == "number" && ge >= 0);
      var Ke = ge % 26, ht = (ge - Ke) / 26, wt = 1 << Ke;
      if (this.length <= ht) return !1;
      var vt = this.words[ht];
      return !!(vt & wt);
    }, oe.prototype.imaskn = function(ge) {
      ne(typeof ge == "number" && ge >= 0);
      var Ke = ge % 26, ht = (ge - Ke) / 26;
      if (ne(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ht)
        return this;
      if (Ke !== 0 && ht++, this.length = Math.min(ht, this.length), Ke !== 0) {
        var wt = 67108863 ^ 67108863 >>> Ke << Ke;
        this.words[this.length - 1] &= wt;
      }
      return this._strip();
    }, oe.prototype.maskn = function(ge) {
      return this.clone().imaskn(ge);
    }, oe.prototype.iaddn = function(ge) {
      return ne(typeof ge == "number"), ne(ge < 67108864), ge < 0 ? this.isubn(-ge) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= ge ? (this.words[0] = ge - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(ge), this.negative = 1, this) : this._iaddn(ge);
    }, oe.prototype._iaddn = function(ge) {
      this.words[0] += ge;
      for (var Ke = 0; Ke < this.length && this.words[Ke] >= 67108864; Ke++)
        this.words[Ke] -= 67108864, Ke === this.length - 1 ? this.words[Ke + 1] = 1 : this.words[Ke + 1]++;
      return this.length = Math.max(this.length, Ke + 1), this;
    }, oe.prototype.isubn = function(ge) {
      if (ne(typeof ge == "number"), ne(ge < 67108864), ge < 0) return this.iaddn(-ge);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(ge), this.negative = 1, this;
      if (this.words[0] -= ge, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var Ke = 0; Ke < this.length && this.words[Ke] < 0; Ke++)
          this.words[Ke] += 67108864, this.words[Ke + 1] -= 1;
      return this._strip();
    }, oe.prototype.addn = function(ge) {
      return this.clone().iaddn(ge);
    }, oe.prototype.subn = function(ge) {
      return this.clone().isubn(ge);
    }, oe.prototype.iabs = function() {
      return this.negative = 0, this;
    }, oe.prototype.abs = function() {
      return this.clone().iabs();
    }, oe.prototype._ishlnsubmul = function(ge, Ke, ht) {
      var wt = ge.length + ht, vt;
      this._expand(wt);
      var $t, Qe = 0;
      for (vt = 0; vt < ge.length; vt++) {
        $t = (this.words[vt + ht] | 0) + Qe;
        var xt = (ge.words[vt] | 0) * Ke;
        $t -= xt & 67108863, Qe = ($t >> 26) - (xt / 67108864 | 0), this.words[vt + ht] = $t & 67108863;
      }
      for (; vt < this.length - ht; vt++)
        $t = (this.words[vt + ht] | 0) + Qe, Qe = $t >> 26, this.words[vt + ht] = $t & 67108863;
      if (Qe === 0) return this._strip();
      for (ne(Qe === -1), Qe = 0, vt = 0; vt < this.length; vt++)
        $t = -(this.words[vt] | 0) + Qe, Qe = $t >> 26, this.words[vt] = $t & 67108863;
      return this.negative = 1, this._strip();
    }, oe.prototype._wordDiv = function(ge, Ke) {
      var ht = this.length - ge.length, wt = this.clone(), vt = ge, $t = vt.words[vt.length - 1] | 0, Qe = this._countBits($t);
      ht = 26 - Qe, ht !== 0 && (vt = vt.ushln(ht), wt.iushln(ht), $t = vt.words[vt.length - 1] | 0);
      var xt = wt.length - vt.length, bt;
      if (Ke !== "mod") {
        bt = new oe(null), bt.length = xt + 1, bt.words = new Array(bt.length);
        for (var Dt = 0; Dt < bt.length; Dt++)
          bt.words[Dt] = 0;
      }
      var er = wt.clone()._ishlnsubmul(vt, 1, xt);
      er.negative === 0 && (wt = er, bt && (bt.words[xt] = 1));
      for (var fr = xt - 1; fr >= 0; fr--) {
        var Qt = (wt.words[vt.length + fr] | 0) * 67108864 + (wt.words[vt.length + fr - 1] | 0);
        for (Qt = Math.min(Qt / $t | 0, 67108863), wt._ishlnsubmul(vt, Qt, fr); wt.negative !== 0; )
          Qt--, wt.negative = 0, wt._ishlnsubmul(vt, 1, fr), wt.isZero() || (wt.negative ^= 1);
        bt && (bt.words[fr] = Qt);
      }
      return bt && bt._strip(), wt._strip(), Ke !== "div" && ht !== 0 && wt.iushrn(ht), {
        div: bt || null,
        mod: wt
      };
    }, oe.prototype.divmod = function(ge, Ke, ht) {
      if (ne(!ge.isZero()), this.isZero())
        return {
          div: new oe(0),
          mod: new oe(0)
        };
      var wt, vt, $t;
      return this.negative !== 0 && ge.negative === 0 ? ($t = this.neg().divmod(ge, Ke), Ke !== "mod" && (wt = $t.div.neg()), Ke !== "div" && (vt = $t.mod.neg(), ht && vt.negative !== 0 && vt.iadd(ge)), {
        div: wt,
        mod: vt
      }) : this.negative === 0 && ge.negative !== 0 ? ($t = this.divmod(ge.neg(), Ke), Ke !== "mod" && (wt = $t.div.neg()), {
        div: wt,
        mod: $t.mod
      }) : this.negative & ge.negative ? ($t = this.neg().divmod(ge.neg(), Ke), Ke !== "div" && (vt = $t.mod.neg(), ht && vt.negative !== 0 && vt.isub(ge)), {
        div: $t.div,
        mod: vt
      }) : ge.length > this.length || this.cmp(ge) < 0 ? {
        div: new oe(0),
        mod: this
      } : ge.length === 1 ? Ke === "div" ? {
        div: this.divn(ge.words[0]),
        mod: null
      } : Ke === "mod" ? {
        div: null,
        mod: new oe(this.modrn(ge.words[0]))
      } : {
        div: this.divn(ge.words[0]),
        mod: new oe(this.modrn(ge.words[0]))
      } : this._wordDiv(ge, Ke);
    }, oe.prototype.div = function(ge) {
      return this.divmod(ge, "div", !1).div;
    }, oe.prototype.mod = function(ge) {
      return this.divmod(ge, "mod", !1).mod;
    }, oe.prototype.umod = function(ge) {
      return this.divmod(ge, "mod", !0).mod;
    }, oe.prototype.divRound = function(ge) {
      var Ke = this.divmod(ge);
      if (Ke.mod.isZero()) return Ke.div;
      var ht = Ke.div.negative !== 0 ? Ke.mod.isub(ge) : Ke.mod, wt = ge.ushrn(1), vt = ge.andln(1), $t = ht.cmp(wt);
      return $t < 0 || vt === 1 && $t === 0 ? Ke.div : Ke.div.negative !== 0 ? Ke.div.isubn(1) : Ke.div.iaddn(1);
    }, oe.prototype.modrn = function(ge) {
      var Ke = ge < 0;
      Ke && (ge = -ge), ne(ge <= 67108863);
      for (var ht = (1 << 26) % ge, wt = 0, vt = this.length - 1; vt >= 0; vt--)
        wt = (ht * wt + (this.words[vt] | 0)) % ge;
      return Ke ? -wt : wt;
    }, oe.prototype.modn = function(ge) {
      return this.modrn(ge);
    }, oe.prototype.idivn = function(ge) {
      var Ke = ge < 0;
      Ke && (ge = -ge), ne(ge <= 67108863);
      for (var ht = 0, wt = this.length - 1; wt >= 0; wt--) {
        var vt = (this.words[wt] | 0) + ht * 67108864;
        this.words[wt] = vt / ge | 0, ht = vt % ge;
      }
      return this._strip(), Ke ? this.ineg() : this;
    }, oe.prototype.divn = function(ge) {
      return this.clone().idivn(ge);
    }, oe.prototype.egcd = function(ge) {
      ne(ge.negative === 0), ne(!ge.isZero());
      var Ke = this, ht = ge.clone();
      Ke.negative !== 0 ? Ke = Ke.umod(ge) : Ke = Ke.clone();
      for (var wt = new oe(1), vt = new oe(0), $t = new oe(0), Qe = new oe(1), xt = 0; Ke.isEven() && ht.isEven(); )
        Ke.iushrn(1), ht.iushrn(1), ++xt;
      for (var bt = ht.clone(), Dt = Ke.clone(); !Ke.isZero(); ) {
        for (var er = 0, fr = 1; !(Ke.words[0] & fr) && er < 26; ++er, fr <<= 1) ;
        if (er > 0)
          for (Ke.iushrn(er); er-- > 0; )
            (wt.isOdd() || vt.isOdd()) && (wt.iadd(bt), vt.isub(Dt)), wt.iushrn(1), vt.iushrn(1);
        for (var Qt = 0, Ht = 1; !(ht.words[0] & Ht) && Qt < 26; ++Qt, Ht <<= 1) ;
        if (Qt > 0)
          for (ht.iushrn(Qt); Qt-- > 0; )
            ($t.isOdd() || Qe.isOdd()) && ($t.iadd(bt), Qe.isub(Dt)), $t.iushrn(1), Qe.iushrn(1);
        Ke.cmp(ht) >= 0 ? (Ke.isub(ht), wt.isub($t), vt.isub(Qe)) : (ht.isub(Ke), $t.isub(wt), Qe.isub(vt));
      }
      return {
        a: $t,
        b: Qe,
        gcd: ht.iushln(xt)
      };
    }, oe.prototype._invmp = function(ge) {
      ne(ge.negative === 0), ne(!ge.isZero());
      var Ke = this, ht = ge.clone();
      Ke.negative !== 0 ? Ke = Ke.umod(ge) : Ke = Ke.clone();
      for (var wt = new oe(1), vt = new oe(0), $t = ht.clone(); Ke.cmpn(1) > 0 && ht.cmpn(1) > 0; ) {
        for (var Qe = 0, xt = 1; !(Ke.words[0] & xt) && Qe < 26; ++Qe, xt <<= 1) ;
        if (Qe > 0)
          for (Ke.iushrn(Qe); Qe-- > 0; )
            wt.isOdd() && wt.iadd($t), wt.iushrn(1);
        for (var bt = 0, Dt = 1; !(ht.words[0] & Dt) && bt < 26; ++bt, Dt <<= 1) ;
        if (bt > 0)
          for (ht.iushrn(bt); bt-- > 0; )
            vt.isOdd() && vt.iadd($t), vt.iushrn(1);
        Ke.cmp(ht) >= 0 ? (Ke.isub(ht), wt.isub(vt)) : (ht.isub(Ke), vt.isub(wt));
      }
      var er;
      return Ke.cmpn(1) === 0 ? er = wt : er = vt, er.cmpn(0) < 0 && er.iadd(ge), er;
    }, oe.prototype.gcd = function(ge) {
      if (this.isZero()) return ge.abs();
      if (ge.isZero()) return this.abs();
      var Ke = this.clone(), ht = ge.clone();
      Ke.negative = 0, ht.negative = 0;
      for (var wt = 0; Ke.isEven() && ht.isEven(); wt++)
        Ke.iushrn(1), ht.iushrn(1);
      do {
        for (; Ke.isEven(); )
          Ke.iushrn(1);
        for (; ht.isEven(); )
          ht.iushrn(1);
        var vt = Ke.cmp(ht);
        if (vt < 0) {
          var $t = Ke;
          Ke = ht, ht = $t;
        } else if (vt === 0 || ht.cmpn(1) === 0)
          break;
        Ke.isub(ht);
      } while (!0);
      return ht.iushln(wt);
    }, oe.prototype.invm = function(ge) {
      return this.egcd(ge).a.umod(ge);
    }, oe.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, oe.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, oe.prototype.andln = function(ge) {
      return this.words[0] & ge;
    }, oe.prototype.bincn = function(ge) {
      ne(typeof ge == "number");
      var Ke = ge % 26, ht = (ge - Ke) / 26, wt = 1 << Ke;
      if (this.length <= ht)
        return this._expand(ht + 1), this.words[ht] |= wt, this;
      for (var vt = wt, $t = ht; vt !== 0 && $t < this.length; $t++) {
        var Qe = this.words[$t] | 0;
        Qe += vt, vt = Qe >>> 26, Qe &= 67108863, this.words[$t] = Qe;
      }
      return vt !== 0 && (this.words[$t] = vt, this.length++), this;
    }, oe.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, oe.prototype.cmpn = function(ge) {
      var Ke = ge < 0;
      if (this.negative !== 0 && !Ke) return -1;
      if (this.negative === 0 && Ke) return 1;
      this._strip();
      var ht;
      if (this.length > 1)
        ht = 1;
      else {
        Ke && (ge = -ge), ne(ge <= 67108863, "Number is too big");
        var wt = this.words[0] | 0;
        ht = wt === ge ? 0 : wt < ge ? -1 : 1;
      }
      return this.negative !== 0 ? -ht | 0 : ht;
    }, oe.prototype.cmp = function(ge) {
      if (this.negative !== 0 && ge.negative === 0) return -1;
      if (this.negative === 0 && ge.negative !== 0) return 1;
      var Ke = this.ucmp(ge);
      return this.negative !== 0 ? -Ke | 0 : Ke;
    }, oe.prototype.ucmp = function(ge) {
      if (this.length > ge.length) return 1;
      if (this.length < ge.length) return -1;
      for (var Ke = 0, ht = this.length - 1; ht >= 0; ht--) {
        var wt = this.words[ht] | 0, vt = ge.words[ht] | 0;
        if (wt !== vt) {
          wt < vt ? Ke = -1 : wt > vt && (Ke = 1);
          break;
        }
      }
      return Ke;
    }, oe.prototype.gtn = function(ge) {
      return this.cmpn(ge) === 1;
    }, oe.prototype.gt = function(ge) {
      return this.cmp(ge) === 1;
    }, oe.prototype.gten = function(ge) {
      return this.cmpn(ge) >= 0;
    }, oe.prototype.gte = function(ge) {
      return this.cmp(ge) >= 0;
    }, oe.prototype.ltn = function(ge) {
      return this.cmpn(ge) === -1;
    }, oe.prototype.lt = function(ge) {
      return this.cmp(ge) === -1;
    }, oe.prototype.lten = function(ge) {
      return this.cmpn(ge) <= 0;
    }, oe.prototype.lte = function(ge) {
      return this.cmp(ge) <= 0;
    }, oe.prototype.eqn = function(ge) {
      return this.cmpn(ge) === 0;
    }, oe.prototype.eq = function(ge) {
      return this.cmp(ge) === 0;
    }, oe.red = function(ge) {
      return new Bt(ge);
    }, oe.prototype.toRed = function(ge) {
      return ne(!this.red, "Already a number in reduction context"), ne(this.negative === 0, "red works only with positives"), ge.convertTo(this)._forceRed(ge);
    }, oe.prototype.fromRed = function() {
      return ne(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, oe.prototype._forceRed = function(ge) {
      return this.red = ge, this;
    }, oe.prototype.forceRed = function(ge) {
      return ne(!this.red, "Already a number in reduction context"), this._forceRed(ge);
    }, oe.prototype.redAdd = function(ge) {
      return ne(this.red, "redAdd works only with red numbers"), this.red.add(this, ge);
    }, oe.prototype.redIAdd = function(ge) {
      return ne(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, ge);
    }, oe.prototype.redSub = function(ge) {
      return ne(this.red, "redSub works only with red numbers"), this.red.sub(this, ge);
    }, oe.prototype.redISub = function(ge) {
      return ne(this.red, "redISub works only with red numbers"), this.red.isub(this, ge);
    }, oe.prototype.redShl = function(ge) {
      return ne(this.red, "redShl works only with red numbers"), this.red.shl(this, ge);
    }, oe.prototype.redMul = function(ge) {
      return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, ge), this.red.mul(this, ge);
    }, oe.prototype.redIMul = function(ge) {
      return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, ge), this.red.imul(this, ge);
    }, oe.prototype.redSqr = function() {
      return ne(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, oe.prototype.redISqr = function() {
      return ne(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, oe.prototype.redSqrt = function() {
      return ne(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, oe.prototype.redInvm = function() {
      return ne(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, oe.prototype.redNeg = function() {
      return ne(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, oe.prototype.redPow = function(ge) {
      return ne(this.red && !ge.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, ge);
    };
    var Jt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Vt(Ve, ge) {
      this.name = Ve, this.p = new oe(ge, 16), this.n = this.p.bitLength(), this.k = new oe(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Vt.prototype._tmp = function() {
      var ge = new oe(null);
      return ge.words = new Array(Math.ceil(this.n / 13)), ge;
    }, Vt.prototype.ireduce = function(ge) {
      var Ke = ge, ht;
      do
        this.split(Ke, this.tmp), Ke = this.imulK(Ke), Ke = Ke.iadd(this.tmp), ht = Ke.bitLength();
      while (ht > this.n);
      var wt = ht < this.n ? -1 : Ke.ucmp(this.p);
      return wt === 0 ? (Ke.words[0] = 0, Ke.length = 1) : wt > 0 ? Ke.isub(this.p) : Ke.strip !== void 0 ? Ke.strip() : Ke._strip(), Ke;
    }, Vt.prototype.split = function(ge, Ke) {
      ge.iushrn(this.n, 0, Ke);
    }, Vt.prototype.imulK = function(ge) {
      return ge.imul(this.k);
    };
    function ir() {
      Vt.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    ie(ir, Vt), ir.prototype.split = function(ge, Ke) {
      for (var ht = 4194303, wt = Math.min(ge.length, 9), vt = 0; vt < wt; vt++)
        Ke.words[vt] = ge.words[vt];
      if (Ke.length = wt, ge.length <= 9) {
        ge.words[0] = 0, ge.length = 1;
        return;
      }
      var $t = ge.words[9];
      for (Ke.words[Ke.length++] = $t & ht, vt = 10; vt < ge.length; vt++) {
        var Qe = ge.words[vt] | 0;
        ge.words[vt - 10] = (Qe & ht) << 4 | $t >>> 22, $t = Qe;
      }
      $t >>>= 22, ge.words[vt - 10] = $t, $t === 0 && ge.length > 10 ? ge.length -= 10 : ge.length -= 9;
    }, ir.prototype.imulK = function(ge) {
      ge.words[ge.length] = 0, ge.words[ge.length + 1] = 0, ge.length += 2;
      for (var Ke = 0, ht = 0; ht < ge.length; ht++) {
        var wt = ge.words[ht] | 0;
        Ke += wt * 977, ge.words[ht] = Ke & 67108863, Ke = wt * 64 + (Ke / 67108864 | 0);
      }
      return ge.words[ge.length - 1] === 0 && (ge.length--, ge.words[ge.length - 1] === 0 && ge.length--), ge;
    };
    function jt() {
      Vt.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    ie(jt, Vt);
    function Rt() {
      Vt.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    ie(Rt, Vt);
    function Kt() {
      Vt.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    ie(Kt, Vt), Kt.prototype.imulK = function(ge) {
      for (var Ke = 0, ht = 0; ht < ge.length; ht++) {
        var wt = (ge.words[ht] | 0) * 19 + Ke, vt = wt & 67108863;
        wt >>>= 26, ge.words[ht] = vt, Ke = wt;
      }
      return Ke !== 0 && (ge.words[ge.length++] = Ke), ge;
    }, oe._prime = function(ge) {
      if (Jt[ge]) return Jt[ge];
      var Ke;
      if (ge === "k256")
        Ke = new ir();
      else if (ge === "p224")
        Ke = new jt();
      else if (ge === "p192")
        Ke = new Rt();
      else if (ge === "p25519")
        Ke = new Kt();
      else
        throw new Error("Unknown prime " + ge);
      return Jt[ge] = Ke, Ke;
    };
    function Bt(Ve) {
      if (typeof Ve == "string") {
        var ge = oe._prime(Ve);
        this.m = ge.p, this.prime = ge;
      } else
        ne(Ve.gtn(1), "modulus must be greater than 1"), this.m = Ve, this.prime = null;
    }
    Bt.prototype._verify1 = function(ge) {
      ne(ge.negative === 0, "red works only with positives"), ne(ge.red, "red works only with red numbers");
    }, Bt.prototype._verify2 = function(ge, Ke) {
      ne((ge.negative | Ke.negative) === 0, "red works only with positives"), ne(
        ge.red && ge.red === Ke.red,
        "red works only with red numbers"
      );
    }, Bt.prototype.imod = function(ge) {
      return this.prime ? this.prime.ireduce(ge)._forceRed(this) : (le(ge, ge.umod(this.m)._forceRed(this)), ge);
    }, Bt.prototype.neg = function(ge) {
      return ge.isZero() ? ge.clone() : this.m.sub(ge)._forceRed(this);
    }, Bt.prototype.add = function(ge, Ke) {
      this._verify2(ge, Ke);
      var ht = ge.add(Ke);
      return ht.cmp(this.m) >= 0 && ht.isub(this.m), ht._forceRed(this);
    }, Bt.prototype.iadd = function(ge, Ke) {
      this._verify2(ge, Ke);
      var ht = ge.iadd(Ke);
      return ht.cmp(this.m) >= 0 && ht.isub(this.m), ht;
    }, Bt.prototype.sub = function(ge, Ke) {
      this._verify2(ge, Ke);
      var ht = ge.sub(Ke);
      return ht.cmpn(0) < 0 && ht.iadd(this.m), ht._forceRed(this);
    }, Bt.prototype.isub = function(ge, Ke) {
      this._verify2(ge, Ke);
      var ht = ge.isub(Ke);
      return ht.cmpn(0) < 0 && ht.iadd(this.m), ht;
    }, Bt.prototype.shl = function(ge, Ke) {
      return this._verify1(ge), this.imod(ge.ushln(Ke));
    }, Bt.prototype.imul = function(ge, Ke) {
      return this._verify2(ge, Ke), this.imod(ge.imul(Ke));
    }, Bt.prototype.mul = function(ge, Ke) {
      return this._verify2(ge, Ke), this.imod(ge.mul(Ke));
    }, Bt.prototype.isqr = function(ge) {
      return this.imul(ge, ge.clone());
    }, Bt.prototype.sqr = function(ge) {
      return this.mul(ge, ge);
    }, Bt.prototype.sqrt = function(ge) {
      if (ge.isZero()) return ge.clone();
      var Ke = this.m.andln(3);
      if (ne(Ke % 2 === 1), Ke === 3) {
        var ht = this.m.add(new oe(1)).iushrn(2);
        return this.pow(ge, ht);
      }
      for (var wt = this.m.subn(1), vt = 0; !wt.isZero() && wt.andln(1) === 0; )
        vt++, wt.iushrn(1);
      ne(!wt.isZero());
      var $t = new oe(1).toRed(this), Qe = $t.redNeg(), xt = this.m.subn(1).iushrn(1), bt = this.m.bitLength();
      for (bt = new oe(2 * bt * bt).toRed(this); this.pow(bt, xt).cmp(Qe) !== 0; )
        bt.redIAdd(Qe);
      for (var Dt = this.pow(bt, wt), er = this.pow(ge, wt.addn(1).iushrn(1)), fr = this.pow(ge, wt), Qt = vt; fr.cmp($t) !== 0; ) {
        for (var Ht = fr, qt = 0; Ht.cmp($t) !== 0; qt++)
          Ht = Ht.redSqr();
        ne(qt < Qt);
        var nr = this.pow(Dt, new oe(1).iushln(Qt - qt - 1));
        er = er.redMul(nr), Dt = nr.redSqr(), fr = fr.redMul(Dt), Qt = qt;
      }
      return er;
    }, Bt.prototype.invm = function(ge) {
      var Ke = ge._invmp(this.m);
      return Ke.negative !== 0 ? (Ke.negative = 0, this.imod(Ke).redNeg()) : this.imod(Ke);
    }, Bt.prototype.pow = function(ge, Ke) {
      if (Ke.isZero()) return new oe(1).toRed(this);
      if (Ke.cmpn(1) === 0) return ge.clone();
      var ht = 4, wt = new Array(1 << ht);
      wt[0] = new oe(1).toRed(this), wt[1] = ge;
      for (var vt = 2; vt < wt.length; vt++)
        wt[vt] = this.mul(wt[vt - 1], ge);
      var $t = wt[0], Qe = 0, xt = 0, bt = Ke.bitLength() % 26;
      for (bt === 0 && (bt = 26), vt = Ke.length - 1; vt >= 0; vt--) {
        for (var Dt = Ke.words[vt], er = bt - 1; er >= 0; er--) {
          var fr = Dt >> er & 1;
          if ($t !== wt[0] && ($t = this.sqr($t)), fr === 0 && Qe === 0) {
            xt = 0;
            continue;
          }
          Qe <<= 1, Qe |= fr, xt++, !(xt !== ht && (vt !== 0 || er !== 0)) && ($t = this.mul($t, wt[Qe]), xt = 0, Qe = 0);
        }
        bt = 26;
      }
      return $t;
    }, Bt.prototype.convertTo = function(ge) {
      var Ke = ge.umod(this.m);
      return Ke === ge ? Ke.clone() : Ke;
    }, Bt.prototype.convertFrom = function(ge) {
      var Ke = ge.clone();
      return Ke.red = null, Ke;
    }, oe.mont = function(ge) {
      return new Xe(ge);
    };
    function Xe(Ve) {
      Bt.call(this, Ve), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new oe(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    ie(Xe, Bt), Xe.prototype.convertTo = function(ge) {
      return this.imod(ge.ushln(this.shift));
    }, Xe.prototype.convertFrom = function(ge) {
      var Ke = this.imod(ge.mul(this.rinv));
      return Ke.red = null, Ke;
    }, Xe.prototype.imul = function(ge, Ke) {
      if (ge.isZero() || Ke.isZero())
        return ge.words[0] = 0, ge.length = 1, ge;
      var ht = ge.imul(Ke), wt = ht.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), vt = ht.isub(wt).iushrn(this.shift), $t = vt;
      return vt.cmp(this.m) >= 0 ? $t = vt.isub(this.m) : vt.cmpn(0) < 0 && ($t = vt.iadd(this.m)), $t._forceRed(this);
    }, Xe.prototype.mul = function(ge, Ke) {
      if (ge.isZero() || Ke.isZero()) return new oe(0)._forceRed(this);
      var ht = ge.mul(Ke), wt = ht.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), vt = ht.isub(wt).iushrn(this.shift), $t = vt;
      return vt.cmp(this.m) >= 0 ? $t = vt.isub(this.m) : vt.cmpn(0) < 0 && ($t = vt.iadd(this.m)), $t._forceRed(this);
    }, Xe.prototype.invm = function(ge) {
      var Ke = this.imod(ge._invmp(this.m).mul(this.r2));
      return Ke._forceRed(this);
    };
  })(B, commonjsGlobal);
})(bn);
var bnExports = bn.exports, BN$a = bnExports, randomBytes$1 = browserExports, Buffer$8 = safeBufferExports$1.Buffer;
function getr(B) {
  var z = B.modulus.byteLength(), Y;
  do
    Y = new BN$a(randomBytes$1(z));
  while (Y.cmp(B.modulus) >= 0 || !Y.umod(B.prime1) || !Y.umod(B.prime2));
  return Y;
}
function blind(B) {
  var z = getr(B), Y = z.toRed(BN$a.mont(B.modulus)).redPow(new BN$a(B.publicExponent)).fromRed();
  return { blinder: Y, unblinder: z.invm(B.modulus) };
}
function crt$2(B, z) {
  var Y = blind(z), ne = z.modulus.byteLength(), ie = new BN$a(B).mul(Y.blinder).umod(z.modulus), oe = ie.toRed(BN$a.mont(z.prime1)), se = ie.toRed(BN$a.mont(z.prime2)), ae = z.coefficient, ve = z.prime1, Pe = z.prime2, le = oe.redPow(z.exponent1).fromRed(), Ee = se.redPow(z.exponent2).fromRed(), Je = le.isub(Ee).imul(ae).umod(ve).imul(Pe);
  return Ee.iadd(Je).imul(Y.unblinder).umod(z.modulus).toArrayLike(Buffer$8, "be", ne);
}
crt$2.getr = getr;
var browserifyRsa = crt$2, elliptic = {};
const version = "6.6.1", require$$0 = {
  version
};
var utils$m = {}, utils$l = {};
(function(B) {
  var z = B;
  function Y(oe, se) {
    if (Array.isArray(oe))
      return oe.slice();
    if (!oe)
      return [];
    var ae = [];
    if (typeof oe != "string") {
      for (var ve = 0; ve < oe.length; ve++)
        ae[ve] = oe[ve] | 0;
      return ae;
    }
    if (se === "hex") {
      oe = oe.replace(/[^a-z0-9]+/ig, ""), oe.length % 2 !== 0 && (oe = "0" + oe);
      for (var ve = 0; ve < oe.length; ve += 2)
        ae.push(parseInt(oe[ve] + oe[ve + 1], 16));
    } else
      for (var ve = 0; ve < oe.length; ve++) {
        var Pe = oe.charCodeAt(ve), le = Pe >> 8, Ee = Pe & 255;
        le ? ae.push(le, Ee) : ae.push(Ee);
      }
    return ae;
  }
  z.toArray = Y;
  function ne(oe) {
    return oe.length === 1 ? "0" + oe : oe;
  }
  z.zero2 = ne;
  function ie(oe) {
    for (var se = "", ae = 0; ae < oe.length; ae++)
      se += ne(oe[ae].toString(16));
    return se;
  }
  z.toHex = ie, z.encode = function(se, ae) {
    return ae === "hex" ? ie(se) : se;
  };
})(utils$l);
(function(B) {
  var z = B, Y = bnExports$1, ne = minimalisticAssert, ie = utils$l;
  z.assert = ne, z.toArray = ie.toArray, z.zero2 = ie.zero2, z.toHex = ie.toHex, z.encode = ie.encode;
  function oe(le, Ee, Je) {
    var Ce = new Array(Math.max(le.bitLength(), Je) + 1), _t;
    for (_t = 0; _t < Ce.length; _t += 1)
      Ce[_t] = 0;
    var kt = 1 << Ee + 1, Ct = le.clone();
    for (_t = 0; _t < Ce.length; _t++) {
      var Lt, Pt = Ct.andln(kt - 1);
      Ct.isOdd() ? (Pt > (kt >> 1) - 1 ? Lt = (kt >> 1) - Pt : Lt = Pt, Ct.isubn(Lt)) : Lt = 0, Ce[_t] = Lt, Ct.iushrn(1);
    }
    return Ce;
  }
  z.getNAF = oe;
  function se(le, Ee) {
    var Je = [
      [],
      []
    ];
    le = le.clone(), Ee = Ee.clone();
    for (var Ce = 0, _t = 0, kt; le.cmpn(-Ce) > 0 || Ee.cmpn(-_t) > 0; ) {
      var Ct = le.andln(3) + Ce & 3, Lt = Ee.andln(3) + _t & 3;
      Ct === 3 && (Ct = -1), Lt === 3 && (Lt = -1);
      var Pt;
      Ct & 1 ? (kt = le.andln(7) + Ce & 7, (kt === 3 || kt === 5) && Lt === 2 ? Pt = -Ct : Pt = Ct) : Pt = 0, Je[0].push(Pt);
      var Ft;
      Lt & 1 ? (kt = Ee.andln(7) + _t & 7, (kt === 3 || kt === 5) && Ct === 2 ? Ft = -Lt : Ft = Lt) : Ft = 0, Je[1].push(Ft), 2 * Ce === Pt + 1 && (Ce = 1 - Ce), 2 * _t === Ft + 1 && (_t = 1 - _t), le.iushrn(1), Ee.iushrn(1);
    }
    return Je;
  }
  z.getJSF = se;
  function ae(le, Ee, Je) {
    var Ce = "_" + Ee;
    le.prototype[Ee] = function() {
      return this[Ce] !== void 0 ? this[Ce] : this[Ce] = Je.call(this);
    };
  }
  z.cachedProperty = ae;
  function ve(le) {
    return typeof le == "string" ? z.toArray(le, "hex") : le;
  }
  z.parseBytes = ve;
  function Pe(le) {
    return new Y(le, "hex", "le");
  }
  z.intFromLE = Pe;
})(utils$m);
var curve = {}, BN$9 = bnExports$1, utils$k = utils$m, getNAF = utils$k.getNAF, getJSF = utils$k.getJSF, assert$e = utils$k.assert;
function BaseCurve(B, z) {
  this.type = B, this.p = new BN$9(z.p, 16), this.red = z.prime ? BN$9.red(z.prime) : BN$9.mont(this.p), this.zero = new BN$9(0).toRed(this.red), this.one = new BN$9(1).toRed(this.red), this.two = new BN$9(2).toRed(this.red), this.n = z.n && new BN$9(z.n, 16), this.g = z.g && this.pointFromJSON(z.g, z.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var Y = this.n && this.p.div(this.n);
  !Y || Y.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$3 = BaseCurve;
BaseCurve.prototype.point = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function(z, Y) {
  assert$e(z.precomputed);
  var ne = z._getDoubles(), ie = getNAF(Y, 1, this._bitLength), oe = (1 << ne.step + 1) - (ne.step % 2 === 0 ? 2 : 1);
  oe /= 3;
  var se = [], ae, ve;
  for (ae = 0; ae < ie.length; ae += ne.step) {
    ve = 0;
    for (var Pe = ae + ne.step - 1; Pe >= ae; Pe--)
      ve = (ve << 1) + ie[Pe];
    se.push(ve);
  }
  for (var le = this.jpoint(null, null, null), Ee = this.jpoint(null, null, null), Je = oe; Je > 0; Je--) {
    for (ae = 0; ae < se.length; ae++)
      ve = se[ae], ve === Je ? Ee = Ee.mixedAdd(ne.points[ae]) : ve === -Je && (Ee = Ee.mixedAdd(ne.points[ae].neg()));
    le = le.add(Ee);
  }
  return le.toP();
};
BaseCurve.prototype._wnafMul = function(z, Y) {
  var ne = 4, ie = z._getNAFPoints(ne);
  ne = ie.wnd;
  for (var oe = ie.points, se = getNAF(Y, ne, this._bitLength), ae = this.jpoint(null, null, null), ve = se.length - 1; ve >= 0; ve--) {
    for (var Pe = 0; ve >= 0 && se[ve] === 0; ve--)
      Pe++;
    if (ve >= 0 && Pe++, ae = ae.dblp(Pe), ve < 0)
      break;
    var le = se[ve];
    assert$e(le !== 0), z.type === "affine" ? le > 0 ? ae = ae.mixedAdd(oe[le - 1 >> 1]) : ae = ae.mixedAdd(oe[-le - 1 >> 1].neg()) : le > 0 ? ae = ae.add(oe[le - 1 >> 1]) : ae = ae.add(oe[-le - 1 >> 1].neg());
  }
  return z.type === "affine" ? ae.toP() : ae;
};
BaseCurve.prototype._wnafMulAdd = function(z, Y, ne, ie, oe) {
  var se = this._wnafT1, ae = this._wnafT2, ve = this._wnafT3, Pe = 0, le, Ee, Je;
  for (le = 0; le < ie; le++) {
    Je = Y[le];
    var Ce = Je._getNAFPoints(z);
    se[le] = Ce.wnd, ae[le] = Ce.points;
  }
  for (le = ie - 1; le >= 1; le -= 2) {
    var _t = le - 1, kt = le;
    if (se[_t] !== 1 || se[kt] !== 1) {
      ve[_t] = getNAF(ne[_t], se[_t], this._bitLength), ve[kt] = getNAF(ne[kt], se[kt], this._bitLength), Pe = Math.max(ve[_t].length, Pe), Pe = Math.max(ve[kt].length, Pe);
      continue;
    }
    var Ct = [
      Y[_t],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      Y[kt]
      /* 7 */
    ];
    Y[_t].y.cmp(Y[kt].y) === 0 ? (Ct[1] = Y[_t].add(Y[kt]), Ct[2] = Y[_t].toJ().mixedAdd(Y[kt].neg())) : Y[_t].y.cmp(Y[kt].y.redNeg()) === 0 ? (Ct[1] = Y[_t].toJ().mixedAdd(Y[kt]), Ct[2] = Y[_t].add(Y[kt].neg())) : (Ct[1] = Y[_t].toJ().mixedAdd(Y[kt]), Ct[2] = Y[_t].toJ().mixedAdd(Y[kt].neg()));
    var Lt = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], Pt = getJSF(ne[_t], ne[kt]);
    for (Pe = Math.max(Pt[0].length, Pe), ve[_t] = new Array(Pe), ve[kt] = new Array(Pe), Ee = 0; Ee < Pe; Ee++) {
      var Ft = Pt[0][Ee] | 0, Ut = Pt[1][Ee] | 0;
      ve[_t][Ee] = Lt[(Ft + 1) * 3 + (Ut + 1)], ve[kt][Ee] = 0, ae[_t] = Ct;
    }
  }
  var Jt = this.jpoint(null, null, null), Vt = this._wnafT4;
  for (le = Pe; le >= 0; le--) {
    for (var ir = 0; le >= 0; ) {
      var jt = !0;
      for (Ee = 0; Ee < ie; Ee++)
        Vt[Ee] = ve[Ee][le] | 0, Vt[Ee] !== 0 && (jt = !1);
      if (!jt)
        break;
      ir++, le--;
    }
    if (le >= 0 && ir++, Jt = Jt.dblp(ir), le < 0)
      break;
    for (Ee = 0; Ee < ie; Ee++) {
      var Rt = Vt[Ee];
      Rt !== 0 && (Rt > 0 ? Je = ae[Ee][Rt - 1 >> 1] : Rt < 0 && (Je = ae[Ee][-Rt - 1 >> 1].neg()), Je.type === "affine" ? Jt = Jt.mixedAdd(Je) : Jt = Jt.add(Je));
    }
  }
  for (le = 0; le < ie; le++)
    ae[le] = null;
  return oe ? Jt : Jt.toP();
};
function BasePoint(B, z) {
  this.curve = B, this.type = z, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function(z, Y) {
  z = utils$k.toArray(z, Y);
  var ne = this.p.byteLength();
  if ((z[0] === 4 || z[0] === 6 || z[0] === 7) && z.length - 1 === 2 * ne) {
    z[0] === 6 ? assert$e(z[z.length - 1] % 2 === 0) : z[0] === 7 && assert$e(z[z.length - 1] % 2 === 1);
    var ie = this.point(
      z.slice(1, 1 + ne),
      z.slice(1 + ne, 1 + 2 * ne)
    );
    return ie;
  } else if ((z[0] === 2 || z[0] === 3) && z.length - 1 === ne)
    return this.pointFromX(z.slice(1, 1 + ne), z[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function(z) {
  return this.encode(z, !0);
};
BasePoint.prototype._encode = function(z) {
  var Y = this.curve.p.byteLength(), ne = this.getX().toArray("be", Y);
  return z ? [this.getY().isEven() ? 2 : 3].concat(ne) : [4].concat(ne, this.getY().toArray("be", Y));
};
BasePoint.prototype.encode = function(z, Y) {
  return utils$k.encode(this._encode(Y), z);
};
BasePoint.prototype.precompute = function(z) {
  if (this.precomputed)
    return this;
  var Y = {
    doubles: null,
    naf: null,
    beta: null
  };
  return Y.naf = this._getNAFPoints(8), Y.doubles = this._getDoubles(4, z), Y.beta = this._getBeta(), this.precomputed = Y, this;
};
BasePoint.prototype._hasDoubles = function(z) {
  if (!this.precomputed)
    return !1;
  var Y = this.precomputed.doubles;
  return Y ? Y.points.length >= Math.ceil((z.bitLength() + 1) / Y.step) : !1;
};
BasePoint.prototype._getDoubles = function(z, Y) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var ne = [this], ie = this, oe = 0; oe < Y; oe += z) {
    for (var se = 0; se < z; se++)
      ie = ie.dbl();
    ne.push(ie);
  }
  return {
    step: z,
    points: ne
  };
};
BasePoint.prototype._getNAFPoints = function(z) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var Y = [this], ne = (1 << z) - 1, ie = ne === 1 ? null : this.dbl(), oe = 1; oe < ne; oe++)
    Y[oe] = Y[oe - 1].add(ie);
  return {
    wnd: z,
    points: Y
  };
};
BasePoint.prototype._getBeta = function() {
  return null;
};
BasePoint.prototype.dblp = function(z) {
  for (var Y = this, ne = 0; ne < z; ne++)
    Y = Y.dbl();
  return Y;
};
var utils$j = utils$m, BN$8 = bnExports$1, inherits$4 = inherits_browserExports, Base$2 = base$3, assert$d = utils$j.assert;
function ShortCurve(B) {
  Base$2.call(this, "short", B), this.a = new BN$8(B.a, 16).toRed(this.red), this.b = new BN$8(B.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(B), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$4(ShortCurve, Base$2);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function(z) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var Y, ne;
    if (z.beta)
      Y = new BN$8(z.beta, 16).toRed(this.red);
    else {
      var ie = this._getEndoRoots(this.p);
      Y = ie[0].cmp(ie[1]) < 0 ? ie[0] : ie[1], Y = Y.toRed(this.red);
    }
    if (z.lambda)
      ne = new BN$8(z.lambda, 16);
    else {
      var oe = this._getEndoRoots(this.n);
      this.g.mul(oe[0]).x.cmp(this.g.x.redMul(Y)) === 0 ? ne = oe[0] : (ne = oe[1], assert$d(this.g.mul(ne).x.cmp(this.g.x.redMul(Y)) === 0));
    }
    var se;
    return z.basis ? se = z.basis.map(function(ae) {
      return {
        a: new BN$8(ae.a, 16),
        b: new BN$8(ae.b, 16)
      };
    }) : se = this._getEndoBasis(ne), {
      beta: Y,
      lambda: ne,
      basis: se
    };
  }
};
ShortCurve.prototype._getEndoRoots = function(z) {
  var Y = z === this.p ? this.red : BN$8.mont(z), ne = new BN$8(2).toRed(Y).redInvm(), ie = ne.redNeg(), oe = new BN$8(3).toRed(Y).redNeg().redSqrt().redMul(ne), se = ie.redAdd(oe).fromRed(), ae = ie.redSub(oe).fromRed();
  return [se, ae];
};
ShortCurve.prototype._getEndoBasis = function(z) {
  for (var Y = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), ne = z, ie = this.n.clone(), oe = new BN$8(1), se = new BN$8(0), ae = new BN$8(0), ve = new BN$8(1), Pe, le, Ee, Je, Ce, _t, kt, Ct = 0, Lt, Pt; ne.cmpn(0) !== 0; ) {
    var Ft = ie.div(ne);
    Lt = ie.sub(Ft.mul(ne)), Pt = ae.sub(Ft.mul(oe));
    var Ut = ve.sub(Ft.mul(se));
    if (!Ee && Lt.cmp(Y) < 0)
      Pe = kt.neg(), le = oe, Ee = Lt.neg(), Je = Pt;
    else if (Ee && ++Ct === 2)
      break;
    kt = Lt, ie = ne, ne = Lt, ae = oe, oe = Pt, ve = se, se = Ut;
  }
  Ce = Lt.neg(), _t = Pt;
  var Jt = Ee.sqr().add(Je.sqr()), Vt = Ce.sqr().add(_t.sqr());
  return Vt.cmp(Jt) >= 0 && (Ce = Pe, _t = le), Ee.negative && (Ee = Ee.neg(), Je = Je.neg()), Ce.negative && (Ce = Ce.neg(), _t = _t.neg()), [
    { a: Ee, b: Je },
    { a: Ce, b: _t }
  ];
};
ShortCurve.prototype._endoSplit = function(z) {
  var Y = this.endo.basis, ne = Y[0], ie = Y[1], oe = ie.b.mul(z).divRound(this.n), se = ne.b.neg().mul(z).divRound(this.n), ae = oe.mul(ne.a), ve = se.mul(ie.a), Pe = oe.mul(ne.b), le = se.mul(ie.b), Ee = z.sub(ae).sub(ve), Je = Pe.add(le).neg();
  return { k1: Ee, k2: Je };
};
ShortCurve.prototype.pointFromX = function(z, Y) {
  z = new BN$8(z, 16), z.red || (z = z.toRed(this.red));
  var ne = z.redSqr().redMul(z).redIAdd(z.redMul(this.a)).redIAdd(this.b), ie = ne.redSqrt();
  if (ie.redSqr().redSub(ne).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var oe = ie.fromRed().isOdd();
  return (Y && !oe || !Y && oe) && (ie = ie.redNeg()), this.point(z, ie);
};
ShortCurve.prototype.validate = function(z) {
  if (z.inf)
    return !0;
  var Y = z.x, ne = z.y, ie = this.a.redMul(Y), oe = Y.redSqr().redMul(Y).redIAdd(ie).redIAdd(this.b);
  return ne.redSqr().redISub(oe).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function(z, Y, ne) {
  for (var ie = this._endoWnafT1, oe = this._endoWnafT2, se = 0; se < z.length; se++) {
    var ae = this._endoSplit(Y[se]), ve = z[se], Pe = ve._getBeta();
    ae.k1.negative && (ae.k1.ineg(), ve = ve.neg(!0)), ae.k2.negative && (ae.k2.ineg(), Pe = Pe.neg(!0)), ie[se * 2] = ve, ie[se * 2 + 1] = Pe, oe[se * 2] = ae.k1, oe[se * 2 + 1] = ae.k2;
  }
  for (var le = this._wnafMulAdd(1, ie, oe, se * 2, ne), Ee = 0; Ee < se * 2; Ee++)
    ie[Ee] = null, oe[Ee] = null;
  return le;
};
function Point$2(B, z, Y, ne) {
  Base$2.BasePoint.call(this, B, "affine"), z === null && Y === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$8(z, 16), this.y = new BN$8(Y, 16), ne && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$4(Point$2, Base$2.BasePoint);
ShortCurve.prototype.point = function(z, Y, ne) {
  return new Point$2(this, z, Y, ne);
};
ShortCurve.prototype.pointFromJSON = function(z, Y) {
  return Point$2.fromJSON(this, z, Y);
};
Point$2.prototype._getBeta = function() {
  if (this.curve.endo) {
    var z = this.precomputed;
    if (z && z.beta)
      return z.beta;
    var Y = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (z) {
      var ne = this.curve, ie = function(oe) {
        return ne.point(oe.x.redMul(ne.endo.beta), oe.y);
      };
      z.beta = Y, Y.precomputed = {
        beta: null,
        naf: z.naf && {
          wnd: z.naf.wnd,
          points: z.naf.points.map(ie)
        },
        doubles: z.doubles && {
          step: z.doubles.step,
          points: z.doubles.points.map(ie)
        }
      };
    }
    return Y;
  }
};
Point$2.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$2.fromJSON = function(z, Y, ne) {
  typeof Y == "string" && (Y = JSON.parse(Y));
  var ie = z.point(Y[0], Y[1], ne);
  if (!Y[2])
    return ie;
  function oe(ae) {
    return z.point(ae[0], ae[1], ne);
  }
  var se = Y[2];
  return ie.precomputed = {
    beta: null,
    doubles: se.doubles && {
      step: se.doubles.step,
      points: [ie].concat(se.doubles.points.map(oe))
    },
    naf: se.naf && {
      wnd: se.naf.wnd,
      points: [ie].concat(se.naf.points.map(oe))
    }
  }, ie;
};
Point$2.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function() {
  return this.inf;
};
Point$2.prototype.add = function(z) {
  if (this.inf)
    return z;
  if (z.inf)
    return this;
  if (this.eq(z))
    return this.dbl();
  if (this.neg().eq(z))
    return this.curve.point(null, null);
  if (this.x.cmp(z.x) === 0)
    return this.curve.point(null, null);
  var Y = this.y.redSub(z.y);
  Y.cmpn(0) !== 0 && (Y = Y.redMul(this.x.redSub(z.x).redInvm()));
  var ne = Y.redSqr().redISub(this.x).redISub(z.x), ie = Y.redMul(this.x.redSub(ne)).redISub(this.y);
  return this.curve.point(ne, ie);
};
Point$2.prototype.dbl = function() {
  if (this.inf)
    return this;
  var z = this.y.redAdd(this.y);
  if (z.cmpn(0) === 0)
    return this.curve.point(null, null);
  var Y = this.curve.a, ne = this.x.redSqr(), ie = z.redInvm(), oe = ne.redAdd(ne).redIAdd(ne).redIAdd(Y).redMul(ie), se = oe.redSqr().redISub(this.x.redAdd(this.x)), ae = oe.redMul(this.x.redSub(se)).redISub(this.y);
  return this.curve.point(se, ae);
};
Point$2.prototype.getX = function() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function(z) {
  return z = new BN$8(z, 16), this.isInfinity() ? this : this._hasDoubles(z) ? this.curve._fixedNafMul(this, z) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [z]) : this.curve._wnafMul(this, z);
};
Point$2.prototype.mulAdd = function(z, Y, ne) {
  var ie = [this, Y], oe = [z, ne];
  return this.curve.endo ? this.curve._endoWnafMulAdd(ie, oe) : this.curve._wnafMulAdd(1, ie, oe, 2);
};
Point$2.prototype.jmulAdd = function(z, Y, ne) {
  var ie = [this, Y], oe = [z, ne];
  return this.curve.endo ? this.curve._endoWnafMulAdd(ie, oe, !0) : this.curve._wnafMulAdd(1, ie, oe, 2, !0);
};
Point$2.prototype.eq = function(z) {
  return this === z || this.inf === z.inf && (this.inf || this.x.cmp(z.x) === 0 && this.y.cmp(z.y) === 0);
};
Point$2.prototype.neg = function(z) {
  if (this.inf)
    return this;
  var Y = this.curve.point(this.x, this.y.redNeg());
  if (z && this.precomputed) {
    var ne = this.precomputed, ie = function(oe) {
      return oe.neg();
    };
    Y.precomputed = {
      naf: ne.naf && {
        wnd: ne.naf.wnd,
        points: ne.naf.points.map(ie)
      },
      doubles: ne.doubles && {
        step: ne.doubles.step,
        points: ne.doubles.points.map(ie)
      }
    };
  }
  return Y;
};
Point$2.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var z = this.curve.jpoint(this.x, this.y, this.curve.one);
  return z;
};
function JPoint(B, z, Y, ne) {
  Base$2.BasePoint.call(this, B, "jacobian"), z === null && Y === null && ne === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$8(0)) : (this.x = new BN$8(z, 16), this.y = new BN$8(Y, 16), this.z = new BN$8(ne, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$4(JPoint, Base$2.BasePoint);
ShortCurve.prototype.jpoint = function(z, Y, ne) {
  return new JPoint(this, z, Y, ne);
};
JPoint.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var z = this.z.redInvm(), Y = z.redSqr(), ne = this.x.redMul(Y), ie = this.y.redMul(Y).redMul(z);
  return this.curve.point(ne, ie);
};
JPoint.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function(z) {
  if (this.isInfinity())
    return z;
  if (z.isInfinity())
    return this;
  var Y = z.z.redSqr(), ne = this.z.redSqr(), ie = this.x.redMul(Y), oe = z.x.redMul(ne), se = this.y.redMul(Y.redMul(z.z)), ae = z.y.redMul(ne.redMul(this.z)), ve = ie.redSub(oe), Pe = se.redSub(ae);
  if (ve.cmpn(0) === 0)
    return Pe.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var le = ve.redSqr(), Ee = le.redMul(ve), Je = ie.redMul(le), Ce = Pe.redSqr().redIAdd(Ee).redISub(Je).redISub(Je), _t = Pe.redMul(Je.redISub(Ce)).redISub(se.redMul(Ee)), kt = this.z.redMul(z.z).redMul(ve);
  return this.curve.jpoint(Ce, _t, kt);
};
JPoint.prototype.mixedAdd = function(z) {
  if (this.isInfinity())
    return z.toJ();
  if (z.isInfinity())
    return this;
  var Y = this.z.redSqr(), ne = this.x, ie = z.x.redMul(Y), oe = this.y, se = z.y.redMul(Y).redMul(this.z), ae = ne.redSub(ie), ve = oe.redSub(se);
  if (ae.cmpn(0) === 0)
    return ve.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Pe = ae.redSqr(), le = Pe.redMul(ae), Ee = ne.redMul(Pe), Je = ve.redSqr().redIAdd(le).redISub(Ee).redISub(Ee), Ce = ve.redMul(Ee.redISub(Je)).redISub(oe.redMul(le)), _t = this.z.redMul(ae);
  return this.curve.jpoint(Je, Ce, _t);
};
JPoint.prototype.dblp = function(z) {
  if (z === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!z)
    return this.dbl();
  var Y;
  if (this.curve.zeroA || this.curve.threeA) {
    var ne = this;
    for (Y = 0; Y < z; Y++)
      ne = ne.dbl();
    return ne;
  }
  var ie = this.curve.a, oe = this.curve.tinv, se = this.x, ae = this.y, ve = this.z, Pe = ve.redSqr().redSqr(), le = ae.redAdd(ae);
  for (Y = 0; Y < z; Y++) {
    var Ee = se.redSqr(), Je = le.redSqr(), Ce = Je.redSqr(), _t = Ee.redAdd(Ee).redIAdd(Ee).redIAdd(ie.redMul(Pe)), kt = se.redMul(Je), Ct = _t.redSqr().redISub(kt.redAdd(kt)), Lt = kt.redISub(Ct), Pt = _t.redMul(Lt);
    Pt = Pt.redIAdd(Pt).redISub(Ce);
    var Ft = le.redMul(ve);
    Y + 1 < z && (Pe = Pe.redMul(Ce)), se = Ct, ve = Ft, le = Pt;
  }
  return this.curve.jpoint(se, le.redMul(oe), ve);
};
JPoint.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function() {
  var z, Y, ne;
  if (this.zOne) {
    var ie = this.x.redSqr(), oe = this.y.redSqr(), se = oe.redSqr(), ae = this.x.redAdd(oe).redSqr().redISub(ie).redISub(se);
    ae = ae.redIAdd(ae);
    var ve = ie.redAdd(ie).redIAdd(ie), Pe = ve.redSqr().redISub(ae).redISub(ae), le = se.redIAdd(se);
    le = le.redIAdd(le), le = le.redIAdd(le), z = Pe, Y = ve.redMul(ae.redISub(Pe)).redISub(le), ne = this.y.redAdd(this.y);
  } else {
    var Ee = this.x.redSqr(), Je = this.y.redSqr(), Ce = Je.redSqr(), _t = this.x.redAdd(Je).redSqr().redISub(Ee).redISub(Ce);
    _t = _t.redIAdd(_t);
    var kt = Ee.redAdd(Ee).redIAdd(Ee), Ct = kt.redSqr(), Lt = Ce.redIAdd(Ce);
    Lt = Lt.redIAdd(Lt), Lt = Lt.redIAdd(Lt), z = Ct.redISub(_t).redISub(_t), Y = kt.redMul(_t.redISub(z)).redISub(Lt), ne = this.y.redMul(this.z), ne = ne.redIAdd(ne);
  }
  return this.curve.jpoint(z, Y, ne);
};
JPoint.prototype._threeDbl = function() {
  var z, Y, ne;
  if (this.zOne) {
    var ie = this.x.redSqr(), oe = this.y.redSqr(), se = oe.redSqr(), ae = this.x.redAdd(oe).redSqr().redISub(ie).redISub(se);
    ae = ae.redIAdd(ae);
    var ve = ie.redAdd(ie).redIAdd(ie).redIAdd(this.curve.a), Pe = ve.redSqr().redISub(ae).redISub(ae);
    z = Pe;
    var le = se.redIAdd(se);
    le = le.redIAdd(le), le = le.redIAdd(le), Y = ve.redMul(ae.redISub(Pe)).redISub(le), ne = this.y.redAdd(this.y);
  } else {
    var Ee = this.z.redSqr(), Je = this.y.redSqr(), Ce = this.x.redMul(Je), _t = this.x.redSub(Ee).redMul(this.x.redAdd(Ee));
    _t = _t.redAdd(_t).redIAdd(_t);
    var kt = Ce.redIAdd(Ce);
    kt = kt.redIAdd(kt);
    var Ct = kt.redAdd(kt);
    z = _t.redSqr().redISub(Ct), ne = this.y.redAdd(this.z).redSqr().redISub(Je).redISub(Ee);
    var Lt = Je.redSqr();
    Lt = Lt.redIAdd(Lt), Lt = Lt.redIAdd(Lt), Lt = Lt.redIAdd(Lt), Y = _t.redMul(kt.redISub(z)).redISub(Lt);
  }
  return this.curve.jpoint(z, Y, ne);
};
JPoint.prototype._dbl = function() {
  var z = this.curve.a, Y = this.x, ne = this.y, ie = this.z, oe = ie.redSqr().redSqr(), se = Y.redSqr(), ae = ne.redSqr(), ve = se.redAdd(se).redIAdd(se).redIAdd(z.redMul(oe)), Pe = Y.redAdd(Y);
  Pe = Pe.redIAdd(Pe);
  var le = Pe.redMul(ae), Ee = ve.redSqr().redISub(le.redAdd(le)), Je = le.redISub(Ee), Ce = ae.redSqr();
  Ce = Ce.redIAdd(Ce), Ce = Ce.redIAdd(Ce), Ce = Ce.redIAdd(Ce);
  var _t = ve.redMul(Je).redISub(Ce), kt = ne.redAdd(ne).redMul(ie);
  return this.curve.jpoint(Ee, _t, kt);
};
JPoint.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var z = this.x.redSqr(), Y = this.y.redSqr(), ne = this.z.redSqr(), ie = Y.redSqr(), oe = z.redAdd(z).redIAdd(z), se = oe.redSqr(), ae = this.x.redAdd(Y).redSqr().redISub(z).redISub(ie);
  ae = ae.redIAdd(ae), ae = ae.redAdd(ae).redIAdd(ae), ae = ae.redISub(se);
  var ve = ae.redSqr(), Pe = ie.redIAdd(ie);
  Pe = Pe.redIAdd(Pe), Pe = Pe.redIAdd(Pe), Pe = Pe.redIAdd(Pe);
  var le = oe.redIAdd(ae).redSqr().redISub(se).redISub(ve).redISub(Pe), Ee = Y.redMul(le);
  Ee = Ee.redIAdd(Ee), Ee = Ee.redIAdd(Ee);
  var Je = this.x.redMul(ve).redISub(Ee);
  Je = Je.redIAdd(Je), Je = Je.redIAdd(Je);
  var Ce = this.y.redMul(le.redMul(Pe.redISub(le)).redISub(ae.redMul(ve)));
  Ce = Ce.redIAdd(Ce), Ce = Ce.redIAdd(Ce), Ce = Ce.redIAdd(Ce);
  var _t = this.z.redAdd(ae).redSqr().redISub(ne).redISub(ve);
  return this.curve.jpoint(Je, Ce, _t);
};
JPoint.prototype.mul = function(z, Y) {
  return z = new BN$8(z, Y), this.curve._wnafMul(this, z);
};
JPoint.prototype.eq = function(z) {
  if (z.type === "affine")
    return this.eq(z.toJ());
  if (this === z)
    return !0;
  var Y = this.z.redSqr(), ne = z.z.redSqr();
  if (this.x.redMul(ne).redISub(z.x.redMul(Y)).cmpn(0) !== 0)
    return !1;
  var ie = Y.redMul(this.z), oe = ne.redMul(z.z);
  return this.y.redMul(oe).redISub(z.y.redMul(ie)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function(z) {
  var Y = this.z.redSqr(), ne = z.toRed(this.curve.red).redMul(Y);
  if (this.x.cmp(ne) === 0)
    return !0;
  for (var ie = z.clone(), oe = this.curve.redN.redMul(Y); ; ) {
    if (ie.iadd(this.curve.n), ie.cmp(this.curve.p) >= 0)
      return !1;
    if (ne.redIAdd(oe), this.x.cmp(ne) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var BN$7 = bnExports$1, inherits$3 = inherits_browserExports, Base$1 = base$3, utils$i = utils$m;
function MontCurve(B) {
  Base$1.call(this, "mont", B), this.a = new BN$7(B.a, 16).toRed(this.red), this.b = new BN$7(B.b, 16).toRed(this.red), this.i4 = new BN$7(4).toRed(this.red).redInvm(), this.two = new BN$7(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$3(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function(z) {
  var Y = z.normalize().x, ne = Y.redSqr(), ie = ne.redMul(Y).redAdd(ne.redMul(this.a)).redAdd(Y), oe = ie.redSqrt();
  return oe.redSqr().cmp(ie) === 0;
};
function Point$1(B, z, Y) {
  Base$1.BasePoint.call(this, B, "projective"), z === null && Y === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$7(z, 16), this.z = new BN$7(Y, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$3(Point$1, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function(z, Y) {
  return this.point(utils$i.toArray(z, Y), 1);
};
MontCurve.prototype.point = function(z, Y) {
  return new Point$1(this, z, Y);
};
MontCurve.prototype.pointFromJSON = function(z) {
  return Point$1.fromJSON(this, z);
};
Point$1.prototype.precompute = function() {
};
Point$1.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function(z, Y) {
  return new Point$1(z, Y[0], Y[1] || z.one);
};
Point$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function() {
  var z = this.x.redAdd(this.z), Y = z.redSqr(), ne = this.x.redSub(this.z), ie = ne.redSqr(), oe = Y.redSub(ie), se = Y.redMul(ie), ae = oe.redMul(ie.redAdd(this.curve.a24.redMul(oe)));
  return this.curve.point(se, ae);
};
Point$1.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function(z, Y) {
  var ne = this.x.redAdd(this.z), ie = this.x.redSub(this.z), oe = z.x.redAdd(z.z), se = z.x.redSub(z.z), ae = se.redMul(ne), ve = oe.redMul(ie), Pe = Y.z.redMul(ae.redAdd(ve).redSqr()), le = Y.x.redMul(ae.redISub(ve).redSqr());
  return this.curve.point(Pe, le);
};
Point$1.prototype.mul = function(z) {
  for (var Y = z.clone(), ne = this, ie = this.curve.point(null, null), oe = this, se = []; Y.cmpn(0) !== 0; Y.iushrn(1))
    se.push(Y.andln(1));
  for (var ae = se.length - 1; ae >= 0; ae--)
    se[ae] === 0 ? (ne = ne.diffAdd(ie, oe), ie = ie.dbl()) : (ie = ne.diffAdd(ie, oe), ne = ne.dbl());
  return ie;
};
Point$1.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function(z) {
  return this.getX().cmp(z.getX()) === 0;
};
Point$1.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$1.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var utils$h = utils$m, BN$6 = bnExports$1, inherits$2 = inherits_browserExports, Base = base$3, assert$c = utils$h.assert;
function EdwardsCurve(B) {
  this.twisted = (B.a | 0) !== 1, this.mOneA = this.twisted && (B.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", B), this.a = new BN$6(B.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$6(B.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$6(B.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (B.c | 0) === 1;
}
inherits$2(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function(z) {
  return this.mOneA ? z.redNeg() : this.a.redMul(z);
};
EdwardsCurve.prototype._mulC = function(z) {
  return this.oneC ? z : this.c.redMul(z);
};
EdwardsCurve.prototype.jpoint = function(z, Y, ne, ie) {
  return this.point(z, Y, ne, ie);
};
EdwardsCurve.prototype.pointFromX = function(z, Y) {
  z = new BN$6(z, 16), z.red || (z = z.toRed(this.red));
  var ne = z.redSqr(), ie = this.c2.redSub(this.a.redMul(ne)), oe = this.one.redSub(this.c2.redMul(this.d).redMul(ne)), se = ie.redMul(oe.redInvm()), ae = se.redSqrt();
  if (ae.redSqr().redSub(se).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var ve = ae.fromRed().isOdd();
  return (Y && !ve || !Y && ve) && (ae = ae.redNeg()), this.point(z, ae);
};
EdwardsCurve.prototype.pointFromY = function(z, Y) {
  z = new BN$6(z, 16), z.red || (z = z.toRed(this.red));
  var ne = z.redSqr(), ie = ne.redSub(this.c2), oe = ne.redMul(this.d).redMul(this.c2).redSub(this.a), se = ie.redMul(oe.redInvm());
  if (se.cmp(this.zero) === 0) {
    if (Y)
      throw new Error("invalid point");
    return this.point(this.zero, z);
  }
  var ae = se.redSqrt();
  if (ae.redSqr().redSub(se).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return ae.fromRed().isOdd() !== Y && (ae = ae.redNeg()), this.point(ae, z);
};
EdwardsCurve.prototype.validate = function(z) {
  if (z.isInfinity())
    return !0;
  z.normalize();
  var Y = z.x.redSqr(), ne = z.y.redSqr(), ie = Y.redMul(this.a).redAdd(ne), oe = this.c2.redMul(this.one.redAdd(this.d.redMul(Y).redMul(ne)));
  return ie.cmp(oe) === 0;
};
function Point(B, z, Y, ne, ie) {
  Base.BasePoint.call(this, B, "projective"), z === null && Y === null && ne === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$6(z, 16), this.y = new BN$6(Y, 16), this.z = ne ? new BN$6(ne, 16) : this.curve.one, this.t = ie && new BN$6(ie, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits$2(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function(z) {
  return Point.fromJSON(this, z);
};
EdwardsCurve.prototype.point = function(z, Y, ne, ie) {
  return new Point(this, z, Y, ne, ie);
};
Point.fromJSON = function(z, Y) {
  return new Point(z, Y[0], Y[1], Y[2]);
};
Point.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function() {
  var z = this.x.redSqr(), Y = this.y.redSqr(), ne = this.z.redSqr();
  ne = ne.redIAdd(ne);
  var ie = this.curve._mulA(z), oe = this.x.redAdd(this.y).redSqr().redISub(z).redISub(Y), se = ie.redAdd(Y), ae = se.redSub(ne), ve = ie.redSub(Y), Pe = oe.redMul(ae), le = se.redMul(ve), Ee = oe.redMul(ve), Je = ae.redMul(se);
  return this.curve.point(Pe, le, Je, Ee);
};
Point.prototype._projDbl = function() {
  var z = this.x.redAdd(this.y).redSqr(), Y = this.x.redSqr(), ne = this.y.redSqr(), ie, oe, se, ae, ve, Pe;
  if (this.curve.twisted) {
    ae = this.curve._mulA(Y);
    var le = ae.redAdd(ne);
    this.zOne ? (ie = z.redSub(Y).redSub(ne).redMul(le.redSub(this.curve.two)), oe = le.redMul(ae.redSub(ne)), se = le.redSqr().redSub(le).redSub(le)) : (ve = this.z.redSqr(), Pe = le.redSub(ve).redISub(ve), ie = z.redSub(Y).redISub(ne).redMul(Pe), oe = le.redMul(ae.redSub(ne)), se = le.redMul(Pe));
  } else
    ae = Y.redAdd(ne), ve = this.curve._mulC(this.z).redSqr(), Pe = ae.redSub(ve).redSub(ve), ie = this.curve._mulC(z.redISub(ae)).redMul(Pe), oe = this.curve._mulC(ae).redMul(Y.redISub(ne)), se = ae.redMul(Pe);
  return this.curve.point(ie, oe, se);
};
Point.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point.prototype._extAdd = function(z) {
  var Y = this.y.redSub(this.x).redMul(z.y.redSub(z.x)), ne = this.y.redAdd(this.x).redMul(z.y.redAdd(z.x)), ie = this.t.redMul(this.curve.dd).redMul(z.t), oe = this.z.redMul(z.z.redAdd(z.z)), se = ne.redSub(Y), ae = oe.redSub(ie), ve = oe.redAdd(ie), Pe = ne.redAdd(Y), le = se.redMul(ae), Ee = ve.redMul(Pe), Je = se.redMul(Pe), Ce = ae.redMul(ve);
  return this.curve.point(le, Ee, Ce, Je);
};
Point.prototype._projAdd = function(z) {
  var Y = this.z.redMul(z.z), ne = Y.redSqr(), ie = this.x.redMul(z.x), oe = this.y.redMul(z.y), se = this.curve.d.redMul(ie).redMul(oe), ae = ne.redSub(se), ve = ne.redAdd(se), Pe = this.x.redAdd(this.y).redMul(z.x.redAdd(z.y)).redISub(ie).redISub(oe), le = Y.redMul(ae).redMul(Pe), Ee, Je;
  return this.curve.twisted ? (Ee = Y.redMul(ve).redMul(oe.redSub(this.curve._mulA(ie))), Je = ae.redMul(ve)) : (Ee = Y.redMul(ve).redMul(oe.redSub(ie)), Je = this.curve._mulC(ae).redMul(ve)), this.curve.point(le, Ee, Je);
};
Point.prototype.add = function(z) {
  return this.isInfinity() ? z : z.isInfinity() ? this : this.curve.extended ? this._extAdd(z) : this._projAdd(z);
};
Point.prototype.mul = function(z) {
  return this._hasDoubles(z) ? this.curve._fixedNafMul(this, z) : this.curve._wnafMul(this, z);
};
Point.prototype.mulAdd = function(z, Y, ne) {
  return this.curve._wnafMulAdd(1, [this, Y], [z, ne], 2, !1);
};
Point.prototype.jmulAdd = function(z, Y, ne) {
  return this.curve._wnafMulAdd(1, [this, Y], [z, ne], 2, !0);
};
Point.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var z = this.z.redInvm();
  return this.x = this.x.redMul(z), this.y = this.y.redMul(z), this.t && (this.t = this.t.redMul(z)), this.z = this.curve.one, this.zOne = !0, this;
};
Point.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
Point.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
Point.prototype.eq = function(z) {
  return this === z || this.getX().cmp(z.getX()) === 0 && this.getY().cmp(z.getY()) === 0;
};
Point.prototype.eqXToP = function(z) {
  var Y = z.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(Y) === 0)
    return !0;
  for (var ne = z.clone(), ie = this.curve.redN.redMul(this.z); ; ) {
    if (ne.iadd(this.curve.n), ne.cmp(this.curve.p) >= 0)
      return !1;
    if (Y.redIAdd(ie), this.x.cmp(Y) === 0)
      return !0;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(B) {
  var z = B;
  z.base = base$3, z.short = short, z.mont = mont, z.edwards = edwards;
})(curve);
var curves$1 = {}, hash$2 = {}, utils$g = {}, assert$b = minimalisticAssert, inherits$1 = inherits_browserExports;
utils$g.inherits = inherits$1;
function isSurrogatePair(B, z) {
  return (B.charCodeAt(z) & 64512) !== 55296 || z < 0 || z + 1 >= B.length ? !1 : (B.charCodeAt(z + 1) & 64512) === 56320;
}
function toArray(B, z) {
  if (Array.isArray(B))
    return B.slice();
  if (!B)
    return [];
  var Y = [];
  if (typeof B == "string")
    if (z) {
      if (z === "hex")
        for (B = B.replace(/[^a-z0-9]+/ig, ""), B.length % 2 !== 0 && (B = "0" + B), ie = 0; ie < B.length; ie += 2)
          Y.push(parseInt(B[ie] + B[ie + 1], 16));
    } else for (var ne = 0, ie = 0; ie < B.length; ie++) {
      var oe = B.charCodeAt(ie);
      oe < 128 ? Y[ne++] = oe : oe < 2048 ? (Y[ne++] = oe >> 6 | 192, Y[ne++] = oe & 63 | 128) : isSurrogatePair(B, ie) ? (oe = 65536 + ((oe & 1023) << 10) + (B.charCodeAt(++ie) & 1023), Y[ne++] = oe >> 18 | 240, Y[ne++] = oe >> 12 & 63 | 128, Y[ne++] = oe >> 6 & 63 | 128, Y[ne++] = oe & 63 | 128) : (Y[ne++] = oe >> 12 | 224, Y[ne++] = oe >> 6 & 63 | 128, Y[ne++] = oe & 63 | 128);
    }
  else
    for (ie = 0; ie < B.length; ie++)
      Y[ie] = B[ie] | 0;
  return Y;
}
utils$g.toArray = toArray;
function toHex(B) {
  for (var z = "", Y = 0; Y < B.length; Y++)
    z += zero2(B[Y].toString(16));
  return z;
}
utils$g.toHex = toHex;
function htonl(B) {
  var z = B >>> 24 | B >>> 8 & 65280 | B << 8 & 16711680 | (B & 255) << 24;
  return z >>> 0;
}
utils$g.htonl = htonl;
function toHex32(B, z) {
  for (var Y = "", ne = 0; ne < B.length; ne++) {
    var ie = B[ne];
    z === "little" && (ie = htonl(ie)), Y += zero8(ie.toString(16));
  }
  return Y;
}
utils$g.toHex32 = toHex32;
function zero2(B) {
  return B.length === 1 ? "0" + B : B;
}
utils$g.zero2 = zero2;
function zero8(B) {
  return B.length === 7 ? "0" + B : B.length === 6 ? "00" + B : B.length === 5 ? "000" + B : B.length === 4 ? "0000" + B : B.length === 3 ? "00000" + B : B.length === 2 ? "000000" + B : B.length === 1 ? "0000000" + B : B;
}
utils$g.zero8 = zero8;
function join32(B, z, Y, ne) {
  var ie = Y - z;
  assert$b(ie % 4 === 0);
  for (var oe = new Array(ie / 4), se = 0, ae = z; se < oe.length; se++, ae += 4) {
    var ve;
    ne === "big" ? ve = B[ae] << 24 | B[ae + 1] << 16 | B[ae + 2] << 8 | B[ae + 3] : ve = B[ae + 3] << 24 | B[ae + 2] << 16 | B[ae + 1] << 8 | B[ae], oe[se] = ve >>> 0;
  }
  return oe;
}
utils$g.join32 = join32;
function split32(B, z) {
  for (var Y = new Array(B.length * 4), ne = 0, ie = 0; ne < B.length; ne++, ie += 4) {
    var oe = B[ne];
    z === "big" ? (Y[ie] = oe >>> 24, Y[ie + 1] = oe >>> 16 & 255, Y[ie + 2] = oe >>> 8 & 255, Y[ie + 3] = oe & 255) : (Y[ie + 3] = oe >>> 24, Y[ie + 2] = oe >>> 16 & 255, Y[ie + 1] = oe >>> 8 & 255, Y[ie] = oe & 255);
  }
  return Y;
}
utils$g.split32 = split32;
function rotr32$1(B, z) {
  return B >>> z | B << 32 - z;
}
utils$g.rotr32 = rotr32$1;
function rotl32$2(B, z) {
  return B << z | B >>> 32 - z;
}
utils$g.rotl32 = rotl32$2;
function sum32$3(B, z) {
  return B + z >>> 0;
}
utils$g.sum32 = sum32$3;
function sum32_3$1(B, z, Y) {
  return B + z + Y >>> 0;
}
utils$g.sum32_3 = sum32_3$1;
function sum32_4$2(B, z, Y, ne) {
  return B + z + Y + ne >>> 0;
}
utils$g.sum32_4 = sum32_4$2;
function sum32_5$2(B, z, Y, ne, ie) {
  return B + z + Y + ne + ie >>> 0;
}
utils$g.sum32_5 = sum32_5$2;
function sum64$1(B, z, Y, ne) {
  var ie = B[z], oe = B[z + 1], se = ne + oe >>> 0, ae = (se < ne ? 1 : 0) + Y + ie;
  B[z] = ae >>> 0, B[z + 1] = se;
}
utils$g.sum64 = sum64$1;
function sum64_hi$1(B, z, Y, ne) {
  var ie = z + ne >>> 0, oe = (ie < z ? 1 : 0) + B + Y;
  return oe >>> 0;
}
utils$g.sum64_hi = sum64_hi$1;
function sum64_lo$1(B, z, Y, ne) {
  var ie = z + ne;
  return ie >>> 0;
}
utils$g.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(B, z, Y, ne, ie, oe, se, ae) {
  var ve = 0, Pe = z;
  Pe = Pe + ne >>> 0, ve += Pe < z ? 1 : 0, Pe = Pe + oe >>> 0, ve += Pe < oe ? 1 : 0, Pe = Pe + ae >>> 0, ve += Pe < ae ? 1 : 0;
  var le = B + Y + ie + se + ve;
  return le >>> 0;
}
utils$g.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(B, z, Y, ne, ie, oe, se, ae) {
  var ve = z + ne + oe + ae;
  return ve >>> 0;
}
utils$g.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(B, z, Y, ne, ie, oe, se, ae, ve, Pe) {
  var le = 0, Ee = z;
  Ee = Ee + ne >>> 0, le += Ee < z ? 1 : 0, Ee = Ee + oe >>> 0, le += Ee < oe ? 1 : 0, Ee = Ee + ae >>> 0, le += Ee < ae ? 1 : 0, Ee = Ee + Pe >>> 0, le += Ee < Pe ? 1 : 0;
  var Je = B + Y + ie + se + ve + le;
  return Je >>> 0;
}
utils$g.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(B, z, Y, ne, ie, oe, se, ae, ve, Pe) {
  var le = z + ne + oe + ae + Pe;
  return le >>> 0;
}
utils$g.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(B, z, Y) {
  var ne = z << 32 - Y | B >>> Y;
  return ne >>> 0;
}
utils$g.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(B, z, Y) {
  var ne = B << 32 - Y | z >>> Y;
  return ne >>> 0;
}
utils$g.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(B, z, Y) {
  return B >>> Y;
}
utils$g.shr64_hi = shr64_hi$1;
function shr64_lo$1(B, z, Y) {
  var ne = B << 32 - Y | z >>> Y;
  return ne >>> 0;
}
utils$g.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$f = utils$g, assert$a = minimalisticAssert;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function(z, Y) {
  if (z = utils$f.toArray(z, Y), this.pending ? this.pending = this.pending.concat(z) : this.pending = z, this.pendingTotal += z.length, this.pending.length >= this._delta8) {
    z = this.pending;
    var ne = z.length % this._delta8;
    this.pending = z.slice(z.length - ne, z.length), this.pending.length === 0 && (this.pending = null), z = utils$f.join32(z, 0, z.length - ne, this.endian);
    for (var ie = 0; ie < z.length; ie += this._delta32)
      this._update(z, ie, ie + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function(z) {
  return this.update(this._pad()), assert$a(this.pending === null), this._digest(z);
};
BlockHash$4.prototype._pad = function() {
  var z = this.pendingTotal, Y = this._delta8, ne = Y - (z + this.padLength) % Y, ie = new Array(ne + this.padLength);
  ie[0] = 128;
  for (var oe = 1; oe < ne; oe++)
    ie[oe] = 0;
  if (z <<= 3, this.endian === "big") {
    for (var se = 8; se < this.padLength; se++)
      ie[oe++] = 0;
    ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = z >>> 24 & 255, ie[oe++] = z >>> 16 & 255, ie[oe++] = z >>> 8 & 255, ie[oe++] = z & 255;
  } else
    for (ie[oe++] = z & 255, ie[oe++] = z >>> 8 & 255, ie[oe++] = z >>> 16 & 255, ie[oe++] = z >>> 24 & 255, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, se = 8; se < this.padLength; se++)
      ie[oe++] = 0;
  return ie;
};
var sha = {}, common$4 = {}, utils$e = utils$g, rotr32 = utils$e.rotr32;
function ft_1$1(B, z, Y, ne) {
  if (B === 0)
    return ch32$1(z, Y, ne);
  if (B === 1 || B === 3)
    return p32(z, Y, ne);
  if (B === 2)
    return maj32$1(z, Y, ne);
}
common$4.ft_1 = ft_1$1;
function ch32$1(B, z, Y) {
  return B & z ^ ~B & Y;
}
common$4.ch32 = ch32$1;
function maj32$1(B, z, Y) {
  return B & z ^ B & Y ^ z & Y;
}
common$4.maj32 = maj32$1;
function p32(B, z, Y) {
  return B ^ z ^ Y;
}
common$4.p32 = p32;
function s0_256$1(B) {
  return rotr32(B, 2) ^ rotr32(B, 13) ^ rotr32(B, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(B) {
  return rotr32(B, 6) ^ rotr32(B, 11) ^ rotr32(B, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(B) {
  return rotr32(B, 7) ^ rotr32(B, 18) ^ B >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(B) {
  return rotr32(B, 17) ^ rotr32(B, 19) ^ B >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$d = utils$g, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$d.rotl32, sum32$2 = utils$d.sum32, sum32_5$1 = utils$d.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1$1() {
  if (!(this instanceof SHA1$1))
    return new SHA1$1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$d.inherits(SHA1$1, BlockHash$3);
var _1 = SHA1$1;
SHA1$1.blockSize = 512;
SHA1$1.outSize = 160;
SHA1$1.hmacStrength = 80;
SHA1$1.padLength = 64;
SHA1$1.prototype._update = function(z, Y) {
  for (var ne = this.W, ie = 0; ie < 16; ie++)
    ne[ie] = z[Y + ie];
  for (; ie < ne.length; ie++)
    ne[ie] = rotl32$1(ne[ie - 3] ^ ne[ie - 8] ^ ne[ie - 14] ^ ne[ie - 16], 1);
  var oe = this.h[0], se = this.h[1], ae = this.h[2], ve = this.h[3], Pe = this.h[4];
  for (ie = 0; ie < ne.length; ie++) {
    var le = ~~(ie / 20), Ee = sum32_5$1(rotl32$1(oe, 5), ft_1(le, se, ae, ve), Pe, ne[ie], sha1_K[le]);
    Pe = ve, ve = ae, ae = rotl32$1(se, 30), se = oe, oe = Ee;
  }
  this.h[0] = sum32$2(this.h[0], oe), this.h[1] = sum32$2(this.h[1], se), this.h[2] = sum32$2(this.h[2], ae), this.h[3] = sum32$2(this.h[3], ve), this.h[4] = sum32$2(this.h[4], Pe);
};
SHA1$1.prototype._digest = function(z) {
  return z === "hex" ? utils$d.toHex32(this.h, "big") : utils$d.split32(this.h, "big");
};
var utils$c = utils$g, common$2 = common$5, shaCommon = common$4, assert$9 = minimalisticAssert, sum32$1 = utils$c.sum32, sum32_4$1 = utils$c.sum32_4, sum32_5 = utils$c.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$c.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function(z, Y) {
  for (var ne = this.W, ie = 0; ie < 16; ie++)
    ne[ie] = z[Y + ie];
  for (; ie < ne.length; ie++)
    ne[ie] = sum32_4$1(g1_256(ne[ie - 2]), ne[ie - 7], g0_256(ne[ie - 15]), ne[ie - 16]);
  var oe = this.h[0], se = this.h[1], ae = this.h[2], ve = this.h[3], Pe = this.h[4], le = this.h[5], Ee = this.h[6], Je = this.h[7];
  for (assert$9(this.k.length === ne.length), ie = 0; ie < ne.length; ie++) {
    var Ce = sum32_5(Je, s1_256(Pe), ch32(Pe, le, Ee), this.k[ie], ne[ie]), _t = sum32$1(s0_256(oe), maj32(oe, se, ae));
    Je = Ee, Ee = le, le = Pe, Pe = sum32$1(ve, Ce), ve = ae, ae = se, se = oe, oe = sum32$1(Ce, _t);
  }
  this.h[0] = sum32$1(this.h[0], oe), this.h[1] = sum32$1(this.h[1], se), this.h[2] = sum32$1(this.h[2], ae), this.h[3] = sum32$1(this.h[3], ve), this.h[4] = sum32$1(this.h[4], Pe), this.h[5] = sum32$1(this.h[5], le), this.h[6] = sum32$1(this.h[6], Ee), this.h[7] = sum32$1(this.h[7], Je);
};
SHA256$1.prototype._digest = function(z) {
  return z === "hex" ? utils$c.toHex32(this.h, "big") : utils$c.split32(this.h, "big");
};
var utils$b = utils$g, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$b.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function(z) {
  return z === "hex" ? utils$b.toHex32(this.h.slice(0, 7), "big") : utils$b.split32(this.h.slice(0, 7), "big");
};
var utils$a = utils$g, common$1 = common$5, assert$8 = minimalisticAssert, rotr64_hi = utils$a.rotr64_hi, rotr64_lo = utils$a.rotr64_lo, shr64_hi = utils$a.shr64_hi, shr64_lo = utils$a.shr64_lo, sum64 = utils$a.sum64, sum64_hi = utils$a.sum64_hi, sum64_lo = utils$a.sum64_lo, sum64_4_hi = utils$a.sum64_4_hi, sum64_4_lo = utils$a.sum64_4_lo, sum64_5_hi = utils$a.sum64_5_hi, sum64_5_lo = utils$a.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$a.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function(z, Y) {
  for (var ne = this.W, ie = 0; ie < 32; ie++)
    ne[ie] = z[Y + ie];
  for (; ie < ne.length; ie += 2) {
    var oe = g1_512_hi(ne[ie - 4], ne[ie - 3]), se = g1_512_lo(ne[ie - 4], ne[ie - 3]), ae = ne[ie - 14], ve = ne[ie - 13], Pe = g0_512_hi(ne[ie - 30], ne[ie - 29]), le = g0_512_lo(ne[ie - 30], ne[ie - 29]), Ee = ne[ie - 32], Je = ne[ie - 31];
    ne[ie] = sum64_4_hi(
      oe,
      se,
      ae,
      ve,
      Pe,
      le,
      Ee,
      Je
    ), ne[ie + 1] = sum64_4_lo(
      oe,
      se,
      ae,
      ve,
      Pe,
      le,
      Ee,
      Je
    );
  }
};
SHA512$1.prototype._update = function(z, Y) {
  this._prepareBlock(z, Y);
  var ne = this.W, ie = this.h[0], oe = this.h[1], se = this.h[2], ae = this.h[3], ve = this.h[4], Pe = this.h[5], le = this.h[6], Ee = this.h[7], Je = this.h[8], Ce = this.h[9], _t = this.h[10], kt = this.h[11], Ct = this.h[12], Lt = this.h[13], Pt = this.h[14], Ft = this.h[15];
  assert$8(this.k.length === ne.length);
  for (var Ut = 0; Ut < ne.length; Ut += 2) {
    var Jt = Pt, Vt = Ft, ir = s1_512_hi(Je, Ce), jt = s1_512_lo(Je, Ce), Rt = ch64_hi(Je, Ce, _t, kt, Ct), Kt = ch64_lo(Je, Ce, _t, kt, Ct, Lt), Bt = this.k[Ut], Xe = this.k[Ut + 1], Ve = ne[Ut], ge = ne[Ut + 1], Ke = sum64_5_hi(
      Jt,
      Vt,
      ir,
      jt,
      Rt,
      Kt,
      Bt,
      Xe,
      Ve,
      ge
    ), ht = sum64_5_lo(
      Jt,
      Vt,
      ir,
      jt,
      Rt,
      Kt,
      Bt,
      Xe,
      Ve,
      ge
    );
    Jt = s0_512_hi(ie, oe), Vt = s0_512_lo(ie, oe), ir = maj64_hi(ie, oe, se, ae, ve), jt = maj64_lo(ie, oe, se, ae, ve, Pe);
    var wt = sum64_hi(Jt, Vt, ir, jt), vt = sum64_lo(Jt, Vt, ir, jt);
    Pt = Ct, Ft = Lt, Ct = _t, Lt = kt, _t = Je, kt = Ce, Je = sum64_hi(le, Ee, Ke, ht), Ce = sum64_lo(Ee, Ee, Ke, ht), le = ve, Ee = Pe, ve = se, Pe = ae, se = ie, ae = oe, ie = sum64_hi(Ke, ht, wt, vt), oe = sum64_lo(Ke, ht, wt, vt);
  }
  sum64(this.h, 0, ie, oe), sum64(this.h, 2, se, ae), sum64(this.h, 4, ve, Pe), sum64(this.h, 6, le, Ee), sum64(this.h, 8, Je, Ce), sum64(this.h, 10, _t, kt), sum64(this.h, 12, Ct, Lt), sum64(this.h, 14, Pt, Ft);
};
SHA512$1.prototype._digest = function(z) {
  return z === "hex" ? utils$a.toHex32(this.h, "big") : utils$a.split32(this.h, "big");
};
function ch64_hi(B, z, Y, ne, ie) {
  var oe = B & Y ^ ~B & ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function ch64_lo(B, z, Y, ne, ie, oe) {
  var se = z & ne ^ ~z & oe;
  return se < 0 && (se += 4294967296), se;
}
function maj64_hi(B, z, Y, ne, ie) {
  var oe = B & Y ^ B & ie ^ Y & ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function maj64_lo(B, z, Y, ne, ie, oe) {
  var se = z & ne ^ z & oe ^ ne & oe;
  return se < 0 && (se += 4294967296), se;
}
function s0_512_hi(B, z) {
  var Y = rotr64_hi(B, z, 28), ne = rotr64_hi(z, B, 2), ie = rotr64_hi(z, B, 7), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function s0_512_lo(B, z) {
  var Y = rotr64_lo(B, z, 28), ne = rotr64_lo(z, B, 2), ie = rotr64_lo(z, B, 7), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function s1_512_hi(B, z) {
  var Y = rotr64_hi(B, z, 14), ne = rotr64_hi(B, z, 18), ie = rotr64_hi(z, B, 9), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function s1_512_lo(B, z) {
  var Y = rotr64_lo(B, z, 14), ne = rotr64_lo(B, z, 18), ie = rotr64_lo(z, B, 9), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function g0_512_hi(B, z) {
  var Y = rotr64_hi(B, z, 1), ne = rotr64_hi(B, z, 8), ie = shr64_hi(B, z, 7), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function g0_512_lo(B, z) {
  var Y = rotr64_lo(B, z, 1), ne = rotr64_lo(B, z, 8), ie = shr64_lo(B, z, 7), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function g1_512_hi(B, z) {
  var Y = rotr64_hi(B, z, 19), ne = rotr64_hi(z, B, 29), ie = shr64_hi(B, z, 6), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function g1_512_lo(B, z) {
  var Y = rotr64_lo(B, z, 19), ne = rotr64_lo(z, B, 29), ie = shr64_lo(B, z, 6), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
var utils$9 = utils$g, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$9.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function(z) {
  return z === "hex" ? utils$9.toHex32(this.h.slice(0, 12), "big") : utils$9.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$8 = utils$g, common = common$5, rotl32 = utils$8.rotl32, sum32 = utils$8.sum32, sum32_3 = utils$8.sum32_3, sum32_4 = utils$8.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160$1() {
  if (!(this instanceof RIPEMD160$1))
    return new RIPEMD160$1();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$8.inherits(RIPEMD160$1, BlockHash);
ripemd.ripemd160 = RIPEMD160$1;
RIPEMD160$1.blockSize = 512;
RIPEMD160$1.outSize = 160;
RIPEMD160$1.hmacStrength = 192;
RIPEMD160$1.padLength = 64;
RIPEMD160$1.prototype._update = function(z, Y) {
  for (var ne = this.h[0], ie = this.h[1], oe = this.h[2], se = this.h[3], ae = this.h[4], ve = ne, Pe = ie, le = oe, Ee = se, Je = ae, Ce = 0; Ce < 80; Ce++) {
    var _t = sum32(
      rotl32(
        sum32_4(ne, f$1(Ce, ie, oe, se), z[r$1[Ce] + Y], K(Ce)),
        s$1[Ce]
      ),
      ae
    );
    ne = ae, ae = se, se = rotl32(oe, 10), oe = ie, ie = _t, _t = sum32(
      rotl32(
        sum32_4(ve, f$1(79 - Ce, Pe, le, Ee), z[rh[Ce] + Y], Kh(Ce)),
        sh[Ce]
      ),
      Je
    ), ve = Je, Je = Ee, Ee = rotl32(le, 10), le = Pe, Pe = _t;
  }
  _t = sum32_3(this.h[1], oe, Ee), this.h[1] = sum32_3(this.h[2], se, Je), this.h[2] = sum32_3(this.h[3], ae, ve), this.h[3] = sum32_3(this.h[4], ne, Pe), this.h[4] = sum32_3(this.h[0], ie, le), this.h[0] = _t;
};
RIPEMD160$1.prototype._digest = function(z) {
  return z === "hex" ? utils$8.toHex32(this.h, "little") : utils$8.split32(this.h, "little");
};
function f$1(B, z, Y, ne) {
  return B <= 15 ? z ^ Y ^ ne : B <= 31 ? z & Y | ~z & ne : B <= 47 ? (z | ~Y) ^ ne : B <= 63 ? z & ne | Y & ~ne : z ^ (Y | ~ne);
}
function K(B) {
  return B <= 15 ? 0 : B <= 31 ? 1518500249 : B <= 47 ? 1859775393 : B <= 63 ? 2400959708 : 2840853838;
}
function Kh(B) {
  return B <= 15 ? 1352829926 : B <= 31 ? 1548603684 : B <= 47 ? 1836072691 : B <= 63 ? 2053994217 : 0;
}
var r$1 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s$1 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$7 = utils$g, assert$7 = minimalisticAssert;
function Hmac(B, z, Y) {
  if (!(this instanceof Hmac))
    return new Hmac(B, z, Y);
  this.Hash = B, this.blockSize = B.blockSize / 8, this.outSize = B.outSize / 8, this.inner = null, this.outer = null, this._init(utils$7.toArray(z, Y));
}
var hmac = Hmac;
Hmac.prototype._init = function(z) {
  z.length > this.blockSize && (z = new this.Hash().update(z).digest()), assert$7(z.length <= this.blockSize);
  for (var Y = z.length; Y < this.blockSize; Y++)
    z.push(0);
  for (Y = 0; Y < z.length; Y++)
    z[Y] ^= 54;
  for (this.inner = new this.Hash().update(z), Y = 0; Y < z.length; Y++)
    z[Y] ^= 106;
  this.outer = new this.Hash().update(z);
};
Hmac.prototype.update = function(z, Y) {
  return this.inner.update(z, Y), this;
};
Hmac.prototype.digest = function(z) {
  return this.outer.update(this.inner.digest()), this.outer.digest(z);
};
(function(B) {
  var z = B;
  z.utils = utils$g, z.common = common$5, z.sha = sha, z.ripemd = ripemd, z.hmac = hmac, z.sha1 = z.sha.sha1, z.sha256 = z.sha.sha256, z.sha224 = z.sha.sha224, z.sha384 = z.sha.sha384, z.sha512 = z.sha.sha512, z.ripemd160 = z.ripemd.ripemd160;
})(hash$2);
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
(function(B) {
  var z = B, Y = hash$2, ne = curve, ie = utils$m, oe = ie.assert;
  function se(Pe) {
    Pe.type === "short" ? this.curve = new ne.short(Pe) : Pe.type === "edwards" ? this.curve = new ne.edwards(Pe) : this.curve = new ne.mont(Pe), this.g = this.curve.g, this.n = this.curve.n, this.hash = Pe.hash, oe(this.g.validate(), "Invalid curve"), oe(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  z.PresetCurve = se;
  function ae(Pe, le) {
    Object.defineProperty(z, Pe, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var Ee = new se(le);
        return Object.defineProperty(z, Pe, {
          configurable: !0,
          enumerable: !0,
          value: Ee
        }), Ee;
      }
    });
  }
  ae("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: Y.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), ae("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: Y.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), ae("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: Y.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), ae("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: Y.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), ae("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: Y.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), ae("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Y.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), ae("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Y.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var ve;
  try {
    ve = requireSecp256k1();
  } catch {
    ve = void 0;
  }
  ae("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: Y.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      ve
    ]
  });
})(curves$1);
var hash$1 = hash$2, utils$6 = utils$l, assert$6 = minimalisticAssert;
function HmacDRBG(B) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(B);
  this.hash = B.hash, this.predResist = !!B.predResist, this.outLen = this.hash.outSize, this.minEntropy = B.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var z = utils$6.toArray(B.entropy, B.entropyEnc || "hex"), Y = utils$6.toArray(B.nonce, B.nonceEnc || "hex"), ne = utils$6.toArray(B.pers, B.persEnc || "hex");
  assert$6(
    z.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(z, Y, ne);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function(z, Y, ne) {
  var ie = z.concat(Y).concat(ne);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var oe = 0; oe < this.V.length; oe++)
    this.K[oe] = 0, this.V[oe] = 1;
  this._update(ie), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function(z) {
  var Y = this._hmac().update(this.V).update([0]);
  z && (Y = Y.update(z)), this.K = Y.digest(), this.V = this._hmac().update(this.V).digest(), z && (this.K = this._hmac().update(this.V).update([1]).update(z).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function(z, Y, ne, ie) {
  typeof Y != "string" && (ie = ne, ne = Y, Y = null), z = utils$6.toArray(z, Y), ne = utils$6.toArray(ne, ie), assert$6(
    z.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(z.concat(ne || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function(z, Y, ne, ie) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof Y != "string" && (ie = ne, ne = Y, Y = null), ne && (ne = utils$6.toArray(ne, ie || "hex"), this._update(ne));
  for (var oe = []; oe.length < z; )
    this.V = this._hmac().update(this.V).digest(), oe = oe.concat(this.V);
  var se = oe.slice(0, z);
  return this._update(ne), this._reseed++, utils$6.encode(se, Y);
};
var BN$5 = bnExports$1, utils$5 = utils$m, assert$5 = utils$5.assert;
function KeyPair$2(B, z) {
  this.ec = B, this.priv = null, this.pub = null, z.priv && this._importPrivate(z.priv, z.privEnc), z.pub && this._importPublic(z.pub, z.pubEnc);
}
var key$1 = KeyPair$2;
KeyPair$2.fromPublic = function(z, Y, ne) {
  return Y instanceof KeyPair$2 ? Y : new KeyPair$2(z, {
    pub: Y,
    pubEnc: ne
  });
};
KeyPair$2.fromPrivate = function(z, Y, ne) {
  return Y instanceof KeyPair$2 ? Y : new KeyPair$2(z, {
    priv: Y,
    privEnc: ne
  });
};
KeyPair$2.prototype.validate = function() {
  var z = this.getPublic();
  return z.isInfinity() ? { result: !1, reason: "Invalid public key" } : z.validate() ? z.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$2.prototype.getPublic = function(z, Y) {
  return typeof z == "string" && (Y = z, z = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), Y ? this.pub.encode(Y, z) : this.pub;
};
KeyPair$2.prototype.getPrivate = function(z) {
  return z === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$2.prototype._importPrivate = function(z, Y) {
  this.priv = new BN$5(z, Y || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$2.prototype._importPublic = function(z, Y) {
  if (z.x || z.y) {
    this.ec.curve.type === "mont" ? assert$5(z.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$5(z.x && z.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(z.x, z.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(z, Y);
};
KeyPair$2.prototype.derive = function(z) {
  return z.validate() || assert$5(z.validate(), "public point not validated"), z.mul(this.priv).getX();
};
KeyPair$2.prototype.sign = function(z, Y, ne) {
  return this.ec.sign(z, this, Y, ne);
};
KeyPair$2.prototype.verify = function(z, Y, ne) {
  return this.ec.verify(z, Y, this, void 0, ne);
};
KeyPair$2.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$4 = bnExports$1, utils$4 = utils$m, assert$4 = utils$4.assert;
function Signature$2(B, z) {
  if (B instanceof Signature$2)
    return B;
  this._importDER(B, z) || (assert$4(B.r && B.s, "Signature without r or s"), this.r = new BN$4(B.r, 16), this.s = new BN$4(B.s, 16), B.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = B.recoveryParam);
}
var signature$1 = Signature$2;
function Position() {
  this.place = 0;
}
function getLength(B, z) {
  var Y = B[z.place++];
  if (!(Y & 128))
    return Y;
  var ne = Y & 15;
  if (ne === 0 || ne > 4 || B[z.place] === 0)
    return !1;
  for (var ie = 0, oe = 0, se = z.place; oe < ne; oe++, se++)
    ie <<= 8, ie |= B[se], ie >>>= 0;
  return ie <= 127 ? !1 : (z.place = se, ie);
}
function rmPadding(B) {
  for (var z = 0, Y = B.length - 1; !B[z] && !(B[z + 1] & 128) && z < Y; )
    z++;
  return z === 0 ? B : B.slice(z);
}
Signature$2.prototype._importDER = function(z, Y) {
  z = utils$4.toArray(z, Y);
  var ne = new Position();
  if (z[ne.place++] !== 48)
    return !1;
  var ie = getLength(z, ne);
  if (ie === !1 || ie + ne.place !== z.length || z[ne.place++] !== 2)
    return !1;
  var oe = getLength(z, ne);
  if (oe === !1 || z[ne.place] & 128)
    return !1;
  var se = z.slice(ne.place, oe + ne.place);
  if (ne.place += oe, z[ne.place++] !== 2)
    return !1;
  var ae = getLength(z, ne);
  if (ae === !1 || z.length !== ae + ne.place || z[ne.place] & 128)
    return !1;
  var ve = z.slice(ne.place, ae + ne.place);
  if (se[0] === 0)
    if (se[1] & 128)
      se = se.slice(1);
    else
      return !1;
  if (ve[0] === 0)
    if (ve[1] & 128)
      ve = ve.slice(1);
    else
      return !1;
  return this.r = new BN$4(se), this.s = new BN$4(ve), this.recoveryParam = null, !0;
};
function constructLength(B, z) {
  if (z < 128) {
    B.push(z);
    return;
  }
  var Y = 1 + (Math.log(z) / Math.LN2 >>> 3);
  for (B.push(Y | 128); --Y; )
    B.push(z >>> (Y << 3) & 255);
  B.push(z);
}
Signature$2.prototype.toDER = function(z) {
  var Y = this.r.toArray(), ne = this.s.toArray();
  for (Y[0] & 128 && (Y = [0].concat(Y)), ne[0] & 128 && (ne = [0].concat(ne)), Y = rmPadding(Y), ne = rmPadding(ne); !ne[0] && !(ne[1] & 128); )
    ne = ne.slice(1);
  var ie = [2];
  constructLength(ie, Y.length), ie = ie.concat(Y), ie.push(2), constructLength(ie, ne.length);
  var oe = ie.concat(ne), se = [48];
  return constructLength(se, oe.length), se = se.concat(oe), utils$4.encode(se, z);
};
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var B = bnExports$1, z = hmacDrbg, Y = utils$m, ne = curves$1, ie = requireBrorand(), oe = Y.assert, se = key$1, ae = signature$1;
  function ve(Pe) {
    if (!(this instanceof ve))
      return new ve(Pe);
    typeof Pe == "string" && (oe(
      Object.prototype.hasOwnProperty.call(ne, Pe),
      "Unknown curve " + Pe
    ), Pe = ne[Pe]), Pe instanceof ne.PresetCurve && (Pe = { curve: Pe }), this.curve = Pe.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = Pe.curve.g, this.g.precompute(Pe.curve.n.bitLength() + 1), this.hash = Pe.hash || Pe.curve.hash;
  }
  return ec = ve, ve.prototype.keyPair = function(le) {
    return new se(this, le);
  }, ve.prototype.keyFromPrivate = function(le, Ee) {
    return se.fromPrivate(this, le, Ee);
  }, ve.prototype.keyFromPublic = function(le, Ee) {
    return se.fromPublic(this, le, Ee);
  }, ve.prototype.genKeyPair = function(le) {
    le || (le = {});
    for (var Ee = new z({
      hash: this.hash,
      pers: le.pers,
      persEnc: le.persEnc || "utf8",
      entropy: le.entropy || ie(this.hash.hmacStrength),
      entropyEnc: le.entropy && le.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), Je = this.n.byteLength(), Ce = this.n.sub(new B(2)); ; ) {
      var _t = new B(Ee.generate(Je));
      if (!(_t.cmp(Ce) > 0))
        return _t.iaddn(1), this.keyFromPrivate(_t);
    }
  }, ve.prototype._truncateToN = function(le, Ee, Je) {
    var Ce;
    if (B.isBN(le) || typeof le == "number")
      le = new B(le, 16), Ce = le.byteLength();
    else if (typeof le == "object")
      Ce = le.length, le = new B(le, 16);
    else {
      var _t = le.toString();
      Ce = _t.length + 1 >>> 1, le = new B(_t, 16);
    }
    typeof Je != "number" && (Je = Ce * 8);
    var kt = Je - this.n.bitLength();
    return kt > 0 && (le = le.ushrn(kt)), !Ee && le.cmp(this.n) >= 0 ? le.sub(this.n) : le;
  }, ve.prototype.sign = function(le, Ee, Je, Ce) {
    if (typeof Je == "object" && (Ce = Je, Je = null), Ce || (Ce = {}), typeof le != "string" && typeof le != "number" && !B.isBN(le)) {
      oe(
        typeof le == "object" && le && typeof le.length == "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      ), oe(le.length >>> 0 === le.length);
      for (var _t = 0; _t < le.length; _t++) oe((le[_t] & 255) === le[_t]);
    }
    Ee = this.keyFromPrivate(Ee, Je), le = this._truncateToN(le, !1, Ce.msgBitLength), oe(!le.isNeg(), "Can not sign a negative message");
    var kt = this.n.byteLength(), Ct = Ee.getPrivate().toArray("be", kt), Lt = le.toArray("be", kt);
    oe(new B(Lt).eq(le), "Can not sign message");
    for (var Pt = new z({
      hash: this.hash,
      entropy: Ct,
      nonce: Lt,
      pers: Ce.pers,
      persEnc: Ce.persEnc || "utf8"
    }), Ft = this.n.sub(new B(1)), Ut = 0; ; Ut++) {
      var Jt = Ce.k ? Ce.k(Ut) : new B(Pt.generate(this.n.byteLength()));
      if (Jt = this._truncateToN(Jt, !0), !(Jt.cmpn(1) <= 0 || Jt.cmp(Ft) >= 0)) {
        var Vt = this.g.mul(Jt);
        if (!Vt.isInfinity()) {
          var ir = Vt.getX(), jt = ir.umod(this.n);
          if (jt.cmpn(0) !== 0) {
            var Rt = Jt.invm(this.n).mul(jt.mul(Ee.getPrivate()).iadd(le));
            if (Rt = Rt.umod(this.n), Rt.cmpn(0) !== 0) {
              var Kt = (Vt.getY().isOdd() ? 1 : 0) | (ir.cmp(jt) !== 0 ? 2 : 0);
              return Ce.canonical && Rt.cmp(this.nh) > 0 && (Rt = this.n.sub(Rt), Kt ^= 1), new ae({ r: jt, s: Rt, recoveryParam: Kt });
            }
          }
        }
      }
    }
  }, ve.prototype.verify = function(le, Ee, Je, Ce, _t) {
    _t || (_t = {}), le = this._truncateToN(le, !1, _t.msgBitLength), Je = this.keyFromPublic(Je, Ce), Ee = new ae(Ee, "hex");
    var kt = Ee.r, Ct = Ee.s;
    if (kt.cmpn(1) < 0 || kt.cmp(this.n) >= 0 || Ct.cmpn(1) < 0 || Ct.cmp(this.n) >= 0)
      return !1;
    var Lt = Ct.invm(this.n), Pt = Lt.mul(le).umod(this.n), Ft = Lt.mul(kt).umod(this.n), Ut;
    return this.curve._maxwellTrick ? (Ut = this.g.jmulAdd(Pt, Je.getPublic(), Ft), Ut.isInfinity() ? !1 : Ut.eqXToP(kt)) : (Ut = this.g.mulAdd(Pt, Je.getPublic(), Ft), Ut.isInfinity() ? !1 : Ut.getX().umod(this.n).cmp(kt) === 0);
  }, ve.prototype.recoverPubKey = function(Pe, le, Ee, Je) {
    oe((3 & Ee) === Ee, "The recovery param is more than two bits"), le = new ae(le, Je);
    var Ce = this.n, _t = new B(Pe), kt = le.r, Ct = le.s, Lt = Ee & 1, Pt = Ee >> 1;
    if (kt.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Pt)
      throw new Error("Unable to find sencond key candinate");
    Pt ? kt = this.curve.pointFromX(kt.add(this.curve.n), Lt) : kt = this.curve.pointFromX(kt, Lt);
    var Ft = le.r.invm(Ce), Ut = Ce.sub(_t).mul(Ft).umod(Ce), Jt = Ct.mul(Ft).umod(Ce);
    return this.g.mulAdd(Ut, kt, Jt);
  }, ve.prototype.getKeyRecoveryParam = function(Pe, le, Ee, Je) {
    if (le = new ae(le, Je), le.recoveryParam !== null)
      return le.recoveryParam;
    for (var Ce = 0; Ce < 4; Ce++) {
      var _t;
      try {
        _t = this.recoverPubKey(Pe, le, Ce);
      } catch {
        continue;
      }
      if (_t.eq(Ee))
        return Ce;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var utils$3 = utils$m, assert$3 = utils$3.assert, parseBytes$2 = utils$3.parseBytes, cachedProperty$1 = utils$3.cachedProperty;
function KeyPair$1(B, z) {
  this.eddsa = B, this._secret = parseBytes$2(z.secret), B.isPoint(z.pub) ? this._pub = z.pub : this._pubBytes = parseBytes$2(z.pub);
}
KeyPair$1.fromPublic = function(z, Y) {
  return Y instanceof KeyPair$1 ? Y : new KeyPair$1(z, { pub: Y });
};
KeyPair$1.fromSecret = function(z, Y) {
  return Y instanceof KeyPair$1 ? Y : new KeyPair$1(z, { secret: Y });
};
KeyPair$1.prototype.secret = function() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function() {
  var z = this.eddsa, Y = this.hash(), ne = z.encodingLength - 1, ie = Y.slice(0, z.encodingLength);
  return ie[0] &= 248, ie[ne] &= 127, ie[ne] |= 64, ie;
});
cachedProperty$1(KeyPair$1, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function(z) {
  return assert$3(this._secret, "KeyPair can only verify"), this.eddsa.sign(z, this);
};
KeyPair$1.prototype.verify = function(z, Y) {
  return this.eddsa.verify(z, Y, this);
};
KeyPair$1.prototype.getSecret = function(z) {
  return assert$3(this._secret, "KeyPair is public only"), utils$3.encode(this.secret(), z);
};
KeyPair$1.prototype.getPublic = function(z) {
  return utils$3.encode(this.pubBytes(), z);
};
var key = KeyPair$1, BN$3 = bnExports$1, utils$2 = utils$m, assert$2 = utils$2.assert, cachedProperty = utils$2.cachedProperty, parseBytes$1 = utils$2.parseBytes;
function Signature$1(B, z) {
  this.eddsa = B, typeof z != "object" && (z = parseBytes$1(z)), Array.isArray(z) && (assert$2(z.length === B.encodingLength * 2, "Signature has invalid size"), z = {
    R: z.slice(0, B.encodingLength),
    S: z.slice(B.encodingLength)
  }), assert$2(z.R && z.S, "Signature without R or S"), B.isPoint(z.R) && (this._R = z.R), z.S instanceof BN$3 && (this._S = z.S), this._Rencoded = Array.isArray(z.R) ? z.R : z.Rencoded, this._Sencoded = Array.isArray(z.S) ? z.S : z.Sencoded;
}
cachedProperty(Signature$1, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function() {
  return utils$2.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash = hash$2, curves = curves$1, utils$1 = utils$m, assert$1 = utils$1.assert, parseBytes = utils$1.parseBytes, KeyPair = key, Signature = signature;
function EDDSA(B) {
  if (assert$1(B === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(B);
  B = curves[B].curve, this.curve = B, this.g = B.g, this.g.precompute(B.n.bitLength() + 1), this.pointClass = B.point().constructor, this.encodingLength = Math.ceil(B.n.bitLength() / 8), this.hash = hash.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function(z, Y) {
  z = parseBytes(z);
  var ne = this.keyFromSecret(Y), ie = this.hashInt(ne.messagePrefix(), z), oe = this.g.mul(ie), se = this.encodePoint(oe), ae = this.hashInt(se, ne.pubBytes(), z).mul(ne.priv()), ve = ie.add(ae).umod(this.curve.n);
  return this.makeSignature({ R: oe, S: ve, Rencoded: se });
};
EDDSA.prototype.verify = function(z, Y, ne) {
  if (z = parseBytes(z), Y = this.makeSignature(Y), Y.S().gte(Y.eddsa.curve.n) || Y.S().isNeg())
    return !1;
  var ie = this.keyFromPublic(ne), oe = this.hashInt(Y.Rencoded(), ie.pubBytes(), z), se = this.g.mul(Y.S()), ae = Y.R().add(ie.pub().mul(oe));
  return ae.eq(se);
};
EDDSA.prototype.hashInt = function() {
  for (var z = this.hash(), Y = 0; Y < arguments.length; Y++)
    z.update(arguments[Y]);
  return utils$1.intFromLE(z.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function(z) {
  return KeyPair.fromPublic(this, z);
};
EDDSA.prototype.keyFromSecret = function(z) {
  return KeyPair.fromSecret(this, z);
};
EDDSA.prototype.makeSignature = function(z) {
  return z instanceof Signature ? z : new Signature(this, z);
};
EDDSA.prototype.encodePoint = function(z) {
  var Y = z.getY().toArray("le", this.encodingLength);
  return Y[this.encodingLength - 1] |= z.getX().isOdd() ? 128 : 0, Y;
};
EDDSA.prototype.decodePoint = function(z) {
  z = utils$1.parseBytes(z);
  var Y = z.length - 1, ne = z.slice(0, Y).concat(z[Y] & -129), ie = (z[Y] & 128) !== 0, oe = utils$1.intFromLE(ne);
  return this.curve.pointFromY(oe, ie);
};
EDDSA.prototype.encodeInt = function(z) {
  return z.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function(z) {
  return utils$1.intFromLE(z);
};
EDDSA.prototype.isPoint = function(z) {
  return z instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(B) {
    var z = B;
    z.version = require$$0.version, z.utils = utils$m, z.rand = requireBrorand(), z.curve = curve, z.curves = curves$1, z.ec = requireEc(), z.eddsa = eddsa;
  }(elliptic)), elliptic;
}
var asn1$3 = {}, asn1$2 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(B, z) {
      if (B.indexOf) return B.indexOf(z);
      for (var Y = 0; Y < B.length; Y++)
        if (B[Y] === z) return Y;
      return -1;
    }, Object_keys = function(B) {
      if (Object.keys) return Object.keys(B);
      var z = [];
      for (var Y in B) z.push(Y);
      return z;
    }, forEach = function(B, z) {
      if (B.forEach) return B.forEach(z);
      for (var Y = 0; Y < B.length; Y++)
        z(B[Y], Y, B);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(B, z, Y) {
          Object.defineProperty(B, z, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: Y
          });
        };
      } catch {
        return function(z, Y, ne) {
          z[Y] = ne;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(z) {
      if (!(this instanceof Script)) return new Script(z);
      this.code = z;
    };
    Script.prototype.runInContext = function(B) {
      if (!(B instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var z = document.createElement("iframe");
      z.style || (z.style = {}), z.style.display = "none", document.body.appendChild(z);
      var Y = z.contentWindow, ne = Y.eval, ie = Y.execScript;
      !ne && ie && (ie.call(Y, "null"), ne = Y.eval), forEach(Object_keys(B), function(ae) {
        Y[ae] = B[ae];
      }), forEach(globals, function(ae) {
        B[ae] && (Y[ae] = B[ae]);
      });
      var oe = Object_keys(Y), se = ne.call(Y, this.code);
      return forEach(Object_keys(Y), function(ae) {
        (ae in B || indexOf(oe, ae) === -1) && (B[ae] = Y[ae]);
      }), forEach(globals, function(ae) {
        ae in B || defineProp(B, ae, Y[ae]);
      }), document.body.removeChild(z), se;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(B) {
      var z = Script.createContext(B), Y = this.runInContext(z);
      return B && forEach(Object_keys(z), function(ne) {
        B[ne] = z[ne];
      }), Y;
    }, forEach(Object_keys(Script.prototype), function(B) {
      exports[B] = Script[B] = function(z) {
        var Y = Script(z);
        return Y[B].apply(Y, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(B) {
      return B instanceof Context;
    }, exports.createScript = function(B) {
      return exports.Script(B);
    }, exports.createContext = Script.createContext = function(B) {
      var z = new Context();
      return typeof B == "object" && forEach(Object_keys(B), function(Y) {
        z[Y] = B[Y];
      }), z;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(B) {
    var z = requireAsn1(), Y = inherits_browserExports, ne = B;
    ne.define = function(se, ae) {
      return new ie(se, ae);
    };
    function ie(oe, se) {
      this.name = oe, this.body = se, this.decoders = {}, this.encoders = {};
    }
    ie.prototype._createNamed = function(se) {
      var ae;
      try {
        ae = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        ae = function(Pe) {
          this._initNamed(Pe);
        };
      }
      return Y(ae, se), ae.prototype._initNamed = function(Pe) {
        se.call(this, Pe);
      }, new ae(this);
    }, ie.prototype._getDecoder = function(se) {
      return se = se || "der", this.decoders.hasOwnProperty(se) || (this.decoders[se] = this._createNamed(z.decoders[se])), this.decoders[se];
    }, ie.prototype.decode = function(se, ae, ve) {
      return this._getDecoder(ae).decode(se, ve);
    }, ie.prototype._getEncoder = function(se) {
      return se = se || "der", this.encoders.hasOwnProperty(se) || (this.encoders[se] = this._createNamed(z.encoders[se])), this.encoders[se];
    }, ie.prototype.encode = function(se, ae, ve) {
      return this._getEncoder(ae).encode(se, ve);
    };
  }(api)), api;
}
var base$2 = {}, reporter = {}, inherits = inherits_browserExports;
function Reporter(B) {
  this._reporterState = {
    obj: null,
    path: [],
    options: B || {},
    errors: []
  };
}
reporter.Reporter = Reporter;
Reporter.prototype.isError = function B(z) {
  return z instanceof ReporterError;
};
Reporter.prototype.save = function B() {
  var z = this._reporterState;
  return { obj: z.obj, pathLen: z.path.length };
};
Reporter.prototype.restore = function B(z) {
  var Y = this._reporterState;
  Y.obj = z.obj, Y.path = Y.path.slice(0, z.pathLen);
};
Reporter.prototype.enterKey = function B(z) {
  return this._reporterState.path.push(z);
};
Reporter.prototype.exitKey = function B(z) {
  var Y = this._reporterState;
  Y.path = Y.path.slice(0, z - 1);
};
Reporter.prototype.leaveKey = function B(z, Y, ne) {
  var ie = this._reporterState;
  this.exitKey(z), ie.obj !== null && (ie.obj[Y] = ne);
};
Reporter.prototype.path = function B() {
  return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function B() {
  var z = this._reporterState, Y = z.obj;
  return z.obj = {}, Y;
};
Reporter.prototype.leaveObject = function B(z) {
  var Y = this._reporterState, ne = Y.obj;
  return Y.obj = z, ne;
};
Reporter.prototype.error = function B(z) {
  var Y, ne = this._reporterState, ie = z instanceof ReporterError;
  if (ie ? Y = z : Y = new ReporterError(ne.path.map(function(oe) {
    return "[" + JSON.stringify(oe) + "]";
  }).join(""), z.message || z, z.stack), !ne.options.partial)
    throw Y;
  return ie || ne.errors.push(Y), Y;
};
Reporter.prototype.wrapResult = function B(z) {
  var Y = this._reporterState;
  return Y.options.partial ? {
    result: this.isError(z) ? null : z,
    errors: Y.errors
  } : z;
};
function ReporterError(B, z) {
  this.path = B, this.rethrow(z);
}
inherits(ReporterError, Error);
ReporterError.prototype.rethrow = function B(z) {
  if (this.message = z + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (Y) {
      this.stack = Y.stack;
    }
  return this;
};
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var B = inherits_browserExports, z = requireBase().Reporter, Y = require$$0$1.Buffer;
  function ne(oe, se) {
    if (z.call(this, se), !Y.isBuffer(oe)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = oe, this.offset = 0, this.length = oe.length;
  }
  B(ne, z), buffer.DecoderBuffer = ne, ne.prototype.save = function() {
    return { offset: this.offset, reporter: z.prototype.save.call(this) };
  }, ne.prototype.restore = function(se) {
    var ae = new ne(this.base);
    return ae.offset = se.offset, ae.length = this.offset, this.offset = se.offset, z.prototype.restore.call(this, se.reporter), ae;
  }, ne.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, ne.prototype.readUInt8 = function(se) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(se || "DecoderBuffer overrun");
  }, ne.prototype.skip = function(se, ae) {
    if (!(this.offset + se <= this.length))
      return this.error(ae || "DecoderBuffer overrun");
    var ve = new ne(this.base);
    return ve._reporterState = this._reporterState, ve.offset = this.offset, ve.length = this.offset + se, this.offset += se, ve;
  }, ne.prototype.raw = function(se) {
    return this.base.slice(se ? se.offset : this.offset, this.length);
  };
  function ie(oe, se) {
    if (Array.isArray(oe))
      this.length = 0, this.value = oe.map(function(ae) {
        return ae instanceof ie || (ae = new ie(ae, se)), this.length += ae.length, ae;
      }, this);
    else if (typeof oe == "number") {
      if (!(0 <= oe && oe <= 255))
        return se.error("non-byte EncoderBuffer value");
      this.value = oe, this.length = 1;
    } else if (typeof oe == "string")
      this.value = oe, this.length = Y.byteLength(oe);
    else if (Y.isBuffer(oe))
      this.value = oe, this.length = oe.length;
    else
      return se.error("Unsupported type: " + typeof oe);
  }
  return buffer.EncoderBuffer = ie, ie.prototype.join = function(se, ae) {
    return se || (se = new Y(this.length)), ae || (ae = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(ve) {
      ve.join(se, ae), ae += ve.length;
    }) : (typeof this.value == "number" ? se[ae] = this.value : typeof this.value == "string" ? se.write(this.value, ae) : Y.isBuffer(this.value) && this.value.copy(se, ae), ae += this.length)), se;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var B = requireBase().Reporter, z = requireBase().EncoderBuffer, Y = requireBase().DecoderBuffer, ne = minimalisticAssert, ie = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], oe = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(ie), se = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function ae(Pe, le) {
    var Ee = {};
    this._baseState = Ee, Ee.enc = Pe, Ee.parent = le || null, Ee.children = null, Ee.tag = null, Ee.args = null, Ee.reverseArgs = null, Ee.choice = null, Ee.optional = !1, Ee.any = !1, Ee.obj = !1, Ee.use = null, Ee.useDecoder = null, Ee.key = null, Ee.default = null, Ee.explicit = null, Ee.implicit = null, Ee.contains = null, Ee.parent || (Ee.children = [], this._wrap());
  }
  node = ae;
  var ve = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return ae.prototype.clone = function() {
    var le = this._baseState, Ee = {};
    ve.forEach(function(Ce) {
      Ee[Ce] = le[Ce];
    });
    var Je = new this.constructor(Ee.parent);
    return Je._baseState = Ee, Je;
  }, ae.prototype._wrap = function() {
    var le = this._baseState;
    oe.forEach(function(Ee) {
      this[Ee] = function() {
        var Ce = new this.constructor(this);
        return le.children.push(Ce), Ce[Ee].apply(Ce, arguments);
      };
    }, this);
  }, ae.prototype._init = function(le) {
    var Ee = this._baseState;
    ne(Ee.parent === null), le.call(this), Ee.children = Ee.children.filter(function(Je) {
      return Je._baseState.parent === this;
    }, this), ne.equal(Ee.children.length, 1, "Root node can have only one child");
  }, ae.prototype._useArgs = function(le) {
    var Ee = this._baseState, Je = le.filter(function(Ce) {
      return Ce instanceof this.constructor;
    }, this);
    le = le.filter(function(Ce) {
      return !(Ce instanceof this.constructor);
    }, this), Je.length !== 0 && (ne(Ee.children === null), Ee.children = Je, Je.forEach(function(Ce) {
      Ce._baseState.parent = this;
    }, this)), le.length !== 0 && (ne(Ee.args === null), Ee.args = le, Ee.reverseArgs = le.map(function(Ce) {
      if (typeof Ce != "object" || Ce.constructor !== Object)
        return Ce;
      var _t = {};
      return Object.keys(Ce).forEach(function(kt) {
        kt == (kt | 0) && (kt |= 0);
        var Ct = Ce[kt];
        _t[Ct] = kt;
      }), _t;
    }));
  }, se.forEach(function(Pe) {
    ae.prototype[Pe] = function() {
      var Ee = this._baseState;
      throw new Error(Pe + " not implemented for encoding: " + Ee.enc);
    };
  }), ie.forEach(function(Pe) {
    ae.prototype[Pe] = function() {
      var Ee = this._baseState, Je = Array.prototype.slice.call(arguments);
      return ne(Ee.tag === null), Ee.tag = Pe, this._useArgs(Je), this;
    };
  }), ae.prototype.use = function(le) {
    ne(le);
    var Ee = this._baseState;
    return ne(Ee.use === null), Ee.use = le, this;
  }, ae.prototype.optional = function() {
    var le = this._baseState;
    return le.optional = !0, this;
  }, ae.prototype.def = function(le) {
    var Ee = this._baseState;
    return ne(Ee.default === null), Ee.default = le, Ee.optional = !0, this;
  }, ae.prototype.explicit = function(le) {
    var Ee = this._baseState;
    return ne(Ee.explicit === null && Ee.implicit === null), Ee.explicit = le, this;
  }, ae.prototype.implicit = function(le) {
    var Ee = this._baseState;
    return ne(Ee.explicit === null && Ee.implicit === null), Ee.implicit = le, this;
  }, ae.prototype.obj = function() {
    var le = this._baseState, Ee = Array.prototype.slice.call(arguments);
    return le.obj = !0, Ee.length !== 0 && this._useArgs(Ee), this;
  }, ae.prototype.key = function(le) {
    var Ee = this._baseState;
    return ne(Ee.key === null), Ee.key = le, this;
  }, ae.prototype.any = function() {
    var le = this._baseState;
    return le.any = !0, this;
  }, ae.prototype.choice = function(le) {
    var Ee = this._baseState;
    return ne(Ee.choice === null), Ee.choice = le, this._useArgs(Object.keys(le).map(function(Je) {
      return le[Je];
    })), this;
  }, ae.prototype.contains = function(le) {
    var Ee = this._baseState;
    return ne(Ee.use === null), Ee.contains = le, this;
  }, ae.prototype._decode = function(le, Ee) {
    var Je = this._baseState;
    if (Je.parent === null)
      return le.wrapResult(Je.children[0]._decode(le, Ee));
    var Ce = Je.default, _t = !0, kt = null;
    if (Je.key !== null && (kt = le.enterKey(Je.key)), Je.optional) {
      var Ct = null;
      if (Je.explicit !== null ? Ct = Je.explicit : Je.implicit !== null ? Ct = Je.implicit : Je.tag !== null && (Ct = Je.tag), Ct === null && !Je.any) {
        var Lt = le.save();
        try {
          Je.choice === null ? this._decodeGeneric(Je.tag, le, Ee) : this._decodeChoice(le, Ee), _t = !0;
        } catch {
          _t = !1;
        }
        le.restore(Lt);
      } else if (_t = this._peekTag(le, Ct, Je.any), le.isError(_t))
        return _t;
    }
    var Pt;
    if (Je.obj && _t && (Pt = le.enterObject()), _t) {
      if (Je.explicit !== null) {
        var Ft = this._decodeTag(le, Je.explicit);
        if (le.isError(Ft))
          return Ft;
        le = Ft;
      }
      var Ut = le.offset;
      if (Je.use === null && Je.choice === null) {
        if (Je.any)
          var Lt = le.save();
        var Jt = this._decodeTag(
          le,
          Je.implicit !== null ? Je.implicit : Je.tag,
          Je.any
        );
        if (le.isError(Jt))
          return Jt;
        Je.any ? Ce = le.raw(Lt) : le = Jt;
      }
      if (Ee && Ee.track && Je.tag !== null && Ee.track(le.path(), Ut, le.length, "tagged"), Ee && Ee.track && Je.tag !== null && Ee.track(le.path(), le.offset, le.length, "content"), Je.any ? Ce = Ce : Je.choice === null ? Ce = this._decodeGeneric(Je.tag, le, Ee) : Ce = this._decodeChoice(le, Ee), le.isError(Ce))
        return Ce;
      if (!Je.any && Je.choice === null && Je.children !== null && Je.children.forEach(function(jt) {
        jt._decode(le, Ee);
      }), Je.contains && (Je.tag === "octstr" || Je.tag === "bitstr")) {
        var Vt = new Y(Ce);
        Ce = this._getUse(Je.contains, le._reporterState.obj)._decode(Vt, Ee);
      }
    }
    return Je.obj && _t && (Ce = le.leaveObject(Pt)), Je.key !== null && (Ce !== null || _t === !0) ? le.leaveKey(kt, Je.key, Ce) : kt !== null && le.exitKey(kt), Ce;
  }, ae.prototype._decodeGeneric = function(le, Ee, Je) {
    var Ce = this._baseState;
    return le === "seq" || le === "set" ? null : le === "seqof" || le === "setof" ? this._decodeList(Ee, le, Ce.args[0], Je) : /str$/.test(le) ? this._decodeStr(Ee, le, Je) : le === "objid" && Ce.args ? this._decodeObjid(Ee, Ce.args[0], Ce.args[1], Je) : le === "objid" ? this._decodeObjid(Ee, null, null, Je) : le === "gentime" || le === "utctime" ? this._decodeTime(Ee, le, Je) : le === "null_" ? this._decodeNull(Ee, Je) : le === "bool" ? this._decodeBool(Ee, Je) : le === "objDesc" ? this._decodeStr(Ee, le, Je) : le === "int" || le === "enum" ? this._decodeInt(Ee, Ce.args && Ce.args[0], Je) : Ce.use !== null ? this._getUse(Ce.use, Ee._reporterState.obj)._decode(Ee, Je) : Ee.error("unknown tag: " + le);
  }, ae.prototype._getUse = function(le, Ee) {
    var Je = this._baseState;
    return Je.useDecoder = this._use(le, Ee), ne(Je.useDecoder._baseState.parent === null), Je.useDecoder = Je.useDecoder._baseState.children[0], Je.implicit !== Je.useDecoder._baseState.implicit && (Je.useDecoder = Je.useDecoder.clone(), Je.useDecoder._baseState.implicit = Je.implicit), Je.useDecoder;
  }, ae.prototype._decodeChoice = function(le, Ee) {
    var Je = this._baseState, Ce = null, _t = !1;
    return Object.keys(Je.choice).some(function(kt) {
      var Ct = le.save(), Lt = Je.choice[kt];
      try {
        var Pt = Lt._decode(le, Ee);
        if (le.isError(Pt))
          return !1;
        Ce = { type: kt, value: Pt }, _t = !0;
      } catch {
        return le.restore(Ct), !1;
      }
      return !0;
    }, this), _t ? Ce : le.error("Choice not matched");
  }, ae.prototype._createEncoderBuffer = function(le) {
    return new z(le, this.reporter);
  }, ae.prototype._encode = function(le, Ee, Je) {
    var Ce = this._baseState;
    if (!(Ce.default !== null && Ce.default === le)) {
      var _t = this._encodeValue(le, Ee, Je);
      if (_t !== void 0 && !this._skipDefault(_t, Ee, Je))
        return _t;
    }
  }, ae.prototype._encodeValue = function(le, Ee, Je) {
    var Ce = this._baseState;
    if (Ce.parent === null)
      return Ce.children[0]._encode(le, Ee || new B());
    var Lt = null;
    if (this.reporter = Ee, Ce.optional && le === void 0)
      if (Ce.default !== null)
        le = Ce.default;
      else
        return;
    var _t = null, kt = !1;
    if (Ce.any)
      Lt = this._createEncoderBuffer(le);
    else if (Ce.choice)
      Lt = this._encodeChoice(le, Ee);
    else if (Ce.contains)
      _t = this._getUse(Ce.contains, Je)._encode(le, Ee), kt = !0;
    else if (Ce.children)
      _t = Ce.children.map(function(Ut) {
        if (Ut._baseState.tag === "null_")
          return Ut._encode(null, Ee, le);
        if (Ut._baseState.key === null)
          return Ee.error("Child should have a key");
        var Jt = Ee.enterKey(Ut._baseState.key);
        if (typeof le != "object")
          return Ee.error("Child expected, but input is not object");
        var Vt = Ut._encode(le[Ut._baseState.key], Ee, le);
        return Ee.leaveKey(Jt), Vt;
      }, this).filter(function(Ut) {
        return Ut;
      }), _t = this._createEncoderBuffer(_t);
    else if (Ce.tag === "seqof" || Ce.tag === "setof") {
      if (!(Ce.args && Ce.args.length === 1))
        return Ee.error("Too many args for : " + Ce.tag);
      if (!Array.isArray(le))
        return Ee.error("seqof/setof, but data is not Array");
      var Ct = this.clone();
      Ct._baseState.implicit = null, _t = this._createEncoderBuffer(le.map(function(Ut) {
        var Jt = this._baseState;
        return this._getUse(Jt.args[0], le)._encode(Ut, Ee);
      }, Ct));
    } else Ce.use !== null ? Lt = this._getUse(Ce.use, Je)._encode(le, Ee) : (_t = this._encodePrimitive(Ce.tag, le), kt = !0);
    var Lt;
    if (!Ce.any && Ce.choice === null) {
      var Pt = Ce.implicit !== null ? Ce.implicit : Ce.tag, Ft = Ce.implicit === null ? "universal" : "context";
      Pt === null ? Ce.use === null && Ee.error("Tag could be omitted only for .use()") : Ce.use === null && (Lt = this._encodeComposite(Pt, kt, Ft, _t));
    }
    return Ce.explicit !== null && (Lt = this._encodeComposite(Ce.explicit, !1, "context", Lt)), Lt;
  }, ae.prototype._encodeChoice = function(le, Ee) {
    var Je = this._baseState, Ce = Je.choice[le.type];
    return Ce || ne(
      !1,
      le.type + " not found in " + JSON.stringify(Object.keys(Je.choice))
    ), Ce._encode(le.value, Ee);
  }, ae.prototype._encodePrimitive = function(le, Ee) {
    var Je = this._baseState;
    if (/str$/.test(le))
      return this._encodeStr(Ee, le);
    if (le === "objid" && Je.args)
      return this._encodeObjid(Ee, Je.reverseArgs[0], Je.args[1]);
    if (le === "objid")
      return this._encodeObjid(Ee, null, null);
    if (le === "gentime" || le === "utctime")
      return this._encodeTime(Ee, le);
    if (le === "null_")
      return this._encodeNull();
    if (le === "int" || le === "enum")
      return this._encodeInt(Ee, Je.args && Je.reverseArgs[0]);
    if (le === "bool")
      return this._encodeBool(Ee);
    if (le === "objDesc")
      return this._encodeStr(Ee, le);
    throw new Error("Unsupported tag: " + le);
  }, ae.prototype._isNumstr = function(le) {
    return /^[0-9 ]*$/.test(le);
  }, ae.prototype._isPrintstr = function(le) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(le);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(B) {
    var z = B;
    z.Reporter = reporter.Reporter, z.DecoderBuffer = requireBuffer().DecoderBuffer, z.EncoderBuffer = requireBuffer().EncoderBuffer, z.Node = requireNode();
  }(base$2)), base$2;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(B) {
    var z = requireConstants();
    B.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, B.tagClassByName = z._reverse(B.tagClass), B.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, B.tagByName = z._reverse(B.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(B) {
    var z = B;
    z._reverse = function(ne) {
      var ie = {};
      return Object.keys(ne).forEach(function(oe) {
        (oe | 0) == oe && (oe = oe | 0);
        var se = ne[oe];
        ie[se] = oe;
      }), ie;
    }, z.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var B = inherits_browserExports, z = requireAsn1(), Y = z.base, ne = z.bignum, ie = z.constants.der;
  function oe(Pe) {
    this.enc = "der", this.name = Pe.name, this.entity = Pe, this.tree = new se(), this.tree._init(Pe.body);
  }
  der_1$1 = oe, oe.prototype.decode = function(le, Ee) {
    return le instanceof Y.DecoderBuffer || (le = new Y.DecoderBuffer(le, Ee)), this.tree._decode(le, Ee);
  };
  function se(Pe) {
    Y.Node.call(this, "der", Pe);
  }
  B(se, Y.Node), se.prototype._peekTag = function(le, Ee, Je) {
    if (le.isEmpty())
      return !1;
    var Ce = le.save(), _t = ae(le, 'Failed to peek tag: "' + Ee + '"');
    return le.isError(_t) ? _t : (le.restore(Ce), _t.tag === Ee || _t.tagStr === Ee || _t.tagStr + "of" === Ee || Je);
  }, se.prototype._decodeTag = function(le, Ee, Je) {
    var Ce = ae(
      le,
      'Failed to decode tag of "' + Ee + '"'
    );
    if (le.isError(Ce))
      return Ce;
    var _t = ve(
      le,
      Ce.primitive,
      'Failed to get length of "' + Ee + '"'
    );
    if (le.isError(_t))
      return _t;
    if (!Je && Ce.tag !== Ee && Ce.tagStr !== Ee && Ce.tagStr + "of" !== Ee)
      return le.error('Failed to match tag: "' + Ee + '"');
    if (Ce.primitive || _t !== null)
      return le.skip(_t, 'Failed to match body of: "' + Ee + '"');
    var kt = le.save(), Ct = this._skipUntilEnd(
      le,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return le.isError(Ct) ? Ct : (_t = le.offset - kt.offset, le.restore(kt), le.skip(_t, 'Failed to match body of: "' + Ee + '"'));
  }, se.prototype._skipUntilEnd = function(le, Ee) {
    for (; ; ) {
      var Je = ae(le, Ee);
      if (le.isError(Je))
        return Je;
      var Ce = ve(le, Je.primitive, Ee);
      if (le.isError(Ce))
        return Ce;
      var _t;
      if (Je.primitive || Ce !== null ? _t = le.skip(Ce) : _t = this._skipUntilEnd(le, Ee), le.isError(_t))
        return _t;
      if (Je.tagStr === "end")
        break;
    }
  }, se.prototype._decodeList = function(le, Ee, Je, Ce) {
    for (var _t = []; !le.isEmpty(); ) {
      var kt = this._peekTag(le, "end");
      if (le.isError(kt))
        return kt;
      var Ct = Je.decode(le, "der", Ce);
      if (le.isError(Ct) && kt)
        break;
      _t.push(Ct);
    }
    return _t;
  }, se.prototype._decodeStr = function(le, Ee) {
    if (Ee === "bitstr") {
      var Je = le.readUInt8();
      return le.isError(Je) ? Je : { unused: Je, data: le.raw() };
    } else if (Ee === "bmpstr") {
      var Ce = le.raw();
      if (Ce.length % 2 === 1)
        return le.error("Decoding of string type: bmpstr length mismatch");
      for (var _t = "", kt = 0; kt < Ce.length / 2; kt++)
        _t += String.fromCharCode(Ce.readUInt16BE(kt * 2));
      return _t;
    } else if (Ee === "numstr") {
      var Ct = le.raw().toString("ascii");
      return this._isNumstr(Ct) ? Ct : le.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (Ee === "octstr")
        return le.raw();
      if (Ee === "objDesc")
        return le.raw();
      if (Ee === "printstr") {
        var Lt = le.raw().toString("ascii");
        return this._isPrintstr(Lt) ? Lt : le.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(Ee) ? le.raw().toString() : le.error("Decoding of string type: " + Ee + " unsupported");
    }
  }, se.prototype._decodeObjid = function(le, Ee, Je) {
    for (var Ce, _t = [], kt = 0; !le.isEmpty(); ) {
      var Ct = le.readUInt8();
      kt <<= 7, kt |= Ct & 127, Ct & 128 || (_t.push(kt), kt = 0);
    }
    Ct & 128 && _t.push(kt);
    var Lt = _t[0] / 40 | 0, Pt = _t[0] % 40;
    if (Je ? Ce = _t : Ce = [Lt, Pt].concat(_t.slice(1)), Ee) {
      var Ft = Ee[Ce.join(" ")];
      Ft === void 0 && (Ft = Ee[Ce.join(".")]), Ft !== void 0 && (Ce = Ft);
    }
    return Ce;
  }, se.prototype._decodeTime = function(le, Ee) {
    var Je = le.raw().toString();
    if (Ee === "gentime")
      var Ce = Je.slice(0, 4) | 0, _t = Je.slice(4, 6) | 0, kt = Je.slice(6, 8) | 0, Ct = Je.slice(8, 10) | 0, Lt = Je.slice(10, 12) | 0, Pt = Je.slice(12, 14) | 0;
    else if (Ee === "utctime") {
      var Ce = Je.slice(0, 2) | 0, _t = Je.slice(2, 4) | 0, kt = Je.slice(4, 6) | 0, Ct = Je.slice(6, 8) | 0, Lt = Je.slice(8, 10) | 0, Pt = Je.slice(10, 12) | 0;
      Ce < 70 ? Ce = 2e3 + Ce : Ce = 1900 + Ce;
    } else
      return le.error("Decoding " + Ee + " time is not supported yet");
    return Date.UTC(Ce, _t - 1, kt, Ct, Lt, Pt, 0);
  }, se.prototype._decodeNull = function(le) {
    return null;
  }, se.prototype._decodeBool = function(le) {
    var Ee = le.readUInt8();
    return le.isError(Ee) ? Ee : Ee !== 0;
  }, se.prototype._decodeInt = function(le, Ee) {
    var Je = le.raw(), Ce = new ne(Je);
    return Ee && (Ce = Ee[Ce.toString(10)] || Ce), Ce;
  }, se.prototype._use = function(le, Ee) {
    return typeof le == "function" && (le = le(Ee)), le._getDecoder("der").tree;
  };
  function ae(Pe, le) {
    var Ee = Pe.readUInt8(le);
    if (Pe.isError(Ee))
      return Ee;
    var Je = ie.tagClass[Ee >> 6], Ce = (Ee & 32) === 0;
    if ((Ee & 31) === 31) {
      var _t = Ee;
      for (Ee = 0; (_t & 128) === 128; ) {
        if (_t = Pe.readUInt8(le), Pe.isError(_t))
          return _t;
        Ee <<= 7, Ee |= _t & 127;
      }
    } else
      Ee &= 31;
    var kt = ie.tag[Ee];
    return {
      cls: Je,
      primitive: Ce,
      tag: Ee,
      tagStr: kt
    };
  }
  function ve(Pe, le, Ee) {
    var Je = Pe.readUInt8(Ee);
    if (Pe.isError(Je))
      return Je;
    if (!le && Je === 128)
      return null;
    if (!(Je & 128))
      return Je;
    var Ce = Je & 127;
    if (Ce > 4)
      return Pe.error("length octect is too long");
    Je = 0;
    for (var _t = 0; _t < Ce; _t++) {
      Je <<= 8;
      var kt = Pe.readUInt8(Ee);
      if (Pe.isError(kt))
        return kt;
      Je |= kt;
    }
    return Je;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var B = inherits_browserExports, z = require$$0$1.Buffer, Y = requireDer$1();
  function ne(ie) {
    Y.call(this, ie), this.enc = "pem";
  }
  return B(ne, Y), pem$1 = ne, ne.prototype.decode = function(oe, se) {
    for (var ae = oe.toString().split(/[\r\n]+/g), ve = se.label.toUpperCase(), Pe = /^-----(BEGIN|END) ([^-]+)-----$/, le = -1, Ee = -1, Je = 0; Je < ae.length; Je++) {
      var Ce = ae[Je].match(Pe);
      if (Ce !== null && Ce[2] === ve)
        if (le === -1) {
          if (Ce[1] !== "BEGIN")
            break;
          le = Je;
        } else {
          if (Ce[1] !== "END")
            break;
          Ee = Je;
          break;
        }
    }
    if (le === -1 || Ee === -1)
      throw new Error("PEM section not found for: " + ve);
    var _t = ae.slice(le + 1, Ee).join("");
    _t.replace(/[^a-z0-9\+\/=]+/gi, "");
    var kt = new z(_t, "base64");
    return Y.prototype.decode.call(this, kt, se);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(B) {
    var z = B;
    z.der = requireDer$1(), z.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var B = inherits_browserExports, z = require$$0$1.Buffer, Y = requireAsn1(), ne = Y.base, ie = Y.constants.der;
  function oe(Pe) {
    this.enc = "der", this.name = Pe.name, this.entity = Pe, this.tree = new se(), this.tree._init(Pe.body);
  }
  der_1 = oe, oe.prototype.encode = function(le, Ee) {
    return this.tree._encode(le, Ee).join();
  };
  function se(Pe) {
    ne.Node.call(this, "der", Pe);
  }
  B(se, ne.Node), se.prototype._encodeComposite = function(le, Ee, Je, Ce) {
    var _t = ve(le, Ee, Je, this.reporter);
    if (Ce.length < 128) {
      var Lt = new z(2);
      return Lt[0] = _t, Lt[1] = Ce.length, this._createEncoderBuffer([Lt, Ce]);
    }
    for (var kt = 1, Ct = Ce.length; Ct >= 256; Ct >>= 8)
      kt++;
    var Lt = new z(2 + kt);
    Lt[0] = _t, Lt[1] = 128 | kt;
    for (var Ct = 1 + kt, Pt = Ce.length; Pt > 0; Ct--, Pt >>= 8)
      Lt[Ct] = Pt & 255;
    return this._createEncoderBuffer([Lt, Ce]);
  }, se.prototype._encodeStr = function(le, Ee) {
    if (Ee === "bitstr")
      return this._createEncoderBuffer([le.unused | 0, le.data]);
    if (Ee === "bmpstr") {
      for (var Je = new z(le.length * 2), Ce = 0; Ce < le.length; Ce++)
        Je.writeUInt16BE(le.charCodeAt(Ce), Ce * 2);
      return this._createEncoderBuffer(Je);
    } else return Ee === "numstr" ? this._isNumstr(le) ? this._createEncoderBuffer(le) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : Ee === "printstr" ? this._isPrintstr(le) ? this._createEncoderBuffer(le) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(Ee) ? this._createEncoderBuffer(le) : Ee === "objDesc" ? this._createEncoderBuffer(le) : this.reporter.error("Encoding of string type: " + Ee + " unsupported");
  }, se.prototype._encodeObjid = function(le, Ee, Je) {
    if (typeof le == "string") {
      if (!Ee)
        return this.reporter.error("string objid given, but no values map found");
      if (!Ee.hasOwnProperty(le))
        return this.reporter.error("objid not found in values map");
      le = Ee[le].split(/[\s\.]+/g);
      for (var Ce = 0; Ce < le.length; Ce++)
        le[Ce] |= 0;
    } else if (Array.isArray(le)) {
      le = le.slice();
      for (var Ce = 0; Ce < le.length; Ce++)
        le[Ce] |= 0;
    }
    if (!Array.isArray(le))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(le));
    if (!Je) {
      if (le[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      le.splice(0, 2, le[0] * 40 + le[1]);
    }
    for (var _t = 0, Ce = 0; Ce < le.length; Ce++) {
      var kt = le[Ce];
      for (_t++; kt >= 128; kt >>= 7)
        _t++;
    }
    for (var Ct = new z(_t), Lt = Ct.length - 1, Ce = le.length - 1; Ce >= 0; Ce--) {
      var kt = le[Ce];
      for (Ct[Lt--] = kt & 127; (kt >>= 7) > 0; )
        Ct[Lt--] = 128 | kt & 127;
    }
    return this._createEncoderBuffer(Ct);
  };
  function ae(Pe) {
    return Pe < 10 ? "0" + Pe : Pe;
  }
  se.prototype._encodeTime = function(le, Ee) {
    var Je, Ce = new Date(le);
    return Ee === "gentime" ? Je = [
      ae(Ce.getFullYear()),
      ae(Ce.getUTCMonth() + 1),
      ae(Ce.getUTCDate()),
      ae(Ce.getUTCHours()),
      ae(Ce.getUTCMinutes()),
      ae(Ce.getUTCSeconds()),
      "Z"
    ].join("") : Ee === "utctime" ? Je = [
      ae(Ce.getFullYear() % 100),
      ae(Ce.getUTCMonth() + 1),
      ae(Ce.getUTCDate()),
      ae(Ce.getUTCHours()),
      ae(Ce.getUTCMinutes()),
      ae(Ce.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + Ee + " time is not supported yet"), this._encodeStr(Je, "octstr");
  }, se.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, se.prototype._encodeInt = function(le, Ee) {
    if (typeof le == "string") {
      if (!Ee)
        return this.reporter.error("String int or enum given, but no values map");
      if (!Ee.hasOwnProperty(le))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(le));
      le = Ee[le];
    }
    if (typeof le != "number" && !z.isBuffer(le)) {
      var Je = le.toArray();
      !le.sign && Je[0] & 128 && Je.unshift(0), le = new z(Je);
    }
    if (z.isBuffer(le)) {
      var Ce = le.length;
      le.length === 0 && Ce++;
      var kt = new z(Ce);
      return le.copy(kt), le.length === 0 && (kt[0] = 0), this._createEncoderBuffer(kt);
    }
    if (le < 128)
      return this._createEncoderBuffer(le);
    if (le < 256)
      return this._createEncoderBuffer([0, le]);
    for (var Ce = 1, _t = le; _t >= 256; _t >>= 8)
      Ce++;
    for (var kt = new Array(Ce), _t = kt.length - 1; _t >= 0; _t--)
      kt[_t] = le & 255, le >>= 8;
    return kt[0] & 128 && kt.unshift(0), this._createEncoderBuffer(new z(kt));
  }, se.prototype._encodeBool = function(le) {
    return this._createEncoderBuffer(le ? 255 : 0);
  }, se.prototype._use = function(le, Ee) {
    return typeof le == "function" && (le = le(Ee)), le._getEncoder("der").tree;
  }, se.prototype._skipDefault = function(le, Ee, Je) {
    var Ce = this._baseState, _t;
    if (Ce.default === null)
      return !1;
    var kt = le.join();
    if (Ce.defaultBuffer === void 0 && (Ce.defaultBuffer = this._encodeValue(Ce.default, Ee, Je).join()), kt.length !== Ce.defaultBuffer.length)
      return !1;
    for (_t = 0; _t < kt.length; _t++)
      if (kt[_t] !== Ce.defaultBuffer[_t])
        return !1;
    return !0;
  };
  function ve(Pe, le, Ee, Je) {
    var Ce;
    if (Pe === "seqof" ? Pe = "seq" : Pe === "setof" && (Pe = "set"), ie.tagByName.hasOwnProperty(Pe))
      Ce = ie.tagByName[Pe];
    else if (typeof Pe == "number" && (Pe | 0) === Pe)
      Ce = Pe;
    else
      return Je.error("Unknown tag: " + Pe);
    return Ce >= 31 ? Je.error("Multi-octet tag encoding unsupported") : (le || (Ce |= 32), Ce |= ie.tagClassByName[Ee || "universal"] << 6, Ce);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var B = inherits_browserExports, z = requireDer();
  function Y(ne) {
    z.call(this, ne), this.enc = "pem";
  }
  return B(Y, z), pem = Y, Y.prototype.encode = function(ie, oe) {
    for (var se = z.prototype.encode.call(this, ie), ae = se.toString("base64"), ve = ["-----BEGIN " + oe.label + "-----"], Pe = 0; Pe < ae.length; Pe += 64)
      ve.push(ae.slice(Pe, Pe + 64));
    return ve.push("-----END " + oe.label + "-----"), ve.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(B) {
    var z = B;
    z.der = requireDer(), z.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1;
function requireAsn1() {
  return hasRequiredAsn1 || (hasRequiredAsn1 = 1, function(B) {
    var z = B;
    z.bignum = bnExports$1, z.define = requireApi().define, z.base = requireBase(), z.constants = requireConstants(), z.decoders = requireDecoders(), z.encoders = requireEncoders();
  }(asn1$2)), asn1$2;
}
var asn = requireAsn1(), Time = asn.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), AlgorithmIdentifier$1 = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPublicKey").bitstr()
  );
}), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
}), RDNSequence = asn.define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
}), Name = asn.define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
}), Validity = asn.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(Time),
    this.key("notAfter").use(Time)
  );
}), Extension = asn.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), TBSCertificate = asn.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(AlgorithmIdentifier$1),
    this.key("issuer").use(Name),
    this.key("validity").use(Validity),
    this.key("subject").use(Name),
    this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(Extension).optional()
  );
}), X509Certificate = asn.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(TBSCertificate),
    this.key("signatureAlgorithm").use(AlgorithmIdentifier$1),
    this.key("signatureValue").bitstr()
  );
}), certificate = X509Certificate, asn1$1 = requireAsn1();
asn1$3.certificate = certificate;
var RSAPrivateKey = asn1$1.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
asn1$3.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1$1.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
asn1$3.RSAPublicKey = RSAPublicKey;
var AlgorithmIdentifier = asn1$1.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), PublicKey = asn1$1.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPublicKey").bitstr()
  );
});
asn1$3.PublicKey = PublicKey;
var PrivateKeyInfo = asn1$1.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1$1.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1$1.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
asn1$3.DSAPrivateKey = DSAPrivateKey;
asn1$3.DSAparam = asn1$1.define("DSAparam", function() {
  this.int();
});
var ECParameters = asn1$1.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
}), ECPrivateKey = asn1$1.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(ECParameters),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
asn1$3.ECPrivateKey = ECPrivateKey;
asn1$3.signature = asn1$1.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = evp_bytestokey, ciphers$1 = browser$5, Buffer$7 = safeBufferExports$1.Buffer, fixProc$1 = function(B, z) {
  var Y = B.toString(), ne = Y.match(findProc), ie;
  if (ne) {
    var se = "aes" + ne[1], ae = Buffer$7.from(ne[2], "hex"), ve = Buffer$7.from(ne[3].replace(/[\r\n]/g, ""), "base64"), Pe = evp(z, ae.slice(0, 8), parseInt(ne[1], 10)).key, le = [], Ee = ciphers$1.createDecipheriv(se, Pe, ae);
    le.push(Ee.update(ve)), le.push(Ee.final()), ie = Buffer$7.concat(le);
  } else {
    var oe = Y.match(fullRegex);
    ie = Buffer$7.from(oe[2].replace(/[\r\n]/g, ""), "base64");
  }
  var Je = Y.match(startRegex)[1];
  return {
    tag: Je,
    data: ie
  };
}, asn1 = asn1$3, aesid = require$$1, fixProc = fixProc$1, ciphers = browser$5, compat = browser$7, Buffer$6 = safeBufferExports$1.Buffer;
function decrypt(B, z) {
  var Y = B.algorithm.decrypt.kde.kdeparams.salt, ne = parseInt(B.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), ie = aesid[B.algorithm.decrypt.cipher.algo.join(".")], oe = B.algorithm.decrypt.cipher.iv, se = B.subjectPrivateKey, ae = parseInt(ie.split("-")[1], 10) / 8, ve = compat.pbkdf2Sync(z, Y, ne, ae, "sha1"), Pe = ciphers.createDecipheriv(ie, ve, oe), le = [];
  return le.push(Pe.update(se)), le.push(Pe.final()), Buffer$6.concat(le);
}
function parseKeys$2(B) {
  var z;
  typeof B == "object" && !Buffer$6.isBuffer(B) && (z = B.passphrase, B = B.key), typeof B == "string" && (B = Buffer$6.from(B));
  var Y = fixProc(B, z), ne = Y.tag, ie = Y.data, oe, se;
  switch (ne) {
    case "CERTIFICATE":
      se = asn1.certificate.decode(ie, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (se || (se = asn1.PublicKey.decode(ie, "der")), oe = se.algorithm.algorithm.join("."), oe) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPublicKey.decode(se.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return se.subjectPrivateKey = se.subjectPublicKey, {
            type: "ec",
            data: se
          };
        case "1.2.840.10040.4.1":
          return se.algorithm.params.pub_key = asn1.DSAparam.decode(se.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: se.algorithm.params
          };
        default:
          throw new Error("unknown key id " + oe);
      }
    case "ENCRYPTED PRIVATE KEY":
      ie = asn1.EncryptedPrivateKey.decode(ie, "der"), ie = decrypt(ie, z);
    case "PRIVATE KEY":
      switch (se = asn1.PrivateKey.decode(ie, "der"), oe = se.algorithm.algorithm.join("."), oe) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPrivateKey.decode(se.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: se.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(se.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return se.algorithm.params.priv_key = asn1.DSAparam.decode(se.subjectPrivateKey, "der"), {
            type: "dsa",
            params: se.algorithm.params
          };
        default:
          throw new Error("unknown key id " + oe);
      }
    case "RSA PUBLIC KEY":
      return asn1.RSAPublicKey.decode(ie, "der");
    case "RSA PRIVATE KEY":
      return asn1.RSAPrivateKey.decode(ie, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: asn1.DSAPrivateKey.decode(ie, "der")
      };
    case "EC PRIVATE KEY":
      return ie = asn1.ECPrivateKey.decode(ie, "der"), {
        curve: ie.parameters.value,
        privateKey: ie.privateKey
      };
    default:
      throw new Error("unknown key type " + ne);
  }
}
parseKeys$2.signature = asn1.signature;
var parseAsn1 = parseKeys$2;
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var B = safeBufferExports$1.Buffer, z = browser$8, Y = browserifyRsa, ne = requireElliptic().ec, ie = bnExports, oe = parseAsn1, se = require$$4, ae = 1;
  function ve(Lt, Pt, Ft, Ut, Jt) {
    var Vt = oe(Pt);
    if (Vt.curve) {
      if (Ut !== "ecdsa" && Ut !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return Pe(Lt, Vt);
    } else if (Vt.type === "dsa") {
      if (Ut !== "dsa")
        throw new Error("wrong private key type");
      return le(Lt, Vt, Ft);
    }
    if (Ut !== "rsa" && Ut !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (Pt.padding !== void 0 && Pt.padding !== ae)
      throw new Error("illegal or unsupported padding mode");
    Lt = B.concat([Jt, Lt]);
    for (var ir = Vt.modulus.byteLength(), jt = [0, 1]; Lt.length + jt.length + 1 < ir; )
      jt.push(255);
    jt.push(0);
    for (var Rt = -1; ++Rt < Lt.length; )
      jt.push(Lt[Rt]);
    var Kt = Y(jt, Vt);
    return Kt;
  }
  function Pe(Lt, Pt) {
    var Ft = se[Pt.curve.join(".")];
    if (!Ft)
      throw new Error("unknown curve " + Pt.curve.join("."));
    var Ut = new ne(Ft), Jt = Ut.keyFromPrivate(Pt.privateKey), Vt = Jt.sign(Lt);
    return B.from(Vt.toDER());
  }
  function le(Lt, Pt, Ft) {
    for (var Ut = Pt.params.priv_key, Jt = Pt.params.p, Vt = Pt.params.q, ir = Pt.params.g, jt = new ie(0), Rt, Kt = Ce(Lt, Vt).mod(Vt), Bt = !1, Xe = Je(Ut, Vt, Lt, Ft); Bt === !1; )
      Rt = kt(Vt, Xe, Ft), jt = Ct(ir, Rt, Jt, Vt), Bt = Rt.invm(Vt).imul(Kt.add(Ut.mul(jt))).mod(Vt), Bt.cmpn(0) === 0 && (Bt = !1, jt = new ie(0));
    return Ee(jt, Bt);
  }
  function Ee(Lt, Pt) {
    Lt = Lt.toArray(), Pt = Pt.toArray(), Lt[0] & 128 && (Lt = [0].concat(Lt)), Pt[0] & 128 && (Pt = [0].concat(Pt));
    var Ft = Lt.length + Pt.length + 4, Ut = [
      48,
      Ft,
      2,
      Lt.length
    ];
    return Ut = Ut.concat(Lt, [2, Pt.length], Pt), B.from(Ut);
  }
  function Je(Lt, Pt, Ft, Ut) {
    if (Lt = B.from(Lt.toArray()), Lt.length < Pt.byteLength()) {
      var Jt = B.alloc(Pt.byteLength() - Lt.length);
      Lt = B.concat([Jt, Lt]);
    }
    var Vt = Ft.length, ir = _t(Ft, Pt), jt = B.alloc(Vt);
    jt.fill(1);
    var Rt = B.alloc(Vt);
    return Rt = z(Ut, Rt).update(jt).update(B.from([0])).update(Lt).update(ir).digest(), jt = z(Ut, Rt).update(jt).digest(), Rt = z(Ut, Rt).update(jt).update(B.from([1])).update(Lt).update(ir).digest(), jt = z(Ut, Rt).update(jt).digest(), { k: Rt, v: jt };
  }
  function Ce(Lt, Pt) {
    var Ft = new ie(Lt), Ut = (Lt.length << 3) - Pt.bitLength();
    return Ut > 0 && Ft.ishrn(Ut), Ft;
  }
  function _t(Lt, Pt) {
    Lt = Ce(Lt, Pt), Lt = Lt.mod(Pt);
    var Ft = B.from(Lt.toArray());
    if (Ft.length < Pt.byteLength()) {
      var Ut = B.alloc(Pt.byteLength() - Ft.length);
      Ft = B.concat([Ut, Ft]);
    }
    return Ft;
  }
  function kt(Lt, Pt, Ft) {
    var Ut, Jt;
    do {
      for (Ut = B.alloc(0); Ut.length * 8 < Lt.bitLength(); )
        Pt.v = z(Ft, Pt.k).update(Pt.v).digest(), Ut = B.concat([Ut, Pt.v]);
      Jt = Ce(Ut, Lt), Pt.k = z(Ft, Pt.k).update(Pt.v).update(B.from([0])).digest(), Pt.v = z(Ft, Pt.k).update(Pt.v).digest();
    } while (Jt.cmp(Lt) !== -1);
    return Jt;
  }
  function Ct(Lt, Pt, Ft, Ut) {
    return Lt.toRed(ie.mont(Ft)).redPow(Pt).fromRed().mod(Ut);
  }
  return sign.exports = ve, sign.exports.getKey = Je, sign.exports.makeKey = kt, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var B = safeBufferExports$1.Buffer, z = bnExports, Y = requireElliptic().ec, ne = parseAsn1, ie = require$$4;
  function oe(Pe, le, Ee, Je, Ce) {
    var _t = ne(Ee);
    if (_t.type === "ec") {
      if (Je !== "ecdsa" && Je !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return se(Pe, le, _t);
    } else if (_t.type === "dsa") {
      if (Je !== "dsa")
        throw new Error("wrong public key type");
      return ae(Pe, le, _t);
    }
    if (Je !== "rsa" && Je !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    le = B.concat([Ce, le]);
    for (var kt = _t.modulus.byteLength(), Ct = [1], Lt = 0; le.length + Ct.length + 2 < kt; )
      Ct.push(255), Lt += 1;
    Ct.push(0);
    for (var Pt = -1; ++Pt < le.length; )
      Ct.push(le[Pt]);
    Ct = B.from(Ct);
    var Ft = z.mont(_t.modulus);
    Pe = new z(Pe).toRed(Ft), Pe = Pe.redPow(new z(_t.publicExponent)), Pe = B.from(Pe.fromRed().toArray());
    var Ut = Lt < 8 ? 1 : 0;
    for (kt = Math.min(Pe.length, Ct.length), Pe.length !== Ct.length && (Ut = 1), Pt = -1; ++Pt < kt; )
      Ut |= Pe[Pt] ^ Ct[Pt];
    return Ut === 0;
  }
  function se(Pe, le, Ee) {
    var Je = ie[Ee.data.algorithm.curve.join(".")];
    if (!Je)
      throw new Error("unknown curve " + Ee.data.algorithm.curve.join("."));
    var Ce = new Y(Je), _t = Ee.data.subjectPrivateKey.data;
    return Ce.verify(le, Pe, _t);
  }
  function ae(Pe, le, Ee) {
    var Je = Ee.data.p, Ce = Ee.data.q, _t = Ee.data.g, kt = Ee.data.pub_key, Ct = ne.signature.decode(Pe, "der"), Lt = Ct.s, Pt = Ct.r;
    ve(Lt, Ce), ve(Pt, Ce);
    var Ft = z.mont(Je), Ut = Lt.invm(Ce), Jt = _t.toRed(Ft).redPow(new z(le).mul(Ut).mod(Ce)).fromRed().mul(kt.toRed(Ft).redPow(Pt.mul(Ut).mod(Ce)).fromRed()).mod(Je).mod(Ce);
    return Jt.cmp(Pt) === 0;
  }
  function ve(Pe, le) {
    if (Pe.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (Pe.cmp(le) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = oe, verify_1;
}
var browser$3, hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$3;
  hasRequiredBrowser$1 = 1;
  var B = safeBufferExports$1.Buffer, z = browser$9, Y = readableBrowserExports, ne = inherits_browserExports, ie = requireSign(), oe = requireVerify(), se = require$$6;
  Object.keys(se).forEach(function(Ee) {
    se[Ee].id = B.from(se[Ee].id, "hex"), se[Ee.toLowerCase()] = se[Ee];
  });
  function ae(Ee) {
    Y.Writable.call(this);
    var Je = se[Ee];
    if (!Je)
      throw new Error("Unknown message digest");
    this._hashType = Je.hash, this._hash = z(Je.hash), this._tag = Je.id, this._signType = Je.sign;
  }
  ne(ae, Y.Writable), ae.prototype._write = function(Je, Ce, _t) {
    this._hash.update(Je), _t();
  }, ae.prototype.update = function(Je, Ce) {
    return this._hash.update(typeof Je == "string" ? B.from(Je, Ce) : Je), this;
  }, ae.prototype.sign = function(Je, Ce) {
    this.end();
    var _t = this._hash.digest(), kt = ie(_t, Je, this._hashType, this._signType, this._tag);
    return Ce ? kt.toString(Ce) : kt;
  };
  function ve(Ee) {
    Y.Writable.call(this);
    var Je = se[Ee];
    if (!Je)
      throw new Error("Unknown message digest");
    this._hash = z(Je.hash), this._tag = Je.id, this._signType = Je.sign;
  }
  ne(ve, Y.Writable), ve.prototype._write = function(Je, Ce, _t) {
    this._hash.update(Je), _t();
  }, ve.prototype.update = function(Je, Ce) {
    return this._hash.update(typeof Je == "string" ? B.from(Je, Ce) : Je), this;
  }, ve.prototype.verify = function(Je, Ce, _t) {
    var kt = typeof Ce == "string" ? B.from(Ce, _t) : Ce;
    this.end();
    var Ct = this._hash.digest();
    return oe(kt, Ct, Je, this._signType, this._tag);
  };
  function Pe(Ee) {
    return new ae(Ee);
  }
  function le(Ee) {
    return new ve(Ee);
  }
  return browser$3 = {
    Sign: Pe,
    Verify: le,
    createSign: Pe,
    createVerify: le
  }, browser$3;
}
var browser$2, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser$2;
  hasRequiredBrowser = 1;
  var B = requireElliptic(), z = bnExports$1;
  browser$2 = function(se) {
    return new ne(se);
  };
  var Y = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  Y.p224 = Y.secp224r1, Y.p256 = Y.secp256r1 = Y.prime256v1, Y.p192 = Y.secp192r1 = Y.prime192v1, Y.p384 = Y.secp384r1, Y.p521 = Y.secp521r1;
  function ne(oe) {
    this.curveType = Y[oe], this.curveType || (this.curveType = {
      name: oe
    }), this.curve = new B.ec(this.curveType.name), this.keys = void 0;
  }
  ne.prototype.generateKeys = function(oe, se) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(oe, se);
  }, ne.prototype.computeSecret = function(oe, se, ae) {
    se = se || "utf8", Buffer$D.isBuffer(oe) || (oe = new Buffer$D(oe, se));
    var ve = this.curve.keyFromPublic(oe).getPublic(), Pe = ve.mul(this.keys.getPrivate()).getX();
    return ie(Pe, ae, this.curveType.byteLength);
  }, ne.prototype.getPublicKey = function(oe, se) {
    var ae = this.keys.getPublic(se === "compressed", !0);
    return se === "hybrid" && (ae[ae.length - 1] % 2 ? ae[0] = 7 : ae[0] = 6), ie(ae, oe);
  }, ne.prototype.getPrivateKey = function(oe) {
    return ie(this.keys.getPrivate(), oe);
  }, ne.prototype.setPublicKey = function(oe, se) {
    return se = se || "utf8", Buffer$D.isBuffer(oe) || (oe = new Buffer$D(oe, se)), this.keys._importPublic(oe), this;
  }, ne.prototype.setPrivateKey = function(oe, se) {
    se = se || "utf8", Buffer$D.isBuffer(oe) || (oe = new Buffer$D(oe, se));
    var ae = new z(oe);
    return ae = ae.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(ae), this;
  };
  function ie(oe, se, ae) {
    Array.isArray(oe) || (oe = oe.toArray());
    var ve = new Buffer$D(oe);
    if (ae && ve.length < ae) {
      var Pe = new Buffer$D(ae - ve.length);
      Pe.fill(0), ve = Buffer$D.concat([Pe, ve]);
    }
    return se ? ve.toString(se) : ve;
  }
  return browser$2;
}
var browser$1 = {}, createHash$2 = browser$9, Buffer$5 = safeBufferExports$1.Buffer, mgf$2 = function(B, z) {
  for (var Y = Buffer$5.alloc(0), ne = 0, ie; Y.length < z; )
    ie = i2ops(ne++), Y = Buffer$5.concat([Y, createHash$2("sha1").update(B).update(ie).digest()]);
  return Y.slice(0, z);
};
function i2ops(B) {
  var z = Buffer$5.allocUnsafe(4);
  return z.writeUInt32BE(B, 0), z;
}
var xor$2 = function B(z, Y) {
  for (var ne = z.length, ie = -1; ++ie < ne; )
    z[ie] ^= Y[ie];
  return z;
}, BN$2 = bnExports$1, Buffer$4 = safeBufferExports$1.Buffer;
function withPublic$2(B, z) {
  return Buffer$4.from(B.toRed(BN$2.mont(z.modulus)).redPow(new BN$2(z.publicExponent)).fromRed().toArray());
}
var withPublic_1 = withPublic$2, parseKeys$1 = parseAsn1, randomBytes = browserExports, createHash$1 = browser$9, mgf$1 = mgf$2, xor$1 = xor$2, BN$1 = bnExports$1, withPublic$1 = withPublic_1, crt$1 = browserifyRsa, Buffer$3 = safeBufferExports$1.Buffer, publicEncrypt = function B(z, Y, ne) {
  var ie;
  z.padding ? ie = z.padding : ne ? ie = 1 : ie = 4;
  var oe = parseKeys$1(z), se;
  if (ie === 4)
    se = oaep$1(oe, Y);
  else if (ie === 1)
    se = pkcs1$1(oe, Y, ne);
  else if (ie === 3) {
    if (se = new BN$1(Y), se.cmp(oe.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return ne ? crt$1(se, oe) : withPublic$1(se, oe);
};
function oaep$1(B, z) {
  var Y = B.modulus.byteLength(), ne = z.length, ie = createHash$1("sha1").update(Buffer$3.alloc(0)).digest(), oe = ie.length, se = 2 * oe;
  if (ne > Y - se - 2)
    throw new Error("message too long");
  var ae = Buffer$3.alloc(Y - ne - se - 2), ve = Y - oe - 1, Pe = randomBytes(oe), le = xor$1(Buffer$3.concat([ie, ae, Buffer$3.alloc(1, 1), z], ve), mgf$1(Pe, ve)), Ee = xor$1(Pe, mgf$1(le, oe));
  return new BN$1(Buffer$3.concat([Buffer$3.alloc(1), Ee, le], Y));
}
function pkcs1$1(B, z, Y) {
  var ne = z.length, ie = B.modulus.byteLength();
  if (ne > ie - 11)
    throw new Error("message too long");
  var oe;
  return Y ? oe = Buffer$3.alloc(ie - ne - 3, 255) : oe = nonZero(ie - ne - 3), new BN$1(Buffer$3.concat([Buffer$3.from([0, Y ? 1 : 2]), oe, Buffer$3.alloc(1), z], ie));
}
function nonZero(B) {
  for (var z = Buffer$3.allocUnsafe(B), Y = 0, ne = randomBytes(B * 2), ie = 0, oe; Y < B; )
    ie === ne.length && (ne = randomBytes(B * 2), ie = 0), oe = ne[ie++], oe && (z[Y++] = oe);
  return z;
}
var parseKeys = parseAsn1, mgf = mgf$2, xor = xor$2, BN = bnExports$1, crt = browserifyRsa, createHash = browser$9, withPublic = withPublic_1, Buffer$2 = safeBufferExports$1.Buffer, privateDecrypt = function B(z, Y, ne) {
  var ie;
  z.padding ? ie = z.padding : ne ? ie = 1 : ie = 4;
  var oe = parseKeys(z), se = oe.modulus.byteLength();
  if (Y.length > se || new BN(Y).cmp(oe.modulus) >= 0)
    throw new Error("decryption error");
  var ae;
  ne ? ae = withPublic(new BN(Y), oe) : ae = crt(Y, oe);
  var ve = Buffer$2.alloc(se - ae.length);
  if (ae = Buffer$2.concat([ve, ae], se), ie === 4)
    return oaep(oe, ae);
  if (ie === 1)
    return pkcs1(oe, ae, ne);
  if (ie === 3)
    return ae;
  throw new Error("unknown padding");
};
function oaep(B, z) {
  var Y = B.modulus.byteLength(), ne = createHash("sha1").update(Buffer$2.alloc(0)).digest(), ie = ne.length;
  if (z[0] !== 0)
    throw new Error("decryption error");
  var oe = z.slice(1, ie + 1), se = z.slice(ie + 1), ae = xor(oe, mgf(se, ie)), ve = xor(se, mgf(ae, Y - ie - 1));
  if (compare$1(ne, ve.slice(0, ie)))
    throw new Error("decryption error");
  for (var Pe = ie; ve[Pe] === 0; )
    Pe++;
  if (ve[Pe++] !== 1)
    throw new Error("decryption error");
  return ve.slice(Pe);
}
function pkcs1(B, z, Y) {
  for (var ne = z.slice(0, 2), ie = 2, oe = 0; z[ie++] !== 0; )
    if (ie >= z.length) {
      oe++;
      break;
    }
  var se = z.slice(2, ie - 1);
  if ((ne.toString("hex") !== "0002" && !Y || ne.toString("hex") !== "0001" && Y) && oe++, se.length < 8 && oe++, oe)
    throw new Error("decryption error");
  return z.slice(ie);
}
function compare$1(B, z) {
  B = Buffer$2.from(B), z = Buffer$2.from(z);
  var Y = 0, ne = B.length;
  B.length !== z.length && (Y++, ne = Math.min(B.length, z.length));
  for (var ie = -1; ++ie < ne; )
    Y += B[ie] ^ z[ie];
  return Y;
}
(function(B) {
  B.publicEncrypt = publicEncrypt, B.privateDecrypt = privateDecrypt, B.privateEncrypt = function(Y, ne) {
    return B.publicEncrypt(Y, ne, !0);
  }, B.publicDecrypt = function(Y, ne) {
    return B.privateDecrypt(Y, ne, !0);
  };
})(browser$1);
var browser = {};
function oldBrowser() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var safeBuffer = safeBufferExports$1, randombytes = browserExports, Buffer$1 = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto$2 = commonjsGlobal.crypto || commonjsGlobal.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(B, z) {
  if (typeof B != "number" || B !== B)
    throw new TypeError("offset must be a number");
  if (B > kMaxUint32 || B < 0)
    throw new TypeError("offset must be a uint32");
  if (B > kBufferMaxLength || B > z)
    throw new RangeError("offset out of range");
}
function assertSize(B, z, Y) {
  if (typeof B != "number" || B !== B)
    throw new TypeError("size must be a number");
  if (B > kMaxUint32 || B < 0)
    throw new TypeError("size must be a uint32");
  if (B + z > Y || B > kBufferMaxLength)
    throw new RangeError("buffer too small");
}
crypto$2 && crypto$2.getRandomValues || !process$1.browser ? (browser.randomFill = randomFill, browser.randomFillSync = randomFillSync) : (browser.randomFill = oldBrowser, browser.randomFillSync = oldBrowser);
function randomFill(B, z, Y, ne) {
  if (!Buffer$1.isBuffer(B) && !(B instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof z == "function")
    ne = z, z = 0, Y = B.length;
  else if (typeof Y == "function")
    ne = Y, Y = B.length - z;
  else if (typeof ne != "function")
    throw new TypeError('"cb" argument must be a function');
  return assertOffset(z, B.length), assertSize(Y, z, B.length), actualFill(B, z, Y, ne);
}
function actualFill(B, z, Y, ne) {
  if (process$1.browser) {
    var ie = B.buffer, oe = new Uint8Array(ie, z, Y);
    if (crypto$2.getRandomValues(oe), ne) {
      process$1.nextTick(function() {
        ne(null, B);
      });
      return;
    }
    return B;
  }
  if (ne) {
    randombytes(Y, function(ae, ve) {
      if (ae)
        return ne(ae);
      ve.copy(B, z), ne(null, B);
    });
    return;
  }
  var se = randombytes(Y);
  return se.copy(B, z), B;
}
function randomFillSync(B, z, Y) {
  if (typeof z > "u" && (z = 0), !Buffer$1.isBuffer(B) && !(B instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return assertOffset(z, B.length), Y === void 0 && (Y = B.length - z), assertSize(Y, z, B.length), actualFill(B, z, Y);
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports, cryptoBrowserify.createHash = cryptoBrowserify.Hash = browser$9, cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$8;
  var B = algos, z = Object.keys(B), Y = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(z);
  cryptoBrowserify.getHashes = function() {
    return Y;
  };
  var ne = browser$7;
  cryptoBrowserify.pbkdf2 = ne.pbkdf2, cryptoBrowserify.pbkdf2Sync = ne.pbkdf2Sync;
  var ie = browser$6;
  cryptoBrowserify.Cipher = ie.Cipher, cryptoBrowserify.createCipher = ie.createCipher, cryptoBrowserify.Cipheriv = ie.Cipheriv, cryptoBrowserify.createCipheriv = ie.createCipheriv, cryptoBrowserify.Decipher = ie.Decipher, cryptoBrowserify.createDecipher = ie.createDecipher, cryptoBrowserify.Decipheriv = ie.Decipheriv, cryptoBrowserify.createDecipheriv = ie.createDecipheriv, cryptoBrowserify.getCiphers = ie.getCiphers, cryptoBrowserify.listCiphers = ie.listCiphers;
  var oe = requireBrowser$2();
  cryptoBrowserify.DiffieHellmanGroup = oe.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = oe.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = oe.getDiffieHellman, cryptoBrowserify.createDiffieHellman = oe.createDiffieHellman, cryptoBrowserify.DiffieHellman = oe.DiffieHellman;
  var se = requireBrowser$1();
  cryptoBrowserify.createSign = se.createSign, cryptoBrowserify.Sign = se.Sign, cryptoBrowserify.createVerify = se.createVerify, cryptoBrowserify.Verify = se.Verify, cryptoBrowserify.createECDH = requireBrowser();
  var ae = browser$1;
  cryptoBrowserify.publicEncrypt = ae.publicEncrypt, cryptoBrowserify.privateEncrypt = ae.privateEncrypt, cryptoBrowserify.publicDecrypt = ae.publicDecrypt, cryptoBrowserify.privateDecrypt = ae.privateDecrypt;
  var ve = browser;
  return cryptoBrowserify.randomFill = ve.randomFill, cryptoBrowserify.randomFillSync = ve.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(B) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.utils = B.schnorr = B.verify = B.signSync = B.sign = B.getSharedSecret = B.recoverPublicKey = B.getPublicKey = B.Signature = B.Point = B.CURVE = void 0;
  const z = requireCryptoBrowserify(), Y = BigInt(0), ne = BigInt(1), ie = BigInt(2), oe = BigInt(3), se = BigInt(8), ae = Object.freeze({
    a: Y,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: ne,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  B.CURVE = ae;
  const ve = (tr, Xt) => (tr + Xt / ie) / Xt, Pe = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(tr) {
      const { n: Xt } = ae, rr = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), or = -ne * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), pr = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), vr = rr, wr = BigInt("0x100000000000000000000000000000000"), Er = ve(vr * tr, Xt), Pr = ve(-or * tr, Xt);
      let Ar = Dt(tr - Er * rr - Pr * pr, Xt), Tr = Dt(-Er * or - Pr * vr, Xt);
      const Nr = Ar > wr, Zt = Tr > wr;
      if (Nr && (Ar = Xt - Ar), Zt && (Tr = Xt - Tr), Ar > wr || Tr > wr)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + tr);
      return { k1neg: Nr, k1: Ar, k2neg: Zt, k2: Tr };
    }
  }, le = 32, Ee = 32, Je = 32, Ce = le + 1, _t = 2 * le + 1;
  function kt(tr) {
    const { a: Xt, b: rr } = ae, or = Dt(tr * tr), pr = Dt(or * tr);
    return Dt(pr + Xt * tr + rr);
  }
  const Ct = ae.a === Y;
  class Lt extends Error {
    constructor(Xt) {
      super(Xt);
    }
  }
  function Pt(tr) {
    if (!(tr instanceof Ft))
      throw new TypeError("JacobianPoint expected");
  }
  class Ft {
    constructor(Xt, rr, or) {
      this.x = Xt, this.y = rr, this.z = or;
    }
    static fromAffine(Xt) {
      if (!(Xt instanceof Vt))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return Xt.equals(Vt.ZERO) ? Ft.ZERO : new Ft(Xt.x, Xt.y, ne);
    }
    static toAffineBatch(Xt) {
      const rr = Ht(Xt.map((or) => or.z));
      return Xt.map((or, pr) => or.toAffine(rr[pr]));
    }
    static normalizeZ(Xt) {
      return Ft.toAffineBatch(Xt).map(Ft.fromAffine);
    }
    equals(Xt) {
      Pt(Xt);
      const { x: rr, y: or, z: pr } = this, { x: vr, y: wr, z: Er } = Xt, Pr = Dt(pr * pr), Ar = Dt(Er * Er), Tr = Dt(rr * Ar), Nr = Dt(vr * Pr), Zt = Dt(Dt(or * Er) * Ar), yr = Dt(Dt(wr * pr) * Pr);
      return Tr === Nr && Zt === yr;
    }
    negate() {
      return new Ft(this.x, Dt(-this.y), this.z);
    }
    double() {
      const { x: Xt, y: rr, z: or } = this, pr = Dt(Xt * Xt), vr = Dt(rr * rr), wr = Dt(vr * vr), Er = Xt + vr, Pr = Dt(ie * (Dt(Er * Er) - pr - wr)), Ar = Dt(oe * pr), Tr = Dt(Ar * Ar), Nr = Dt(Tr - ie * Pr), Zt = Dt(Ar * (Pr - Nr) - se * wr), yr = Dt(ie * rr * or);
      return new Ft(Nr, Zt, yr);
    }
    add(Xt) {
      Pt(Xt);
      const { x: rr, y: or, z: pr } = this, { x: vr, y: wr, z: Er } = Xt;
      if (vr === Y || wr === Y)
        return this;
      if (rr === Y || or === Y)
        return Xt;
      const Pr = Dt(pr * pr), Ar = Dt(Er * Er), Tr = Dt(rr * Ar), Nr = Dt(vr * Pr), Zt = Dt(Dt(or * Er) * Ar), yr = Dt(Dt(wr * pr) * Pr), _r = Dt(Nr - Tr), Sr = Dt(yr - Zt);
      if (_r === Y)
        return Sr === Y ? this.double() : Ft.ZERO;
      const Cr = Dt(_r * _r), Fr = Dt(_r * Cr), Rr = Dt(Tr * Cr), Gr = Dt(Sr * Sr - Fr - ie * Rr), sn = Dt(Sr * (Rr - Gr) - Zt * Fr), en = Dt(pr * Er * _r);
      return new Ft(Gr, sn, en);
    }
    subtract(Xt) {
      return this.add(Xt.negate());
    }
    multiplyUnsafe(Xt) {
      const rr = Ft.ZERO;
      if (typeof Xt == "bigint" && Xt === Y)
        return rr;
      let or = bt(Xt);
      if (or === ne)
        return this;
      if (!Ct) {
        let Nr = rr, Zt = this;
        for (; or > Y; )
          or & ne && (Nr = Nr.add(Zt)), Zt = Zt.double(), or >>= ne;
        return Nr;
      }
      let { k1neg: pr, k1: vr, k2neg: wr, k2: Er } = Pe.splitScalar(or), Pr = rr, Ar = rr, Tr = this;
      for (; vr > Y || Er > Y; )
        vr & ne && (Pr = Pr.add(Tr)), Er & ne && (Ar = Ar.add(Tr)), Tr = Tr.double(), vr >>= ne, Er >>= ne;
      return pr && (Pr = Pr.negate()), wr && (Ar = Ar.negate()), Ar = new Ft(Dt(Ar.x * Pe.beta), Ar.y, Ar.z), Pr.add(Ar);
    }
    precomputeWindow(Xt) {
      const rr = Ct ? 128 / Xt + 1 : 256 / Xt + 1, or = [];
      let pr = this, vr = pr;
      for (let wr = 0; wr < rr; wr++) {
        vr = pr, or.push(vr);
        for (let Er = 1; Er < 2 ** (Xt - 1); Er++)
          vr = vr.add(pr), or.push(vr);
        pr = vr.double();
      }
      return or;
    }
    wNAF(Xt, rr) {
      !rr && this.equals(Ft.BASE) && (rr = Vt.BASE);
      const or = rr && rr._WINDOW_SIZE || 1;
      if (256 % or)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let pr = rr && Jt.get(rr);
      pr || (pr = this.precomputeWindow(or), rr && or !== 1 && (pr = Ft.normalizeZ(pr), Jt.set(rr, pr)));
      let vr = Ft.ZERO, wr = Ft.BASE;
      const Er = 1 + (Ct ? 128 / or : 256 / or), Pr = 2 ** (or - 1), Ar = BigInt(2 ** or - 1), Tr = 2 ** or, Nr = BigInt(or);
      for (let Zt = 0; Zt < Er; Zt++) {
        const yr = Zt * Pr;
        let _r = Number(Xt & Ar);
        Xt >>= Nr, _r > Pr && (_r -= Tr, Xt += ne);
        const Sr = yr, Cr = yr + Math.abs(_r) - 1, Fr = Zt % 2 !== 0, Rr = _r < 0;
        _r === 0 ? wr = wr.add(Ut(Fr, pr[Sr])) : vr = vr.add(Ut(Rr, pr[Cr]));
      }
      return { p: vr, f: wr };
    }
    multiply(Xt, rr) {
      let or = bt(Xt), pr, vr;
      if (Ct) {
        const { k1neg: wr, k1: Er, k2neg: Pr, k2: Ar } = Pe.splitScalar(or);
        let { p: Tr, f: Nr } = this.wNAF(Er, rr), { p: Zt, f: yr } = this.wNAF(Ar, rr);
        Tr = Ut(wr, Tr), Zt = Ut(Pr, Zt), Zt = new Ft(Dt(Zt.x * Pe.beta), Zt.y, Zt.z), pr = Tr.add(Zt), vr = Nr.add(yr);
      } else {
        const { p: wr, f: Er } = this.wNAF(or, rr);
        pr = wr, vr = Er;
      }
      return Ft.normalizeZ([pr, vr])[0];
    }
    toAffine(Xt) {
      const { x: rr, y: or, z: pr } = this, vr = this.equals(Ft.ZERO);
      Xt == null && (Xt = vr ? se : Qt(pr));
      const wr = Xt, Er = Dt(wr * wr), Pr = Dt(Er * wr), Ar = Dt(rr * Er), Tr = Dt(or * Pr), Nr = Dt(pr * wr);
      if (vr)
        return Vt.ZERO;
      if (Nr !== ne)
        throw new Error("invZ was invalid");
      return new Vt(Ar, Tr);
    }
  }
  Ft.BASE = new Ft(ae.Gx, ae.Gy, ne), Ft.ZERO = new Ft(Y, ne, Y);
  function Ut(tr, Xt) {
    const rr = Xt.negate();
    return tr ? rr : Xt;
  }
  const Jt = /* @__PURE__ */ new WeakMap();
  class Vt {
    constructor(Xt, rr) {
      this.x = Xt, this.y = rr;
    }
    _setWindowSize(Xt) {
      this._WINDOW_SIZE = Xt, Jt.delete(this);
    }
    hasEvenY() {
      return this.y % ie === Y;
    }
    static fromCompressedHex(Xt) {
      const rr = Xt.length === 32, or = Qe(rr ? Xt : Xt.subarray(1));
      if (!gr(or))
        throw new Error("Point is not on curve");
      const pr = kt(or);
      let vr = fr(pr);
      const wr = (vr & ne) === ne;
      rr ? wr && (vr = Dt(-vr)) : (Xt[0] & 1) === 1 !== wr && (vr = Dt(-vr));
      const Er = new Vt(or, vr);
      return Er.assertValidity(), Er;
    }
    static fromUncompressedHex(Xt) {
      const rr = Qe(Xt.subarray(1, le + 1)), or = Qe(Xt.subarray(le + 1, le * 2 + 1)), pr = new Vt(rr, or);
      return pr.assertValidity(), pr;
    }
    static fromHex(Xt) {
      const rr = xt(Xt), or = rr.length, pr = rr[0];
      if (or === le)
        return this.fromCompressedHex(rr);
      if (or === Ce && (pr === 2 || pr === 3))
        return this.fromCompressedHex(rr);
      if (or === _t && pr === 4)
        return this.fromUncompressedHex(rr);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${Ce} compressed bytes or ${_t} uncompressed bytes, not ${or}`);
    }
    static fromPrivateKey(Xt) {
      return Vt.BASE.multiply(xr(Xt));
    }
    static fromSignature(Xt, rr, or) {
      const { r: pr, s: vr } = kr(rr);
      if (![0, 1, 2, 3].includes(or))
        throw new Error("Cannot recover: invalid recovery bit");
      const wr = nr(xt(Xt)), { n: Er } = ae, Pr = or === 2 || or === 3 ? pr + Er : pr, Ar = Qt(Pr, Er), Tr = Dt(-wr * Ar, Er), Nr = Dt(vr * Ar, Er), Zt = or & 1 ? "03" : "02", yr = Vt.fromHex(Zt + Ke(Pr)), _r = Vt.BASE.multiplyAndAddUnsafe(yr, Tr, Nr);
      if (!_r)
        throw new Error("Cannot recover signature: point at infinify");
      return _r.assertValidity(), _r;
    }
    toRawBytes(Xt = !1) {
      return $t(this.toHex(Xt));
    }
    toHex(Xt = !1) {
      const rr = Ke(this.x);
      return Xt ? `${this.hasEvenY() ? "02" : "03"}${rr}` : `04${rr}${Ke(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const Xt = "Point is not on elliptic curve", { x: rr, y: or } = this;
      if (!gr(rr) || !gr(or))
        throw new Error(Xt);
      const pr = Dt(or * or), vr = kt(rr);
      if (Dt(pr - vr) !== Y)
        throw new Error(Xt);
    }
    equals(Xt) {
      return this.x === Xt.x && this.y === Xt.y;
    }
    negate() {
      return new Vt(this.x, Dt(-this.y));
    }
    double() {
      return Ft.fromAffine(this).double().toAffine();
    }
    add(Xt) {
      return Ft.fromAffine(this).add(Ft.fromAffine(Xt)).toAffine();
    }
    subtract(Xt) {
      return this.add(Xt.negate());
    }
    multiply(Xt) {
      return Ft.fromAffine(this).multiply(Xt, this).toAffine();
    }
    multiplyAndAddUnsafe(Xt, rr, or) {
      const pr = Ft.fromAffine(this), vr = rr === Y || rr === ne || this !== Vt.BASE ? pr.multiplyUnsafe(rr) : pr.multiply(rr), wr = Ft.fromAffine(Xt).multiplyUnsafe(or), Er = vr.add(wr);
      return Er.equals(Ft.ZERO) ? void 0 : Er.toAffine();
    }
  }
  B.Point = Vt, Vt.BASE = new Vt(ae.Gx, ae.Gy), Vt.ZERO = new Vt(Y, Y);
  function ir(tr) {
    return Number.parseInt(tr[0], 16) >= 8 ? "00" + tr : tr;
  }
  function jt(tr) {
    if (tr.length < 2 || tr[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${Ve(tr)}`);
    const Xt = tr[1], rr = tr.subarray(2, Xt + 2);
    if (!Xt || rr.length !== Xt)
      throw new Error("Invalid signature integer: wrong length");
    if (rr[0] === 0 && rr[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: Qe(rr), left: tr.subarray(Xt + 2) };
  }
  function Rt(tr) {
    if (tr.length < 2 || tr[0] != 48)
      throw new Error(`Invalid signature tag: ${Ve(tr)}`);
    if (tr[1] !== tr.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: Xt, left: rr } = jt(tr.subarray(2)), { data: or, left: pr } = jt(rr);
    if (pr.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${Ve(pr)}`);
    return { r: Xt, s: or };
  }
  class Kt {
    constructor(Xt, rr) {
      this.r = Xt, this.s = rr, this.assertValidity();
    }
    static fromCompact(Xt) {
      const rr = Xt instanceof Uint8Array, or = "Signature.fromCompact";
      if (typeof Xt != "string" && !rr)
        throw new TypeError(`${or}: Expected string or Uint8Array`);
      const pr = rr ? Ve(Xt) : Xt;
      if (pr.length !== 128)
        throw new Error(`${or}: Expected 64-byte hex`);
      return new Kt(vt(pr.slice(0, 64)), vt(pr.slice(64, 128)));
    }
    static fromDER(Xt) {
      const rr = Xt instanceof Uint8Array;
      if (typeof Xt != "string" && !rr)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: or, s: pr } = Rt(rr ? Xt : $t(Xt));
      return new Kt(or, pr);
    }
    static fromHex(Xt) {
      return this.fromDER(Xt);
    }
    assertValidity() {
      const { r: Xt, s: rr } = this;
      if (!cr(Xt))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!cr(rr))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const Xt = ae.n >> ne;
      return this.s > Xt;
    }
    normalizeS() {
      return this.hasHighS() ? new Kt(this.r, Dt(-this.s, ae.n)) : this;
    }
    toDERRawBytes() {
      return $t(this.toDERHex());
    }
    toDERHex() {
      const Xt = ir(wt(this.s)), rr = ir(wt(this.r)), or = Xt.length / 2, pr = rr.length / 2, vr = wt(or), wr = wt(pr);
      return `30${wt(pr + or + 4)}02${wr}${rr}02${vr}${Xt}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return $t(this.toCompactHex());
    }
    toCompactHex() {
      return Ke(this.r) + Ke(this.s);
    }
  }
  B.Signature = Kt;
  function Bt(...tr) {
    if (!tr.every((or) => or instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (tr.length === 1)
      return tr[0];
    const Xt = tr.reduce((or, pr) => or + pr.length, 0), rr = new Uint8Array(Xt);
    for (let or = 0, pr = 0; or < tr.length; or++) {
      const vr = tr[or];
      rr.set(vr, pr), pr += vr.length;
    }
    return rr;
  }
  const Xe = Array.from({ length: 256 }, (tr, Xt) => Xt.toString(16).padStart(2, "0"));
  function Ve(tr) {
    if (!(tr instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let Xt = "";
    for (let rr = 0; rr < tr.length; rr++)
      Xt += Xe[tr[rr]];
    return Xt;
  }
  const ge = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function Ke(tr) {
    if (typeof tr != "bigint")
      throw new Error("Expected bigint");
    if (!(Y <= tr && tr < ge))
      throw new Error("Expected number 0 <= n < 2^256");
    return tr.toString(16).padStart(64, "0");
  }
  function ht(tr) {
    const Xt = $t(Ke(tr));
    if (Xt.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return Xt;
  }
  function wt(tr) {
    const Xt = tr.toString(16);
    return Xt.length & 1 ? `0${Xt}` : Xt;
  }
  function vt(tr) {
    if (typeof tr != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof tr);
    return BigInt(`0x${tr}`);
  }
  function $t(tr) {
    if (typeof tr != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof tr);
    if (tr.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + tr.length);
    const Xt = new Uint8Array(tr.length / 2);
    for (let rr = 0; rr < Xt.length; rr++) {
      const or = rr * 2, pr = tr.slice(or, or + 2), vr = Number.parseInt(pr, 16);
      if (Number.isNaN(vr) || vr < 0)
        throw new Error("Invalid byte sequence");
      Xt[rr] = vr;
    }
    return Xt;
  }
  function Qe(tr) {
    return vt(Ve(tr));
  }
  function xt(tr) {
    return tr instanceof Uint8Array ? Uint8Array.from(tr) : $t(tr);
  }
  function bt(tr) {
    if (typeof tr == "number" && Number.isSafeInteger(tr) && tr > 0)
      return BigInt(tr);
    if (typeof tr == "bigint" && cr(tr))
      return tr;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function Dt(tr, Xt = ae.P) {
    const rr = tr % Xt;
    return rr >= Y ? rr : Xt + rr;
  }
  function er(tr, Xt) {
    const { P: rr } = ae;
    let or = tr;
    for (; Xt-- > Y; )
      or *= or, or %= rr;
    return or;
  }
  function fr(tr) {
    const { P: Xt } = ae, rr = BigInt(6), or = BigInt(11), pr = BigInt(22), vr = BigInt(23), wr = BigInt(44), Er = BigInt(88), Pr = tr * tr * tr % Xt, Ar = Pr * Pr * tr % Xt, Tr = er(Ar, oe) * Ar % Xt, Nr = er(Tr, oe) * Ar % Xt, Zt = er(Nr, ie) * Pr % Xt, yr = er(Zt, or) * Zt % Xt, _r = er(yr, pr) * yr % Xt, Sr = er(_r, wr) * _r % Xt, Cr = er(Sr, Er) * Sr % Xt, Fr = er(Cr, wr) * _r % Xt, Rr = er(Fr, oe) * Ar % Xt, Gr = er(Rr, vr) * yr % Xt, sn = er(Gr, rr) * Pr % Xt, en = er(sn, ie);
    if (en * en % Xt !== tr)
      throw new Error("Cannot find square root");
    return en;
  }
  function Qt(tr, Xt = ae.P) {
    if (tr === Y || Xt <= Y)
      throw new Error(`invert: expected positive integers, got n=${tr} mod=${Xt}`);
    let rr = Dt(tr, Xt), or = Xt, pr = Y, vr = ne;
    for (; rr !== Y; ) {
      const Er = or / rr, Pr = or % rr, Ar = pr - vr * Er;
      or = rr, rr = Pr, pr = vr, vr = Ar;
    }
    if (or !== ne)
      throw new Error("invert: does not exist");
    return Dt(pr, Xt);
  }
  function Ht(tr, Xt = ae.P) {
    const rr = new Array(tr.length), or = tr.reduce((vr, wr, Er) => wr === Y ? vr : (rr[Er] = vr, Dt(vr * wr, Xt)), ne), pr = Qt(or, Xt);
    return tr.reduceRight((vr, wr, Er) => wr === Y ? vr : (rr[Er] = Dt(vr * rr[Er], Xt), Dt(vr * wr, Xt)), pr), rr;
  }
  function qt(tr) {
    const Xt = tr.length * 8 - Ee * 8, rr = Qe(tr);
    return Xt > 0 ? rr >> BigInt(Xt) : rr;
  }
  function nr(tr, Xt = !1) {
    const rr = qt(tr);
    if (Xt)
      return rr;
    const { n: or } = ae;
    return rr >= or ? rr - or : rr;
  }
  let ur, zt;
  class Gt {
    constructor(Xt, rr) {
      if (this.hashLen = Xt, this.qByteLen = rr, typeof Xt != "number" || Xt < 2)
        throw new Error("hashLen must be a number");
      if (typeof rr != "number" || rr < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(Xt).fill(1), this.k = new Uint8Array(Xt).fill(0), this.counter = 0;
    }
    hmac(...Xt) {
      return B.utils.hmacSha256(this.k, ...Xt);
    }
    hmacSync(...Xt) {
      return zt(this.k, ...Xt);
    }
    checkSync() {
      if (typeof zt != "function")
        throw new Lt("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(Xt = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), Xt), this.v = await this.hmac(this.v), Xt.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), Xt), this.v = await this.hmac(this.v));
    }
    reseedSync(Xt = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), Xt), this.v = this.hmacSync(this.v), Xt.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), Xt), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let Xt = 0;
      const rr = [];
      for (; Xt < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const or = this.v.slice();
        rr.push(or), Xt += this.v.length;
      }
      return Bt(...rr);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let Xt = 0;
      const rr = [];
      for (; Xt < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const or = this.v.slice();
        rr.push(or), Xt += this.v.length;
      }
      return Bt(...rr);
    }
  }
  function cr(tr) {
    return Y < tr && tr < ae.n;
  }
  function gr(tr) {
    return Y < tr && tr < ae.P;
  }
  function $r(tr, Xt, rr, or = !0) {
    const { n: pr } = ae, vr = nr(tr, !0);
    if (!cr(vr))
      return;
    const wr = Qt(vr, pr), Er = Vt.BASE.multiply(vr), Pr = Dt(Er.x, pr);
    if (Pr === Y)
      return;
    const Ar = Dt(wr * Dt(Xt + rr * Pr, pr), pr);
    if (Ar === Y)
      return;
    let Tr = new Kt(Pr, Ar), Nr = (Er.x === Tr.r ? 0 : 2) | Number(Er.y & ne);
    return or && Tr.hasHighS() && (Tr = Tr.normalizeS(), Nr ^= 1), { sig: Tr, recovery: Nr };
  }
  function xr(tr) {
    let Xt;
    if (typeof tr == "bigint")
      Xt = tr;
    else if (typeof tr == "number" && Number.isSafeInteger(tr) && tr > 0)
      Xt = BigInt(tr);
    else if (typeof tr == "string") {
      if (tr.length !== 2 * Ee)
        throw new Error("Expected 32 bytes of private key");
      Xt = vt(tr);
    } else if (tr instanceof Uint8Array) {
      if (tr.length !== Ee)
        throw new Error("Expected 32 bytes of private key");
      Xt = Qe(tr);
    } else
      throw new TypeError("Expected valid private key");
    if (!cr(Xt))
      throw new Error("Expected private key: 0 < key < n");
    return Xt;
  }
  function Mr(tr) {
    return tr instanceof Vt ? (tr.assertValidity(), tr) : Vt.fromHex(tr);
  }
  function kr(tr) {
    if (tr instanceof Kt)
      return tr.assertValidity(), tr;
    try {
      return Kt.fromDER(tr);
    } catch {
      return Kt.fromCompact(tr);
    }
  }
  function br(tr, Xt = !1) {
    return Vt.fromPrivateKey(tr).toRawBytes(Xt);
  }
  B.getPublicKey = br;
  function Yr(tr, Xt, rr, or = !1) {
    return Vt.fromSignature(tr, Xt, rr).toRawBytes(or);
  }
  B.recoverPublicKey = Yr;
  function jr(tr) {
    const Xt = tr instanceof Uint8Array, rr = typeof tr == "string", or = (Xt || rr) && tr.length;
    return Xt ? or === Ce || or === _t : rr ? or === Ce * 2 || or === _t * 2 : tr instanceof Vt;
  }
  function Qr(tr, Xt, rr = !1) {
    if (jr(tr))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!jr(Xt))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const or = Mr(Xt);
    return or.assertValidity(), or.multiply(xr(tr)).toRawBytes(rr);
  }
  B.getSharedSecret = Qr;
  function Xr(tr) {
    const Xt = tr.length > le ? tr.slice(0, le) : tr;
    return Qe(Xt);
  }
  function Or(tr) {
    const Xt = Xr(tr), rr = Dt(Xt, ae.n);
    return Wr(rr < Y ? Xt : rr);
  }
  function Wr(tr) {
    return ht(tr);
  }
  function Jr(tr, Xt, rr) {
    if (tr == null)
      throw new Error(`sign: expected valid message hash, not "${tr}"`);
    const or = xt(tr), pr = xr(Xt), vr = [Wr(pr), Or(or)];
    if (rr != null) {
      rr === !0 && (rr = B.utils.randomBytes(le));
      const Pr = xt(rr);
      if (Pr.length !== le)
        throw new Error(`sign: Expected ${le} bytes of extra data`);
      vr.push(Pr);
    }
    const wr = Bt(...vr), Er = Xr(or);
    return { seed: wr, m: Er, d: pr };
  }
  function Hr(tr, Xt) {
    const { sig: rr, recovery: or } = tr, { der: pr, recovered: vr } = Object.assign({ canonical: !0, der: !0 }, Xt), wr = pr ? rr.toDERRawBytes() : rr.toCompactRawBytes();
    return vr ? [wr, or] : wr;
  }
  async function Vr(tr, Xt, rr = {}) {
    const { seed: or, m: pr, d: vr } = Jr(tr, Xt, rr.extraEntropy), wr = new Gt(Je, Ee);
    await wr.reseed(or);
    let Er;
    for (; !(Er = $r(await wr.generate(), pr, vr, rr.canonical)); )
      await wr.reseed();
    return Hr(Er, rr);
  }
  B.sign = Vr;
  function tn(tr, Xt, rr = {}) {
    const { seed: or, m: pr, d: vr } = Jr(tr, Xt, rr.extraEntropy), wr = new Gt(Je, Ee);
    wr.reseedSync(or);
    let Er;
    for (; !(Er = $r(wr.generateSync(), pr, vr, rr.canonical)); )
      wr.reseedSync();
    return Hr(Er, rr);
  }
  B.signSync = tn;
  const Wt = { strict: !0 };
  function Ot(tr, Xt, rr, or = Wt) {
    let pr;
    try {
      pr = kr(tr), Xt = xt(Xt);
    } catch {
      return !1;
    }
    const { r: vr, s: wr } = pr;
    if (or.strict && pr.hasHighS())
      return !1;
    const Er = nr(Xt);
    let Pr;
    try {
      Pr = Mr(rr);
    } catch {
      return !1;
    }
    const { n: Ar } = ae, Tr = Qt(wr, Ar), Nr = Dt(Er * Tr, Ar), Zt = Dt(vr * Tr, Ar), yr = Vt.BASE.multiplyAndAddUnsafe(Pr, Nr, Zt);
    return yr ? Dt(yr.x, Ar) === vr : !1;
  }
  B.verify = Ot;
  function Nt(tr) {
    return Dt(Qe(tr), ae.n);
  }
  class Yt {
    constructor(Xt, rr) {
      this.r = Xt, this.s = rr, this.assertValidity();
    }
    static fromHex(Xt) {
      const rr = xt(Xt);
      if (rr.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${rr.length}`);
      const or = Qe(rr.subarray(0, 32)), pr = Qe(rr.subarray(32, 64));
      return new Yt(or, pr);
    }
    assertValidity() {
      const { r: Xt, s: rr } = this;
      if (!gr(Xt) || !cr(rr))
        throw new Error("Invalid signature");
    }
    toHex() {
      return Ke(this.r) + Ke(this.s);
    }
    toRawBytes() {
      return $t(this.toHex());
    }
  }
  function ar(tr) {
    return Vt.fromPrivateKey(tr).toRawX();
  }
  class lr {
    constructor(Xt, rr, or = B.utils.randomBytes()) {
      if (Xt == null)
        throw new TypeError(`sign: Expected valid message, not "${Xt}"`);
      this.m = xt(Xt);
      const { x: pr, scalar: vr } = this.getScalar(xr(rr));
      if (this.px = pr, this.d = vr, this.rand = xt(or), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(Xt) {
      const rr = Vt.fromPrivateKey(Xt), or = rr.hasEvenY() ? Xt : ae.n - Xt;
      return { point: rr, scalar: or, x: rr.toRawX() };
    }
    initNonce(Xt, rr) {
      return ht(Xt ^ Qe(rr));
    }
    finalizeNonce(Xt) {
      const rr = Dt(Qe(Xt), ae.n);
      if (rr === Y)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: or, x: pr, scalar: vr } = this.getScalar(rr);
      return { R: or, rx: pr, k: vr };
    }
    finalizeSig(Xt, rr, or, pr) {
      return new Yt(Xt.x, Dt(rr + or * pr, ae.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: Xt, d: rr, px: or, rand: pr } = this, vr = B.utils.taggedHash, wr = this.initNonce(rr, await vr(Zr.aux, pr)), { R: Er, rx: Pr, k: Ar } = this.finalizeNonce(await vr(Zr.nonce, wr, or, Xt)), Tr = Nt(await vr(Zr.challenge, Pr, or, Xt)), Nr = this.finalizeSig(Er, Ar, Tr, rr);
      return await Ur(Nr, Xt, or) || this.error(), Nr;
    }
    calcSync() {
      const { m: Xt, d: rr, px: or, rand: pr } = this, vr = B.utils.taggedHashSync, wr = this.initNonce(rr, vr(Zr.aux, pr)), { R: Er, rx: Pr, k: Ar } = this.finalizeNonce(vr(Zr.nonce, wr, or, Xt)), Tr = Nt(vr(Zr.challenge, Pr, or, Xt)), Nr = this.finalizeSig(Er, Ar, Tr, rr);
      return Lr(Nr, Xt, or) || this.error(), Nr;
    }
  }
  async function dr(tr, Xt, rr) {
    return new lr(tr, Xt, rr).calc();
  }
  function Ir(tr, Xt, rr) {
    return new lr(tr, Xt, rr).calcSync();
  }
  function qr(tr, Xt, rr) {
    const or = tr instanceof Yt, pr = or ? tr : Yt.fromHex(tr);
    return or && pr.assertValidity(), {
      ...pr,
      m: xt(Xt),
      P: Mr(rr)
    };
  }
  function Br(tr, Xt, rr, or) {
    const pr = Vt.BASE.multiplyAndAddUnsafe(Xt, xr(rr), Dt(-or, ae.n));
    return !(!pr || !pr.hasEvenY() || pr.x !== tr);
  }
  async function Ur(tr, Xt, rr) {
    try {
      const { r: or, s: pr, m: vr, P: wr } = qr(tr, Xt, rr), Er = Nt(await B.utils.taggedHash(Zr.challenge, ht(or), wr.toRawX(), vr));
      return Br(or, wr, pr, Er);
    } catch {
      return !1;
    }
  }
  function Lr(tr, Xt, rr) {
    try {
      const { r: or, s: pr, m: vr, P: wr } = qr(tr, Xt, rr), Er = Nt(B.utils.taggedHashSync(Zr.challenge, ht(or), wr.toRawX(), vr));
      return Br(or, wr, pr, Er);
    } catch (or) {
      if (or instanceof Lt)
        throw or;
      return !1;
    }
  }
  B.schnorr = {
    Signature: Yt,
    getPublicKey: ar,
    sign: dr,
    verify: Ur,
    signSync: Ir,
    verifySync: Lr
  }, Vt.BASE._setWindowSize(8);
  const Dr = {
    node: z,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, Zr = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, nn = {};
  B.utils = {
    bytesToHex: Ve,
    hexToBytes: $t,
    concatBytes: Bt,
    mod: Dt,
    invert: Qt,
    isValidPrivateKey(tr) {
      try {
        return xr(tr), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: ht,
    _normalizePrivateKey: xr,
    hashToPrivateKey: (tr) => {
      tr = xt(tr);
      const Xt = Ee + 8;
      if (tr.length < Xt || tr.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const rr = Dt(Qe(tr), ae.n - ne) + ne;
      return ht(rr);
    },
    randomBytes: (tr = 32) => {
      if (Dr.web)
        return Dr.web.getRandomValues(new Uint8Array(tr));
      if (Dr.node) {
        const { randomBytes: Xt } = Dr.node;
        return Uint8Array.from(Xt(tr));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => B.utils.hashToPrivateKey(B.utils.randomBytes(Ee + 8)),
    precompute(tr = 8, Xt = Vt.BASE) {
      const rr = Xt === Vt.BASE ? Xt : new Vt(Xt.x, Xt.y);
      return rr._setWindowSize(tr), rr.multiply(oe), rr;
    },
    sha256: async (...tr) => {
      if (Dr.web) {
        const Xt = await Dr.web.subtle.digest("SHA-256", Bt(...tr));
        return new Uint8Array(Xt);
      } else if (Dr.node) {
        const { createHash: Xt } = Dr.node, rr = Xt("sha256");
        return tr.forEach((or) => rr.update(or)), Uint8Array.from(rr.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (tr, ...Xt) => {
      if (Dr.web) {
        const rr = await Dr.web.subtle.importKey("raw", tr, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), or = Bt(...Xt), pr = await Dr.web.subtle.sign("HMAC", rr, or);
        return new Uint8Array(pr);
      } else if (Dr.node) {
        const { createHmac: rr } = Dr.node, or = rr("sha256", tr);
        return Xt.forEach((pr) => or.update(pr)), Uint8Array.from(or.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (tr, ...Xt) => {
      let rr = nn[tr];
      if (rr === void 0) {
        const or = await B.utils.sha256(Uint8Array.from(tr, (pr) => pr.charCodeAt(0)));
        rr = Bt(or, or), nn[tr] = rr;
      }
      return B.utils.sha256(rr, ...Xt);
    },
    taggedHashSync: (tr, ...Xt) => {
      if (typeof ur != "function")
        throw new Lt("sha256Sync is undefined, you need to set it");
      let rr = nn[tr];
      if (rr === void 0) {
        const or = ur(Uint8Array.from(tr, (pr) => pr.charCodeAt(0)));
        rr = Bt(or, or), nn[tr] = rr;
      }
      return ur(rr, ...Xt);
    },
    _JacobianPoint: Ft
  }, Object.defineProperties(B.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return ur;
      },
      set(tr) {
        ur || (ur = tr);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return zt;
      },
      set(tr) {
        zt || (zt = tr);
      }
    }
  });
})(lib);
var ecdsaSigFormatter = {};
Object.defineProperty(ecdsaSigFormatter, "__esModule", { value: !0 });
ecdsaSigFormatter.joseToDer = ecdsaSigFormatter.derToJose = void 0;
const base64_js_1 = base64Js, base64Url_1 = base64Url;
function getParamSize(B) {
  return (B / 8 | 0) + (B % 8 === 0 ? 0 : 1);
}
const paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg(B) {
  const z = paramBytesForAlg[B];
  if (z)
    return z;
  throw new Error(`Unknown algorithm "${B}"`);
}
const MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function signatureAsBytes(B) {
  if (B instanceof Uint8Array)
    return B;
  if (typeof B == "string")
    return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(B));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function derToJose(B, z) {
  const Y = signatureAsBytes(B), ne = getParamBytesForAlg(z), ie = ne + 1, oe = Y.length;
  let se = 0;
  if (Y[se++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  let ae = Y[se++];
  if (ae === (MAX_OCTET | 1) && (ae = Y[se++]), oe - se < ae)
    throw new Error(`"seq" specified length of "${ae}", only "${oe - se}" remaining`);
  if (Y[se++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  const ve = Y[se++];
  if (oe - se - 2 < ve)
    throw new Error(`"r" specified length of "${ve}", only "${oe - se - 2}" available`);
  if (ie < ve)
    throw new Error(`"r" specified length of "${ve}", max of "${ie}" is acceptable`);
  const Pe = se;
  if (se += ve, Y[se++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  const le = Y[se++];
  if (oe - se !== le)
    throw new Error(`"s" specified length of "${le}", expected "${oe - se}"`);
  if (ie < le)
    throw new Error(`"s" specified length of "${le}", max of "${ie}" is acceptable`);
  const Ee = se;
  if (se += le, se !== oe)
    throw new Error(`Expected to consume entire array, but "${oe - se}" bytes remain`);
  const Je = ne - ve, Ce = ne - le, _t = new Uint8Array(Je + ve + Ce + le);
  for (se = 0; se < Je; ++se)
    _t[se] = 0;
  _t.set(Y.subarray(Pe + Math.max(-Je, 0), Pe + ve), se), se = ne;
  for (const kt = se; se < kt + Ce; ++se)
    _t[se] = 0;
  return _t.set(Y.subarray(Ee + Math.max(-Ce, 0), Ee + le), se), (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(_t));
}
ecdsaSigFormatter.derToJose = derToJose;
function countPadding(B, z, Y) {
  let ne = 0;
  for (; z + ne < Y && B[z + ne] === 0; )
    ++ne;
  return B[z + ne] >= MAX_OCTET && --ne, ne;
}
function joseToDer(B, z) {
  B = signatureAsBytes(B);
  const Y = getParamBytesForAlg(z), ne = B.length;
  if (ne !== Y * 2)
    throw new TypeError(`"${z}" signatures must be "${Y * 2}" bytes, saw "${ne}"`);
  const ie = countPadding(B, 0, Y), oe = countPadding(B, Y, B.length), se = Y - ie, ae = Y - oe, ve = 2 + se + 1 + 1 + ae, Pe = ve < MAX_OCTET, le = new Uint8Array((Pe ? 2 : 3) + ve);
  let Ee = 0;
  return le[Ee++] = ENCODED_TAG_SEQ, Pe ? le[Ee++] = ve : (le[Ee++] = MAX_OCTET | 1, le[Ee++] = ve & 255), le[Ee++] = ENCODED_TAG_INT, le[Ee++] = se, ie < 0 ? (le[Ee++] = 0, le.set(B.subarray(0, Y), Ee), Ee += Y) : (le.set(B.subarray(ie, Y), Ee), Ee += Y - ie), le[Ee++] = ENCODED_TAG_INT, le[Ee++] = ae, oe < 0 ? (le[Ee++] = 0, le.set(B.subarray(Y), Ee)) : le.set(B.subarray(Y + oe), Ee), le;
}
ecdsaSigFormatter.joseToDer = joseToDer;
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: !0 });
errors$1.InvalidTokenError = errors$1.MissingParametersError = void 0;
class MissingParametersError extends Error {
  constructor(z) {
    super(), this.name = "MissingParametersError", this.message = z || "";
  }
}
errors$1.MissingParametersError = MissingParametersError;
class InvalidTokenError extends Error {
  constructor(z) {
    super(), this.name = "InvalidTokenError", this.message = z || "";
  }
}
errors$1.InvalidTokenError = InvalidTokenError;
Object.defineProperty(secp256k1$1, "__esModule", { value: !0 });
secp256k1$1.SECP256K1Client = void 0;
const hmac_1 = hmac$1, sha256_1$3 = sha256$4, secp = lib, ecdsaSigFormatter_1 = ecdsaSigFormatter, errors_1$2 = errors$1, utils_1$2 = utils$p;
secp.utils.hmacSha256Sync = (B, ...z) => {
  const Y = hmac_1.hmac.create(sha256_1$3.sha256, B);
  return z.forEach((ne) => Y.update(ne)), Y.digest();
};
class SECP256K1Client {
  static derivePublicKey(z, Y = !0) {
    return z.length === 66 && (z = z.slice(0, 64)), z.length < 64 && (z = z.padStart(64, "0")), (0, utils_1$2.bytesToHex)(secp.getPublicKey(z, Y));
  }
  static signHash(z, Y, ne = "jose") {
    if (!z || !Y)
      throw new errors_1$2.MissingParametersError("a signing input hash and private key are all required");
    const ie = secp.signSync(z, Y.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (ne === "der")
      return (0, utils_1$2.bytesToHex)(ie);
    if (ne === "jose")
      return (0, ecdsaSigFormatter_1.derToJose)(ie, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(z) {
    return (0, ecdsaSigFormatter_1.joseToDer)(z, "ES256");
  }
  static verifyHash(z, Y, ne) {
    if (!z || !Y || !ne)
      throw new errors_1$2.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return secp.verify(Y, z, ne, { strict: !1 });
  }
}
secp256k1$1.SECP256K1Client = SECP256K1Client;
SECP256K1Client.algorithmName = "ES256K";
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.cryptoClients = B.SECP256K1Client = void 0;
  const z = secp256k1$1;
  Object.defineProperty(B, "SECP256K1Client", { enumerable: !0, get: function() {
    return z.SECP256K1Client;
  } });
  const Y = {
    ES256K: z.SECP256K1Client
  };
  B.cryptoClients = Y;
})(cryptoClients);
var sha256$1 = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(B, z, Y, ne) {
  function ie(oe) {
    return oe instanceof Y ? oe : new Y(function(se) {
      se(oe);
    });
  }
  return new (Y || (Y = Promise))(function(oe, se) {
    function ae(le) {
      try {
        Pe(ne.next(le));
      } catch (Ee) {
        se(Ee);
      }
    }
    function ve(le) {
      try {
        Pe(ne.throw(le));
      } catch (Ee) {
        se(Ee);
      }
    }
    function Pe(le) {
      le.done ? oe(le.value) : ie(le.value).then(ae, ve);
    }
    Pe((ne = ne.apply(B, z || [])).next());
  });
};
Object.defineProperty(sha256$1, "__esModule", { value: !0 });
sha256$1.hashSha256Async = sha256$1.hashSha256 = void 0;
const sha256_1$2 = sha256$4;
function hashSha256(B) {
  return (0, sha256_1$2.sha256)(B);
}
sha256$1.hashSha256 = hashSha256;
function hashSha256Async(B) {
  return __awaiter$1(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const Y = typeof B == "string" ? new TextEncoder().encode(B) : B, ne = yield crypto.subtle.digest("SHA-256", Y);
        return new Uint8Array(ne);
      } else {
        const Y = requireCryptoBrowserify();
        if (!Y.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(Y.createHash("sha256").update(B).digest());
      }
    } catch (z) {
      return console.log(z), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(hashSha256(B));
    }
  });
}
sha256$1.hashSha256Async = hashSha256Async;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(B, z, Y, ne) {
  function ie(oe) {
    return oe instanceof Y ? oe : new Y(function(se) {
      se(oe);
    });
  }
  return new (Y || (Y = Promise))(function(oe, se) {
    function ae(le) {
      try {
        Pe(ne.next(le));
      } catch (Ee) {
        se(Ee);
      }
    }
    function ve(le) {
      try {
        Pe(ne.throw(le));
      } catch (Ee) {
        se(Ee);
      }
    }
    function Pe(le) {
      le.done ? oe(le.value) : ie(le.value).then(ae, ve);
    }
    Pe((ne = ne.apply(B, z || [])).next());
  });
};
Object.defineProperty(signer, "__esModule", { value: !0 });
signer.TokenSigner = signer.createUnsecuredToken = void 0;
const base64url$2 = base64Url, cryptoClients_1$1 = cryptoClients, errors_1$1 = errors$1, sha256_1$1 = sha256$1;
function createSigningInput(B, z) {
  const Y = [], ne = base64url$2.encode(JSON.stringify(z));
  Y.push(ne);
  const ie = base64url$2.encode(JSON.stringify(B));
  return Y.push(ie), Y.join(".");
}
function createUnsecuredToken(B) {
  return createSigningInput(B, { typ: "JWT", alg: "none" }) + ".";
}
signer.createUnsecuredToken = createUnsecuredToken;
class TokenSigner {
  constructor(z, Y) {
    if (!(z && Y))
      throw new errors_1$1.MissingParametersError("a signing algorithm and private key are required");
    if (typeof z != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (z = z.toUpperCase(), !cryptoClients_1$1.cryptoClients.hasOwnProperty(z))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1$1.cryptoClients[z], this.rawPrivateKey = Y;
  }
  header(z = {}) {
    const Y = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, Y, z);
  }
  sign(z, Y = !1, ne = {}) {
    const ie = this.header(ne), oe = createSigningInput(z, ie), se = (0, sha256_1$1.hashSha256)(oe);
    return this.createWithSignedHash(z, Y, ie, oe, se);
  }
  signAsync(z, Y = !1, ne = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const ie = this.header(ne), oe = createSigningInput(z, ie), se = yield (0, sha256_1$1.hashSha256Async)(oe);
      return this.createWithSignedHash(z, Y, ie, oe, se);
    });
  }
  createWithSignedHash(z, Y, ne, ie, oe) {
    const se = this.cryptoClient.signHash(oe, this.rawPrivateKey);
    return Y ? {
      header: [base64url$2.encode(JSON.stringify(ne))],
      payload: JSON.stringify(z),
      signature: [se]
    } : [ie, se].join(".");
  }
}
signer.TokenSigner = TokenSigner;
var verifier = {};
Object.defineProperty(verifier, "__esModule", { value: !0 });
verifier.TokenVerifier = void 0;
const base64url$1 = base64Url, cryptoClients_1 = cryptoClients, errors_1 = errors$1, sha256_1 = sha256$1;
class TokenVerifier {
  constructor(z, Y) {
    if (!(z && Y))
      throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
    if (typeof z != "string")
      throw "signing algorithm parameter must be a string";
    if (z = z.toUpperCase(), !cryptoClients_1.cryptoClients.hasOwnProperty(z))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1.cryptoClients[z], this.rawPublicKey = Y;
  }
  verify(z) {
    return typeof z == "string" ? this.verifyCompact(z, !1) : typeof z == "object" ? this.verifyExpanded(z, !1) : !1;
  }
  verifyAsync(z) {
    return typeof z == "string" ? this.verifyCompact(z, !0) : typeof z == "object" ? this.verifyExpanded(z, !0) : Promise.resolve(!1);
  }
  verifyCompact(z, Y) {
    const ne = z.split("."), ie = ne[0] + "." + ne[1], oe = (se) => {
      const ae = this.cryptoClient.loadSignature(ne[2]);
      return this.cryptoClient.verifyHash(se, ae, this.rawPublicKey);
    };
    if (Y)
      return (0, sha256_1.hashSha256Async)(ie).then((se) => oe(se));
    {
      const se = (0, sha256_1.hashSha256)(ie);
      return oe(se);
    }
  }
  verifyExpanded(z, Y) {
    const ne = [z.header.join("."), base64url$1.encode(z.payload)].join(".");
    let ie = !0;
    const oe = (se) => (z.signature.map((ae) => {
      const ve = this.cryptoClient.loadSignature(ae);
      this.cryptoClient.verifyHash(se, ve, this.rawPublicKey) || (ie = !1);
    }), ie);
    if (Y)
      return (0, sha256_1.hashSha256Async)(ne).then((se) => oe(se));
    {
      const se = (0, sha256_1.hashSha256)(ne);
      return oe(se);
    }
  }
}
verifier.TokenVerifier = TokenVerifier;
var decode$i = {};
Object.defineProperty(decode$i, "__esModule", { value: !0 });
decode$i.decodeToken = void 0;
const base64url = base64Url;
function decodeToken(B) {
  if (typeof B == "string") {
    const z = B.split("."), Y = JSON.parse(base64url.decode(z[0])), ne = JSON.parse(base64url.decode(z[1])), ie = z[2];
    return {
      header: Y,
      payload: ne,
      signature: ie
    };
  } else if (typeof B == "object") {
    if (typeof B.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let z = B.payload;
    B.payload[0] !== "{" && (z = base64url.decode(z));
    const Y = [];
    return B.header.map((ne) => {
      const ie = JSON.parse(base64url.decode(ne));
      Y.push(ie);
    }), {
      header: Y,
      payload: JSON.parse(z),
      signature: B.signature
    };
  }
}
decode$i.decodeToken = decodeToken;
(function(B) {
  var z = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ne, ie, oe, se) {
    se === void 0 && (se = oe);
    var ae = Object.getOwnPropertyDescriptor(ie, oe);
    (!ae || ("get" in ae ? !ie.__esModule : ae.writable || ae.configurable)) && (ae = { enumerable: !0, get: function() {
      return ie[oe];
    } }), Object.defineProperty(ne, se, ae);
  } : function(ne, ie, oe, se) {
    se === void 0 && (se = oe), ne[se] = ie[oe];
  }), Y = commonjsGlobal && commonjsGlobal.__exportStar || function(ne, ie) {
    for (var oe in ne) oe !== "default" && !Object.prototype.hasOwnProperty.call(ie, oe) && z(ie, ne, oe);
  };
  Object.defineProperty(B, "__esModule", { value: !0 }), Y(signer, B), Y(verifier, B), Y(decode$i, B), Y(errors$1, B), Y(cryptoClients, B);
})(lib$1);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const B = Array(256).fill(-1);
  for (let z = 0; z < r.length; ++z) B[r.charCodeAt(z)] = z;
})();
var s, i, o, h$1 = (s = function(B, z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.bech32m = z.bech32 = void 0;
  const Y = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ne = {};
  for (let Ee = 0; Ee < 32; Ee++) {
    const Je = Y.charAt(Ee);
    ne[Je] = Ee;
  }
  function ie(Ee) {
    const Je = Ee >> 25;
    return (33554431 & Ee) << 5 ^ 996825010 & -(Je >> 0 & 1) ^ 642813549 & -(Je >> 1 & 1) ^ 513874426 & -(Je >> 2 & 1) ^ 1027748829 & -(Je >> 3 & 1) ^ 705979059 & -(Je >> 4 & 1);
  }
  function oe(Ee) {
    let Je = 1;
    for (let Ce = 0; Ce < Ee.length; ++Ce) {
      const _t = Ee.charCodeAt(Ce);
      if (_t < 33 || _t > 126) return "Invalid prefix (" + Ee + ")";
      Je = ie(Je) ^ _t >> 5;
    }
    Je = ie(Je);
    for (let Ce = 0; Ce < Ee.length; ++Ce) {
      const _t = Ee.charCodeAt(Ce);
      Je = ie(Je) ^ 31 & _t;
    }
    return Je;
  }
  function se(Ee, Je, Ce, _t) {
    let kt = 0, Ct = 0;
    const Lt = (1 << Ce) - 1, Pt = [];
    for (let Ft = 0; Ft < Ee.length; ++Ft) for (kt = kt << Je | Ee[Ft], Ct += Je; Ct >= Ce; ) Ct -= Ce, Pt.push(kt >> Ct & Lt);
    if (_t) Ct > 0 && Pt.push(kt << Ce - Ct & Lt);
    else {
      if (Ct >= Je) return "Excess padding";
      if (kt << Ce - Ct & Lt) return "Non-zero padding";
    }
    return Pt;
  }
  function ae(Ee) {
    return se(Ee, 8, 5, !0);
  }
  function ve(Ee) {
    const Je = se(Ee, 5, 8, !1);
    if (Array.isArray(Je)) return Je;
  }
  function Pe(Ee) {
    const Je = se(Ee, 5, 8, !1);
    if (Array.isArray(Je)) return Je;
    throw new Error(Je);
  }
  function le(Ee) {
    let Je;
    function Ce(_t, kt) {
      if (kt = kt || 90, _t.length < 8) return _t + " too short";
      if (_t.length > kt) return "Exceeds length limit";
      const Ct = _t.toLowerCase(), Lt = _t.toUpperCase();
      if (_t !== Ct && _t !== Lt) return "Mixed-case string " + _t;
      const Pt = (_t = Ct).lastIndexOf("1");
      if (Pt === -1) return "No separator character for " + _t;
      if (Pt === 0) return "Missing prefix for " + _t;
      const Ft = _t.slice(0, Pt), Ut = _t.slice(Pt + 1);
      if (Ut.length < 6) return "Data too short";
      let Jt = oe(Ft);
      if (typeof Jt == "string") return Jt;
      const Vt = [];
      for (let ir = 0; ir < Ut.length; ++ir) {
        const jt = Ut.charAt(ir), Rt = ne[jt];
        if (Rt === void 0) return "Unknown character " + jt;
        Jt = ie(Jt) ^ Rt, ir + 6 >= Ut.length || Vt.push(Rt);
      }
      return Jt !== Je ? "Invalid checksum for " + _t : { prefix: Ft, words: Vt };
    }
    return Je = Ee === "bech32" ? 1 : 734539939, { decodeUnsafe: function(_t, kt) {
      const Ct = Ce(_t, kt);
      if (typeof Ct == "object") return Ct;
    }, decode: function(_t, kt) {
      const Ct = Ce(_t, kt);
      if (typeof Ct == "object") return Ct;
      throw new Error(Ct);
    }, encode: function(_t, kt, Ct) {
      if (Ct = Ct || 90, _t.length + 7 + kt.length > Ct) throw new TypeError("Exceeds length limit");
      let Lt = oe(_t = _t.toLowerCase());
      if (typeof Lt == "string") throw new Error(Lt);
      let Pt = _t + "1";
      for (let Ft = 0; Ft < kt.length; ++Ft) {
        const Ut = kt[Ft];
        if (Ut >> 5) throw new Error("Non 5-bit word");
        Lt = ie(Lt) ^ Ut, Pt += Y.charAt(Ut);
      }
      for (let Ft = 0; Ft < 6; ++Ft) Lt = ie(Lt);
      Lt ^= Je;
      for (let Ft = 0; Ft < 6; ++Ft) Pt += Y.charAt(Lt >> 5 * (5 - Ft) & 31);
      return Pt;
    }, toWords: ae, fromWordsUnsafe: ve, fromWords: Pe };
  }
  z.bech32 = le("bech32"), z.bech32m = le("bech32m");
}, s(i = { exports: {} }, i.exports), i.exports);
(o = h$1) && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") && o.default;
h$1.bech32m;
h$1.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var x, k;
(function(B) {
  B.mainnet = "mainnet", B.testnet = "testnet", B.regtest = "regtest";
})(x || (x = {})), function(B) {
  B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr";
}(k || (k = {}));
k.p2pkh, x.mainnet, k.p2pkh, x.testnet, k.p2sh, x.mainnet, k.p2sh, x.testnet;
var accountChangeEventName = "accountChange";
object({
  type: literal(accountChangeEventName)
});
var networkChangeEventName = "networkChange", networkType = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  type: literal(networkChangeEventName),
  bitcoin: object({
    name: picklist(networkType)
  }),
  stacks: object({
    name: string()
  })
});
var disconnectEventName = "disconnect";
object({
  type: literal(disconnectEventName)
});
function getProviderById(B) {
  return B == null ? void 0 : B.split(".").reduce((z, Y) => z == null ? void 0 : z[Y], window);
}
var BitcoinNetworkType = /* @__PURE__ */ ((B) => (B.Mainnet = "Mainnet", B.Testnet = "Testnet", B.Testnet4 = "Testnet4", B.Signet = "Signet", B.Regtest = "Regtest", B))(BitcoinNetworkType || {}), RpcIdSchema = optional(union([string(), number(), null_()])), rpcRequestMessageSchema = object({
  jsonrpc: literal("2.0"),
  method: string(),
  params: optional(
    union([
      array(unknown()),
      looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      null_()
    ])
  ),
  id: unwrap(RpcIdSchema)
}), RpcErrorCode = /* @__PURE__ */ ((B) => (B[B.PARSE_ERROR = -32700] = "PARSE_ERROR", B[B.INVALID_REQUEST = -32600] = "INVALID_REQUEST", B[B.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", B[B.INVALID_PARAMS = -32602] = "INVALID_PARAMS", B[B.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", B[B.USER_REJECTION = -32e3] = "USER_REJECTION", B[B.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED", B[B.ACCESS_DENIED = -32002] = "ACCESS_DENIED", B))(RpcErrorCode || {}), rpcSuccessResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  result: nonOptional(unknown()),
  id: RpcIdSchema
}), rpcErrorResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  error: nonOptional(unknown()),
  id: RpcIdSchema
});
union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);
var stxCallContractMethodName = "stx_callContract", stxCallContractParamsSchema = object({
  /**
   * The contract principal.
   *
   * E.g. `"SPKE...GD5C.my-contract"`
   */
  contract: string(),
  /**
   * The name of the function to call.
   *
   * Note: spec changes ongoing,
   * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
   */
  functionName: string(),
  /**
   * The function's arguments. The arguments are expected to be hex-encoded
   * strings of Clarity values.
   *
   * To convert Clarity values to their hex representation, the `cvToHex`
   * helper from the `@stacks/transactions` package may be helpful.
   *
   * ```js
   * import { cvToHex } from '@stacks/transactions';
   *
   * const functionArgs = [someClarityValue1, someClarityValue2];
   * const hexArgs = functionArgs.map(cvToHex);
   * ```
   */
  arguments: optional(array(string()))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxCallContractMethodName),
    params: stxCallContractParamsSchema,
    id: string()
  }).entries
});
var stxDeployContractMethodName = "stx_deployContract", stxDeployContractParamsSchema = object({
  /**
   * Name of the contract.
   */
  name: string(),
  /**
   * The source code of the Clarity contract.
   */
  clarityCode: string(),
  /**
   * The version of the Clarity contract.
   */
  clarityVersion: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxDeployContractMethodName),
    params: stxDeployContractParamsSchema,
    id: string()
  }).entries
});
var stxGetAccountsMethodName = "stx_getAccounts", stxGetAccountsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAccountsMethodName),
    params: stxGetAccountsParamsSchema,
    id: string()
  }).entries
});
var AddressPurpose = /* @__PURE__ */ ((B) => (B.Ordinals = "ordinals", B.Payment = "payment", B.Stacks = "stacks", B))(AddressPurpose || {}), AddressType = /* @__PURE__ */ ((B) => (B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr", B.stacks = "stacks", B))(AddressType || {}), addressSchema = object({
  address: string(),
  publicKey: string(),
  purpose: enum_(AddressPurpose),
  addressType: enum_(AddressType),
  walletType: walletTypeSchema
}), stxGetAddressesMethodName = "stx_getAddresses", stxGetAddressesParamsSchema = nullish(
  object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: optional(string())
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: string()
  }).entries
});
var stxSignMessageMethodName = "stx_signMessage", stxSignMessageParamsSchema = object({
  /**
   * The message to sign.
   */
  message: string(),
  /**
   * The public key to sign the message with.
   */
  publicKey: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignMessageMethodName),
    params: stxSignMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignStructuredMessageMethodName = "stx_signStructuredMessage", stxSignStructuredMessageParamsSchema = object({
  /**
   * The domain to be signed.
   */
  domain: string(),
  /**
   * Message payload to be signed.
   */
  message: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number()),
  /**
   * The public key to sign the message with.
   */
  publicKey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignStructuredMessageMethodName),
    params: stxSignStructuredMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionMethodName = "stx_signTransaction", stxSignTransactionParamsSchema = object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionsMethodName = "stx_signTransactions", stxSignTransactionsParamsSchema = object({
  /**
   * The transactions to sign as hex-encoded strings.
   */
  transactions: pipe(
    array(
      pipe(
        string(),
        check$e((B) => !0, "Invalid hex-encoded Stacks transaction.")
      )
    ),
    minLength(1)
  ),
  /**
   * Whether the signed transactions should be broadcast after signing. Defaults
   * to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionsMethodName),
    params: stxSignTransactionsParamsSchema,
    id: string()
  }).entries
});
var stxTransferStxMethodName = "stx_transferStx", stxTransferStxParamsSchema = object({
  /**
   * Amount of STX tokens to transfer in microstacks as a string. Anything
   * parseable by `BigInt` is acceptable.
   *
   * Example,
   *
   * ```js
   * const amount1 = 1234;
   * const amount2 = 1234n;
   * const amount3 = '1234';
   * ```
   */
  amount: union([number(), string()]),
  /**
   * The recipeint's principal.
   */
  recipient: string(),
  /**
   * A string representing the memo.
   */
  memo: optional(string()),
  /**
   * Version of parameter format.
   */
  version: optional(string()),
  /**
   * The mode of the post conditions.
   */
  postConditionMode: optional(number()),
  /**
   * A hex-encoded string representing the post conditions.
   *
   * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
   *
   * ```js
   * import { serializePostCondition } from '@stacks/transactions';
   *
   * const postCondition = somePostCondition;
   * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
   * ```
   */
  postConditions: optional(array(string())),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxTransferStxMethodName),
    params: stxTransferStxParamsSchema,
    id: string()
  }).entries
});
var walletTypes = ["software", "ledger", "keystone"], walletTypeSchema = picklist(walletTypes), getInfoMethodName = "getInfo", getInfoParamsSchema = nullish(null_());
object({
  /**
   * Version of the wallet.
   */
  version: string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: optional(array(string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: array(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: string()
  }).entries
});
var getAddressesMethodName = "getAddresses", getAddressesParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: string()
  }).entries
});
var signMessageMethodName = "signMessage", MessageSigningProtocols = /* @__PURE__ */ ((B) => (B.ECDSA = "ECDSA", B.BIP322 = "BIP322", B))(MessageSigningProtocols || {}), signMessageParamsSchema = object({
  /**
   * The address used for signing.
   **/
  address: string(),
  /**
   * The message to sign.
   **/
  message: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: optional(enum_(MessageSigningProtocols))
});
object({
  /**
   * The signature of the message.
   */
  signature: string(),
  /**
   * hash of the message.
   */
  messageHash: string(),
  /**
   * The address used for signing.
   */
  address: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: enum_(MessageSigningProtocols)
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: string()
  }).entries
});
var sendTransferMethodName = "sendTransfer", sendTransferParamsSchema = object({
  /**
   * Array of recipients to send to.
   * The amount to send to each recipient is in satoshis.
   */
  recipients: array(
    object({
      address: string(),
      amount: number()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendTransferMethodName),
    params: sendTransferParamsSchema,
    id: string()
  }).entries
});
var signPsbtMethodName = "signPsbt", signPsbtParamsSchema = object({
  /**
   * The base64 encoded PSBT to sign.
   */
  psbt: string(),
  /**
   * The inputs to sign.
   * The key is the address and the value is an array of indexes of the inputs to sign.
   */
  signInputs: record(string(), array(number())),
  /**
   * Whether to broadcast the transaction after signing.
   **/
  broadcast: optional(boolean())
});
object({
  /**
   * The base64 encoded PSBT after signing.
   */
  psbt: string(),
  /**
   * The transaction id as a hex-encoded string.
   * This is only returned if the transaction was broadcast.
   **/
  txid: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signPsbtMethodName),
    params: signPsbtParamsSchema,
    id: string()
  }).entries
});
var getAccountsMethodName = "getAccounts", getAccountsParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
array(
  object({
    ...addressSchema.entries,
    ...object({
      walletType: walletTypeSchema
    }).entries
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: string()
  }).entries
});
var getBalanceMethodName = "getBalance";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getBalanceMethodName),
    id: string()
  }).entries
});
var accountActionsSchema = object({
  read: optional(boolean())
}), walletActionsSchema = object({
  readNetwork: optional(boolean())
}), accountPermissionSchema = object({
  type: literal("account"),
  resourceId: string(),
  clientId: string(),
  actions: accountActionsSchema
}), walletPermissionSchema = object({
  type: literal("wallet"),
  resourceId: string(),
  clientId: string(),
  actions: walletActionsSchema
}), PermissionRequestParams = variant("type", [
  object({
    ...omit(accountPermissionSchema, ["clientId"]).entries
  }),
  object({
    ...omit(walletPermissionSchema, ["clientId"]).entries
  })
]), requestPermissionsMethodName = "wallet_requestPermissions", requestPermissionsParamsSchema = nullish(array(PermissionRequestParams));
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions", renouncePermissionsParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: string()
  }).entries
});
var disconnectMethodName = "wallet_disconnect", disconnectParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(disconnectMethodName),
    params: disconnectParamsSchema,
    id: string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType", getWalletTypeParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getWalletTypeMethodName),
    params: getWalletTypeParamsSchema,
    id: string()
  }).entries
});
var getCurrentPermissionsMethodName = "wallet_getCurrentPermissions", getCurrentPermissionsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getCurrentPermissionsMethodName),
    params: getCurrentPermissionsParamsSchema,
    id: string()
  }).entries
});
var getAccountMethodName = "wallet_getAccount", getAccountParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountMethodName),
    params: getAccountParamsSchema,
    id: string()
  }).entries
});
var getNetworkMethodName = "wallet_getNetwork", getNetworkParamsSchema = nullish(null_()), networkType2 = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  bitcoin: object({
    name: picklist(networkType2)
  }),
  stacks: object({
    name: string()
  })
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getNetworkMethodName),
    params: getNetworkParamsSchema,
    id: string()
  }).entries
});
var connectMethodName = "wallet_connect", connectParamsSchema = nullish(
  object({
    permissions: optional(array(PermissionRequestParams)),
    addresses: optional(array(enum_(AddressPurpose))),
    message: optional(
      pipe(string(), maxLength(80, "The message must not exceed 80 characters."))
    )
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(connectMethodName),
    params: connectParamsSchema,
    id: string()
  }).entries
});
var runesEtchMethodName = "runes_etch", etchTermsSchema = object({
  amount: string(),
  cap: string(),
  heightStart: optional(string()),
  heightEnd: optional(string()),
  offsetStart: optional(string()),
  offsetEnd: optional(string())
}), inscriptionDetailsSchema = object({
  contentType: string(),
  contentBase64: string()
}), runesEtchParamsSchema = object({
  runeName: string(),
  divisibility: optional(number()),
  symbol: optional(string()),
  premine: optional(string()),
  isMintable: boolean(),
  delegateInscriptionId: optional(string()),
  destinationAddress: string(),
  refundAddress: string(),
  feeRate: number(),
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  terms: optional(etchTermsSchema),
  inscriptionDetails: optional(inscriptionDetailsSchema),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesEtchMethodName),
    params: runesEtchParamsSchema,
    id: string()
  }).entries
});
var runesGetBalanceMethodName = "runes_getBalance", runesGetBalanceParamsSchema = nullish(null_());
object({
  balances: array(
    object({
      runeName: string(),
      amount: string(),
      divisibility: number(),
      symbol: string(),
      inscriptionId: nullish(string())
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesGetBalanceMethodName),
    params: runesGetBalanceParamsSchema,
    id: string()
  }).entries
});
var runesMintMethodName = "runes_mint", runesMintParamsSchema = object({
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  destinationAddress: string(),
  feeRate: number(),
  refundAddress: string(),
  repeats: number(),
  runeName: string(),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesMintMethodName),
    params: runesMintParamsSchema,
    id: string()
  }).entries
});
var runesTransferMethodName = "runes_transfer", runesTransferParamsSchema = object({
  recipients: array(
    object({
      runeName: string(),
      amount: string(),
      address: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesTransferMethodName),
    params: runesTransferParamsSchema,
    id: string()
  }).entries
});
var getInscriptionsMethodName = "ord_getInscriptions", getInscriptionsParamsSchema = object({
  offset: number(),
  limit: number()
});
object({
  total: number(),
  limit: number(),
  offset: number(),
  inscriptions: array(
    object({
      inscriptionId: string(),
      inscriptionNumber: string(),
      address: string(),
      collectionName: optional(string()),
      postage: string(),
      contentLength: string(),
      contentType: string(),
      timestamp: number(),
      offset: number(),
      genesisTransaction: string(),
      output: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions", sendInscriptionsParamsSchema = object({
  transfers: array(
    object({
      address: string(),
      inscriptionId: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: string()
  }).entries
});
var request = async (B, z, Y) => {
  var oe;
  let ne = ((oe = window.XverseProviders) == null ? void 0 : oe.BitcoinProvider) || window.BitcoinProvider;
  if (ne = await getProviderById(Y), !ne)
    throw new Error("no wallet provider was found");
  if (!B)
    throw new Error("A wallet method is required");
  const ie = await ne.request(B, z);
  return is(rpcErrorResponseMessageSchema, ie) ? {
    status: "error",
    error: ie.error
  } : is(rpcSuccessResponseMessageSchema, ie) ? {
    status: "success",
    result: ie.result
  } : {
    status: "error",
    error: {
      code: -32603,
      message: "Received unknown response from provider.",
      data: ie
    }
  };
};
async function waitForUnisatExtensionReady() {
  let B = 0;
  const z = 20;
  for (; B < z; ) {
    if (typeof window < "u" && window.unisat)
      try {
        const Y = await window.unisat.getAccounts();
        if (Y && Y.length > 0)
          return !0;
      } catch {
        break;
      }
    B += 1, await new Promise((Y) => {
      setTimeout(Y, 100);
    });
  }
  return !1;
}
BitcoinNetworkType.Mainnet, BitcoinNetworkType.Testnet, BitcoinNetworkType.Signet;
const getXverseAddresses = async (B) => {
  var ie;
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  if (!(typeof ((ie = window.XverseProviders) == null ? void 0 : ie.BitcoinProvider) < "u"))
    throw new BrowserWalletNotInstalledError("Xverse not installed");
  const Y = [], ne = await request(
    "wallet_connect",
    {
      message: "Provide access to Payment address and Ordinals address",
      addresses: ["ordinals", "payment"]
    },
    "XverseProviders.BitcoinProvider"
  );
  if (ne.status === "error")
    throw new Error("Failed to connect to Xverse");
  if (ne.status === "success") {
    if (console.log("==>response", ne.result), !ne.result || !ne.result.addresses || ne.result.addresses.length !== 2)
      throw new BrowserWalletSigningError(
        "Failed to retrieve addresses using selected wallet"
      );
    ne.result.addresses.forEach((oe) => {
      console.log("==>format", "format");
      try {
        const se = getAddressFormat(oe.address, B);
        let ae = oe.publicKey;
        se === "taproot" && (ae = Buffer$D.from(oe.publicKey, "hex").length === 33 ? ae : `02${ae}`), Y.push({
          publicKey: ae,
          address: oe.address,
          format: se
        });
      } catch {
        throw B === Network.TESTNET ? new Error(
          "Wrong network type selected. To switch networks in Xverse wallet, go to Settings () > click on Network > Switch to Testnet4 and save your settings."
        ) : new Error(
          `Wrong network type selected. To switch networks in Xverse wallet, go to Settings () > click on Network > Switch to ${B} and save your settings.`
        );
      }
    });
  }
  return Y;
}, WALLET_CHROME_EXTENSION_URL = {
  [Wallet.OKX]: "https://www.okx.com/web3",
  [Wallet.MAGICEDEN]: "https://wallet.magiceden.io/",
  [Wallet.UNISAT]: "https://unisat.io/download",
  // their www subdomain doesn't work\  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.LEATHER]: "https://leather.io/install-extension"
}, connectWallet = async ({
  network: B,
  wallet: z,
  chain: Y = Chain.BITCOIN
}, { readOnly: ne = !1 } = {}) => {
  switch (z) {
    case Wallet.UNISAT: {
      const oe = await getAddresses$3(B === "testnet4" ? "testnet" : B, Y, {
        readOnly: ne
      });
      if (!oe || oe.length < 1)
        throw new Error("Unisat via Ordit returned no addresses");
      const se = oe[0];
      return {
        address: {
          ordinals: se.address,
          payments: se.address
        },
        publicKey: {
          ordinals: se.publicKey,
          payments: se.publicKey
        },
        format: {
          ordinals: se.format,
          payments: se.format
        }
      };
    }
    case Wallet.XVERSE: {
      const ie = await getXverseAddresses(B);
      if (console.log("==>xverse", ie), !ie || ie.length < 1)
        throw new Error("Xverse via Ordit returned no addresses");
      const oe = ie.find(
        (ae) => ae.format === "p2sh-p2wpkh" || ae.format === "segwit"
      );
      if (!oe)
        throw new Error(
          "Xverse via Ordit did not return a P2SH or Segwit address"
        );
      const se = ie.find(
        (ae) => ae.format === "taproot"
      );
      if (!se)
        throw new Error("Xverse via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: se.address,
          payments: oe.address
        },
        publicKey: {
          ordinals: se.publicKey,
          payments: oe.publicKey
        },
        format: {
          ordinals: se.format,
          payments: oe.format
        }
      };
    }
    case Wallet.MAGICEDEN: {
      const ie = await getAddresses$2(B);
      if (!ie || ie.length < 1)
        throw new Error("Magic Eden via Ordit returned no addresses");
      const oe = ie.find(
        (ae) => ae.format === "segwit" || ae.format === "p2sh-p2wpkh"
      );
      if (!oe)
        throw new Error(
          "Magic Eden via Ordit did not return a P2SH or Segwit address"
        );
      const se = ie.find(
        (ae) => ae.format === "taproot"
      );
      if (!se)
        throw new Error(
          "Magic Eden via Ordit did not return a Taproot address"
        );
      return {
        address: {
          ordinals: se.address,
          payments: oe.address
        },
        publicKey: {
          ordinals: se.publicKey,
          payments: oe.publicKey
        },
        format: {
          ordinals: se.format,
          payments: oe.format
        }
      };
    }
    case Wallet.LEATHER: {
      const ie = await getAddresses$1(B);
      if (!ie || ie.length < 1)
        throw new Error("Leather via Ordit returned no addresses");
      const oe = ie.find(
        (ae) => ae.format === "segwit"
      );
      if (!oe)
        throw new Error("Leather via Ordit did not return a Segwit address");
      const se = ie.find(
        (ae) => ae.format === "taproot"
      );
      if (!se)
        throw new Error("Leather via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: se.address,
          payments: oe.address
        },
        publicKey: {
          ordinals: se.publicKey,
          payments: oe.publicKey
        },
        format: {
          ordinals: se.format,
          payments: oe.format
        }
      };
    }
    case Wallet.OKX: {
      const ie = await getAddresses(B);
      if (!ie || ie.length < 1)
        throw new Error("OKX via Ordit returned no addresses");
      const oe = ie[0];
      return {
        address: {
          ordinals: oe.address,
          payments: oe.address
        },
        publicKey: {
          ordinals: oe.publicKey,
          payments: oe.publicKey
        },
        format: {
          ordinals: oe.format,
          payments: oe.format
        }
      };
    }
    default:
      throw new Error("Invalid wallet");
  }
};
function useConnect({
  onClose: B,
  onError: z
}) {
  const {
    updateAddress: Y,
    network: ne,
    updateWallet: ie,
    updatePublicKey: oe,
    updateFormat: se,
    disconnectWallet: ae,
    address: ve,
    publicKey: Pe,
    format: le,
    wallet: Ee,
    chain: Je
  } = useOrdConnect(), Ce = (kt, Ct) => {
    z(Ct.message ?? Ct.toString()), console.error(`Error while connecting to ${kt} wallet`, Ct), ae(), Ct instanceof BrowserWalletNotInstalledError && window.open(
      WALLET_CHROME_EXTENSION_URL[kt],
      "_blank",
      "noopener,noreferrer"
    );
  }, _t = async (kt, { readOnly: Ct = !1 } = {}) => {
    try {
      const { address: Lt, publicKey: Pt, format: Ft } = await connectWallet(
        { network: ne, wallet: kt, chain: Je },
        { readOnly: Ct }
      );
      return Y({
        ordinals: Lt.ordinals,
        payments: Lt.payments
      }), oe({
        ordinals: Pt.ordinals,
        payments: Pt.payments
      }), ie(kt), se({
        ordinals: Ft.ordinals,
        payments: Ft.payments
      }), B(), !0;
    } catch (Lt) {
      return console.log("===>err", Lt), Ce(kt, Lt), !1;
    }
  };
  return useEffect(() => {
    if (Ee !== Wallet.UNISAT)
      return;
    let kt = !0, Ct = !1;
    const Lt = () => _t(Wallet.UNISAT);
    return ve && Pe && le && (async () => {
      const Ft = await waitForUnisatExtensionReady();
      if (kt) {
        if (!Ft) {
          ae();
          return;
        }
        Ct = await _t(Wallet.UNISAT, {
          readOnly: !0
        }), kt && Ct && window.unisat.addListener("accountsChanged", Lt);
      }
    })(), () => {
      kt = !1, Ct && window.unisat.removeListener("accountsChanged", Lt);
    };
  }, [Ee]), { connectWallet: _t };
}
const ChevronRightIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9%2018L15%2012L9%206'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LoadingIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='44'%20height='44'%20viewBox='0%200%2044%2044'%20stroke='%23fff'%3e%3cg%20fill='none'%20fill-rule='evenodd'%20stroke-width='2'%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='0s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='0s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='-0.9s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='-0.9s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3c/g%3e%3c/svg%3e", WALLET_TO_NAME = {
  [Wallet.MAGICEDEN]: "Magic Eden",
  [Wallet.UNISAT]: "UniSat",
  [Wallet.XVERSE]: "Xverse",
  [Wallet.LEATHER]: "Leather",
  [Wallet.OKX]: "OKX"
};
function WalletButton({
  wallet: B,
  onConnect: z,
  icon: Y,
  renderAvatar: ne,
  isPreferred: ie
}) {
  const oe = isMobileUserAgent(), { wallet: se, address: ae } = useOrdConnect(), [ve, Pe] = useState(!1), le = WALLET_TO_NAME[B], Ee = async () => {
    Pe(!0);
    try {
      await z();
    } catch {
    }
    Pe(!1);
  }, Je = se === B && ae.ordinals;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      className: "wallet-option-button",
      onClick: Ee,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "option-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "wallet-icon", src: Y, alt: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-label", children: le }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-subtitle", children: oe ? "Available on app" : "" })
        ] }),
        se === B && ae.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option-connected-address", children: [
          ne ? ne(ae.ordinals, "small") : /* @__PURE__ */ jsxRuntimeExports.jsx(
            Avatar,
            {
              size: oe ? 12 : 16,
              variant: "beam",
              name: ae.ordinals,
              colors: ["#1C2DCB", "#F226B8"]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: truncateMiddle(ae.ordinals) })
        ] }) : null,
        !Je && ie ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "preferred-label", children: "Preferred" }) : null,
        ve ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: LoadingIcon,
            width: oe ? 20 : 24,
            height: oe ? 20 : 24,
            alt: `${le} extension is loading`
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: ChevronRightIcon,
            alt: "",
            width: oe ? 20 : 24,
            height: oe ? 20 : 24,
            className: "chevron-btn"
          }
        )
      ] })
    }
  );
}
const CHAIN_TO_NAME = {
  [Chain.BITCOIN]: "Bitcoin",
  [Chain.FRACTAL_BITCOIN]: "Fractal Bitcoin"
};
function SelectWalletModal({
  isOpen: B,
  closeModal: z,
  renderAvatar: Y,
  preferredWallet: ne,
  walletsOrder: ie,
  visibleWallets: oe
}) {
  const [se, ae] = useState(""), { connectWallet: ve } = useConnect({
    onClose: z,
    onError: (Ce) => ae(Ce)
  }), { network: Pe, chain: le } = useOrdConnect(), Ee = isMobileUserAgent(), Je = useMemo(() => {
    const _t = [
      {
        wallet: Wallet.OKX,
        onConnect: () => ve(Wallet.OKX),
        icon: OKXWalletIcon,
        hidden: Ee && Pe !== Network.MAINNET,
        order: 20,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.UNISAT,
        onConnect: () => ve(Wallet.UNISAT),
        icon: UnisatWalletIcon,
        hidden: Ee,
        order: 21,
        chains: [Chain.BITCOIN, Chain.FRACTAL_BITCOIN]
      },
      {
        wallet: Wallet.XVERSE,
        onConnect: () => ve(Wallet.XVERSE),
        icon: XverseWalletIcon,
        order: 22,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.MAGICEDEN,
        onConnect: () => ve(Wallet.MAGICEDEN),
        icon: MagicEdenWalletIcon,
        order: 23,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.LEATHER,
        onConnect: () => ve(Wallet.LEATHER),
        icon: LeatherWalletIcon,
        hidden: Ee,
        order: 24,
        chains: [Chain.BITCOIN]
      }
    ].filter((Ct) => (oe || []).includes(Ct.wallet)).filter(
      (Ct) => Ct.chains.includes(le) && !Ct.hidden
    );
    return ie ? _t.map((Ct) => {
      const Lt = ie.findIndex(
        (Pt) => Pt === Ct.wallet
      );
      return Lt >= 0 ? { ...Ct, order: Lt } : Ct;
    }).sort((Ct, Lt) => Ct.order - Lt.order) : _t;
  }, [Ee, Pe, ie, ve, oe, le]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ze$1, { appear: !0, show: B, as: Fragment, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    yt$1,
    {
      as: "div",
      className: "ord-connect-font ord-connect-wallet-modal",
      onClose: z,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ze$1.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0",
            enterTo: "opacity-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100",
            leaveTo: "opacity-0",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "backdrop" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "outer-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inner-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ze$1.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0 scale-95",
            enterTo: "opacity-100 scale-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100 scale-100",
            leaveTo: "opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(yt$1.Panel, { className: "panel", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-title-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(yt$1.Title, { as: "h3", className: "panel-title", children: [
                  "Choose ",
                  CHAIN_TO_NAME[le],
                  " wallet to connect"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: z,
                    className: "close-button",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: CloseModalIcon, alt: "Close" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-content-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "panel-content-inner-container", children: Je.map((Ce, _t) => {
                  const kt = _t === Je.length - 1;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      WalletButton,
                      {
                        wallet: Ce.wallet,
                        onConnect: async () => {
                          ae("");
                          const Ct = Ce.onConnect().then((Pt) => (Pt && ae(""), Pt)), Lt = await Promise.race([
                            Ct,
                            new Promise((Pt) => {
                              setTimeout(() => Pt("timeout"), 5e3);
                            })
                          ]);
                          return typeof Lt == "string" ? (ae(
                            "No wallet pop-up? The extension is not responding. Try reloading your browser."
                          ), Ct) : Lt;
                        },
                        icon: Ce.icon,
                        renderAvatar: Y,
                        isPreferred: ne === Ce.wallet
                      }
                    ),
                    !kt && /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" })
                  ] }, Ce.wallet);
                }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "error-message", children: se })
              ] })
            ] })
          }
        ) }) })
      ]
    }
  ) });
}
function OrdConnectKit({
  hideConnectButton: B,
  onViewProfile: z,
  onChangeWalletClick: Y,
  onDisconnectWalletClick: ne,
  renderAvatar: ie,
  preferredWallet: oe,
  walletsOrder: se
}) {
  const {
    address: ae,
    disconnectWallet: ve,
    network: Pe,
    isModalOpen: le,
    openModal: Ee,
    closeModal: Je,
    visibleWallets: Ce
  } = useOrdConnect(), _t = useHasMounted(), kt = () => B ? null : ae != null && ae.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    PostConnectButton,
    {
      address: ae.ordinals,
      network: Pe,
      onViewProfile: z,
      onChangeWallet: () => {
        Ee(), Y == null || Y();
      },
      onDisconnectWallet: () => {
        ve(), ne == null || ne();
      },
      renderAvatar: ie
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(PreConnectButton, { disabled: !_t, openModal: Ee });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    kt(),
    _t ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectWalletModal,
      {
        isOpen: le,
        closeModal: Je,
        renderAvatar: ie,
        preferredWallet: oe,
        walletsOrder: se,
        visibleWallets: Ce
      }
    ) : null
  ] });
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER$2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(B) {
  var z, Y, ne, ie = Pt.prototype = { constructor: Pt, toString: null, valueOf: null }, oe = new Pt(1), se = 20, ae = 4, ve = -7, Pe = 21, le = -1e7, Ee = 1e7, Je = !1, Ce = 1, _t = 0, kt = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, Ct = "0123456789abcdefghijklmnopqrstuvwxyz", Lt = !0;
  function Pt(jt, Rt) {
    var Kt, Bt, Xe, Ve, ge, Ke, ht, wt, vt = this;
    if (!(vt instanceof Pt)) return new Pt(jt, Rt);
    if (Rt == null) {
      if (jt && jt._isBigNumber === !0) {
        vt.s = jt.s, !jt.c || jt.e > Ee ? vt.c = vt.e = null : jt.e < le ? vt.c = [vt.e = 0] : (vt.e = jt.e, vt.c = jt.c.slice());
        return;
      }
      if ((Ke = typeof jt == "number") && jt * 0 == 0) {
        if (vt.s = 1 / jt < 0 ? (jt = -jt, -1) : 1, jt === ~~jt) {
          for (Ve = 0, ge = jt; ge >= 10; ge /= 10, Ve++) ;
          Ve > Ee ? vt.c = vt.e = null : (vt.e = Ve, vt.c = [jt]);
          return;
        }
        wt = String(jt);
      } else {
        if (!isNumeric.test(wt = String(jt))) return ne(vt, wt, Ke);
        vt.s = wt.charCodeAt(0) == 45 ? (wt = wt.slice(1), -1) : 1;
      }
      (Ve = wt.indexOf(".")) > -1 && (wt = wt.replace(".", "")), (ge = wt.search(/e/i)) > 0 ? (Ve < 0 && (Ve = ge), Ve += +wt.slice(ge + 1), wt = wt.substring(0, ge)) : Ve < 0 && (Ve = wt.length);
    } else {
      if (intCheck(Rt, 2, Ct.length, "Base"), Rt == 10 && Lt)
        return vt = new Pt(jt), Vt(vt, se + vt.e + 1, ae);
      if (wt = String(jt), Ke = typeof jt == "number") {
        if (jt * 0 != 0) return ne(vt, wt, Ke, Rt);
        if (vt.s = 1 / jt < 0 ? (wt = wt.slice(1), -1) : 1, Pt.DEBUG && wt.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + jt);
      } else
        vt.s = wt.charCodeAt(0) === 45 ? (wt = wt.slice(1), -1) : 1;
      for (Kt = Ct.slice(0, Rt), Ve = ge = 0, ht = wt.length; ge < ht; ge++)
        if (Kt.indexOf(Bt = wt.charAt(ge)) < 0) {
          if (Bt == ".") {
            if (ge > Ve) {
              Ve = ht;
              continue;
            }
          } else if (!Xe && (wt == wt.toUpperCase() && (wt = wt.toLowerCase()) || wt == wt.toLowerCase() && (wt = wt.toUpperCase()))) {
            Xe = !0, ge = -1, Ve = 0;
            continue;
          }
          return ne(vt, String(jt), Ke, Rt);
        }
      Ke = !1, wt = Y(wt, Rt, 10, vt.s), (Ve = wt.indexOf(".")) > -1 ? wt = wt.replace(".", "") : Ve = wt.length;
    }
    for (ge = 0; wt.charCodeAt(ge) === 48; ge++) ;
    for (ht = wt.length; wt.charCodeAt(--ht) === 48; ) ;
    if (wt = wt.slice(ge, ++ht)) {
      if (ht -= ge, Ke && Pt.DEBUG && ht > 15 && (jt > MAX_SAFE_INTEGER$2 || jt !== mathfloor(jt)))
        throw Error(tooManyDigits + vt.s * jt);
      if ((Ve = Ve - ge - 1) > Ee)
        vt.c = vt.e = null;
      else if (Ve < le)
        vt.c = [vt.e = 0];
      else {
        if (vt.e = Ve, vt.c = [], ge = (Ve + 1) % LOG_BASE, Ve < 0 && (ge += LOG_BASE), ge < ht) {
          for (ge && vt.c.push(+wt.slice(0, ge)), ht -= LOG_BASE; ge < ht; )
            vt.c.push(+wt.slice(ge, ge += LOG_BASE));
          ge = LOG_BASE - (wt = wt.slice(ge)).length;
        } else
          ge -= ht;
        for (; ge--; wt += "0") ;
        vt.c.push(+wt);
      }
    } else
      vt.c = [vt.e = 0];
  }
  Pt.clone = clone, Pt.ROUND_UP = 0, Pt.ROUND_DOWN = 1, Pt.ROUND_CEIL = 2, Pt.ROUND_FLOOR = 3, Pt.ROUND_HALF_UP = 4, Pt.ROUND_HALF_DOWN = 5, Pt.ROUND_HALF_EVEN = 6, Pt.ROUND_HALF_CEIL = 7, Pt.ROUND_HALF_FLOOR = 8, Pt.EUCLID = 9, Pt.config = Pt.set = function(jt) {
    var Rt, Kt;
    if (jt != null)
      if (typeof jt == "object") {
        if (jt.hasOwnProperty(Rt = "DECIMAL_PLACES") && (Kt = jt[Rt], intCheck(Kt, 0, MAX, Rt), se = Kt), jt.hasOwnProperty(Rt = "ROUNDING_MODE") && (Kt = jt[Rt], intCheck(Kt, 0, 8, Rt), ae = Kt), jt.hasOwnProperty(Rt = "EXPONENTIAL_AT") && (Kt = jt[Rt], Kt && Kt.pop ? (intCheck(Kt[0], -1e9, 0, Rt), intCheck(Kt[1], 0, MAX, Rt), ve = Kt[0], Pe = Kt[1]) : (intCheck(Kt, -1e9, MAX, Rt), ve = -(Pe = Kt < 0 ? -Kt : Kt))), jt.hasOwnProperty(Rt = "RANGE"))
          if (Kt = jt[Rt], Kt && Kt.pop)
            intCheck(Kt[0], -1e9, -1, Rt), intCheck(Kt[1], 1, MAX, Rt), le = Kt[0], Ee = Kt[1];
          else if (intCheck(Kt, -1e9, MAX, Rt), Kt)
            le = -(Ee = Kt < 0 ? -Kt : Kt);
          else
            throw Error(bignumberError + Rt + " cannot be zero: " + Kt);
        if (jt.hasOwnProperty(Rt = "CRYPTO"))
          if (Kt = jt[Rt], Kt === !!Kt)
            if (Kt)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                Je = Kt;
              else
                throw Je = !Kt, Error(bignumberError + "crypto unavailable");
            else
              Je = Kt;
          else
            throw Error(bignumberError + Rt + " not true or false: " + Kt);
        if (jt.hasOwnProperty(Rt = "MODULO_MODE") && (Kt = jt[Rt], intCheck(Kt, 0, 9, Rt), Ce = Kt), jt.hasOwnProperty(Rt = "POW_PRECISION") && (Kt = jt[Rt], intCheck(Kt, 0, MAX, Rt), _t = Kt), jt.hasOwnProperty(Rt = "FORMAT"))
          if (Kt = jt[Rt], typeof Kt == "object") kt = Kt;
          else throw Error(bignumberError + Rt + " not an object: " + Kt);
        if (jt.hasOwnProperty(Rt = "ALPHABET"))
          if (Kt = jt[Rt], typeof Kt == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(Kt))
            Lt = Kt.slice(0, 10) == "0123456789", Ct = Kt;
          else
            throw Error(bignumberError + Rt + " invalid: " + Kt);
      } else
        throw Error(bignumberError + "Object expected: " + jt);
    return {
      DECIMAL_PLACES: se,
      ROUNDING_MODE: ae,
      EXPONENTIAL_AT: [ve, Pe],
      RANGE: [le, Ee],
      CRYPTO: Je,
      MODULO_MODE: Ce,
      POW_PRECISION: _t,
      FORMAT: kt,
      ALPHABET: Ct
    };
  }, Pt.isBigNumber = function(jt) {
    if (!jt || jt._isBigNumber !== !0) return !1;
    if (!Pt.DEBUG) return !0;
    var Rt, Kt, Bt = jt.c, Xe = jt.e, Ve = jt.s;
    e: if ({}.toString.call(Bt) == "[object Array]") {
      if ((Ve === 1 || Ve === -1) && Xe >= -1e9 && Xe <= MAX && Xe === mathfloor(Xe)) {
        if (Bt[0] === 0) {
          if (Xe === 0 && Bt.length === 1) return !0;
          break e;
        }
        if (Rt = (Xe + 1) % LOG_BASE, Rt < 1 && (Rt += LOG_BASE), String(Bt[0]).length == Rt) {
          for (Rt = 0; Rt < Bt.length; Rt++)
            if (Kt = Bt[Rt], Kt < 0 || Kt >= BASE || Kt !== mathfloor(Kt)) break e;
          if (Kt !== 0) return !0;
        }
      }
    } else if (Bt === null && Xe === null && (Ve === null || Ve === 1 || Ve === -1))
      return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + jt);
  }, Pt.maximum = Pt.max = function() {
    return Ut(arguments, -1);
  }, Pt.minimum = Pt.min = function() {
    return Ut(arguments, 1);
  }, Pt.random = function() {
    var jt = 9007199254740992, Rt = Math.random() * jt & 2097151 ? function() {
      return mathfloor(Math.random() * jt);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(Kt) {
      var Bt, Xe, Ve, ge, Ke, ht = 0, wt = [], vt = new Pt(oe);
      if (Kt == null ? Kt = se : intCheck(Kt, 0, MAX), ge = mathceil(Kt / LOG_BASE), Je)
        if (crypto.getRandomValues) {
          for (Bt = crypto.getRandomValues(new Uint32Array(ge *= 2)); ht < ge; )
            Ke = Bt[ht] * 131072 + (Bt[ht + 1] >>> 11), Ke >= 9e15 ? (Xe = crypto.getRandomValues(new Uint32Array(2)), Bt[ht] = Xe[0], Bt[ht + 1] = Xe[1]) : (wt.push(Ke % 1e14), ht += 2);
          ht = ge / 2;
        } else if (crypto.randomBytes) {
          for (Bt = crypto.randomBytes(ge *= 7); ht < ge; )
            Ke = (Bt[ht] & 31) * 281474976710656 + Bt[ht + 1] * 1099511627776 + Bt[ht + 2] * 4294967296 + Bt[ht + 3] * 16777216 + (Bt[ht + 4] << 16) + (Bt[ht + 5] << 8) + Bt[ht + 6], Ke >= 9e15 ? crypto.randomBytes(7).copy(Bt, ht) : (wt.push(Ke % 1e14), ht += 7);
          ht = ge / 7;
        } else
          throw Je = !1, Error(bignumberError + "crypto unavailable");
      if (!Je)
        for (; ht < ge; )
          Ke = Rt(), Ke < 9e15 && (wt[ht++] = Ke % 1e14);
      for (ge = wt[--ht], Kt %= LOG_BASE, ge && Kt && (Ke = POWS_TEN[LOG_BASE - Kt], wt[ht] = mathfloor(ge / Ke) * Ke); wt[ht] === 0; wt.pop(), ht--) ;
      if (ht < 0)
        wt = [Ve = 0];
      else {
        for (Ve = -1; wt[0] === 0; wt.splice(0, 1), Ve -= LOG_BASE) ;
        for (ht = 1, Ke = wt[0]; Ke >= 10; Ke /= 10, ht++) ;
        ht < LOG_BASE && (Ve -= LOG_BASE - ht);
      }
      return vt.e = Ve, vt.c = wt, vt;
    };
  }(), Pt.sum = function() {
    for (var jt = 1, Rt = arguments, Kt = new Pt(Rt[0]); jt < Rt.length; ) Kt = Kt.plus(Rt[jt++]);
    return Kt;
  }, Y = /* @__PURE__ */ function() {
    var jt = "0123456789";
    function Rt(Kt, Bt, Xe, Ve) {
      for (var ge, Ke = [0], ht, wt = 0, vt = Kt.length; wt < vt; ) {
        for (ht = Ke.length; ht--; Ke[ht] *= Bt) ;
        for (Ke[0] += Ve.indexOf(Kt.charAt(wt++)), ge = 0; ge < Ke.length; ge++)
          Ke[ge] > Xe - 1 && (Ke[ge + 1] == null && (Ke[ge + 1] = 0), Ke[ge + 1] += Ke[ge] / Xe | 0, Ke[ge] %= Xe);
      }
      return Ke.reverse();
    }
    return function(Kt, Bt, Xe, Ve, ge) {
      var Ke, ht, wt, vt, $t, Qe, xt, bt, Dt = Kt.indexOf("."), er = se, fr = ae;
      for (Dt >= 0 && (vt = _t, _t = 0, Kt = Kt.replace(".", ""), bt = new Pt(Bt), Qe = bt.pow(Kt.length - Dt), _t = vt, bt.c = Rt(
        toFixedPoint(coeffToString(Qe.c), Qe.e, "0"),
        10,
        Xe,
        jt
      ), bt.e = bt.c.length), xt = Rt(Kt, Bt, Xe, ge ? (Ke = Ct, jt) : (Ke = jt, Ct)), wt = vt = xt.length; xt[--vt] == 0; xt.pop()) ;
      if (!xt[0]) return Ke.charAt(0);
      if (Dt < 0 ? --wt : (Qe.c = xt, Qe.e = wt, Qe.s = Ve, Qe = z(Qe, bt, er, fr, Xe), xt = Qe.c, $t = Qe.r, wt = Qe.e), ht = wt + er + 1, Dt = xt[ht], vt = Xe / 2, $t = $t || ht < 0 || xt[ht + 1] != null, $t = fr < 4 ? (Dt != null || $t) && (fr == 0 || fr == (Qe.s < 0 ? 3 : 2)) : Dt > vt || Dt == vt && (fr == 4 || $t || fr == 6 && xt[ht - 1] & 1 || fr == (Qe.s < 0 ? 8 : 7)), ht < 1 || !xt[0])
        Kt = $t ? toFixedPoint(Ke.charAt(1), -er, Ke.charAt(0)) : Ke.charAt(0);
      else {
        if (xt.length = ht, $t)
          for (--Xe; ++xt[--ht] > Xe; )
            xt[ht] = 0, ht || (++wt, xt = [1].concat(xt));
        for (vt = xt.length; !xt[--vt]; ) ;
        for (Dt = 0, Kt = ""; Dt <= vt; Kt += Ke.charAt(xt[Dt++])) ;
        Kt = toFixedPoint(Kt, wt, Ke.charAt(0));
      }
      return Kt;
    };
  }(), z = /* @__PURE__ */ function() {
    function jt(Bt, Xe, Ve) {
      var ge, Ke, ht, wt, vt = 0, $t = Bt.length, Qe = Xe % SQRT_BASE, xt = Xe / SQRT_BASE | 0;
      for (Bt = Bt.slice(); $t--; )
        ht = Bt[$t] % SQRT_BASE, wt = Bt[$t] / SQRT_BASE | 0, ge = xt * ht + wt * Qe, Ke = Qe * ht + ge % SQRT_BASE * SQRT_BASE + vt, vt = (Ke / Ve | 0) + (ge / SQRT_BASE | 0) + xt * wt, Bt[$t] = Ke % Ve;
      return vt && (Bt = [vt].concat(Bt)), Bt;
    }
    function Rt(Bt, Xe, Ve, ge) {
      var Ke, ht;
      if (Ve != ge)
        ht = Ve > ge ? 1 : -1;
      else
        for (Ke = ht = 0; Ke < Ve; Ke++)
          if (Bt[Ke] != Xe[Ke]) {
            ht = Bt[Ke] > Xe[Ke] ? 1 : -1;
            break;
          }
      return ht;
    }
    function Kt(Bt, Xe, Ve, ge) {
      for (var Ke = 0; Ve--; )
        Bt[Ve] -= Ke, Ke = Bt[Ve] < Xe[Ve] ? 1 : 0, Bt[Ve] = Ke * ge + Bt[Ve] - Xe[Ve];
      for (; !Bt[0] && Bt.length > 1; Bt.splice(0, 1)) ;
    }
    return function(Bt, Xe, Ve, ge, Ke) {
      var ht, wt, vt, $t, Qe, xt, bt, Dt, er, fr, Qt, Ht, qt, nr, ur, zt, Gt, cr = Bt.s == Xe.s ? 1 : -1, gr = Bt.c, $r = Xe.c;
      if (!gr || !gr[0] || !$r || !$r[0])
        return new Pt(
          // Return NaN if either NaN, or both Infinity or 0.
          !Bt.s || !Xe.s || (gr ? $r && gr[0] == $r[0] : !$r) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            gr && gr[0] == 0 || !$r ? cr * 0 : cr / 0
          )
        );
      for (Dt = new Pt(cr), er = Dt.c = [], wt = Bt.e - Xe.e, cr = Ve + wt + 1, Ke || (Ke = BASE, wt = bitFloor(Bt.e / LOG_BASE) - bitFloor(Xe.e / LOG_BASE), cr = cr / LOG_BASE | 0), vt = 0; $r[vt] == (gr[vt] || 0); vt++) ;
      if ($r[vt] > (gr[vt] || 0) && wt--, cr < 0)
        er.push(1), $t = !0;
      else {
        for (nr = gr.length, zt = $r.length, vt = 0, cr += 2, Qe = mathfloor(Ke / ($r[0] + 1)), Qe > 1 && ($r = jt($r, Qe, Ke), gr = jt(gr, Qe, Ke), zt = $r.length, nr = gr.length), qt = zt, fr = gr.slice(0, zt), Qt = fr.length; Qt < zt; fr[Qt++] = 0) ;
        Gt = $r.slice(), Gt = [0].concat(Gt), ur = $r[0], $r[1] >= Ke / 2 && ur++;
        do {
          if (Qe = 0, ht = Rt($r, fr, zt, Qt), ht < 0) {
            if (Ht = fr[0], zt != Qt && (Ht = Ht * Ke + (fr[1] || 0)), Qe = mathfloor(Ht / ur), Qe > 1)
              for (Qe >= Ke && (Qe = Ke - 1), xt = jt($r, Qe, Ke), bt = xt.length, Qt = fr.length; Rt(xt, fr, bt, Qt) == 1; )
                Qe--, Kt(xt, zt < bt ? Gt : $r, bt, Ke), bt = xt.length, ht = 1;
            else
              Qe == 0 && (ht = Qe = 1), xt = $r.slice(), bt = xt.length;
            if (bt < Qt && (xt = [0].concat(xt)), Kt(fr, xt, Qt, Ke), Qt = fr.length, ht == -1)
              for (; Rt($r, fr, zt, Qt) < 1; )
                Qe++, Kt(fr, zt < Qt ? Gt : $r, Qt, Ke), Qt = fr.length;
          } else ht === 0 && (Qe++, fr = [0]);
          er[vt++] = Qe, fr[0] ? fr[Qt++] = gr[qt] || 0 : (fr = [gr[qt]], Qt = 1);
        } while ((qt++ < nr || fr[0] != null) && cr--);
        $t = fr[0] != null, er[0] || er.splice(0, 1);
      }
      if (Ke == BASE) {
        for (vt = 1, cr = er[0]; cr >= 10; cr /= 10, vt++) ;
        Vt(Dt, Ve + (Dt.e = vt + wt * LOG_BASE - 1) + 1, ge, $t);
      } else
        Dt.e = wt, Dt.r = +$t;
      return Dt;
    };
  }();
  function Ft(jt, Rt, Kt, Bt) {
    var Xe, Ve, ge, Ke, ht;
    if (Kt == null ? Kt = ae : intCheck(Kt, 0, 8), !jt.c) return jt.toString();
    if (Xe = jt.c[0], ge = jt.e, Rt == null)
      ht = coeffToString(jt.c), ht = Bt == 1 || Bt == 2 && (ge <= ve || ge >= Pe) ? toExponential(ht, ge) : toFixedPoint(ht, ge, "0");
    else if (jt = Vt(new Pt(jt), Rt, Kt), Ve = jt.e, ht = coeffToString(jt.c), Ke = ht.length, Bt == 1 || Bt == 2 && (Rt <= Ve || Ve <= ve)) {
      for (; Ke < Rt; ht += "0", Ke++) ;
      ht = toExponential(ht, Ve);
    } else if (Rt -= ge, ht = toFixedPoint(ht, Ve, "0"), Ve + 1 > Ke) {
      if (--Rt > 0) for (ht += "."; Rt--; ht += "0") ;
    } else if (Rt += Ve - Ke, Rt > 0)
      for (Ve + 1 == Ke && (ht += "."); Rt--; ht += "0") ;
    return jt.s < 0 && Xe ? "-" + ht : ht;
  }
  function Ut(jt, Rt) {
    for (var Kt, Bt, Xe = 1, Ve = new Pt(jt[0]); Xe < jt.length; Xe++)
      Bt = new Pt(jt[Xe]), (!Bt.s || (Kt = compare(Ve, Bt)) === Rt || Kt === 0 && Ve.s === Rt) && (Ve = Bt);
    return Ve;
  }
  function Jt(jt, Rt, Kt) {
    for (var Bt = 1, Xe = Rt.length; !Rt[--Xe]; Rt.pop()) ;
    for (Xe = Rt[0]; Xe >= 10; Xe /= 10, Bt++) ;
    return (Kt = Bt + Kt * LOG_BASE - 1) > Ee ? jt.c = jt.e = null : Kt < le ? jt.c = [jt.e = 0] : (jt.e = Kt, jt.c = Rt), jt;
  }
  ne = /* @__PURE__ */ function() {
    var jt = /^(-?)0([xbo])(?=\w[\w.]*$)/i, Rt = /^([^.]+)\.$/, Kt = /^\.([^.]+)$/, Bt = /^-?(Infinity|NaN)$/, Xe = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(Ve, ge, Ke, ht) {
      var wt, vt = Ke ? ge : ge.replace(Xe, "");
      if (Bt.test(vt))
        Ve.s = isNaN(vt) ? null : vt < 0 ? -1 : 1;
      else {
        if (!Ke && (vt = vt.replace(jt, function($t, Qe, xt) {
          return wt = (xt = xt.toLowerCase()) == "x" ? 16 : xt == "b" ? 2 : 8, !ht || ht == wt ? Qe : $t;
        }), ht && (wt = ht, vt = vt.replace(Rt, "$1").replace(Kt, "0.$1")), ge != vt))
          return new Pt(vt, wt);
        if (Pt.DEBUG)
          throw Error(bignumberError + "Not a" + (ht ? " base " + ht : "") + " number: " + ge);
        Ve.s = null;
      }
      Ve.c = Ve.e = null;
    };
  }();
  function Vt(jt, Rt, Kt, Bt) {
    var Xe, Ve, ge, Ke, ht, wt, vt, $t = jt.c, Qe = POWS_TEN;
    if ($t) {
      e: {
        for (Xe = 1, Ke = $t[0]; Ke >= 10; Ke /= 10, Xe++) ;
        if (Ve = Rt - Xe, Ve < 0)
          Ve += LOG_BASE, ge = Rt, ht = $t[wt = 0], vt = mathfloor(ht / Qe[Xe - ge - 1] % 10);
        else if (wt = mathceil((Ve + 1) / LOG_BASE), wt >= $t.length)
          if (Bt) {
            for (; $t.length <= wt; $t.push(0)) ;
            ht = vt = 0, Xe = 1, Ve %= LOG_BASE, ge = Ve - LOG_BASE + 1;
          } else
            break e;
        else {
          for (ht = Ke = $t[wt], Xe = 1; Ke >= 10; Ke /= 10, Xe++) ;
          Ve %= LOG_BASE, ge = Ve - LOG_BASE + Xe, vt = ge < 0 ? 0 : mathfloor(ht / Qe[Xe - ge - 1] % 10);
        }
        if (Bt = Bt || Rt < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        $t[wt + 1] != null || (ge < 0 ? ht : ht % Qe[Xe - ge - 1]), Bt = Kt < 4 ? (vt || Bt) && (Kt == 0 || Kt == (jt.s < 0 ? 3 : 2)) : vt > 5 || vt == 5 && (Kt == 4 || Bt || Kt == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (Ve > 0 ? ge > 0 ? ht / Qe[Xe - ge] : 0 : $t[wt - 1]) % 10 & 1 || Kt == (jt.s < 0 ? 8 : 7)), Rt < 1 || !$t[0])
          return $t.length = 0, Bt ? (Rt -= jt.e + 1, $t[0] = Qe[(LOG_BASE - Rt % LOG_BASE) % LOG_BASE], jt.e = -Rt || 0) : $t[0] = jt.e = 0, jt;
        if (Ve == 0 ? ($t.length = wt, Ke = 1, wt--) : ($t.length = wt + 1, Ke = Qe[LOG_BASE - Ve], $t[wt] = ge > 0 ? mathfloor(ht / Qe[Xe - ge] % Qe[ge]) * Ke : 0), Bt)
          for (; ; )
            if (wt == 0) {
              for (Ve = 1, ge = $t[0]; ge >= 10; ge /= 10, Ve++) ;
              for (ge = $t[0] += Ke, Ke = 1; ge >= 10; ge /= 10, Ke++) ;
              Ve != Ke && (jt.e++, $t[0] == BASE && ($t[0] = 1));
              break;
            } else {
              if ($t[wt] += Ke, $t[wt] != BASE) break;
              $t[wt--] = 0, Ke = 1;
            }
        for (Ve = $t.length; $t[--Ve] === 0; $t.pop()) ;
      }
      jt.e > Ee ? jt.c = jt.e = null : jt.e < le && (jt.c = [jt.e = 0]);
    }
    return jt;
  }
  function ir(jt) {
    var Rt, Kt = jt.e;
    return Kt === null ? jt.toString() : (Rt = coeffToString(jt.c), Rt = Kt <= ve || Kt >= Pe ? toExponential(Rt, Kt) : toFixedPoint(Rt, Kt, "0"), jt.s < 0 ? "-" + Rt : Rt);
  }
  return ie.absoluteValue = ie.abs = function() {
    var jt = new Pt(this);
    return jt.s < 0 && (jt.s = 1), jt;
  }, ie.comparedTo = function(jt, Rt) {
    return compare(this, new Pt(jt, Rt));
  }, ie.decimalPlaces = ie.dp = function(jt, Rt) {
    var Kt, Bt, Xe, Ve = this;
    if (jt != null)
      return intCheck(jt, 0, MAX), Rt == null ? Rt = ae : intCheck(Rt, 0, 8), Vt(new Pt(Ve), jt + Ve.e + 1, Rt);
    if (!(Kt = Ve.c)) return null;
    if (Bt = ((Xe = Kt.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, Xe = Kt[Xe]) for (; Xe % 10 == 0; Xe /= 10, Bt--) ;
    return Bt < 0 && (Bt = 0), Bt;
  }, ie.dividedBy = ie.div = function(jt, Rt) {
    return z(this, new Pt(jt, Rt), se, ae);
  }, ie.dividedToIntegerBy = ie.idiv = function(jt, Rt) {
    return z(this, new Pt(jt, Rt), 0, 1);
  }, ie.exponentiatedBy = ie.pow = function(jt, Rt) {
    var Kt, Bt, Xe, Ve, ge, Ke, ht, wt, vt, $t = this;
    if (jt = new Pt(jt), jt.c && !jt.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + ir(jt));
    if (Rt != null && (Rt = new Pt(Rt)), Ke = jt.e > 14, !$t.c || !$t.c[0] || $t.c[0] == 1 && !$t.e && $t.c.length == 1 || !jt.c || !jt.c[0])
      return vt = new Pt(Math.pow(+ir($t), Ke ? jt.s * (2 - isOdd(jt)) : +ir(jt))), Rt ? vt.mod(Rt) : vt;
    if (ht = jt.s < 0, Rt) {
      if (Rt.c ? !Rt.c[0] : !Rt.s) return new Pt(NaN);
      Bt = !ht && $t.isInteger() && Rt.isInteger(), Bt && ($t = $t.mod(Rt));
    } else {
      if (jt.e > 9 && ($t.e > 0 || $t.e < -1 || ($t.e == 0 ? $t.c[0] > 1 || Ke && $t.c[1] >= 24e7 : $t.c[0] < 8e13 || Ke && $t.c[0] <= 9999975e7)))
        return Ve = $t.s < 0 && isOdd(jt) ? -0 : 0, $t.e > -1 && (Ve = 1 / Ve), new Pt(ht ? 1 / Ve : Ve);
      _t && (Ve = mathceil(_t / LOG_BASE + 2));
    }
    for (Ke ? (Kt = new Pt(0.5), ht && (jt.s = 1), wt = isOdd(jt)) : (Xe = Math.abs(+ir(jt)), wt = Xe % 2), vt = new Pt(oe); ; ) {
      if (wt) {
        if (vt = vt.times($t), !vt.c) break;
        Ve ? vt.c.length > Ve && (vt.c.length = Ve) : Bt && (vt = vt.mod(Rt));
      }
      if (Xe) {
        if (Xe = mathfloor(Xe / 2), Xe === 0) break;
        wt = Xe % 2;
      } else if (jt = jt.times(Kt), Vt(jt, jt.e + 1, 1), jt.e > 14)
        wt = isOdd(jt);
      else {
        if (Xe = +ir(jt), Xe === 0) break;
        wt = Xe % 2;
      }
      $t = $t.times($t), Ve ? $t.c && $t.c.length > Ve && ($t.c.length = Ve) : Bt && ($t = $t.mod(Rt));
    }
    return Bt ? vt : (ht && (vt = oe.div(vt)), Rt ? vt.mod(Rt) : Ve ? Vt(vt, _t, ae, ge) : vt);
  }, ie.integerValue = function(jt) {
    var Rt = new Pt(this);
    return jt == null ? jt = ae : intCheck(jt, 0, 8), Vt(Rt, Rt.e + 1, jt);
  }, ie.isEqualTo = ie.eq = function(jt, Rt) {
    return compare(this, new Pt(jt, Rt)) === 0;
  }, ie.isFinite = function() {
    return !!this.c;
  }, ie.isGreaterThan = ie.gt = function(jt, Rt) {
    return compare(this, new Pt(jt, Rt)) > 0;
  }, ie.isGreaterThanOrEqualTo = ie.gte = function(jt, Rt) {
    return (Rt = compare(this, new Pt(jt, Rt))) === 1 || Rt === 0;
  }, ie.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, ie.isLessThan = ie.lt = function(jt, Rt) {
    return compare(this, new Pt(jt, Rt)) < 0;
  }, ie.isLessThanOrEqualTo = ie.lte = function(jt, Rt) {
    return (Rt = compare(this, new Pt(jt, Rt))) === -1 || Rt === 0;
  }, ie.isNaN = function() {
    return !this.s;
  }, ie.isNegative = function() {
    return this.s < 0;
  }, ie.isPositive = function() {
    return this.s > 0;
  }, ie.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, ie.minus = function(jt, Rt) {
    var Kt, Bt, Xe, Ve, ge = this, Ke = ge.s;
    if (jt = new Pt(jt, Rt), Rt = jt.s, !Ke || !Rt) return new Pt(NaN);
    if (Ke != Rt)
      return jt.s = -Rt, ge.plus(jt);
    var ht = ge.e / LOG_BASE, wt = jt.e / LOG_BASE, vt = ge.c, $t = jt.c;
    if (!ht || !wt) {
      if (!vt || !$t) return vt ? (jt.s = -Rt, jt) : new Pt($t ? ge : NaN);
      if (!vt[0] || !$t[0])
        return $t[0] ? (jt.s = -Rt, jt) : new Pt(vt[0] ? ge : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ae == 3 ? -0 : 0
        ));
    }
    if (ht = bitFloor(ht), wt = bitFloor(wt), vt = vt.slice(), Ke = ht - wt) {
      for ((Ve = Ke < 0) ? (Ke = -Ke, Xe = vt) : (wt = ht, Xe = $t), Xe.reverse(), Rt = Ke; Rt--; Xe.push(0)) ;
      Xe.reverse();
    } else
      for (Bt = (Ve = (Ke = vt.length) < (Rt = $t.length)) ? Ke : Rt, Ke = Rt = 0; Rt < Bt; Rt++)
        if (vt[Rt] != $t[Rt]) {
          Ve = vt[Rt] < $t[Rt];
          break;
        }
    if (Ve && (Xe = vt, vt = $t, $t = Xe, jt.s = -jt.s), Rt = (Bt = $t.length) - (Kt = vt.length), Rt > 0) for (; Rt--; vt[Kt++] = 0) ;
    for (Rt = BASE - 1; Bt > Ke; ) {
      if (vt[--Bt] < $t[Bt]) {
        for (Kt = Bt; Kt && !vt[--Kt]; vt[Kt] = Rt) ;
        --vt[Kt], vt[Bt] += BASE;
      }
      vt[Bt] -= $t[Bt];
    }
    for (; vt[0] == 0; vt.splice(0, 1), --wt) ;
    return vt[0] ? Jt(jt, vt, wt) : (jt.s = ae == 3 ? -1 : 1, jt.c = [jt.e = 0], jt);
  }, ie.modulo = ie.mod = function(jt, Rt) {
    var Kt, Bt, Xe = this;
    return jt = new Pt(jt, Rt), !Xe.c || !jt.s || jt.c && !jt.c[0] ? new Pt(NaN) : !jt.c || Xe.c && !Xe.c[0] ? new Pt(Xe) : (Ce == 9 ? (Bt = jt.s, jt.s = 1, Kt = z(Xe, jt, 0, 3), jt.s = Bt, Kt.s *= Bt) : Kt = z(Xe, jt, 0, Ce), jt = Xe.minus(Kt.times(jt)), !jt.c[0] && Ce == 1 && (jt.s = Xe.s), jt);
  }, ie.multipliedBy = ie.times = function(jt, Rt) {
    var Kt, Bt, Xe, Ve, ge, Ke, ht, wt, vt, $t, Qe, xt, bt, Dt, er, fr = this, Qt = fr.c, Ht = (jt = new Pt(jt, Rt)).c;
    if (!Qt || !Ht || !Qt[0] || !Ht[0])
      return !fr.s || !jt.s || Qt && !Qt[0] && !Ht || Ht && !Ht[0] && !Qt ? jt.c = jt.e = jt.s = null : (jt.s *= fr.s, !Qt || !Ht ? jt.c = jt.e = null : (jt.c = [0], jt.e = 0)), jt;
    for (Bt = bitFloor(fr.e / LOG_BASE) + bitFloor(jt.e / LOG_BASE), jt.s *= fr.s, ht = Qt.length, $t = Ht.length, ht < $t && (bt = Qt, Qt = Ht, Ht = bt, Xe = ht, ht = $t, $t = Xe), Xe = ht + $t, bt = []; Xe--; bt.push(0)) ;
    for (Dt = BASE, er = SQRT_BASE, Xe = $t; --Xe >= 0; ) {
      for (Kt = 0, Qe = Ht[Xe] % er, xt = Ht[Xe] / er | 0, ge = ht, Ve = Xe + ge; Ve > Xe; )
        wt = Qt[--ge] % er, vt = Qt[ge] / er | 0, Ke = xt * wt + vt * Qe, wt = Qe * wt + Ke % er * er + bt[Ve] + Kt, Kt = (wt / Dt | 0) + (Ke / er | 0) + xt * vt, bt[Ve--] = wt % Dt;
      bt[Ve] = Kt;
    }
    return Kt ? ++Bt : bt.splice(0, 1), Jt(jt, bt, Bt);
  }, ie.negated = function() {
    var jt = new Pt(this);
    return jt.s = -jt.s || null, jt;
  }, ie.plus = function(jt, Rt) {
    var Kt, Bt = this, Xe = Bt.s;
    if (jt = new Pt(jt, Rt), Rt = jt.s, !Xe || !Rt) return new Pt(NaN);
    if (Xe != Rt)
      return jt.s = -Rt, Bt.minus(jt);
    var Ve = Bt.e / LOG_BASE, ge = jt.e / LOG_BASE, Ke = Bt.c, ht = jt.c;
    if (!Ve || !ge) {
      if (!Ke || !ht) return new Pt(Xe / 0);
      if (!Ke[0] || !ht[0]) return ht[0] ? jt : new Pt(Ke[0] ? Bt : Xe * 0);
    }
    if (Ve = bitFloor(Ve), ge = bitFloor(ge), Ke = Ke.slice(), Xe = Ve - ge) {
      for (Xe > 0 ? (ge = Ve, Kt = ht) : (Xe = -Xe, Kt = Ke), Kt.reverse(); Xe--; Kt.push(0)) ;
      Kt.reverse();
    }
    for (Xe = Ke.length, Rt = ht.length, Xe - Rt < 0 && (Kt = ht, ht = Ke, Ke = Kt, Rt = Xe), Xe = 0; Rt; )
      Xe = (Ke[--Rt] = Ke[Rt] + ht[Rt] + Xe) / BASE | 0, Ke[Rt] = BASE === Ke[Rt] ? 0 : Ke[Rt] % BASE;
    return Xe && (Ke = [Xe].concat(Ke), ++ge), Jt(jt, Ke, ge);
  }, ie.precision = ie.sd = function(jt, Rt) {
    var Kt, Bt, Xe, Ve = this;
    if (jt != null && jt !== !!jt)
      return intCheck(jt, 1, MAX), Rt == null ? Rt = ae : intCheck(Rt, 0, 8), Vt(new Pt(Ve), jt, Rt);
    if (!(Kt = Ve.c)) return null;
    if (Xe = Kt.length - 1, Bt = Xe * LOG_BASE + 1, Xe = Kt[Xe]) {
      for (; Xe % 10 == 0; Xe /= 10, Bt--) ;
      for (Xe = Kt[0]; Xe >= 10; Xe /= 10, Bt++) ;
    }
    return jt && Ve.e + 1 > Bt && (Bt = Ve.e + 1), Bt;
  }, ie.shiftedBy = function(jt) {
    return intCheck(jt, -9007199254740991, MAX_SAFE_INTEGER$2), this.times("1e" + jt);
  }, ie.squareRoot = ie.sqrt = function() {
    var jt, Rt, Kt, Bt, Xe, Ve = this, ge = Ve.c, Ke = Ve.s, ht = Ve.e, wt = se + 4, vt = new Pt("0.5");
    if (Ke !== 1 || !ge || !ge[0])
      return new Pt(!Ke || Ke < 0 && (!ge || ge[0]) ? NaN : ge ? Ve : 1 / 0);
    if (Ke = Math.sqrt(+ir(Ve)), Ke == 0 || Ke == 1 / 0 ? (Rt = coeffToString(ge), (Rt.length + ht) % 2 == 0 && (Rt += "0"), Ke = Math.sqrt(+Rt), ht = bitFloor((ht + 1) / 2) - (ht < 0 || ht % 2), Ke == 1 / 0 ? Rt = "5e" + ht : (Rt = Ke.toExponential(), Rt = Rt.slice(0, Rt.indexOf("e") + 1) + ht), Kt = new Pt(Rt)) : Kt = new Pt(Ke + ""), Kt.c[0]) {
      for (ht = Kt.e, Ke = ht + wt, Ke < 3 && (Ke = 0); ; )
        if (Xe = Kt, Kt = vt.times(Xe.plus(z(Ve, Xe, wt, 1))), coeffToString(Xe.c).slice(0, Ke) === (Rt = coeffToString(Kt.c)).slice(0, Ke))
          if (Kt.e < ht && --Ke, Rt = Rt.slice(Ke - 3, Ke + 1), Rt == "9999" || !Bt && Rt == "4999") {
            if (!Bt && (Vt(Xe, Xe.e + se + 2, 0), Xe.times(Xe).eq(Ve))) {
              Kt = Xe;
              break;
            }
            wt += 4, Ke += 4, Bt = 1;
          } else {
            (!+Rt || !+Rt.slice(1) && Rt.charAt(0) == "5") && (Vt(Kt, Kt.e + se + 2, 1), jt = !Kt.times(Kt).eq(Ve));
            break;
          }
    }
    return Vt(Kt, Kt.e + se + 1, ae, jt);
  }, ie.toExponential = function(jt, Rt) {
    return jt != null && (intCheck(jt, 0, MAX), jt++), Ft(this, jt, Rt, 1);
  }, ie.toFixed = function(jt, Rt) {
    return jt != null && (intCheck(jt, 0, MAX), jt = jt + this.e + 1), Ft(this, jt, Rt);
  }, ie.toFormat = function(jt, Rt, Kt) {
    var Bt, Xe = this;
    if (Kt == null)
      jt != null && Rt && typeof Rt == "object" ? (Kt = Rt, Rt = null) : jt && typeof jt == "object" ? (Kt = jt, jt = Rt = null) : Kt = kt;
    else if (typeof Kt != "object")
      throw Error(bignumberError + "Argument not an object: " + Kt);
    if (Bt = Xe.toFixed(jt, Rt), Xe.c) {
      var Ve, ge = Bt.split("."), Ke = +Kt.groupSize, ht = +Kt.secondaryGroupSize, wt = Kt.groupSeparator || "", vt = ge[0], $t = ge[1], Qe = Xe.s < 0, xt = Qe ? vt.slice(1) : vt, bt = xt.length;
      if (ht && (Ve = Ke, Ke = ht, ht = Ve, bt -= Ve), Ke > 0 && bt > 0) {
        for (Ve = bt % Ke || Ke, vt = xt.substr(0, Ve); Ve < bt; Ve += Ke) vt += wt + xt.substr(Ve, Ke);
        ht > 0 && (vt += wt + xt.slice(Ve)), Qe && (vt = "-" + vt);
      }
      Bt = $t ? vt + (Kt.decimalSeparator || "") + ((ht = +Kt.fractionGroupSize) ? $t.replace(
        new RegExp("\\d{" + ht + "}\\B", "g"),
        "$&" + (Kt.fractionGroupSeparator || "")
      ) : $t) : vt;
    }
    return (Kt.prefix || "") + Bt + (Kt.suffix || "");
  }, ie.toFraction = function(jt) {
    var Rt, Kt, Bt, Xe, Ve, ge, Ke, ht, wt, vt, $t, Qe, xt = this, bt = xt.c;
    if (jt != null && (Ke = new Pt(jt), !Ke.isInteger() && (Ke.c || Ke.s !== 1) || Ke.lt(oe)))
      throw Error(bignumberError + "Argument " + (Ke.isInteger() ? "out of range: " : "not an integer: ") + ir(Ke));
    if (!bt) return new Pt(xt);
    for (Rt = new Pt(oe), wt = Kt = new Pt(oe), Bt = ht = new Pt(oe), Qe = coeffToString(bt), Ve = Rt.e = Qe.length - xt.e - 1, Rt.c[0] = POWS_TEN[(ge = Ve % LOG_BASE) < 0 ? LOG_BASE + ge : ge], jt = !jt || Ke.comparedTo(Rt) > 0 ? Ve > 0 ? Rt : wt : Ke, ge = Ee, Ee = 1 / 0, Ke = new Pt(Qe), ht.c[0] = 0; vt = z(Ke, Rt, 0, 1), Xe = Kt.plus(vt.times(Bt)), Xe.comparedTo(jt) != 1; )
      Kt = Bt, Bt = Xe, wt = ht.plus(vt.times(Xe = wt)), ht = Xe, Rt = Ke.minus(vt.times(Xe = Rt)), Ke = Xe;
    return Xe = z(jt.minus(Kt), Bt, 0, 1), ht = ht.plus(Xe.times(wt)), Kt = Kt.plus(Xe.times(Bt)), ht.s = wt.s = xt.s, Ve = Ve * 2, $t = z(wt, Bt, Ve, ae).minus(xt).abs().comparedTo(
      z(ht, Kt, Ve, ae).minus(xt).abs()
    ) < 1 ? [wt, Bt] : [ht, Kt], Ee = ge, $t;
  }, ie.toNumber = function() {
    return +ir(this);
  }, ie.toPrecision = function(jt, Rt) {
    return jt != null && intCheck(jt, 1, MAX), Ft(this, jt, Rt, 2);
  }, ie.toString = function(jt) {
    var Rt, Kt = this, Bt = Kt.s, Xe = Kt.e;
    return Xe === null ? Bt ? (Rt = "Infinity", Bt < 0 && (Rt = "-" + Rt)) : Rt = "NaN" : (jt == null ? Rt = Xe <= ve || Xe >= Pe ? toExponential(coeffToString(Kt.c), Xe) : toFixedPoint(coeffToString(Kt.c), Xe, "0") : jt === 10 && Lt ? (Kt = Vt(new Pt(Kt), se + Xe + 1, ae), Rt = toFixedPoint(coeffToString(Kt.c), Kt.e, "0")) : (intCheck(jt, 2, Ct.length, "Base"), Rt = Y(toFixedPoint(coeffToString(Kt.c), Xe, "0"), 10, jt, Bt, !0)), Bt < 0 && Kt.c[0] && (Rt = "-" + Rt)), Rt;
  }, ie.valueOf = ie.toJSON = function() {
    return ir(this);
  }, ie._isBigNumber = !0, ie[Symbol.toStringTag] = "BigNumber", ie[Symbol.for("nodejs.util.inspect.custom")] = ie.valueOf, B != null && Pt.set(B), Pt;
}
function bitFloor(B) {
  var z = B | 0;
  return B > 0 || B === z ? z : z - 1;
}
function coeffToString(B) {
  for (var z, Y, ne = 1, ie = B.length, oe = B[0] + ""; ne < ie; ) {
    for (z = B[ne++] + "", Y = LOG_BASE - z.length; Y--; z = "0" + z) ;
    oe += z;
  }
  for (ie = oe.length; oe.charCodeAt(--ie) === 48; ) ;
  return oe.slice(0, ie + 1 || 1);
}
function compare(B, z) {
  var Y, ne, ie = B.c, oe = z.c, se = B.s, ae = z.s, ve = B.e, Pe = z.e;
  if (!se || !ae) return null;
  if (Y = ie && !ie[0], ne = oe && !oe[0], Y || ne) return Y ? ne ? 0 : -ae : se;
  if (se != ae) return se;
  if (Y = se < 0, ne = ve == Pe, !ie || !oe) return ne ? 0 : !ie ^ Y ? 1 : -1;
  if (!ne) return ve > Pe ^ Y ? 1 : -1;
  for (ae = (ve = ie.length) < (Pe = oe.length) ? ve : Pe, se = 0; se < ae; se++) if (ie[se] != oe[se]) return ie[se] > oe[se] ^ Y ? 1 : -1;
  return ve == Pe ? 0 : ve > Pe ^ Y ? 1 : -1;
}
function intCheck(B, z, Y, ne) {
  if (B < z || B > Y || B !== mathfloor(B))
    throw Error(bignumberError + (ne || "Argument") + (typeof B == "number" ? B < z || B > Y ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(B));
}
function isOdd(B) {
  var z = B.c.length - 1;
  return bitFloor(B.e / LOG_BASE) == z && B.c[z] % 2 != 0;
}
function toExponential(B, z) {
  return (B.length > 1 ? B.charAt(0) + "." + B.slice(1) : B) + (z < 0 ? "e" : "e+") + z;
}
function toFixedPoint(B, z, Y) {
  var ne, ie;
  if (z < 0) {
    for (ie = Y + "."; ++z; ie += Y) ;
    B = ie + B;
  } else if (ne = B.length, ++z > ne) {
    for (ie = Y, z -= ne; --z; ie += Y) ;
    B += ie;
  } else z < ne && (B = B.slice(0, z) + "." + B.slice(z));
  return B;
}
var BigNumber = clone();
function useBalance() {
  const { network: B, publicKey: z, format: Y, chain: ne } = useOrdConnect(), [ie, oe] = useState(null), [se, ae] = useState(!1);
  return { getBalance: useCallback(async () => {
    ae(!0);
    try {
      if (oe(null), !Y || !Y.payments || !z || !z.payments)
        throw new Error("No wallet is connected");
      const { address: Pe } = getAddressesFromPublicKey(
        z.payments,
        B,
        ADDRESS_FORMAT_TO_TYPE[Y.payments],
        ne
      )[0], Ee = await new JsonRpcDatasource({
        chain: ne,
        network: B
      }).getBalance({ address: Pe }), Je = Number(
        new BigNumber(Ee).multipliedBy(1e8).toFixed(0, BigNumber.ROUND_HALF_DOWN)
      );
      return ae(!1), Je;
    } catch (Pe) {
      throw oe(Pe.message), ae(!1), Pe;
    }
  }, [Y, B, z]), error: ie, loading: se };
}
async function signPsbt({
  address: B,
  wallet: z,
  network: Y,
  psbt: ne,
  options: ie
}) {
  var ve, Pe;
  if ((ve = ie == null ? void 0 : ie.signingIndexes) != null && ve.length && ((Pe = ie == null ? void 0 : ie.inputsToSign) != null && Pe.length))
    throw new Error("Cannot have both indexes and inputs to sign together");
  const oe = (ie == null ? void 0 : ie.finalize) ?? !0, se = (ie == null ? void 0 : ie.extractTx) ?? !0, ae = () => ne.data.inputs.map((le, Ee) => Ee);
  if (z === Wallet.MAGICEDEN)
    return await signPsbt$1(ne, {
      network: Y,
      inputsToSign: (ie == null ? void 0 : ie.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (ie == null ? void 0 : ie.signingIndexes) ?? ae(),
          sigHash: ie == null ? void 0 : ie.sigHash
        }
      ],
      finalize: oe,
      extractTx: se
    });
  if (z === Wallet.UNISAT)
    return await signPsbt$2(ne, {
      finalize: oe,
      extractTx: se
    });
  if (z === Wallet.XVERSE)
    return await signPsbt$3(ne, {
      network: Y,
      inputsToSign: (ie == null ? void 0 : ie.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (ie == null ? void 0 : ie.signingIndexes) ?? ae(),
          // If signingIndexes is not provided, just sign everything
          sigHash: ie == null ? void 0 : ie.sigHash
        }
      ],
      finalize: oe,
      extractTx: se
    });
  if (z === Wallet.LEATHER)
    return await signPsbt$4(ne, {
      network: Y,
      finalize: oe,
      extractTx: se,
      allowedSighash: ie != null && ie.sigHash ? [ie == null ? void 0 : ie.sigHash] : [],
      signAtIndexes: (ie == null ? void 0 : ie.signingIndexes) ?? ae()
      // If signingIndexes is not provided, just sign everything
    });
  if (z === Wallet.OKX)
    return await signPsbt$5(ne, {
      finalize: oe,
      extractTx: se,
      network: Y,
      inputsToSign: (ie == null ? void 0 : ie.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (ie == null ? void 0 : ie.signingIndexes) ?? ae(),
          // If signingIndexes is not provided, just sign everything
          sigHash: ie == null ? void 0 : ie.sigHash
        }
      ]
    });
  throw new Error("Invalid wallet selected");
}
function useSend() {
  const { wallet: B, network: z, address: Y, publicKey: ne, chain: ie } = useOrdConnect(), [oe, se] = useState(null), [ae, ve] = useState(!1);
  return { send: useCallback(
    async (le, Ee, Je, Ce = !0) => {
      ve(!0);
      try {
        if (se(null), !Y || !Y.payments || !ne || !ne.payments || !B)
          throw new Error("No wallet is connected");
        const _t = new PSBTBuilder({
          address: Y.payments,
          feeRate: Je,
          network: z,
          chain: ie,
          publicKey: ne.payments,
          outputs: [
            {
              address: le,
              value: Ee
            }
          ]
        });
        await _t.prepare();
        const kt = await signPsbt({
          address: Y.payments,
          wallet: B,
          network: z,
          psbt: _t.toPSBT()
        });
        if (Ce) {
          const Lt = await new JsonRpcDatasource({ network: z, chain: ie }).relay({ hex: kt.hex });
          return ve(!1), Lt;
        }
        return ve(!1), kt.hex;
      } catch (_t) {
        return se(_t.message), ve(!1), null;
      }
    },
    [Y, z, ne, B]
  ), error: oe, loading: ae };
}
function useSendV2() {
  const { wallet: B, network: z, address: Y, publicKey: ne, chain: ie } = useOrdConnect(), [oe, se] = useState(!1);
  return { send: useCallback(
    async ({
      toAddress: ve,
      satoshis: Pe,
      feeRate: le,
      relay: Ee = !0,
      rbf: Je = !1
    }) => {
      se(!0);
      try {
        if (!Y || !Y.payments || !ne || !ne.payments || !B)
          throw new Error("No wallet is connected");
        const Ce = new PSBTBuilder({
          address: Y.payments,
          feeRate: le,
          network: z,
          chain: ie,
          publicKey: ne.payments,
          outputs: [
            {
              address: ve,
              value: Pe
            }
          ]
        });
        Ce.setRBF(Je), await Ce.prepare();
        const _t = await signPsbt({
          address: Y.payments,
          wallet: B,
          network: z,
          psbt: Ce.toPSBT()
        });
        if (Ee) {
          const Ct = await new JsonRpcDatasource({ network: z, chain: ie }).relay({ hex: _t.hex });
          return se(!1), {
            txId: Ct
          };
        }
        return se(!1), {
          signedPsbtHex: _t.hex
        };
      } catch (Ce) {
        return se(!1), {
          error: Ce.message
        };
      }
    },
    [Y, z, ne, B]
  ), isLoading: oe };
}
var src$1 = {}, address = {}, networks = {};
Object.defineProperty(networks, "__esModule", { value: !0 });
networks.testnet = networks.regtest = networks.bitcoin = void 0;
networks.bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
networks.regtest = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
networks.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var payments$2 = {}, embed = {}, script = {}, bip66 = {};
Object.defineProperty(bip66, "__esModule", { value: !0 });
bip66.encode = bip66.decode = bip66.check = void 0;
function check$d(B) {
  if (B.length < 8 || B.length > 72 || B[0] !== 48 || B[1] !== B.length - 2 || B[2] !== 2) return !1;
  const z = B[3];
  if (z === 0 || 5 + z >= B.length || B[4 + z] !== 2) return !1;
  const Y = B[5 + z];
  return !(Y === 0 || 6 + z + Y !== B.length || B[4] & 128 || z > 1 && B[4] === 0 && !(B[5] & 128) || B[z + 6] & 128 || Y > 1 && B[z + 6] === 0 && !(B[z + 7] & 128));
}
bip66.check = check$d;
function decode$h(B) {
  if (B.length < 8) throw new Error("DER sequence length is too short");
  if (B.length > 72) throw new Error("DER sequence length is too long");
  if (B[0] !== 48) throw new Error("Expected DER sequence");
  if (B[1] !== B.length - 2)
    throw new Error("DER sequence length is invalid");
  if (B[2] !== 2) throw new Error("Expected DER integer");
  const z = B[3];
  if (z === 0) throw new Error("R length is zero");
  if (5 + z >= B.length) throw new Error("R length is too long");
  if (B[4 + z] !== 2) throw new Error("Expected DER integer (2)");
  const Y = B[5 + z];
  if (Y === 0) throw new Error("S length is zero");
  if (6 + z + Y !== B.length) throw new Error("S length is invalid");
  if (B[4] & 128) throw new Error("R value is negative");
  if (z > 1 && B[4] === 0 && !(B[5] & 128))
    throw new Error("R value excessively padded");
  if (B[z + 6] & 128) throw new Error("S value is negative");
  if (Y > 1 && B[z + 6] === 0 && !(B[z + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: B.slice(4, 4 + z),
    s: B.slice(6 + z)
  };
}
bip66.decode = decode$h;
function encode$i(B, z) {
  const Y = B.length, ne = z.length;
  if (Y === 0) throw new Error("R length is zero");
  if (ne === 0) throw new Error("S length is zero");
  if (Y > 33) throw new Error("R length is too long");
  if (ne > 33) throw new Error("S length is too long");
  if (B[0] & 128) throw new Error("R value is negative");
  if (z[0] & 128) throw new Error("S value is negative");
  if (Y > 1 && B[0] === 0 && !(B[1] & 128))
    throw new Error("R value excessively padded");
  if (ne > 1 && z[0] === 0 && !(z[1] & 128))
    throw new Error("S value excessively padded");
  const ie = Buffer$D.allocUnsafe(6 + Y + ne);
  return ie[0] = 48, ie[1] = ie.length - 2, ie[2] = 2, ie[3] = B.length, B.copy(ie, 4), ie[4 + Y] = 2, ie[5 + Y] = z.length, z.copy(ie, 6 + Y), ie;
}
bip66.encode = encode$i;
var ops = {};
Object.defineProperty(ops, "__esModule", { value: !0 });
ops.REVERSE_OPS = ops.OPS = void 0;
const OPS$7 = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
ops.OPS = OPS$7;
const REVERSE_OPS = {};
ops.REVERSE_OPS = REVERSE_OPS;
for (const B of Object.keys(OPS$7)) {
  const z = OPS$7[B];
  REVERSE_OPS[z] = B;
}
var push_data = {};
Object.defineProperty(push_data, "__esModule", { value: !0 });
push_data.decode = push_data.encode = push_data.encodingLength = void 0;
const ops_1 = ops;
function encodingLength$2(B) {
  return B < ops_1.OPS.OP_PUSHDATA1 ? 1 : B <= 255 ? 2 : B <= 65535 ? 3 : 5;
}
push_data.encodingLength = encodingLength$2;
function encode$h(B, z, Y) {
  const ne = encodingLength$2(z);
  return ne === 1 ? B.writeUInt8(z, Y) : ne === 2 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA1, Y), B.writeUInt8(z, Y + 1)) : ne === 3 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA2, Y), B.writeUInt16LE(z, Y + 1)) : (B.writeUInt8(ops_1.OPS.OP_PUSHDATA4, Y), B.writeUInt32LE(z, Y + 1)), ne;
}
push_data.encode = encode$h;
function decode$g(B, z) {
  const Y = B.readUInt8(z);
  let ne, ie;
  if (Y < ops_1.OPS.OP_PUSHDATA1)
    ne = Y, ie = 1;
  else if (Y === ops_1.OPS.OP_PUSHDATA1) {
    if (z + 2 > B.length) return null;
    ne = B.readUInt8(z + 1), ie = 2;
  } else if (Y === ops_1.OPS.OP_PUSHDATA2) {
    if (z + 3 > B.length) return null;
    ne = B.readUInt16LE(z + 1), ie = 3;
  } else {
    if (z + 5 > B.length) return null;
    if (Y !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    ne = B.readUInt32LE(z + 1), ie = 5;
  }
  return {
    opcode: Y,
    number: ne,
    size: ie
  };
}
push_data.decode = decode$g;
var script_number = {};
Object.defineProperty(script_number, "__esModule", { value: !0 });
script_number.encode = script_number.decode = void 0;
function decode$f(B, z, Y) {
  z = z || 4, Y = Y === void 0 ? !0 : Y;
  const ne = B.length;
  if (ne === 0) return 0;
  if (ne > z) throw new TypeError("Script number overflow");
  if (Y && !(B[ne - 1] & 127) && (ne <= 1 || !(B[ne - 2] & 128)))
    throw new Error("Non-minimally encoded script number");
  if (ne === 5) {
    const oe = B.readUInt32LE(0), se = B.readUInt8(4);
    return se & 128 ? -((se & -129) * 4294967296 + oe) : se * 4294967296 + oe;
  }
  let ie = 0;
  for (let oe = 0; oe < ne; ++oe)
    ie |= B[oe] << 8 * oe;
  return B[ne - 1] & 128 ? -(ie & ~(128 << 8 * (ne - 1))) : ie;
}
script_number.decode = decode$f;
function scriptNumSize(B) {
  return B > 2147483647 ? 5 : B > 8388607 ? 4 : B > 32767 ? 3 : B > 127 ? 2 : B > 0 ? 1 : 0;
}
function encode$g(B) {
  let z = Math.abs(B);
  const Y = scriptNumSize(z), ne = Buffer$D.allocUnsafe(Y), ie = B < 0;
  for (let oe = 0; oe < Y; ++oe)
    ne.writeUInt8(z & 255, oe), z >>= 8;
  return ne[Y - 1] & 128 ? ne.writeUInt8(ie ? 128 : 0, Y - 1) : ie && (ne[Y - 1] |= 128), ne;
}
script_number.encode = encode$g;
var script_signature = {}, types$4 = {}, types$3 = {
  Array: function(B) {
    return B != null && B.constructor === Array;
  },
  Boolean: function(B) {
    return typeof B == "boolean";
  },
  Function: function(B) {
    return typeof B == "function";
  },
  Nil: function(B) {
    return B == null;
  },
  Number: function(B) {
    return typeof B == "number";
  },
  Object: function(B) {
    return typeof B == "object";
  },
  String: function(B) {
    return typeof B == "string";
  },
  "": function() {
    return !0;
  }
};
types$3.Null = types$3.Nil;
for (var typeName$1 in types$3)
  types$3[typeName$1].toJSON = (function(B) {
    return B;
  }).bind(null, typeName$1);
var native$1 = types$3, native = native$1;
function getTypeName(B) {
  return B.name || B.toString().match(/function (.*?)\s*\(/)[1];
}
function getValueTypeName$1(B) {
  return native.Nil(B) ? "" : getTypeName(B.constructor);
}
function getValue(B) {
  return native.Function(B) ? "" : native.String(B) ? JSON.stringify(B) : B && native.Object(B) ? "" : B;
}
function captureStackTrace(B, z) {
  Error.captureStackTrace && Error.captureStackTrace(B, z);
}
function tfJSON$1(B) {
  return native.Function(B) ? B.toJSON ? B.toJSON() : getTypeName(B) : native.Array(B) ? "Array" : B && native.Object(B) ? "Object" : B !== void 0 ? B : "";
}
function tfErrorString(B, z, Y) {
  var ne = getValue(z);
  return "Expected " + tfJSON$1(B) + ", got" + (Y !== "" ? " " + Y : "") + (ne !== "" ? " " + ne : "");
}
function TfTypeError$1(B, z, Y) {
  Y = Y || getValueTypeName$1(z), this.message = tfErrorString(B, z, Y), captureStackTrace(this, TfTypeError$1), this.__type = B, this.__value = z, this.__valueTypeName = Y;
}
TfTypeError$1.prototype = Object.create(Error.prototype);
TfTypeError$1.prototype.constructor = TfTypeError$1;
function tfPropertyErrorString(B, z, Y, ne, ie) {
  var oe = '" of type ';
  return z === "key" && (oe = '" with key type '), tfErrorString('property "' + tfJSON$1(Y) + oe + tfJSON$1(B), ne, ie);
}
function TfPropertyTypeError$1(B, z, Y, ne, ie) {
  B ? (ie = ie || getValueTypeName$1(ne), this.message = tfPropertyErrorString(B, Y, z, ne, ie)) : this.message = 'Unexpected property "' + z + '"', captureStackTrace(this, TfTypeError$1), this.__label = Y, this.__property = z, this.__type = B, this.__value = ne, this.__valueTypeName = ie;
}
TfPropertyTypeError$1.prototype = Object.create(Error.prototype);
TfPropertyTypeError$1.prototype.constructor = TfTypeError$1;
function tfCustomError(B, z) {
  return new TfTypeError$1(B, {}, z);
}
function tfSubError$1(B, z, Y) {
  return B instanceof TfPropertyTypeError$1 ? (z = z + "." + B.__property, B = new TfPropertyTypeError$1(
    B.__type,
    z,
    B.__label,
    B.__value,
    B.__valueTypeName
  )) : B instanceof TfTypeError$1 && (B = new TfPropertyTypeError$1(
    B.__type,
    z,
    Y,
    B.__value,
    B.__valueTypeName
  )), captureStackTrace(B), B;
}
var errors = {
  TfTypeError: TfTypeError$1,
  TfPropertyTypeError: TfPropertyTypeError$1,
  tfCustomError,
  tfSubError: tfSubError$1,
  tfJSON: tfJSON$1,
  getValueTypeName: getValueTypeName$1
}, extra, hasRequiredExtra;
function requireExtra() {
  if (hasRequiredExtra) return extra;
  hasRequiredExtra = 1;
  var B = native$1, z = errors;
  function Y(Vt) {
    return Buffer$D.isBuffer(Vt);
  }
  function ne(Vt) {
    return typeof Vt == "string" && /^([0-9a-f]{2})+$/i.test(Vt);
  }
  function ie(Vt, ir) {
    var jt = Vt.toJSON();
    function Rt(Kt) {
      if (!Vt(Kt)) return !1;
      if (Kt.length === ir) return !0;
      throw z.tfCustomError(jt + "(Length: " + ir + ")", jt + "(Length: " + Kt.length + ")");
    }
    return Rt.toJSON = function() {
      return jt;
    }, Rt;
  }
  var oe = ie.bind(null, B.Array), se = ie.bind(null, Y), ae = ie.bind(null, ne), ve = ie.bind(null, B.String);
  function Pe(Vt, ir, jt) {
    jt = jt || B.Number;
    function Rt(Kt, Bt) {
      return jt(Kt, Bt) && Kt > Vt && Kt < ir;
    }
    return Rt.toJSON = function() {
      return `${jt.toJSON()} between [${Vt}, ${ir}]`;
    }, Rt;
  }
  var le = Math.pow(2, 53) - 1;
  function Ee(Vt) {
    return typeof Vt == "number" && isFinite(Vt);
  }
  function Je(Vt) {
    return Vt << 24 >> 24 === Vt;
  }
  function Ce(Vt) {
    return Vt << 16 >> 16 === Vt;
  }
  function _t(Vt) {
    return (Vt | 0) === Vt;
  }
  function kt(Vt) {
    return typeof Vt == "number" && Vt >= -le && Vt <= le && Math.floor(Vt) === Vt;
  }
  function Ct(Vt) {
    return (Vt & 255) === Vt;
  }
  function Lt(Vt) {
    return (Vt & 65535) === Vt;
  }
  function Pt(Vt) {
    return Vt >>> 0 === Vt;
  }
  function Ft(Vt) {
    return typeof Vt == "number" && Vt >= 0 && Vt <= le && Math.floor(Vt) === Vt;
  }
  var Ut = {
    ArrayN: oe,
    Buffer: Y,
    BufferN: se,
    Finite: Ee,
    Hex: ne,
    HexN: ae,
    Int8: Je,
    Int16: Ce,
    Int32: _t,
    Int53: kt,
    Range: Pe,
    StringN: ve,
    UInt8: Ct,
    UInt16: Lt,
    UInt32: Pt,
    UInt53: Ft
  };
  for (var Jt in Ut)
    Ut[Jt].toJSON = (function(Vt) {
      return Vt;
    }).bind(null, Jt);
  return extra = Ut, extra;
}
var ERRORS = errors, NATIVE = native$1, tfJSON = ERRORS.tfJSON, TfTypeError = ERRORS.TfTypeError, TfPropertyTypeError = ERRORS.TfPropertyTypeError, tfSubError = ERRORS.tfSubError, getValueTypeName = ERRORS.getValueTypeName, TYPES = {
  arrayOf: function B(z, Y) {
    z = compile(z), Y = Y || {};
    function ne(ie, oe) {
      return !NATIVE.Array(ie) || NATIVE.Nil(ie) || Y.minLength !== void 0 && ie.length < Y.minLength || Y.maxLength !== void 0 && ie.length > Y.maxLength || Y.length !== void 0 && ie.length !== Y.length ? !1 : ie.every(function(se, ae) {
        try {
          return typeforce$3(z, se, oe);
        } catch (ve) {
          throw tfSubError(ve, ae);
        }
      });
    }
    return ne.toJSON = function() {
      var ie = "[" + tfJSON(z) + "]";
      return Y.length !== void 0 ? ie += "{" + Y.length + "}" : (Y.minLength !== void 0 || Y.maxLength !== void 0) && (ie += "{" + (Y.minLength === void 0 ? 0 : Y.minLength) + "," + (Y.maxLength === void 0 ? 1 / 0 : Y.maxLength) + "}"), ie;
    }, ne;
  },
  maybe: function B(z) {
    z = compile(z);
    function Y(ne, ie) {
      return NATIVE.Nil(ne) || z(ne, ie, B);
    }
    return Y.toJSON = function() {
      return "?" + tfJSON(z);
    }, Y;
  },
  map: function B(z, Y) {
    z = compile(z), Y && (Y = compile(Y));
    function ne(ie, oe) {
      if (!NATIVE.Object(ie) || NATIVE.Nil(ie)) return !1;
      for (var se in ie) {
        try {
          Y && typeforce$3(Y, se, oe);
        } catch (ve) {
          throw tfSubError(ve, se, "key");
        }
        try {
          var ae = ie[se];
          typeforce$3(z, ae, oe);
        } catch (ve) {
          throw tfSubError(ve, se);
        }
      }
      return !0;
    }
    return Y ? ne.toJSON = function() {
      return "{" + tfJSON(Y) + ": " + tfJSON(z) + "}";
    } : ne.toJSON = function() {
      return "{" + tfJSON(z) + "}";
    }, ne;
  },
  object: function B(z) {
    var Y = {};
    for (var ne in z)
      Y[ne] = compile(z[ne]);
    function ie(oe, se) {
      if (!NATIVE.Object(oe) || NATIVE.Nil(oe)) return !1;
      var ae;
      try {
        for (ae in Y) {
          var ve = Y[ae], Pe = oe[ae];
          typeforce$3(ve, Pe, se);
        }
      } catch (le) {
        throw tfSubError(le, ae);
      }
      if (se) {
        for (ae in oe)
          if (!Y[ae])
            throw new TfPropertyTypeError(void 0, ae);
      }
      return !0;
    }
    return ie.toJSON = function() {
      return tfJSON(Y);
    }, ie;
  },
  anyOf: function B() {
    var z = [].slice.call(arguments).map(compile);
    function Y(ne, ie) {
      return z.some(function(oe) {
        try {
          return typeforce$3(oe, ne, ie);
        } catch {
          return !1;
        }
      });
    }
    return Y.toJSON = function() {
      return z.map(tfJSON).join("|");
    }, Y;
  },
  allOf: function B() {
    var z = [].slice.call(arguments).map(compile);
    function Y(ne, ie) {
      return z.every(function(oe) {
        try {
          return typeforce$3(oe, ne, ie);
        } catch {
          return !1;
        }
      });
    }
    return Y.toJSON = function() {
      return z.map(tfJSON).join(" & ");
    }, Y;
  },
  quacksLike: function B(z) {
    function Y(ne) {
      return z === getValueTypeName(ne);
    }
    return Y.toJSON = function() {
      return z;
    }, Y;
  },
  tuple: function B() {
    var z = [].slice.call(arguments).map(compile);
    function Y(ne, ie) {
      return NATIVE.Nil(ne) || NATIVE.Nil(ne.length) || ie && ne.length !== z.length ? !1 : z.every(function(oe, se) {
        try {
          return typeforce$3(oe, ne[se], ie);
        } catch (ae) {
          throw tfSubError(ae, se);
        }
      });
    }
    return Y.toJSON = function() {
      return "(" + z.map(tfJSON).join(", ") + ")";
    }, Y;
  },
  value: function B(z) {
    function Y(ne) {
      return ne === z;
    }
    return Y.toJSON = function() {
      return z;
    }, Y;
  }
};
TYPES.oneOf = TYPES.anyOf;
function compile(B) {
  if (NATIVE.String(B))
    return B[0] === "?" ? TYPES.maybe(B.slice(1)) : NATIVE[B] || TYPES.quacksLike(B);
  if (B && NATIVE.Object(B)) {
    if (NATIVE.Array(B)) {
      if (B.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return TYPES.arrayOf(B[0]);
    }
    return TYPES.object(B);
  } else if (NATIVE.Function(B))
    return B;
  return TYPES.value(B);
}
function typeforce$3(B, z, Y, ne) {
  if (NATIVE.Function(B)) {
    if (B(z, Y)) return !0;
    throw new TfTypeError(ne || B, z);
  }
  return typeforce$3(compile(B), z, Y);
}
for (var typeName in NATIVE)
  typeforce$3[typeName] = NATIVE[typeName];
for (typeName in TYPES)
  typeforce$3[typeName] = TYPES[typeName];
var EXTRA = requireExtra();
for (typeName in EXTRA)
  typeforce$3[typeName] = EXTRA[typeName];
typeforce$3.compile = compile;
typeforce$3.TfTypeError = TfTypeError;
typeforce$3.TfPropertyTypeError = TfPropertyTypeError;
var typeforce_1 = typeforce$3;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.oneOf = B.Null = B.BufferN = B.Function = B.UInt32 = B.UInt8 = B.tuple = B.maybe = B.Hex = B.Buffer = B.String = B.Boolean = B.Array = B.Number = B.Hash256bit = B.Hash160bit = B.Buffer256bit = B.isTaptree = B.isTapleaf = B.TAPLEAF_VERSION_MASK = B.Satoshi = B.isPoint = B.stacksEqual = B.typeforce = void 0;
  const z = require$$0$1;
  B.typeforce = typeforce_1;
  const Y = z.Buffer.alloc(32, 0), ne = z.Buffer.from(
    "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "hex"
  );
  function ie(le, Ee) {
    return le.length !== Ee.length ? !1 : le.every((Je, Ce) => Je.equals(Ee[Ce]));
  }
  B.stacksEqual = ie;
  function oe(le) {
    if (!z.Buffer.isBuffer(le) || le.length < 33) return !1;
    const Ee = le[0], Je = le.slice(1, 33);
    if (Je.compare(Y) === 0 || Je.compare(ne) >= 0) return !1;
    if ((Ee === 2 || Ee === 3) && le.length === 33)
      return !0;
    const Ce = le.slice(33);
    return Ce.compare(Y) === 0 || Ce.compare(ne) >= 0 ? !1 : Ee === 4 && le.length === 65;
  }
  B.isPoint = oe;
  const se = 21 * 1e14;
  function ae(le) {
    return B.typeforce.UInt53(le) && le <= se;
  }
  B.Satoshi = ae, B.TAPLEAF_VERSION_MASK = 254;
  function ve(le) {
    return !le || !("output" in le) || !z.Buffer.isBuffer(le.output) ? !1 : le.version !== void 0 ? (le.version & B.TAPLEAF_VERSION_MASK) === le.version : !0;
  }
  B.isTapleaf = ve;
  function Pe(le) {
    return (0, B.Array)(le) ? le.length !== 2 ? !1 : le.every((Ee) => Pe(Ee)) : ve(le);
  }
  B.isTaptree = Pe, B.Buffer256bit = B.typeforce.BufferN(32), B.Hash160bit = B.typeforce.BufferN(20), B.Hash256bit = B.typeforce.BufferN(32), B.Number = B.typeforce.Number, B.Array = B.typeforce.Array, B.Boolean = B.typeforce.Boolean, B.String = B.typeforce.String, B.Buffer = B.typeforce.Buffer, B.Hex = B.typeforce.Hex, B.maybe = B.typeforce.maybe, B.tuple = B.typeforce.tuple, B.UInt8 = B.typeforce.UInt8, B.UInt32 = B.typeforce.UInt32, B.Function = B.typeforce.Function, B.BufferN = B.typeforce.BufferN, B.Null = B.typeforce.Null, B.oneOf = B.typeforce.oneOf;
})(types$4);
var hasRequiredScript_signature;
function requireScript_signature() {
  if (hasRequiredScript_signature) return script_signature;
  hasRequiredScript_signature = 1, Object.defineProperty(script_signature, "__esModule", { value: !0 }), script_signature.encode = script_signature.decode = void 0;
  const B = bip66, z = requireScript(), Y = types$4, { typeforce: ne } = Y, ie = Buffer$D.alloc(1, 0);
  function oe(Pe) {
    let le = 0;
    for (; Pe[le] === 0; ) ++le;
    return le === Pe.length ? ie : (Pe = Pe.slice(le), Pe[0] & 128 ? Buffer$D.concat([ie, Pe], 1 + Pe.length) : Pe);
  }
  function se(Pe) {
    Pe[0] === 0 && (Pe = Pe.slice(1));
    const le = Buffer$D.alloc(32, 0), Ee = Math.max(0, 32 - Pe.length);
    return Pe.copy(le, Ee), le;
  }
  function ae(Pe) {
    const le = Pe.readUInt8(Pe.length - 1);
    if (!(0, z.isDefinedHashType)(le))
      throw new Error("Invalid hashType " + le);
    const Ee = B.decode(Pe.slice(0, -1)), Je = se(Ee.r), Ce = se(Ee.s);
    return { signature: Buffer$D.concat([Je, Ce], 64), hashType: le };
  }
  script_signature.decode = ae;
  function ve(Pe, le) {
    if (ne(
      {
        signature: Y.BufferN(64),
        hashType: Y.UInt8
      },
      { signature: Pe, hashType: le }
    ), !(0, z.isDefinedHashType)(le))
      throw new Error("Invalid hashType " + le);
    const Ee = Buffer$D.allocUnsafe(1);
    Ee.writeUInt8(le, 0);
    const Je = oe(Pe.slice(0, 32)), Ce = oe(Pe.slice(32, 64));
    return Buffer$D.concat([B.encode(Je, Ce), Ee]);
  }
  return script_signature.encode = ve, script_signature;
}
var hasRequiredScript;
function requireScript() {
  return hasRequiredScript || (hasRequiredScript = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.signature = B.number = B.isCanonicalScriptSignature = B.isDefinedHashType = B.isCanonicalPubKey = B.toStack = B.fromASM = B.toASM = B.decompile = B.compile = B.countNonPushOnlyOPs = B.isPushOnly = B.OPS = void 0;
    const z = bip66, Y = ops;
    Object.defineProperty(B, "OPS", {
      enumerable: !0,
      get: function() {
        return Y.OPS;
      }
    });
    const ne = push_data, ie = script_number, oe = requireScript_signature(), se = types$4, { typeforce: ae } = se, ve = Y.OPS.OP_RESERVED;
    function Pe(Rt) {
      return se.Number(Rt) && (Rt === Y.OPS.OP_0 || Rt >= Y.OPS.OP_1 && Rt <= Y.OPS.OP_16 || Rt === Y.OPS.OP_1NEGATE);
    }
    function le(Rt) {
      return se.Buffer(Rt) || Pe(Rt);
    }
    function Ee(Rt) {
      return se.Array(Rt) && Rt.every(le);
    }
    B.isPushOnly = Ee;
    function Je(Rt) {
      return Rt.length - Rt.filter(le).length;
    }
    B.countNonPushOnlyOPs = Je;
    function Ce(Rt) {
      if (Rt.length === 0) return Y.OPS.OP_0;
      if (Rt.length === 1) {
        if (Rt[0] >= 1 && Rt[0] <= 16) return ve + Rt[0];
        if (Rt[0] === 129) return Y.OPS.OP_1NEGATE;
      }
    }
    function _t(Rt) {
      return Buffer$D.isBuffer(Rt);
    }
    function kt(Rt) {
      return se.Array(Rt);
    }
    function Ct(Rt) {
      return Buffer$D.isBuffer(Rt);
    }
    function Lt(Rt) {
      if (_t(Rt)) return Rt;
      ae(se.Array, Rt);
      const Kt = Rt.reduce((Ve, ge) => Ct(ge) ? ge.length === 1 && Ce(ge) !== void 0 ? Ve + 1 : Ve + ne.encodingLength(ge.length) + ge.length : Ve + 1, 0), Bt = Buffer$D.allocUnsafe(Kt);
      let Xe = 0;
      if (Rt.forEach((Ve) => {
        if (Ct(Ve)) {
          const ge = Ce(Ve);
          if (ge !== void 0) {
            Bt.writeUInt8(ge, Xe), Xe += 1;
            return;
          }
          Xe += ne.encode(Bt, Ve.length, Xe), Ve.copy(Bt, Xe), Xe += Ve.length;
        } else
          Bt.writeUInt8(Ve, Xe), Xe += 1;
      }), Xe !== Bt.length) throw new Error("Could not decode chunks");
      return Bt;
    }
    B.compile = Lt;
    function Pt(Rt) {
      if (kt(Rt)) return Rt;
      ae(se.Buffer, Rt);
      const Kt = [];
      let Bt = 0;
      for (; Bt < Rt.length; ) {
        const Xe = Rt[Bt];
        if (Xe > Y.OPS.OP_0 && Xe <= Y.OPS.OP_PUSHDATA4) {
          const Ve = ne.decode(Rt, Bt);
          if (Ve === null || (Bt += Ve.size, Bt + Ve.number > Rt.length)) return null;
          const ge = Rt.slice(Bt, Bt + Ve.number);
          Bt += Ve.number;
          const Ke = Ce(ge);
          Ke !== void 0 ? Kt.push(Ke) : Kt.push(ge);
        } else
          Kt.push(Xe), Bt += 1;
      }
      return Kt;
    }
    B.decompile = Pt;
    function Ft(Rt) {
      if (_t(Rt) && (Rt = Pt(Rt)), !Rt)
        throw new Error("Could not convert invalid chunks to ASM");
      return Rt.map((Kt) => {
        if (Ct(Kt)) {
          const Bt = Ce(Kt);
          if (Bt === void 0) return Kt.toString("hex");
          Kt = Bt;
        }
        return Y.REVERSE_OPS[Kt];
      }).join(" ");
    }
    B.toASM = Ft;
    function Ut(Rt) {
      return ae(se.String, Rt), Lt(
        Rt.split(" ").map((Kt) => Y.OPS[Kt] !== void 0 ? Y.OPS[Kt] : (ae(se.Hex, Kt), Buffer$D.from(Kt, "hex")))
      );
    }
    B.fromASM = Ut;
    function Jt(Rt) {
      return Rt = Pt(Rt), ae(Ee, Rt), Rt.map((Kt) => Ct(Kt) ? Kt : Kt === Y.OPS.OP_0 ? Buffer$D.allocUnsafe(0) : ie.encode(Kt - ve));
    }
    B.toStack = Jt;
    function Vt(Rt) {
      return se.isPoint(Rt);
    }
    B.isCanonicalPubKey = Vt;
    function ir(Rt) {
      const Kt = Rt & -129;
      return Kt > 0 && Kt < 4;
    }
    B.isDefinedHashType = ir;
    function jt(Rt) {
      return !Buffer$D.isBuffer(Rt) || !ir(Rt[Rt.length - 1]) ? !1 : z.check(Rt.slice(0, -1));
    }
    B.isCanonicalScriptSignature = jt, B.number = ie, B.signature = oe;
  }(script)), script;
}
var lazy$7 = {};
Object.defineProperty(lazy$7, "__esModule", { value: !0 });
lazy$7.value = lazy$7.prop = void 0;
function prop(B, z, Y) {
  Object.defineProperty(B, z, {
    configurable: !0,
    enumerable: !0,
    get() {
      const ne = Y.call(this);
      return this[z] = ne, ne;
    },
    set(ne) {
      Object.defineProperty(this, z, {
        configurable: !0,
        enumerable: !0,
        value: ne,
        writable: !0
      });
    }
  });
}
lazy$7.prop = prop;
function value(B) {
  let z;
  return () => (z !== void 0 || (z = B()), z);
}
lazy$7.value = value;
Object.defineProperty(embed, "__esModule", { value: !0 });
embed.p2data = void 0;
const networks_1$7 = networks, bscript$9 = requireScript(), types_1$7 = types$4, lazy$6 = lazy$7, OPS$6 = bscript$9.OPS;
function p2data(B, z) {
  if (!B.data && !B.output) throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$7.typeforce)(
    {
      network: types_1$7.typeforce.maybe(types_1$7.typeforce.Object),
      output: types_1$7.typeforce.maybe(types_1$7.typeforce.Buffer),
      data: types_1$7.typeforce.maybe(
        types_1$7.typeforce.arrayOf(types_1$7.typeforce.Buffer)
      )
    },
    B
  );
  const ne = { name: "embed", network: B.network || networks_1$7.bitcoin };
  if (lazy$6.prop(ne, "output", () => {
    if (B.data)
      return bscript$9.compile([OPS$6.OP_RETURN].concat(B.data));
  }), lazy$6.prop(ne, "data", () => {
    if (B.output)
      return bscript$9.decompile(B.output).slice(1);
  }), z.validate && B.output) {
    const ie = bscript$9.decompile(B.output);
    if (ie[0] !== OPS$6.OP_RETURN) throw new TypeError("Output is invalid");
    if (!ie.slice(1).every(types_1$7.typeforce.Buffer))
      throw new TypeError("Output is invalid");
    if (B.data && !(0, types_1$7.stacksEqual)(B.data, ne.data))
      throw new TypeError("Data mismatch");
  }
  return Object.assign(ne, B);
}
embed.p2data = p2data;
var p2ms$1 = {};
Object.defineProperty(p2ms$1, "__esModule", { value: !0 });
p2ms$1.p2ms = void 0;
const networks_1$6 = networks, bscript$8 = requireScript(), types_1$6 = types$4, lazy$5 = lazy$7, OPS$5 = bscript$8.OPS, OP_INT_BASE = OPS$5.OP_RESERVED;
function p2ms(B, z) {
  if (!B.input && !B.output && !(B.pubkeys && B.m !== void 0) && !B.signatures)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {});
  function Y(ve) {
    return bscript$8.isCanonicalScriptSignature(ve) || (z.allowIncomplete && ve === OPS$5.OP_0) !== void 0;
  }
  (0, types_1$6.typeforce)(
    {
      network: types_1$6.typeforce.maybe(types_1$6.typeforce.Object),
      m: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      n: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      output: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer),
      pubkeys: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(types_1$6.isPoint)
      ),
      signatures: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(Y)
      ),
      input: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer)
    },
    B
  );
  const ie = { network: B.network || networks_1$6.bitcoin };
  let oe = [], se = !1;
  function ae(ve) {
    se || (se = !0, oe = bscript$8.decompile(ve), ie.m = oe[0] - OP_INT_BASE, ie.n = oe[oe.length - 2] - OP_INT_BASE, ie.pubkeys = oe.slice(1, -2));
  }
  if (lazy$5.prop(ie, "output", () => {
    if (B.m && ie.n && B.pubkeys)
      return bscript$8.compile(
        [].concat(
          OP_INT_BASE + B.m,
          B.pubkeys,
          OP_INT_BASE + ie.n,
          OPS$5.OP_CHECKMULTISIG
        )
      );
  }), lazy$5.prop(ie, "m", () => {
    if (ie.output)
      return ae(ie.output), ie.m;
  }), lazy$5.prop(ie, "n", () => {
    if (ie.pubkeys)
      return ie.pubkeys.length;
  }), lazy$5.prop(ie, "pubkeys", () => {
    if (B.output)
      return ae(B.output), ie.pubkeys;
  }), lazy$5.prop(ie, "signatures", () => {
    if (B.input)
      return bscript$8.decompile(B.input).slice(1);
  }), lazy$5.prop(ie, "input", () => {
    if (B.signatures)
      return bscript$8.compile([OPS$5.OP_0].concat(B.signatures));
  }), lazy$5.prop(ie, "witness", () => {
    if (ie.input)
      return [];
  }), lazy$5.prop(ie, "name", () => {
    if (!(!ie.m || !ie.n))
      return `p2ms(${ie.m} of ${ie.n})`;
  }), z.validate) {
    if (B.output) {
      if (ae(B.output), !types_1$6.typeforce.Number(oe[0]))
        throw new TypeError("Output is invalid");
      if (!types_1$6.typeforce.Number(oe[oe.length - 2]))
        throw new TypeError("Output is invalid");
      if (oe[oe.length - 1] !== OPS$5.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (ie.m <= 0 || ie.n > 16 || ie.m > ie.n || ie.n !== oe.length - 3)
        throw new TypeError("Output is invalid");
      if (!ie.pubkeys.every((ve) => (0, types_1$6.isPoint)(ve)))
        throw new TypeError("Output is invalid");
      if (B.m !== void 0 && B.m !== ie.m) throw new TypeError("m mismatch");
      if (B.n !== void 0 && B.n !== ie.n) throw new TypeError("n mismatch");
      if (B.pubkeys && !(0, types_1$6.stacksEqual)(B.pubkeys, ie.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (B.pubkeys) {
      if (B.n !== void 0 && B.n !== B.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (ie.n = B.pubkeys.length, ie.n < ie.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (B.signatures) {
      if (B.signatures.length < ie.m)
        throw new TypeError("Not enough signatures provided");
      if (B.signatures.length > ie.m)
        throw new TypeError("Too many signatures provided");
    }
    if (B.input) {
      if (B.input[0] !== OPS$5.OP_0) throw new TypeError("Input is invalid");
      if (ie.signatures.length === 0 || !ie.signatures.every(Y))
        throw new TypeError("Input has invalid signature(s)");
      if (B.signatures && !(0, types_1$6.stacksEqual)(B.signatures, ie.signatures))
        throw new TypeError("Signature mismatch");
      if (B.m !== void 0 && B.m !== B.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(ie, B);
}
p2ms$1.p2ms = p2ms;
var p2pk$1 = {};
Object.defineProperty(p2pk$1, "__esModule", { value: !0 });
p2pk$1.p2pk = void 0;
const networks_1$5 = networks, bscript$7 = requireScript(), types_1$5 = types$4, lazy$4 = lazy$7, OPS$4 = bscript$7.OPS;
function p2pk(B, z) {
  if (!B.input && !B.output && !B.pubkey && !B.input && !B.signature)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$5.typeforce)(
    {
      network: types_1$5.typeforce.maybe(types_1$5.typeforce.Object),
      output: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer),
      pubkey: types_1$5.typeforce.maybe(types_1$5.isPoint),
      signature: types_1$5.typeforce.maybe(bscript$7.isCanonicalScriptSignature),
      input: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer)
    },
    B
  );
  const Y = lazy$4.value(() => bscript$7.decompile(B.input)), ie = { name: "p2pk", network: B.network || networks_1$5.bitcoin };
  if (lazy$4.prop(ie, "output", () => {
    if (B.pubkey)
      return bscript$7.compile([B.pubkey, OPS$4.OP_CHECKSIG]);
  }), lazy$4.prop(ie, "pubkey", () => {
    if (B.output)
      return B.output.slice(1, -1);
  }), lazy$4.prop(ie, "signature", () => {
    if (B.input)
      return Y()[0];
  }), lazy$4.prop(ie, "input", () => {
    if (B.signature)
      return bscript$7.compile([B.signature]);
  }), lazy$4.prop(ie, "witness", () => {
    if (ie.input)
      return [];
  }), z.validate) {
    if (B.output) {
      if (B.output[B.output.length - 1] !== OPS$4.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!(0, types_1$5.isPoint)(ie.pubkey))
        throw new TypeError("Output pubkey is invalid");
      if (B.pubkey && !B.pubkey.equals(ie.pubkey))
        throw new TypeError("Pubkey mismatch");
    }
    if (B.signature && B.input && !B.input.equals(ie.input))
      throw new TypeError("Signature mismatch");
    if (B.input) {
      if (Y().length !== 1) throw new TypeError("Input is invalid");
      if (!bscript$7.isCanonicalScriptSignature(ie.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(ie, B);
}
p2pk$1.p2pk = p2pk;
var p2pkh$1 = {}, crypto$1 = {}, ripemd160 = {};
Object.defineProperty(ripemd160, "__esModule", { value: !0 });
ripemd160.ripemd160 = ripemd160.RIPEMD160 = void 0;
const _md_js_1$1 = _md, utils_js_1$1 = utils$p, Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((B, z) => z)), Pi = /* @__PURE__ */ Id.map((B) => (9 * B + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let B = 0; B < 4; B++)
  for (let z of [idxL, idxR])
    z.push(z[B].map((Y) => Rho[Y]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((B) => new Uint8Array(B)), shiftsL = /* @__PURE__ */ idxL.map((B, z) => B.map((Y) => shifts[z][Y])), shiftsR = /* @__PURE__ */ idxR.map((B, z) => B.map((Y) => shifts[z][Y])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f(B, z, Y, ne) {
  return B === 0 ? z ^ Y ^ ne : B === 1 ? z & Y | ~z & ne : B === 2 ? (z | ~Y) ^ ne : B === 3 ? z & ne | Y & ~ne : z ^ (Y | ~ne);
}
const R_BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_js_1$1.HashMD {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: z, h1: Y, h2: ne, h3: ie, h4: oe } = this;
    return [z, Y, ne, ie, oe];
  }
  set(z, Y, ne, ie, oe) {
    this.h0 = z | 0, this.h1 = Y | 0, this.h2 = ne | 0, this.h3 = ie | 0, this.h4 = oe | 0;
  }
  process(z, Y) {
    for (let Ce = 0; Ce < 16; Ce++, Y += 4)
      R_BUF[Ce] = z.getUint32(Y, !0);
    let ne = this.h0 | 0, ie = ne, oe = this.h1 | 0, se = oe, ae = this.h2 | 0, ve = ae, Pe = this.h3 | 0, le = Pe, Ee = this.h4 | 0, Je = Ee;
    for (let Ce = 0; Ce < 5; Ce++) {
      const _t = 4 - Ce, kt = Kl[Ce], Ct = Kr[Ce], Lt = idxL[Ce], Pt = idxR[Ce], Ft = shiftsL[Ce], Ut = shiftsR[Ce];
      for (let Jt = 0; Jt < 16; Jt++) {
        const Vt = (0, utils_js_1$1.rotl)(ne + f(Ce, oe, ae, Pe) + R_BUF[Lt[Jt]] + kt, Ft[Jt]) + Ee | 0;
        ne = Ee, Ee = Pe, Pe = (0, utils_js_1$1.rotl)(ae, 10) | 0, ae = oe, oe = Vt;
      }
      for (let Jt = 0; Jt < 16; Jt++) {
        const Vt = (0, utils_js_1$1.rotl)(ie + f(_t, se, ve, le) + R_BUF[Pt[Jt]] + Ct, Ut[Jt]) + Je | 0;
        ie = Je, Je = le, le = (0, utils_js_1$1.rotl)(ve, 10) | 0, ve = se, se = Vt;
      }
    }
    this.set(this.h1 + ae + le | 0, this.h2 + Pe + Je | 0, this.h3 + Ee + ie | 0, this.h4 + ne + se | 0, this.h0 + oe + ve | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
ripemd160.RIPEMD160 = RIPEMD160;
ripemd160.ripemd160 = (0, utils_js_1$1.wrapConstructor)(() => new RIPEMD160());
var sha1 = {};
Object.defineProperty(sha1, "__esModule", { value: !0 });
sha1.sha1 = sha1.SHA1 = void 0;
const _md_js_1 = _md, utils_js_1 = utils$p, SHA1_IV = /* @__PURE__ */ new Uint32Array([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), SHA1_W = /* @__PURE__ */ new Uint32Array(80);
class SHA1 extends _md_js_1.HashMD {
  constructor() {
    super(64, 20, 8, !1), this.A = SHA1_IV[0] | 0, this.B = SHA1_IV[1] | 0, this.C = SHA1_IV[2] | 0, this.D = SHA1_IV[3] | 0, this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: z, B: Y, C: ne, D: ie, E: oe } = this;
    return [z, Y, ne, ie, oe];
  }
  set(z, Y, ne, ie, oe) {
    this.A = z | 0, this.B = Y | 0, this.C = ne | 0, this.D = ie | 0, this.E = oe | 0;
  }
  process(z, Y) {
    for (let ve = 0; ve < 16; ve++, Y += 4)
      SHA1_W[ve] = z.getUint32(Y, !1);
    for (let ve = 16; ve < 80; ve++)
      SHA1_W[ve] = (0, utils_js_1.rotl)(SHA1_W[ve - 3] ^ SHA1_W[ve - 8] ^ SHA1_W[ve - 14] ^ SHA1_W[ve - 16], 1);
    let { A: ne, B: ie, C: oe, D: se, E: ae } = this;
    for (let ve = 0; ve < 80; ve++) {
      let Pe, le;
      ve < 20 ? (Pe = (0, _md_js_1.Chi)(ie, oe, se), le = 1518500249) : ve < 40 ? (Pe = ie ^ oe ^ se, le = 1859775393) : ve < 60 ? (Pe = (0, _md_js_1.Maj)(ie, oe, se), le = 2400959708) : (Pe = ie ^ oe ^ se, le = 3395469782);
      const Ee = (0, utils_js_1.rotl)(ne, 5) + Pe + ae + le + SHA1_W[ve] | 0;
      ae = se, se = oe, oe = (0, utils_js_1.rotl)(ie, 30), ie = ne, ne = Ee;
    }
    ne = ne + this.A | 0, ie = ie + this.B | 0, oe = oe + this.C | 0, se = se + this.D | 0, ae = ae + this.E | 0, this.set(ne, ie, oe, se, ae);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha1.SHA1 = SHA1;
sha1.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.taggedHash = B.TAGGED_HASH_PREFIXES = B.TAGS = B.hash256 = B.hash160 = B.sha256 = B.sha1 = B.ripemd160 = void 0;
  const z = ripemd160, Y = sha1, ne = sha256$4;
  function ie(le) {
    return Buffer$D.from((0, z.ripemd160)(Uint8Array.from(le)));
  }
  B.ripemd160 = ie;
  function oe(le) {
    return Buffer$D.from((0, Y.sha1)(Uint8Array.from(le)));
  }
  B.sha1 = oe;
  function se(le) {
    return Buffer$D.from((0, ne.sha256)(Uint8Array.from(le)));
  }
  B.sha256 = se;
  function ae(le) {
    return Buffer$D.from(
      (0, z.ripemd160)((0, ne.sha256)(Uint8Array.from(le)))
    );
  }
  B.hash160 = ae;
  function ve(le) {
    return Buffer$D.from(
      (0, ne.sha256)((0, ne.sha256)(Uint8Array.from(le)))
    );
  }
  B.hash256 = ve, B.TAGS = [
    "BIP0340/challenge",
    "BIP0340/aux",
    "BIP0340/nonce",
    "TapLeaf",
    "TapBranch",
    "TapSighash",
    "TapTweak",
    "KeyAgg list",
    "KeyAgg coefficient"
  ], B.TAGGED_HASH_PREFIXES = {
    "BIP0340/challenge": Buffer$D.from([
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124,
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124
    ]),
    "BIP0340/aux": Buffer$D.from([
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144,
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144
    ]),
    "BIP0340/nonce": Buffer$D.from([
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47,
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47
    ]),
    TapLeaf: Buffer$D.from([
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238,
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238
    ]),
    TapBranch: Buffer$D.from([
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21,
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21
    ]),
    TapSighash: Buffer$D.from([
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49,
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49
    ]),
    TapTweak: Buffer$D.from([
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233,
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233
    ]),
    "KeyAgg list": Buffer$D.from([
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240,
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240
    ]),
    "KeyAgg coefficient": Buffer$D.from([
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129,
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129
    ])
  };
  function Pe(le, Ee) {
    return se(Buffer$D.concat([B.TAGGED_HASH_PREFIXES[le], Ee]));
  }
  B.taggedHash = Pe;
})(crypto$1);
function base$1(B) {
  if (B.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var z = new Uint8Array(256), Y = 0; Y < z.length; Y++)
    z[Y] = 255;
  for (var ne = 0; ne < B.length; ne++) {
    var ie = B.charAt(ne), oe = ie.charCodeAt(0);
    if (z[oe] !== 255)
      throw new TypeError(ie + " is ambiguous");
    z[oe] = ne;
  }
  var se = B.length, ae = B.charAt(0), ve = Math.log(se) / Math.log(256), Pe = Math.log(256) / Math.log(se);
  function le(Ce) {
    if (Ce instanceof Uint8Array || (ArrayBuffer.isView(Ce) ? Ce = new Uint8Array(Ce.buffer, Ce.byteOffset, Ce.byteLength) : Array.isArray(Ce) && (Ce = Uint8Array.from(Ce))), !(Ce instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Ce.length === 0)
      return "";
    for (var _t = 0, kt = 0, Ct = 0, Lt = Ce.length; Ct !== Lt && Ce[Ct] === 0; )
      Ct++, _t++;
    for (var Pt = (Lt - Ct) * Pe + 1 >>> 0, Ft = new Uint8Array(Pt); Ct !== Lt; ) {
      for (var Ut = Ce[Ct], Jt = 0, Vt = Pt - 1; (Ut !== 0 || Jt < kt) && Vt !== -1; Vt--, Jt++)
        Ut += 256 * Ft[Vt] >>> 0, Ft[Vt] = Ut % se >>> 0, Ut = Ut / se >>> 0;
      if (Ut !== 0)
        throw new Error("Non-zero carry");
      kt = Jt, Ct++;
    }
    for (var ir = Pt - kt; ir !== Pt && Ft[ir] === 0; )
      ir++;
    for (var jt = ae.repeat(_t); ir < Pt; ++ir)
      jt += B.charAt(Ft[ir]);
    return jt;
  }
  function Ee(Ce) {
    if (typeof Ce != "string")
      throw new TypeError("Expected String");
    if (Ce.length === 0)
      return new Uint8Array();
    for (var _t = 0, kt = 0, Ct = 0; Ce[_t] === ae; )
      kt++, _t++;
    for (var Lt = (Ce.length - _t) * ve + 1 >>> 0, Pt = new Uint8Array(Lt); Ce[_t]; ) {
      var Ft = z[Ce.charCodeAt(_t)];
      if (Ft === 255)
        return;
      for (var Ut = 0, Jt = Lt - 1; (Ft !== 0 || Ut < Ct) && Jt !== -1; Jt--, Ut++)
        Ft += se * Pt[Jt] >>> 0, Pt[Jt] = Ft % 256 >>> 0, Ft = Ft / 256 >>> 0;
      if (Ft !== 0)
        throw new Error("Non-zero carry");
      Ct = Ut, _t++;
    }
    for (var Vt = Lt - Ct; Vt !== Lt && Pt[Vt] === 0; )
      Vt++;
    for (var ir = new Uint8Array(kt + (Lt - Vt)), jt = kt; Vt !== Lt; )
      ir[jt++] = Pt[Vt++];
    return ir;
  }
  function Je(Ce) {
    var _t = Ee(Ce);
    if (_t)
      return _t;
    throw new Error("Non-base" + se + " character");
  }
  return {
    encode: le,
    decodeUnsafe: Ee,
    decode: Je
  };
}
var src = base$1;
const basex = src, ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET$1), base58 = bs58, base = function(B) {
  function z(oe) {
    var se = Uint8Array.from(oe), ae = B(se), ve = se.length + 4, Pe = new Uint8Array(ve);
    return Pe.set(se, 0), Pe.set(ae.subarray(0, 4), se.length), base58.encode(Pe, ve);
  }
  function Y(oe) {
    var se = oe.slice(0, -4), ae = oe.slice(-4), ve = B(se);
    if (!(ae[0] ^ ve[0] | ae[1] ^ ve[1] | ae[2] ^ ve[2] | ae[3] ^ ve[3]))
      return se;
  }
  function ne(oe) {
    var se = base58.decodeUnsafe(oe);
    if (se)
      return Y(se);
  }
  function ie(oe) {
    var se = base58.decode(oe), ae = Y(se);
    if (!ae) throw new Error("Invalid checksum");
    return ae;
  }
  return {
    encode: z,
    decode: ie,
    decodeUnsafe: ne
  };
}, { sha256 } = sha256$4, bs58checkBase = base;
function sha256x2(B) {
  return sha256(sha256(B));
}
var bs58check$2 = bs58checkBase(sha256x2);
Object.defineProperty(p2pkh$1, "__esModule", { value: !0 });
p2pkh$1.p2pkh = void 0;
const bcrypto$5 = crypto$1, networks_1$4 = networks, bscript$6 = requireScript(), types_1$4 = types$4, lazy$3 = lazy$7, bs58check$1 = bs58check$2, OPS$3 = bscript$6.OPS;
function p2pkh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.pubkey && !B.input)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$4.typeforce)(
    {
      network: types_1$4.typeforce.maybe(types_1$4.typeforce.Object),
      address: types_1$4.typeforce.maybe(types_1$4.typeforce.String),
      hash: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(20)),
      output: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(25)),
      pubkey: types_1$4.typeforce.maybe(types_1$4.isPoint),
      signature: types_1$4.typeforce.maybe(bscript$6.isCanonicalScriptSignature),
      input: types_1$4.typeforce.maybe(types_1$4.typeforce.Buffer)
    },
    B
  );
  const Y = lazy$3.value(() => {
    const se = Buffer$D.from(bs58check$1.decode(B.address)), ae = se.readUInt8(0), ve = se.slice(1);
    return { version: ae, hash: ve };
  }), ne = lazy$3.value(() => bscript$6.decompile(B.input)), ie = B.network || networks_1$4.bitcoin, oe = { name: "p2pkh", network: ie };
  if (lazy$3.prop(oe, "address", () => {
    if (!oe.hash) return;
    const se = Buffer$D.allocUnsafe(21);
    return se.writeUInt8(ie.pubKeyHash, 0), oe.hash.copy(se, 1), bs58check$1.encode(se);
  }), lazy$3.prop(oe, "hash", () => {
    if (B.output) return B.output.slice(3, 23);
    if (B.address) return Y().hash;
    if (B.pubkey || oe.pubkey) return bcrypto$5.hash160(B.pubkey || oe.pubkey);
  }), lazy$3.prop(oe, "output", () => {
    if (oe.hash)
      return bscript$6.compile([
        OPS$3.OP_DUP,
        OPS$3.OP_HASH160,
        oe.hash,
        OPS$3.OP_EQUALVERIFY,
        OPS$3.OP_CHECKSIG
      ]);
  }), lazy$3.prop(oe, "pubkey", () => {
    if (B.input)
      return ne()[1];
  }), lazy$3.prop(oe, "signature", () => {
    if (B.input)
      return ne()[0];
  }), lazy$3.prop(oe, "input", () => {
    if (B.pubkey && B.signature)
      return bscript$6.compile([B.signature, B.pubkey]);
  }), lazy$3.prop(oe, "witness", () => {
    if (oe.input)
      return [];
  }), z.validate) {
    let se = Buffer$D.from([]);
    if (B.address) {
      if (Y().version !== ie.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (Y().hash.length !== 20) throw new TypeError("Invalid address");
      se = Y().hash;
    }
    if (B.hash) {
      if (se.length > 0 && !se.equals(B.hash))
        throw new TypeError("Hash mismatch");
      se = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 25 || B.output[0] !== OPS$3.OP_DUP || B.output[1] !== OPS$3.OP_HASH160 || B.output[2] !== 20 || B.output[23] !== OPS$3.OP_EQUALVERIFY || B.output[24] !== OPS$3.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const ae = B.output.slice(3, 23);
      if (se.length > 0 && !se.equals(ae))
        throw new TypeError("Hash mismatch");
      se = ae;
    }
    if (B.pubkey) {
      const ae = bcrypto$5.hash160(B.pubkey);
      if (se.length > 0 && !se.equals(ae))
        throw new TypeError("Hash mismatch");
      se = ae;
    }
    if (B.input) {
      const ae = ne();
      if (ae.length !== 2) throw new TypeError("Input is invalid");
      if (!bscript$6.isCanonicalScriptSignature(ae[0]))
        throw new TypeError("Input has invalid signature");
      if (!(0, types_1$4.isPoint)(ae[1]))
        throw new TypeError("Input has invalid pubkey");
      if (B.signature && !B.signature.equals(ae[0]))
        throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(ae[1]))
        throw new TypeError("Pubkey mismatch");
      const ve = bcrypto$5.hash160(ae[1]);
      if (se.length > 0 && !se.equals(ve))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(oe, B);
}
p2pkh$1.p2pkh = p2pkh;
var p2sh$1 = {};
Object.defineProperty(p2sh$1, "__esModule", { value: !0 });
p2sh$1.p2sh = void 0;
const bcrypto$4 = crypto$1, networks_1$3 = networks, bscript$5 = requireScript(), types_1$3 = types$4, lazy$2 = lazy$7, bs58check = bs58check$2, OPS$2 = bscript$5.OPS;
function p2sh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.redeem && !B.input)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$3.typeforce)(
    {
      network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
      address: types_1$3.typeforce.maybe(types_1$3.typeforce.String),
      hash: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(20)),
      output: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(23)),
      redeem: types_1$3.typeforce.maybe({
        network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
        output: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        witness: types_1$3.typeforce.maybe(
          types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
        )
      }),
      input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
      witness: types_1$3.typeforce.maybe(
        types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
      )
    },
    B
  );
  let Y = B.network;
  Y || (Y = B.redeem && B.redeem.network || networks_1$3.bitcoin);
  const ne = { network: Y }, ie = lazy$2.value(() => {
    const ae = Buffer$D.from(bs58check.decode(B.address)), ve = ae.readUInt8(0), Pe = ae.slice(1);
    return { version: ve, hash: Pe };
  }), oe = lazy$2.value(() => bscript$5.decompile(B.input)), se = lazy$2.value(() => {
    const ae = oe(), ve = ae[ae.length - 1];
    return {
      network: Y,
      output: ve === OPS$2.OP_FALSE ? Buffer$D.from([]) : ve,
      input: bscript$5.compile(ae.slice(0, -1)),
      witness: B.witness || []
    };
  });
  if (lazy$2.prop(ne, "address", () => {
    if (!ne.hash) return;
    const ae = Buffer$D.allocUnsafe(21);
    return ae.writeUInt8(ne.network.scriptHash, 0), ne.hash.copy(ae, 1), bs58check.encode(ae);
  }), lazy$2.prop(ne, "hash", () => {
    if (B.output) return B.output.slice(2, 22);
    if (B.address) return ie().hash;
    if (ne.redeem && ne.redeem.output) return bcrypto$4.hash160(ne.redeem.output);
  }), lazy$2.prop(ne, "output", () => {
    if (ne.hash)
      return bscript$5.compile([OPS$2.OP_HASH160, ne.hash, OPS$2.OP_EQUAL]);
  }), lazy$2.prop(ne, "redeem", () => {
    if (B.input)
      return se();
  }), lazy$2.prop(ne, "input", () => {
    if (!(!B.redeem || !B.redeem.input || !B.redeem.output))
      return bscript$5.compile(
        [].concat(bscript$5.decompile(B.redeem.input), B.redeem.output)
      );
  }), lazy$2.prop(ne, "witness", () => {
    if (ne.redeem && ne.redeem.witness) return ne.redeem.witness;
    if (ne.input) return [];
  }), lazy$2.prop(ne, "name", () => {
    const ae = ["p2sh"];
    return ne.redeem !== void 0 && ne.redeem.name !== void 0 && ae.push(ne.redeem.name), ae.join("-");
  }), z.validate) {
    let ae = Buffer$D.from([]);
    if (B.address) {
      if (ie().version !== Y.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (ie().hash.length !== 20) throw new TypeError("Invalid address");
      ae = ie().hash;
    }
    if (B.hash) {
      if (ae.length > 0 && !ae.equals(B.hash))
        throw new TypeError("Hash mismatch");
      ae = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 23 || B.output[0] !== OPS$2.OP_HASH160 || B.output[1] !== 20 || B.output[22] !== OPS$2.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const Pe = B.output.slice(2, 22);
      if (ae.length > 0 && !ae.equals(Pe))
        throw new TypeError("Hash mismatch");
      ae = Pe;
    }
    const ve = (Pe) => {
      if (Pe.output) {
        const le = bscript$5.decompile(Pe.output);
        if (!le || le.length < 1)
          throw new TypeError("Redeem.output too short");
        if (Pe.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (bscript$5.countNonPushOnlyOPs(le) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const Ee = bcrypto$4.hash160(Pe.output);
        if (ae.length > 0 && !ae.equals(Ee))
          throw new TypeError("Hash mismatch");
        ae = Ee;
      }
      if (Pe.input) {
        const le = Pe.input.length > 0, Ee = Pe.witness && Pe.witness.length > 0;
        if (!le && !Ee) throw new TypeError("Empty input");
        if (le && Ee)
          throw new TypeError("Input and witness provided");
        if (le) {
          const Je = bscript$5.decompile(Pe.input);
          if (!bscript$5.isPushOnly(Je))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (B.input) {
      const Pe = oe();
      if (!Pe || Pe.length < 1) throw new TypeError("Input too short");
      if (!Buffer$D.isBuffer(se().output))
        throw new TypeError("Input is invalid");
      ve(se());
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== Y)
        throw new TypeError("Network mismatch");
      if (B.input) {
        const Pe = se();
        if (B.redeem.output && !B.redeem.output.equals(Pe.output))
          throw new TypeError("Redeem.output mismatch");
        if (B.redeem.input && !B.redeem.input.equals(Pe.input))
          throw new TypeError("Redeem.input mismatch");
      }
      ve(B.redeem);
    }
    if (B.witness && B.redeem && B.redeem.witness && !(0, types_1$3.stacksEqual)(B.redeem.witness, B.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(ne, B);
}
p2sh$1.p2sh = p2sh;
var p2wpkh$1 = {}, dist = {};
Object.defineProperty(dist, "__esModule", { value: !0 });
dist.bech32m = dist.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let B = 0; B < ALPHABET.length; B++) {
  const z = ALPHABET.charAt(B);
  ALPHABET_MAP[z] = B;
}
function polymodStep(B) {
  const z = B >> 25;
  return (B & 33554431) << 5 ^ -(z >> 0 & 1) & 996825010 ^ -(z >> 1 & 1) & 642813549 ^ -(z >> 2 & 1) & 513874426 ^ -(z >> 3 & 1) & 1027748829 ^ -(z >> 4 & 1) & 705979059;
}
function prefixChk(B) {
  let z = 1;
  for (let Y = 0; Y < B.length; ++Y) {
    const ne = B.charCodeAt(Y);
    if (ne < 33 || ne > 126)
      return "Invalid prefix (" + B + ")";
    z = polymodStep(z) ^ ne >> 5;
  }
  z = polymodStep(z);
  for (let Y = 0; Y < B.length; ++Y) {
    const ne = B.charCodeAt(Y);
    z = polymodStep(z) ^ ne & 31;
  }
  return z;
}
function convert$2(B, z, Y, ne) {
  let ie = 0, oe = 0;
  const se = (1 << Y) - 1, ae = [];
  for (let ve = 0; ve < B.length; ++ve)
    for (ie = ie << z | B[ve], oe += z; oe >= Y; )
      oe -= Y, ae.push(ie >> oe & se);
  if (ne)
    oe > 0 && ae.push(ie << Y - oe & se);
  else {
    if (oe >= z)
      return "Excess padding";
    if (ie << Y - oe & se)
      return "Non-zero padding";
  }
  return ae;
}
function toWords(B) {
  return convert$2(B, 8, 5, !0);
}
function fromWordsUnsafe(B) {
  const z = convert$2(B, 5, 8, !1);
  if (Array.isArray(z))
    return z;
}
function fromWords(B) {
  const z = convert$2(B, 5, 8, !1);
  if (Array.isArray(z))
    return z;
  throw new Error(z);
}
function getLibraryFromEncoding(B) {
  let z;
  B === "bech32" ? z = 1 : z = 734539939;
  function Y(se, ae, ve) {
    if (ve = ve || 90, se.length + 7 + ae.length > ve)
      throw new TypeError("Exceeds length limit");
    se = se.toLowerCase();
    let Pe = prefixChk(se);
    if (typeof Pe == "string")
      throw new Error(Pe);
    let le = se + "1";
    for (let Ee = 0; Ee < ae.length; ++Ee) {
      const Je = ae[Ee];
      if (Je >> 5)
        throw new Error("Non 5-bit word");
      Pe = polymodStep(Pe) ^ Je, le += ALPHABET.charAt(Je);
    }
    for (let Ee = 0; Ee < 6; ++Ee)
      Pe = polymodStep(Pe);
    Pe ^= z;
    for (let Ee = 0; Ee < 6; ++Ee) {
      const Je = Pe >> (5 - Ee) * 5 & 31;
      le += ALPHABET.charAt(Je);
    }
    return le;
  }
  function ne(se, ae) {
    if (ae = ae || 90, se.length < 8)
      return se + " too short";
    if (se.length > ae)
      return "Exceeds length limit";
    const ve = se.toLowerCase(), Pe = se.toUpperCase();
    if (se !== ve && se !== Pe)
      return "Mixed-case string " + se;
    se = ve;
    const le = se.lastIndexOf("1");
    if (le === -1)
      return "No separator character for " + se;
    if (le === 0)
      return "Missing prefix for " + se;
    const Ee = se.slice(0, le), Je = se.slice(le + 1);
    if (Je.length < 6)
      return "Data too short";
    let Ce = prefixChk(Ee);
    if (typeof Ce == "string")
      return Ce;
    const _t = [];
    for (let kt = 0; kt < Je.length; ++kt) {
      const Ct = Je.charAt(kt), Lt = ALPHABET_MAP[Ct];
      if (Lt === void 0)
        return "Unknown character " + Ct;
      Ce = polymodStep(Ce) ^ Lt, !(kt + 6 >= Je.length) && _t.push(Lt);
    }
    return Ce !== z ? "Invalid checksum for " + se : { prefix: Ee, words: _t };
  }
  function ie(se, ae) {
    const ve = ne(se, ae);
    if (typeof ve == "object")
      return ve;
  }
  function oe(se, ae) {
    const ve = ne(se, ae);
    if (typeof ve == "object")
      return ve;
    throw new Error(ve);
  }
  return {
    decodeUnsafe: ie,
    decode: oe,
    encode: Y,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
dist.bech32 = getLibraryFromEncoding("bech32");
dist.bech32m = getLibraryFromEncoding("bech32m");
Object.defineProperty(p2wpkh$1, "__esModule", { value: !0 });
p2wpkh$1.p2wpkh = void 0;
const bcrypto$3 = crypto$1, networks_1$2 = networks, bscript$4 = requireScript(), types_1$2 = types$4, lazy$1 = lazy$7, bech32_1$1 = dist, OPS$1 = bscript$4.OPS, EMPTY_BUFFER$2 = Buffer$D.alloc(0);
function p2wpkh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.pubkey && !B.witness)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$2.typeforce)(
    {
      address: types_1$2.typeforce.maybe(types_1$2.typeforce.String),
      hash: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(20)),
      input: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(0)),
      network: types_1$2.typeforce.maybe(types_1$2.typeforce.Object),
      output: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(22)),
      pubkey: types_1$2.typeforce.maybe(types_1$2.isPoint),
      signature: types_1$2.typeforce.maybe(bscript$4.isCanonicalScriptSignature),
      witness: types_1$2.typeforce.maybe(
        types_1$2.typeforce.arrayOf(types_1$2.typeforce.Buffer)
      )
    },
    B
  );
  const Y = lazy$1.value(() => {
    const oe = bech32_1$1.bech32.decode(B.address), se = oe.words.shift(), ae = bech32_1$1.bech32.fromWords(oe.words);
    return {
      version: se,
      prefix: oe.prefix,
      data: Buffer$D.from(ae)
    };
  }), ne = B.network || networks_1$2.bitcoin, ie = { name: "p2wpkh", network: ne };
  if (lazy$1.prop(ie, "address", () => {
    if (!ie.hash) return;
    const oe = bech32_1$1.bech32.toWords(ie.hash);
    return oe.unshift(0), bech32_1$1.bech32.encode(ne.bech32, oe);
  }), lazy$1.prop(ie, "hash", () => {
    if (B.output) return B.output.slice(2, 22);
    if (B.address) return Y().data;
    if (B.pubkey || ie.pubkey) return bcrypto$3.hash160(B.pubkey || ie.pubkey);
  }), lazy$1.prop(ie, "output", () => {
    if (ie.hash)
      return bscript$4.compile([OPS$1.OP_0, ie.hash]);
  }), lazy$1.prop(ie, "pubkey", () => {
    if (B.pubkey) return B.pubkey;
    if (B.witness)
      return B.witness[1];
  }), lazy$1.prop(ie, "signature", () => {
    if (B.witness)
      return B.witness[0];
  }), lazy$1.prop(ie, "input", () => {
    if (ie.witness)
      return EMPTY_BUFFER$2;
  }), lazy$1.prop(ie, "witness", () => {
    if (B.pubkey && B.signature)
      return [B.signature, B.pubkey];
  }), z.validate) {
    let oe = Buffer$D.from([]);
    if (B.address) {
      if (ne && ne.bech32 !== Y().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (Y().version !== 0)
        throw new TypeError("Invalid address version");
      if (Y().data.length !== 20)
        throw new TypeError("Invalid address data");
      oe = Y().data;
    }
    if (B.hash) {
      if (oe.length > 0 && !oe.equals(B.hash))
        throw new TypeError("Hash mismatch");
      oe = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 22 || B.output[0] !== OPS$1.OP_0 || B.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (oe.length > 0 && !oe.equals(B.output.slice(2)))
        throw new TypeError("Hash mismatch");
      oe = B.output.slice(2);
    }
    if (B.pubkey) {
      const se = bcrypto$3.hash160(B.pubkey);
      if (oe.length > 0 && !oe.equals(se))
        throw new TypeError("Hash mismatch");
      if (oe = se, !(0, types_1$2.isPoint)(B.pubkey) || B.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (B.witness) {
      if (B.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!bscript$4.isCanonicalScriptSignature(B.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!(0, types_1$2.isPoint)(B.witness[1]) || B.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (B.signature && !B.signature.equals(B.witness[0]))
        throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(B.witness[1]))
        throw new TypeError("Pubkey mismatch");
      const se = bcrypto$3.hash160(B.witness[1]);
      if (oe.length > 0 && !oe.equals(se))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(ie, B);
}
p2wpkh$1.p2wpkh = p2wpkh;
var p2wsh$1 = {};
Object.defineProperty(p2wsh$1, "__esModule", { value: !0 });
p2wsh$1.p2wsh = void 0;
const bcrypto$2 = crypto$1, networks_1$1 = networks, bscript$3 = requireScript(), types_1$1 = types$4, lazy = lazy$7, bech32_1 = dist, OPS = bscript$3.OPS, EMPTY_BUFFER$1 = Buffer$D.alloc(0);
function chunkHasUncompressedPubkey(B) {
  return !!(Buffer$D.isBuffer(B) && B.length === 65 && B[0] === 4 && (0, types_1$1.isPoint)(B));
}
function p2wsh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.redeem && !B.witness)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$1.typeforce)(
    {
      network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
      address: types_1$1.typeforce.maybe(types_1$1.typeforce.String),
      hash: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(32)),
      output: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(34)),
      redeem: types_1$1.typeforce.maybe({
        input: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
        output: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        witness: types_1$1.typeforce.maybe(
          types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
        )
      }),
      input: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(0)),
      witness: types_1$1.typeforce.maybe(
        types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
      )
    },
    B
  );
  const Y = lazy.value(() => {
    const se = bech32_1.bech32.decode(B.address), ae = se.words.shift(), ve = bech32_1.bech32.fromWords(se.words);
    return {
      version: ae,
      prefix: se.prefix,
      data: Buffer$D.from(ve)
    };
  }), ne = lazy.value(() => bscript$3.decompile(B.redeem.input));
  let ie = B.network;
  ie || (ie = B.redeem && B.redeem.network || networks_1$1.bitcoin);
  const oe = { network: ie };
  if (lazy.prop(oe, "address", () => {
    if (!oe.hash) return;
    const se = bech32_1.bech32.toWords(oe.hash);
    return se.unshift(0), bech32_1.bech32.encode(ie.bech32, se);
  }), lazy.prop(oe, "hash", () => {
    if (B.output) return B.output.slice(2);
    if (B.address) return Y().data;
    if (oe.redeem && oe.redeem.output) return bcrypto$2.sha256(oe.redeem.output);
  }), lazy.prop(oe, "output", () => {
    if (oe.hash)
      return bscript$3.compile([OPS.OP_0, oe.hash]);
  }), lazy.prop(oe, "redeem", () => {
    if (B.witness)
      return {
        output: B.witness[B.witness.length - 1],
        input: EMPTY_BUFFER$1,
        witness: B.witness.slice(0, -1)
      };
  }), lazy.prop(oe, "input", () => {
    if (oe.witness)
      return EMPTY_BUFFER$1;
  }), lazy.prop(oe, "witness", () => {
    if (B.redeem && B.redeem.input && B.redeem.input.length > 0 && B.redeem.output && B.redeem.output.length > 0) {
      const se = bscript$3.toStack(ne());
      return oe.redeem = Object.assign({ witness: se }, B.redeem), oe.redeem.input = EMPTY_BUFFER$1, [].concat(se, B.redeem.output);
    }
    if (B.redeem && B.redeem.output && B.redeem.witness)
      return [].concat(B.redeem.witness, B.redeem.output);
  }), lazy.prop(oe, "name", () => {
    const se = ["p2wsh"];
    return oe.redeem !== void 0 && oe.redeem.name !== void 0 && se.push(oe.redeem.name), se.join("-");
  }), z.validate) {
    let se = Buffer$D.from([]);
    if (B.address) {
      if (Y().prefix !== ie.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (Y().version !== 0)
        throw new TypeError("Invalid address version");
      if (Y().data.length !== 32)
        throw new TypeError("Invalid address data");
      se = Y().data;
    }
    if (B.hash) {
      if (se.length > 0 && !se.equals(B.hash))
        throw new TypeError("Hash mismatch");
      se = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 34 || B.output[0] !== OPS.OP_0 || B.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const ae = B.output.slice(2);
      if (se.length > 0 && !se.equals(ae))
        throw new TypeError("Hash mismatch");
      se = ae;
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== ie)
        throw new TypeError("Network mismatch");
      if (B.redeem.input && B.redeem.input.length > 0 && B.redeem.witness && B.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (B.redeem.output) {
        const ae = bscript$3.decompile(B.redeem.output);
        if (!ae || ae.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (B.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (bscript$3.countNonPushOnlyOPs(ae) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const ve = bcrypto$2.sha256(B.redeem.output);
        if (se.length > 0 && !se.equals(ve))
          throw new TypeError("Hash mismatch");
        se = ve;
      }
      if (B.redeem.input && !bscript$3.isPushOnly(ne()))
        throw new TypeError("Non push-only scriptSig");
      if (B.witness && B.redeem.witness && !(0, types_1$1.stacksEqual)(B.witness, B.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (B.redeem.input && ne().some(chunkHasUncompressedPubkey) || B.redeem.output && (bscript$3.decompile(B.redeem.output) || []).some(
        chunkHasUncompressedPubkey
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (B.witness && B.witness.length > 0) {
      const ae = B.witness[B.witness.length - 1];
      if (B.redeem && B.redeem.output && !B.redeem.output.equals(ae))
        throw new TypeError("Witness and redeem.output mismatch");
      if (B.witness.some(chunkHasUncompressedPubkey) || (bscript$3.decompile(ae) || []).some(chunkHasUncompressedPubkey))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(oe, B);
}
p2wsh$1.p2wsh = p2wsh;
var p2tr = {}, ecc_lib = {};
Object.defineProperty(ecc_lib, "__esModule", { value: !0 });
ecc_lib.getEccLib = ecc_lib.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(B) {
  B ? B !== _ECCLIB_CACHE.eccLib && (verifyEcc(B), _ECCLIB_CACHE.eccLib = B) : _ECCLIB_CACHE.eccLib = B;
}
ecc_lib.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return _ECCLIB_CACHE.eccLib;
}
ecc_lib.getEccLib = getEccLib;
const h = (B) => Buffer$D.from(B, "hex");
function verifyEcc(B) {
  assert(typeof B.isXOnlyPoint == "function"), assert(
    B.isXOnlyPoint(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    B.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), assert(
    B.isXOnlyPoint(
      h("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), assert(
    B.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), assert(
    !B.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), assert(
    !B.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), assert(typeof B.xOnlyPointAddTweak == "function"), tweakAddVectors.forEach((z) => {
    const Y = B.xOnlyPointAddTweak(h(z.pubkey), h(z.tweak));
    z.result === null ? assert(Y === null) : (assert(Y !== null), assert(Y.parity === z.parity), assert(Buffer$D.from(Y.xOnlyPubkey).equals(h(z.result))));
  });
}
function assert(B) {
  if (!B) throw new Error("ecc library invalid");
}
const tweakAddVectors = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];
var bip341 = {}, bufferutils = {}, Buffer = safeBufferExports$1.Buffer, MAX_SAFE_INTEGER$1 = 9007199254740991;
function checkUInt53$1(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER$1 || B % 1 !== 0) throw new RangeError("value out of range");
}
function encode$f(B, z, Y) {
  if (checkUInt53$1(B), z || (z = Buffer.allocUnsafe(encodingLength$1(B))), !Buffer.isBuffer(z)) throw new TypeError("buffer must be a Buffer instance");
  return Y || (Y = 0), B < 253 ? (z.writeUInt8(B, Y), encode$f.bytes = 1) : B <= 65535 ? (z.writeUInt8(253, Y), z.writeUInt16LE(B, Y + 1), encode$f.bytes = 3) : B <= 4294967295 ? (z.writeUInt8(254, Y), z.writeUInt32LE(B, Y + 1), encode$f.bytes = 5) : (z.writeUInt8(255, Y), z.writeUInt32LE(B >>> 0, Y + 1), z.writeUInt32LE(B / 4294967296 | 0, Y + 5), encode$f.bytes = 9), z;
}
function decode$e(B, z) {
  if (!Buffer.isBuffer(B)) throw new TypeError("buffer must be a Buffer instance");
  z || (z = 0);
  var Y = B.readUInt8(z);
  if (Y < 253)
    return decode$e.bytes = 1, Y;
  if (Y === 253)
    return decode$e.bytes = 3, B.readUInt16LE(z + 1);
  if (Y === 254)
    return decode$e.bytes = 5, B.readUInt32LE(z + 1);
  decode$e.bytes = 9;
  var ne = B.readUInt32LE(z + 1), ie = B.readUInt32LE(z + 5), oe = ie * 4294967296 + ne;
  return checkUInt53$1(oe), oe;
}
function encodingLength$1(B) {
  return checkUInt53$1(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
var varuintBitcoin = { encode: encode$f, decode: decode$e, encodingLength: encodingLength$1 };
Object.defineProperty(bufferutils, "__esModule", { value: !0 });
bufferutils.BufferReader = bufferutils.BufferWriter = bufferutils.cloneBuffer = bufferutils.reverseBuffer = bufferutils.writeUInt64LE = bufferutils.readUInt64LE = bufferutils.varuint = void 0;
const types$2 = types$4, { typeforce: typeforce$2 } = types$2, varuint$7 = varuintBitcoin;
bufferutils.varuint = varuint$7;
function verifuint$1(B, z) {
  if (typeof B != "number")
    throw new Error("cannot write a non-number as a number");
  if (B < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (B > z) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B)
    throw new Error("value has a fractional component");
}
function readUInt64LE$1(B, z) {
  const Y = B.readUInt32LE(z);
  let ne = B.readUInt32LE(z + 4);
  return ne *= 4294967296, verifuint$1(ne + Y, 9007199254740991), ne + Y;
}
bufferutils.readUInt64LE = readUInt64LE$1;
function writeUInt64LE$1(B, z, Y) {
  return verifuint$1(z, 9007199254740991), B.writeInt32LE(z & -1, Y), B.writeUInt32LE(Math.floor(z / 4294967296), Y + 4), Y + 8;
}
bufferutils.writeUInt64LE = writeUInt64LE$1;
function reverseBuffer$1(B) {
  if (B.length < 1) return B;
  let z = B.length - 1, Y = 0;
  for (let ne = 0; ne < B.length / 2; ne++)
    Y = B[ne], B[ne] = B[z], B[z] = Y, z--;
  return B;
}
bufferutils.reverseBuffer = reverseBuffer$1;
function cloneBuffer(B) {
  const z = Buffer$D.allocUnsafe(B.length);
  return B.copy(z), z;
}
bufferutils.cloneBuffer = cloneBuffer;
class BufferWriter {
  static withCapacity(z) {
    return new BufferWriter(Buffer$D.alloc(z));
  }
  constructor(z, Y = 0) {
    this.buffer = z, this.offset = Y, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [z, Y]);
  }
  writeUInt8(z) {
    this.offset = this.buffer.writeUInt8(z, this.offset);
  }
  writeInt32(z) {
    this.offset = this.buffer.writeInt32LE(z, this.offset);
  }
  writeUInt32(z) {
    this.offset = this.buffer.writeUInt32LE(z, this.offset);
  }
  writeUInt64(z) {
    this.offset = writeUInt64LE$1(this.buffer, z, this.offset);
  }
  writeVarInt(z) {
    varuint$7.encode(z, this.buffer, this.offset), this.offset += varuint$7.encode.bytes;
  }
  writeSlice(z) {
    if (this.buffer.length < this.offset + z.length)
      throw new Error("Cannot write slice out of bounds");
    this.offset += z.copy(this.buffer, this.offset);
  }
  writeVarSlice(z) {
    this.writeVarInt(z.length), this.writeSlice(z);
  }
  writeVector(z) {
    this.writeVarInt(z.length), z.forEach((Y) => this.writeVarSlice(Y));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
bufferutils.BufferWriter = BufferWriter;
class BufferReader {
  constructor(z, Y = 0) {
    this.buffer = z, this.offset = Y, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [z, Y]);
  }
  readUInt8() {
    const z = this.buffer.readUInt8(this.offset);
    return this.offset++, z;
  }
  readInt32() {
    const z = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, z;
  }
  readUInt32() {
    const z = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, z;
  }
  readUInt64() {
    const z = readUInt64LE$1(this.buffer, this.offset);
    return this.offset += 8, z;
  }
  readVarInt() {
    const z = varuint$7.decode(this.buffer, this.offset);
    return this.offset += varuint$7.decode.bytes, z;
  }
  readSlice(z) {
    if (this.buffer.length < this.offset + z)
      throw new Error("Cannot read slice out of bounds");
    const Y = this.buffer.slice(this.offset, this.offset + z);
    return this.offset += z, Y;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const z = this.readVarInt(), Y = [];
    for (let ne = 0; ne < z; ne++) Y.push(this.readVarSlice());
    return Y;
  }
}
bufferutils.BufferReader = BufferReader;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.tweakKey = B.tapTweakHash = B.tapleafHash = B.findScriptPath = B.toHashTree = B.rootHashFromPath = B.MAX_TAPTREE_DEPTH = B.LEAF_VERSION_TAPSCRIPT = void 0;
  const z = require$$0$1, Y = ecc_lib, ne = crypto$1, ie = bufferutils, oe = types$4;
  B.LEAF_VERSION_TAPSCRIPT = 192, B.MAX_TAPTREE_DEPTH = 128;
  const se = (kt) => "left" in kt && "right" in kt;
  function ae(kt, Ct) {
    if (kt.length < 33)
      throw new TypeError(
        `The control-block length is too small. Got ${kt.length}, expected min 33.`
      );
    const Lt = (kt.length - 33) / 32;
    let Pt = Ct;
    for (let Ft = 0; Ft < Lt; Ft++) {
      const Ut = kt.slice(33 + 32 * Ft, 65 + 32 * Ft);
      Pt.compare(Ut) < 0 ? Pt = Ce(Pt, Ut) : Pt = Ce(Ut, Pt);
    }
    return Pt;
  }
  B.rootHashFromPath = ae;
  function ve(kt) {
    if ((0, oe.isTapleaf)(kt))
      return { hash: le(kt) };
    const Ct = [ve(kt[0]), ve(kt[1])];
    Ct.sort((Ft, Ut) => Ft.hash.compare(Ut.hash));
    const [Lt, Pt] = Ct;
    return {
      hash: Ce(Lt.hash, Pt.hash),
      left: Lt,
      right: Pt
    };
  }
  B.toHashTree = ve;
  function Pe(kt, Ct) {
    if (se(kt)) {
      const Lt = Pe(kt.left, Ct);
      if (Lt !== void 0) return [...Lt, kt.right.hash];
      const Pt = Pe(kt.right, Ct);
      if (Pt !== void 0) return [...Pt, kt.left.hash];
    } else if (kt.hash.equals(Ct))
      return [];
  }
  B.findScriptPath = Pe;
  function le(kt) {
    const Ct = kt.version || B.LEAF_VERSION_TAPSCRIPT;
    return ne.taggedHash(
      "TapLeaf",
      z.Buffer.concat([
        z.Buffer.from([Ct]),
        _t(kt.output)
      ])
    );
  }
  B.tapleafHash = le;
  function Ee(kt, Ct) {
    return ne.taggedHash(
      "TapTweak",
      z.Buffer.concat(Ct ? [kt, Ct] : [kt])
    );
  }
  B.tapTweakHash = Ee;
  function Je(kt, Ct) {
    if (!z.Buffer.isBuffer(kt) || kt.length !== 32 || Ct && Ct.length !== 32) return null;
    const Lt = Ee(kt, Ct), Pt = (0, Y.getEccLib)().xOnlyPointAddTweak(kt, Lt);
    return !Pt || Pt.xOnlyPubkey === null ? null : {
      parity: Pt.parity,
      x: z.Buffer.from(Pt.xOnlyPubkey)
    };
  }
  B.tweakKey = Je;
  function Ce(kt, Ct) {
    return ne.taggedHash("TapBranch", z.Buffer.concat([kt, Ct]));
  }
  function _t(kt) {
    const Ct = ie.varuint.encodingLength(kt.length), Lt = z.Buffer.allocUnsafe(Ct);
    return ie.varuint.encode(kt.length, Lt), z.Buffer.concat([Lt, kt]);
  }
})(bip341);
var hasRequiredP2tr;
function requireP2tr() {
  if (hasRequiredP2tr) return p2tr;
  hasRequiredP2tr = 1, Object.defineProperty(p2tr, "__esModule", { value: !0 }), p2tr.p2tr = void 0;
  const B = require$$0$1, z = networks, Y = requireScript(), ne = types$4, ie = ecc_lib, oe = bip341, se = lazy$7, ae = dist, ve = requireAddress(), Pe = Y.OPS, le = 1, Ee = 80;
  function Je(Ce, _t) {
    if (!Ce.address && !Ce.output && !Ce.pubkey && !Ce.internalPubkey && !(Ce.witness && Ce.witness.length > 1))
      throw new TypeError("Not enough data");
    _t = Object.assign({ validate: !0 }, _t || {}), (0, ne.typeforce)(
      {
        address: ne.typeforce.maybe(ne.typeforce.String),
        input: ne.typeforce.maybe(ne.typeforce.BufferN(0)),
        network: ne.typeforce.maybe(ne.typeforce.Object),
        output: ne.typeforce.maybe(ne.typeforce.BufferN(34)),
        internalPubkey: ne.typeforce.maybe(ne.typeforce.BufferN(32)),
        hash: ne.typeforce.maybe(ne.typeforce.BufferN(32)),
        pubkey: ne.typeforce.maybe(ne.typeforce.BufferN(32)),
        signature: ne.typeforce.maybe(
          ne.typeforce.anyOf(
            ne.typeforce.BufferN(64),
            ne.typeforce.BufferN(65)
          )
        ),
        witness: ne.typeforce.maybe(
          ne.typeforce.arrayOf(ne.typeforce.Buffer)
        ),
        scriptTree: ne.typeforce.maybe(ne.isTaptree),
        redeem: ne.typeforce.maybe({
          output: ne.typeforce.maybe(ne.typeforce.Buffer),
          redeemVersion: ne.typeforce.maybe(ne.typeforce.Number),
          witness: ne.typeforce.maybe(
            ne.typeforce.arrayOf(ne.typeforce.Buffer)
          )
        }),
        redeemVersion: ne.typeforce.maybe(ne.typeforce.Number)
      },
      Ce
    );
    const kt = se.value(() => (0, ve.fromBech32)(Ce.address)), Ct = se.value(() => {
      if (!(!Ce.witness || !Ce.witness.length))
        return Ce.witness.length >= 2 && Ce.witness[Ce.witness.length - 1][0] === Ee ? Ce.witness.slice(0, -1) : Ce.witness.slice();
    }), Lt = se.value(() => {
      if (Ce.scriptTree) return (0, oe.toHashTree)(Ce.scriptTree);
      if (Ce.hash) return { hash: Ce.hash };
    }), Pt = Ce.network || z.bitcoin, Ft = { name: "p2tr", network: Pt };
    if (se.prop(Ft, "address", () => {
      if (!Ft.pubkey) return;
      const Ut = ae.bech32m.toWords(Ft.pubkey);
      return Ut.unshift(le), ae.bech32m.encode(Pt.bech32, Ut);
    }), se.prop(Ft, "hash", () => {
      const Ut = Lt();
      if (Ut) return Ut.hash;
      const Jt = Ct();
      if (Jt && Jt.length > 1) {
        const Vt = Jt[Jt.length - 1], ir = Vt[0] & ne.TAPLEAF_VERSION_MASK, jt = Jt[Jt.length - 2], Rt = (0, oe.tapleafHash)({
          output: jt,
          version: ir
        });
        return (0, oe.rootHashFromPath)(Vt, Rt);
      }
      return null;
    }), se.prop(Ft, "output", () => {
      if (Ft.pubkey)
        return Y.compile([Pe.OP_1, Ft.pubkey]);
    }), se.prop(Ft, "redeemVersion", () => Ce.redeemVersion ? Ce.redeemVersion : Ce.redeem && Ce.redeem.redeemVersion !== void 0 && Ce.redeem.redeemVersion !== null ? Ce.redeem.redeemVersion : oe.LEAF_VERSION_TAPSCRIPT), se.prop(Ft, "redeem", () => {
      const Ut = Ct();
      if (!(!Ut || Ut.length < 2))
        return {
          output: Ut[Ut.length - 2],
          witness: Ut.slice(0, -2),
          redeemVersion: Ut[Ut.length - 1][0] & ne.TAPLEAF_VERSION_MASK
        };
    }), se.prop(Ft, "pubkey", () => {
      if (Ce.pubkey) return Ce.pubkey;
      if (Ce.output) return Ce.output.slice(2);
      if (Ce.address) return kt().data;
      if (Ft.internalPubkey) {
        const Ut = (0, oe.tweakKey)(Ft.internalPubkey, Ft.hash);
        if (Ut) return Ut.x;
      }
    }), se.prop(Ft, "internalPubkey", () => {
      if (Ce.internalPubkey) return Ce.internalPubkey;
      const Ut = Ct();
      if (Ut && Ut.length > 1)
        return Ut[Ut.length - 1].slice(1, 33);
    }), se.prop(Ft, "signature", () => {
      if (Ce.signature) return Ce.signature;
      const Ut = Ct();
      if (!(!Ut || Ut.length !== 1))
        return Ut[0];
    }), se.prop(Ft, "witness", () => {
      if (Ce.witness) return Ce.witness;
      const Ut = Lt();
      if (Ut && Ce.redeem && Ce.redeem.output && Ce.internalPubkey) {
        const Jt = (0, oe.tapleafHash)({
          output: Ce.redeem.output,
          version: Ft.redeemVersion
        }), Vt = (0, oe.findScriptPath)(Ut, Jt);
        if (!Vt) return;
        const ir = (0, oe.tweakKey)(Ce.internalPubkey, Ut.hash);
        if (!ir) return;
        const jt = B.Buffer.concat(
          [
            B.Buffer.from([Ft.redeemVersion | ir.parity]),
            Ce.internalPubkey
          ].concat(Vt)
        );
        return [Ce.redeem.output, jt];
      }
      if (Ce.signature) return [Ce.signature];
    }), _t.validate) {
      let Ut = B.Buffer.from([]);
      if (Ce.address) {
        if (Pt && Pt.bech32 !== kt().prefix)
          throw new TypeError("Invalid prefix or Network mismatch");
        if (kt().version !== le)
          throw new TypeError("Invalid address version");
        if (kt().data.length !== 32)
          throw new TypeError("Invalid address data");
        Ut = kt().data;
      }
      if (Ce.pubkey) {
        if (Ut.length > 0 && !Ut.equals(Ce.pubkey))
          throw new TypeError("Pubkey mismatch");
        Ut = Ce.pubkey;
      }
      if (Ce.output) {
        if (Ce.output.length !== 34 || Ce.output[0] !== Pe.OP_1 || Ce.output[1] !== 32)
          throw new TypeError("Output is invalid");
        if (Ut.length > 0 && !Ut.equals(Ce.output.slice(2)))
          throw new TypeError("Pubkey mismatch");
        Ut = Ce.output.slice(2);
      }
      if (Ce.internalPubkey) {
        const ir = (0, oe.tweakKey)(Ce.internalPubkey, Ft.hash);
        if (Ut.length > 0 && !Ut.equals(ir.x))
          throw new TypeError("Pubkey mismatch");
        Ut = ir.x;
      }
      if (Ut && Ut.length && !(0, ie.getEccLib)().isXOnlyPoint(Ut))
        throw new TypeError("Invalid pubkey for p2tr");
      const Jt = Lt();
      if (Ce.hash && Jt && !Ce.hash.equals(Jt.hash))
        throw new TypeError("Hash mismatch");
      if (Ce.redeem && Ce.redeem.output && Jt) {
        const ir = (0, oe.tapleafHash)({
          output: Ce.redeem.output,
          version: Ft.redeemVersion
        });
        if (!(0, oe.findScriptPath)(Jt, ir))
          throw new TypeError("Redeem script not in tree");
      }
      const Vt = Ct();
      if (Ce.redeem && Ft.redeem) {
        if (Ce.redeem.redeemVersion && Ce.redeem.redeemVersion !== Ft.redeem.redeemVersion)
          throw new TypeError("Redeem.redeemVersion and witness mismatch");
        if (Ce.redeem.output) {
          if (Y.decompile(Ce.redeem.output).length === 0)
            throw new TypeError("Redeem.output is invalid");
          if (Ft.redeem.output && !Ce.redeem.output.equals(Ft.redeem.output))
            throw new TypeError("Redeem.output and witness mismatch");
        }
        if (Ce.redeem.witness && Ft.redeem.witness && !(0, ne.stacksEqual)(Ce.redeem.witness, Ft.redeem.witness))
          throw new TypeError("Redeem.witness and witness mismatch");
      }
      if (Vt && Vt.length)
        if (Vt.length === 1) {
          if (Ce.signature && !Ce.signature.equals(Vt[0]))
            throw new TypeError("Signature mismatch");
        } else {
          const ir = Vt[Vt.length - 1];
          if (ir.length < 33)
            throw new TypeError(
              `The control-block length is too small. Got ${ir.length}, expected min 33.`
            );
          if ((ir.length - 33) % 32 !== 0)
            throw new TypeError(
              `The control-block length of ${ir.length} is incorrect!`
            );
          const jt = (ir.length - 33) / 32;
          if (jt > 128)
            throw new TypeError(
              `The script path is too long. Got ${jt}, expected max 128.`
            );
          const Rt = ir.slice(1, 33);
          if (Ce.internalPubkey && !Ce.internalPubkey.equals(Rt))
            throw new TypeError("Internal pubkey mismatch");
          if (!(0, ie.getEccLib)().isXOnlyPoint(Rt))
            throw new TypeError("Invalid internalPubkey for p2tr witness");
          const Kt = ir[0] & ne.TAPLEAF_VERSION_MASK, Bt = Vt[Vt.length - 2], Xe = (0, oe.tapleafHash)({
            output: Bt,
            version: Kt
          }), Ve = (0, oe.rootHashFromPath)(ir, Xe), ge = (0, oe.tweakKey)(Rt, Ve);
          if (!ge)
            throw new TypeError("Invalid outputKey for p2tr witness");
          if (Ut.length && !Ut.equals(ge.x))
            throw new TypeError("Pubkey mismatch for p2tr witness");
          if (ge.parity !== (ir[0] & 1))
            throw new Error("Incorrect parity");
        }
    }
    return Object.assign(Ft, Ce);
  }
  return p2tr.p2tr = Je, p2tr;
}
var hasRequiredPayments;
function requirePayments() {
  return hasRequiredPayments || (hasRequiredPayments = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.p2tr = B.p2wsh = B.p2wpkh = B.p2sh = B.p2pkh = B.p2pk = B.p2ms = B.embed = void 0;
    const z = embed;
    Object.defineProperty(B, "embed", {
      enumerable: !0,
      get: function() {
        return z.p2data;
      }
    });
    const Y = p2ms$1;
    Object.defineProperty(B, "p2ms", {
      enumerable: !0,
      get: function() {
        return Y.p2ms;
      }
    });
    const ne = p2pk$1;
    Object.defineProperty(B, "p2pk", {
      enumerable: !0,
      get: function() {
        return ne.p2pk;
      }
    });
    const ie = p2pkh$1;
    Object.defineProperty(B, "p2pkh", {
      enumerable: !0,
      get: function() {
        return ie.p2pkh;
      }
    });
    const oe = p2sh$1;
    Object.defineProperty(B, "p2sh", {
      enumerable: !0,
      get: function() {
        return oe.p2sh;
      }
    });
    const se = p2wpkh$1;
    Object.defineProperty(B, "p2wpkh", {
      enumerable: !0,
      get: function() {
        return se.p2wpkh;
      }
    });
    const ae = p2wsh$1;
    Object.defineProperty(B, "p2wsh", {
      enumerable: !0,
      get: function() {
        return ae.p2wsh;
      }
    });
    const ve = requireP2tr();
    Object.defineProperty(B, "p2tr", {
      enumerable: !0,
      get: function() {
        return ve.p2tr;
      }
    });
  }(payments$2)), payments$2;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return address;
  hasRequiredAddress = 1, Object.defineProperty(address, "__esModule", { value: !0 }), address.toOutputScript = address.fromOutputScript = address.toBech32 = address.toBase58Check = address.fromBech32 = address.fromBase58Check = void 0;
  const B = networks, z = requirePayments(), Y = requireScript(), ne = types$4, ie = dist, oe = bs58check$2, se = 40, ae = 2, ve = 16, Pe = 2, le = 80, Ee = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
  function Je(Ft, Ut) {
    const Jt = Ft.slice(2);
    if (Jt.length < ae || Jt.length > se)
      throw new TypeError("Invalid program length for segwit address");
    const Vt = Ft[0] - le;
    if (Vt < Pe || Vt > ve)
      throw new TypeError("Invalid version for segwit address");
    if (Ft[1] !== Jt.length)
      throw new TypeError("Invalid script for segwit address");
    return console.warn(Ee), Ct(Jt, Vt, Ut.bech32);
  }
  function Ce(Ft) {
    const Ut = Buffer$D.from(oe.decode(Ft));
    if (Ut.length < 21) throw new TypeError(Ft + " is too short");
    if (Ut.length > 21) throw new TypeError(Ft + " is too long");
    const Jt = Ut.readUInt8(0), Vt = Ut.slice(1);
    return { version: Jt, hash: Vt };
  }
  address.fromBase58Check = Ce;
  function _t(Ft) {
    let Ut, Jt;
    try {
      Ut = ie.bech32.decode(Ft);
    } catch {
    }
    if (Ut) {
      if (Jt = Ut.words[0], Jt !== 0) throw new TypeError(Ft + " uses wrong encoding");
    } else if (Ut = ie.bech32m.decode(Ft), Jt = Ut.words[0], Jt === 0) throw new TypeError(Ft + " uses wrong encoding");
    const Vt = ie.bech32.fromWords(Ut.words.slice(1));
    return {
      version: Jt,
      prefix: Ut.prefix,
      data: Buffer$D.from(Vt)
    };
  }
  address.fromBech32 = _t;
  function kt(Ft, Ut) {
    (0, ne.typeforce)(
      (0, ne.tuple)(ne.Hash160bit, ne.UInt8),
      arguments
    );
    const Jt = Buffer$D.allocUnsafe(21);
    return Jt.writeUInt8(Ut, 0), Ft.copy(Jt, 1), oe.encode(Jt);
  }
  address.toBase58Check = kt;
  function Ct(Ft, Ut, Jt) {
    const Vt = ie.bech32.toWords(Ft);
    return Vt.unshift(Ut), Ut === 0 ? ie.bech32.encode(Jt, Vt) : ie.bech32m.encode(Jt, Vt);
  }
  address.toBech32 = Ct;
  function Lt(Ft, Ut) {
    Ut = Ut || B.bitcoin;
    try {
      return z.p2pkh({ output: Ft, network: Ut }).address;
    } catch {
    }
    try {
      return z.p2sh({ output: Ft, network: Ut }).address;
    } catch {
    }
    try {
      return z.p2wpkh({ output: Ft, network: Ut }).address;
    } catch {
    }
    try {
      return z.p2wsh({ output: Ft, network: Ut }).address;
    } catch {
    }
    try {
      return z.p2tr({ output: Ft, network: Ut }).address;
    } catch {
    }
    try {
      return Je(Ft, Ut);
    } catch {
    }
    throw new Error(Y.toASM(Ft) + " has no matching Address");
  }
  address.fromOutputScript = Lt;
  function Pt(Ft, Ut) {
    Ut = Ut || B.bitcoin;
    let Jt, Vt;
    try {
      Jt = Ce(Ft);
    } catch {
    }
    if (Jt) {
      if (Jt.version === Ut.pubKeyHash)
        return z.p2pkh({ hash: Jt.hash }).output;
      if (Jt.version === Ut.scriptHash)
        return z.p2sh({ hash: Jt.hash }).output;
    } else {
      try {
        Vt = _t(Ft);
      } catch {
      }
      if (Vt) {
        if (Vt.prefix !== Ut.bech32)
          throw new Error(Ft + " has an invalid prefix");
        if (Vt.version === 0) {
          if (Vt.data.length === 20)
            return z.p2wpkh({ hash: Vt.data }).output;
          if (Vt.data.length === 32)
            return z.p2wsh({ hash: Vt.data }).output;
        } else if (Vt.version === 1) {
          if (Vt.data.length === 32)
            return z.p2tr({ pubkey: Vt.data }).output;
        } else if (Vt.version >= Pe && Vt.version <= ve && Vt.data.length >= ae && Vt.data.length <= se)
          return console.warn(Ee), Y.compile([
            Vt.version + le,
            Vt.data
          ]);
      }
    }
    throw new Error(Ft + " has no matching Script");
  }
  return address.toOutputScript = Pt, address;
}
var block = {}, merkle = {};
Object.defineProperty(merkle, "__esModule", { value: !0 });
merkle.fastMerkleRoot = void 0;
function fastMerkleRoot(B, z) {
  if (!Array.isArray(B)) throw TypeError("Expected values Array");
  if (typeof z != "function")
    throw TypeError("Expected digest Function");
  let Y = B.length;
  const ne = B.concat();
  for (; Y > 1; ) {
    let ie = 0;
    for (let oe = 0; oe < Y; oe += 2, ++ie) {
      const se = ne[oe], ae = oe + 1 === Y ? se : ne[oe + 1], ve = Buffer$D.concat([se, ae]);
      ne[ie] = z(ve);
    }
    Y = ie;
  }
  return ne[0];
}
merkle.fastMerkleRoot = fastMerkleRoot;
var transaction = {};
Object.defineProperty(transaction, "__esModule", { value: !0 });
transaction.Transaction = void 0;
const bufferutils_1$2 = bufferutils, bcrypto$1 = crypto$1, bscript$2 = requireScript(), script_1 = requireScript(), types$1 = types$4, { typeforce: typeforce$1 } = types$1;
function varSliceSize(B) {
  const z = B.length;
  return bufferutils_1$2.varuint.encodingLength(z) + z;
}
function vectorSize(B) {
  const z = B.length;
  return bufferutils_1$2.varuint.encodingLength(z) + B.reduce((Y, ne) => Y + varSliceSize(ne), 0);
}
const EMPTY_BUFFER = Buffer$D.allocUnsafe(0), EMPTY_WITNESS = [], ZERO = Buffer$D.from(
  "0000000000000000000000000000000000000000000000000000000000000000",
  "hex"
), ONE = Buffer$D.from(
  "0000000000000000000000000000000000000000000000000000000000000001",
  "hex"
), VALUE_UINT64_MAX = Buffer$D.from("ffffffffffffffff", "hex"), BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX
};
function isOutput(B) {
  return B.value !== void 0;
}
class Transaction {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static fromBuffer(z, Y) {
    const ne = new bufferutils_1$2.BufferReader(z), ie = new Transaction();
    ie.version = ne.readInt32();
    const oe = ne.readUInt8(), se = ne.readUInt8();
    let ae = !1;
    oe === Transaction.ADVANCED_TRANSACTION_MARKER && se === Transaction.ADVANCED_TRANSACTION_FLAG ? ae = !0 : ne.offset -= 2;
    const ve = ne.readVarInt();
    for (let le = 0; le < ve; ++le)
      ie.ins.push({
        hash: ne.readSlice(32),
        index: ne.readUInt32(),
        script: ne.readVarSlice(),
        sequence: ne.readUInt32(),
        witness: EMPTY_WITNESS
      });
    const Pe = ne.readVarInt();
    for (let le = 0; le < Pe; ++le)
      ie.outs.push({
        value: ne.readUInt64(),
        script: ne.readVarSlice()
      });
    if (ae) {
      for (let le = 0; le < ve; ++le)
        ie.ins[le].witness = ne.readVector();
      if (!ie.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (ie.locktime = ne.readUInt32(), Y) return ie;
    if (ne.offset !== z.length)
      throw new Error("Transaction has unexpected data");
    return ie;
  }
  static fromHex(z) {
    return Transaction.fromBuffer(Buffer$D.from(z, "hex"), !1);
  }
  static isCoinbaseHash(z) {
    typeforce$1(types$1.Hash256bit, z);
    for (let Y = 0; Y < 32; ++Y)
      if (z[Y] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(z, Y, ne, ie) {
    return typeforce$1(
      types$1.tuple(
        types$1.Hash256bit,
        types$1.UInt32,
        types$1.maybe(types$1.UInt32),
        types$1.maybe(types$1.Buffer)
      ),
      arguments
    ), types$1.Null(ne) && (ne = Transaction.DEFAULT_SEQUENCE), this.ins.push({
      hash: z,
      index: Y,
      script: ie || EMPTY_BUFFER,
      sequence: ne,
      witness: EMPTY_WITNESS
    }) - 1;
  }
  addOutput(z, Y) {
    return typeforce$1(types$1.tuple(types$1.Buffer, types$1.Satoshi), arguments), this.outs.push({
      script: z,
      value: Y
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((z) => z.witness.length !== 0);
  }
  weight() {
    const z = this.byteLength(!1), Y = this.byteLength(!0);
    return z * 3 + Y;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(z = !0) {
    const Y = z && this.hasWitnesses();
    return (Y ? 10 : 8) + bufferutils_1$2.varuint.encodingLength(this.ins.length) + bufferutils_1$2.varuint.encodingLength(this.outs.length) + this.ins.reduce((ne, ie) => ne + 40 + varSliceSize(ie.script), 0) + this.outs.reduce((ne, ie) => ne + 8 + varSliceSize(ie.script), 0) + (Y ? this.ins.reduce((ne, ie) => ne + vectorSize(ie.witness), 0) : 0);
  }
  clone() {
    const z = new Transaction();
    return z.version = this.version, z.locktime = this.locktime, z.ins = this.ins.map((Y) => ({
      hash: Y.hash,
      index: Y.index,
      script: Y.script,
      sequence: Y.sequence,
      witness: Y.witness
    })), z.outs = this.outs.map((Y) => ({
      script: Y.script,
      value: Y.value
    })), z;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(z, Y, ne) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        types$1.Buffer,
        /* types.UInt8 */
        types$1.Number
      ),
      arguments
    ), z >= this.ins.length) return ONE;
    const ie = bscript$2.compile(
      bscript$2.decompile(Y).filter((ae) => ae !== script_1.OPS.OP_CODESEPARATOR)
    ), oe = this.clone();
    if ((ne & 31) === Transaction.SIGHASH_NONE)
      oe.outs = [], oe.ins.forEach((ae, ve) => {
        ve !== z && (ae.sequence = 0);
      });
    else if ((ne & 31) === Transaction.SIGHASH_SINGLE) {
      if (z >= this.outs.length) return ONE;
      oe.outs.length = z + 1;
      for (let ae = 0; ae < z; ae++)
        oe.outs[ae] = BLANK_OUTPUT;
      oe.ins.forEach((ae, ve) => {
        ve !== z && (ae.sequence = 0);
      });
    }
    ne & Transaction.SIGHASH_ANYONECANPAY ? (oe.ins = [oe.ins[z]], oe.ins[0].script = ie) : (oe.ins.forEach((ae) => {
      ae.script = EMPTY_BUFFER;
    }), oe.ins[z].script = ie);
    const se = Buffer$D.allocUnsafe(oe.byteLength(!1) + 4);
    return se.writeInt32LE(ne, se.length - 4), oe.__toBuffer(se, 0, !1), bcrypto$1.hash256(se);
  }
  hashForWitnessV1(z, Y, ne, ie, oe, se) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        typeforce$1.arrayOf(types$1.Buffer),
        typeforce$1.arrayOf(types$1.Satoshi),
        types$1.UInt32
      ),
      arguments
    ), ne.length !== this.ins.length || Y.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const ae = ie === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : ie & Transaction.SIGHASH_OUTPUT_MASK, Pe = (ie & Transaction.SIGHASH_INPUT_MASK) === Transaction.SIGHASH_ANYONECANPAY, le = ae === Transaction.SIGHASH_NONE, Ee = ae === Transaction.SIGHASH_SINGLE;
    let Je = EMPTY_BUFFER, Ce = EMPTY_BUFFER, _t = EMPTY_BUFFER, kt = EMPTY_BUFFER, Ct = EMPTY_BUFFER;
    if (!Pe) {
      let Ut = bufferutils_1$2.BufferWriter.withCapacity(
        36 * this.ins.length
      );
      this.ins.forEach((Jt) => {
        Ut.writeSlice(Jt.hash), Ut.writeUInt32(Jt.index);
      }), Je = bcrypto$1.sha256(Ut.end()), Ut = bufferutils_1$2.BufferWriter.withCapacity(
        8 * this.ins.length
      ), ne.forEach((Jt) => Ut.writeUInt64(Jt)), Ce = bcrypto$1.sha256(Ut.end()), Ut = bufferutils_1$2.BufferWriter.withCapacity(
        Y.map(varSliceSize).reduce((Jt, Vt) => Jt + Vt)
      ), Y.forEach(
        (Jt) => Ut.writeVarSlice(Jt)
      ), _t = bcrypto$1.sha256(Ut.end()), Ut = bufferutils_1$2.BufferWriter.withCapacity(
        4 * this.ins.length
      ), this.ins.forEach((Jt) => Ut.writeUInt32(Jt.sequence)), kt = bcrypto$1.sha256(Ut.end());
    }
    if (le || Ee) {
      if (Ee && z < this.outs.length) {
        const Ut = this.outs[z], Jt = bufferutils_1$2.BufferWriter.withCapacity(
          8 + varSliceSize(Ut.script)
        );
        Jt.writeUInt64(Ut.value), Jt.writeVarSlice(Ut.script), Ct = bcrypto$1.sha256(Jt.end());
      }
    } else {
      const Ut = this.outs.map((Vt) => 8 + varSliceSize(Vt.script)).reduce((Vt, ir) => Vt + ir), Jt = bufferutils_1$2.BufferWriter.withCapacity(Ut);
      this.outs.forEach((Vt) => {
        Jt.writeUInt64(Vt.value), Jt.writeVarSlice(Vt.script);
      }), Ct = bcrypto$1.sha256(Jt.end());
    }
    const Lt = (oe ? 2 : 0) + (se ? 1 : 0), Pt = 174 - (Pe ? 49 : 0) - (le ? 32 : 0) + (se ? 32 : 0) + (oe ? 37 : 0), Ft = bufferutils_1$2.BufferWriter.withCapacity(Pt);
    if (Ft.writeUInt8(ie), Ft.writeInt32(this.version), Ft.writeUInt32(this.locktime), Ft.writeSlice(Je), Ft.writeSlice(Ce), Ft.writeSlice(_t), Ft.writeSlice(kt), le || Ee || Ft.writeSlice(Ct), Ft.writeUInt8(Lt), Pe) {
      const Ut = this.ins[z];
      Ft.writeSlice(Ut.hash), Ft.writeUInt32(Ut.index), Ft.writeUInt64(ne[z]), Ft.writeVarSlice(Y[z]), Ft.writeUInt32(Ut.sequence);
    } else
      Ft.writeUInt32(z);
    if (se) {
      const Ut = bufferutils_1$2.BufferWriter.withCapacity(
        varSliceSize(se)
      );
      Ut.writeVarSlice(se), Ft.writeSlice(bcrypto$1.sha256(Ut.end()));
    }
    return Ee && Ft.writeSlice(Ct), oe && (Ft.writeSlice(oe), Ft.writeUInt8(0), Ft.writeUInt32(4294967295)), bcrypto$1.taggedHash(
      "TapSighash",
      Buffer$D.concat([Buffer$D.from([0]), Ft.end()])
    );
  }
  hashForWitnessV0(z, Y, ne, ie) {
    typeforce$1(
      types$1.tuple(types$1.UInt32, types$1.Buffer, types$1.Satoshi, types$1.UInt32),
      arguments
    );
    let oe = Buffer$D.from([]), se, ae = ZERO, ve = ZERO, Pe = ZERO;
    if (ie & Transaction.SIGHASH_ANYONECANPAY || (oe = Buffer$D.allocUnsafe(36 * this.ins.length), se = new bufferutils_1$2.BufferWriter(oe, 0), this.ins.forEach((Ee) => {
      se.writeSlice(Ee.hash), se.writeUInt32(Ee.index);
    }), ve = bcrypto$1.hash256(oe)), !(ie & Transaction.SIGHASH_ANYONECANPAY) && (ie & 31) !== Transaction.SIGHASH_SINGLE && (ie & 31) !== Transaction.SIGHASH_NONE && (oe = Buffer$D.allocUnsafe(4 * this.ins.length), se = new bufferutils_1$2.BufferWriter(oe, 0), this.ins.forEach((Ee) => {
      se.writeUInt32(Ee.sequence);
    }), Pe = bcrypto$1.hash256(oe)), (ie & 31) !== Transaction.SIGHASH_SINGLE && (ie & 31) !== Transaction.SIGHASH_NONE) {
      const Ee = this.outs.reduce((Je, Ce) => Je + 8 + varSliceSize(Ce.script), 0);
      oe = Buffer$D.allocUnsafe(Ee), se = new bufferutils_1$2.BufferWriter(oe, 0), this.outs.forEach((Je) => {
        se.writeUInt64(Je.value), se.writeVarSlice(Je.script);
      }), ae = bcrypto$1.hash256(oe);
    } else if ((ie & 31) === Transaction.SIGHASH_SINGLE && z < this.outs.length) {
      const Ee = this.outs[z];
      oe = Buffer$D.allocUnsafe(8 + varSliceSize(Ee.script)), se = new bufferutils_1$2.BufferWriter(oe, 0), se.writeUInt64(Ee.value), se.writeVarSlice(Ee.script), ae = bcrypto$1.hash256(oe);
    }
    oe = Buffer$D.allocUnsafe(156 + varSliceSize(Y)), se = new bufferutils_1$2.BufferWriter(oe, 0);
    const le = this.ins[z];
    return se.writeInt32(this.version), se.writeSlice(ve), se.writeSlice(Pe), se.writeSlice(le.hash), se.writeUInt32(le.index), se.writeVarSlice(Y), se.writeUInt64(ne), se.writeUInt32(le.sequence), se.writeSlice(ae), se.writeUInt32(this.locktime), se.writeUInt32(ie), bcrypto$1.hash256(oe);
  }
  getHash(z) {
    return z && this.isCoinbase() ? Buffer$D.alloc(32, 0) : bcrypto$1.hash256(this.__toBuffer(void 0, void 0, z));
  }
  getId() {
    return (0, bufferutils_1$2.reverseBuffer)(this.getHash(!1)).toString(
      "hex"
    );
  }
  toBuffer(z, Y) {
    return this.__toBuffer(z, Y, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(z, Y) {
    typeforce$1(types$1.tuple(types$1.Number, types$1.Buffer), arguments), this.ins[z].script = Y;
  }
  setWitness(z, Y) {
    typeforce$1(types$1.tuple(types$1.Number, [types$1.Buffer]), arguments), this.ins[z].witness = Y;
  }
  __toBuffer(z, Y, ne = !1) {
    z || (z = Buffer$D.allocUnsafe(this.byteLength(ne)));
    const ie = new bufferutils_1$2.BufferWriter(
      z,
      Y || 0
    );
    ie.writeInt32(this.version);
    const oe = ne && this.hasWitnesses();
    return oe && (ie.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER), ie.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)), ie.writeVarInt(this.ins.length), this.ins.forEach((se) => {
      ie.writeSlice(se.hash), ie.writeUInt32(se.index), ie.writeVarSlice(se.script), ie.writeUInt32(se.sequence);
    }), ie.writeVarInt(this.outs.length), this.outs.forEach((se) => {
      isOutput(se) ? ie.writeUInt64(se.value) : ie.writeSlice(se.valueBuffer), ie.writeVarSlice(se.script);
    }), oe && this.ins.forEach((se) => {
      ie.writeVector(se.witness);
    }), ie.writeUInt32(this.locktime), Y !== void 0 ? z.slice(Y, ie.offset) : z;
  }
}
transaction.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 4294967295;
Transaction.SIGHASH_DEFAULT = 0;
Transaction.SIGHASH_ALL = 1;
Transaction.SIGHASH_NONE = 2;
Transaction.SIGHASH_SINGLE = 3;
Transaction.SIGHASH_ANYONECANPAY = 128;
Transaction.SIGHASH_OUTPUT_MASK = 3;
Transaction.SIGHASH_INPUT_MASK = 128;
Transaction.ADVANCED_TRANSACTION_MARKER = 0;
Transaction.ADVANCED_TRANSACTION_FLAG = 1;
Object.defineProperty(block, "__esModule", { value: !0 });
block.Block = void 0;
const bufferutils_1$1 = bufferutils, bcrypto = crypto$1, merkle_1 = merkle, transaction_1$3 = transaction, types = types$4, { typeforce } = types, errorMerkleNoTxes = new TypeError(
  "Cannot compute merkle root for zero transactions"
), errorWitnessNotSegwit = new TypeError(
  "Cannot compute witness commit for non-segwit block"
);
class Block {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(z) {
    if (z.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const Y = new bufferutils_1$1.BufferReader(z), ne = new Block();
    if (ne.version = Y.readInt32(), ne.prevHash = Y.readSlice(32), ne.merkleRoot = Y.readSlice(32), ne.timestamp = Y.readUInt32(), ne.bits = Y.readUInt32(), ne.nonce = Y.readUInt32(), z.length === 80) return ne;
    const ie = () => {
      const ae = transaction_1$3.Transaction.fromBuffer(
        Y.buffer.slice(Y.offset),
        !0
      );
      return Y.offset += ae.byteLength(), ae;
    }, oe = Y.readVarInt();
    ne.transactions = [];
    for (let ae = 0; ae < oe; ++ae) {
      const ve = ie();
      ne.transactions.push(ve);
    }
    const se = ne.getWitnessCommit();
    return se && (ne.witnessCommit = se), ne;
  }
  static fromHex(z) {
    return Block.fromBuffer(Buffer$D.from(z, "hex"));
  }
  static calculateTarget(z) {
    const Y = ((z & 4278190080) >> 24) - 3, ne = z & 8388607, ie = Buffer$D.alloc(32, 0);
    return ie.writeUIntBE(ne, 29 - Y, 3), ie;
  }
  static calculateMerkleRoot(z, Y) {
    if (typeforce([{ getHash: types.Function }], z), z.length === 0) throw errorMerkleNoTxes;
    if (Y && !txesHaveWitnessCommit(z))
      throw errorWitnessNotSegwit;
    const ne = z.map(
      (oe) => oe.getHash(Y)
    ), ie = (0, merkle_1.fastMerkleRoot)(ne, bcrypto.hash256);
    return Y ? bcrypto.hash256(
      Buffer$D.concat([ie, z[0].ins[0].witness[0]])
    ) : ie;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    const z = this.transactions[0].outs.filter(
      (ne) => ne.script.slice(0, 6).equals(Buffer$D.from("6a24aa21a9ed", "hex"))
    ).map((ne) => ne.script.slice(6, 38));
    if (z.length === 0) return null;
    const Y = z[z.length - 1];
    return Y instanceof Buffer$D && Y.length === 32 ? Y : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof Buffer$D && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const z = this.byteLength(!1, !1), Y = this.byteLength(!1, !0);
    return z * 3 + Y;
  }
  byteLength(z, Y = !0) {
    return z || !this.transactions ? 80 : 80 + bufferutils_1$1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((ne, ie) => ne + ie.byteLength(Y), 0);
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(!0));
  }
  getId() {
    return (0, bufferutils_1$1.reverseBuffer)(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const z = /* @__PURE__ */ new Date(0);
    return z.setUTCSeconds(this.timestamp), z;
  }
  // TODO: buffer, offset compatibility
  toBuffer(z) {
    const Y = Buffer$D.allocUnsafe(this.byteLength(z)), ne = new bufferutils_1$1.BufferWriter(Y);
    return ne.writeInt32(this.version), ne.writeSlice(this.prevHash), ne.writeSlice(this.merkleRoot), ne.writeUInt32(this.timestamp), ne.writeUInt32(this.bits), ne.writeUInt32(this.nonce), z || !this.transactions || (bufferutils_1$1.varuint.encode(
      this.transactions.length,
      Y,
      ne.offset
    ), ne.offset += bufferutils_1$1.varuint.encode.bytes, this.transactions.forEach((ie) => {
      const oe = ie.byteLength();
      ie.toBuffer(Y, ne.offset), ne.offset += oe;
    })), Y;
  }
  toHex(z) {
    return this.toBuffer(z).toString("hex");
  }
  checkTxRoots() {
    const z = this.hasWitnessCommit();
    return !z && this.hasWitness() ? !1 : this.__checkMerkleRoot() && (z ? this.__checkWitnessCommit() : !0);
  }
  checkProofOfWork() {
    const z = (0, bufferutils_1$1.reverseBuffer)(this.getHash()), Y = Block.calculateTarget(this.bits);
    return z.compare(Y) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const z = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(z) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const z = Block.calculateMerkleRoot(
      this.transactions,
      !0
    );
    return this.witnessCommit.compare(z) === 0;
  }
}
block.Block = Block;
function txesHaveWitnessCommit(B) {
  return B instanceof Array && B[0] && B[0].ins && B[0].ins instanceof Array && B[0].ins[0] && B[0].ins[0].witness && B[0].ins[0].witness instanceof Array && B[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(B) {
  return B instanceof Array && B.some(
    (z) => typeof z == "object" && z.ins instanceof Array && z.ins.some(
      (Y) => typeof Y == "object" && Y.witness instanceof Array && Y.witness.length > 0
    )
  );
}
var psbt$1 = {}, psbt = {}, combiner = {}, parser = {}, fromBuffer = {}, converter = {}, typeFields = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), function(z) {
    z[z.UNSIGNED_TX = 0] = "UNSIGNED_TX", z[z.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
  }(B.GlobalTypes || (B.GlobalTypes = {})), B.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], function(z) {
    z[z.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", z[z.WITNESS_UTXO = 1] = "WITNESS_UTXO", z[z.PARTIAL_SIG = 2] = "PARTIAL_SIG", z[z.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", z[z.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", z[z.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", z[z.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", z[z.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", z[z.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", z[z.POR_COMMITMENT = 9] = "POR_COMMITMENT", z[z.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", z[z.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", z[z.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", z[z.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", z[z.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", z[z.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
  }(B.InputTypes || (B.InputTypes = {})), B.INPUT_TYPE_NAMES = [
    "nonWitnessUtxo",
    "witnessUtxo",
    "partialSig",
    "sighashType",
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "finalScriptSig",
    "finalScriptWitness",
    "porCommitment",
    "tapKeySig",
    "tapScriptSig",
    "tapLeafScript",
    "tapBip32Derivation",
    "tapInternalKey",
    "tapMerkleRoot"
  ], function(z) {
    z[z.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", z[z.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", z[z.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", z[z.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", z[z.TAP_TREE = 6] = "TAP_TREE", z[z.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
  }(B.OutputTypes || (B.OutputTypes = {})), B.OUTPUT_TYPE_NAMES = [
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "tapInternalKey",
    "tapTree",
    "tapBip32Derivation"
  ];
})(typeFields);
var globalXpub$1 = {};
Object.defineProperty(globalXpub$1, "__esModule", { value: !0 });
const typeFields_1$g = typeFields, range$2 = (B) => [...Array(B).keys()];
function decode$d(B) {
  if (B.key[0] !== typeFields_1$g.GlobalTypes.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + B.key.toString("hex")
    );
  if (B.key.length !== 79 || ![2, 3].includes(B.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + B.key.toString("hex")
    );
  if (B.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const z = B.key.slice(1), Y = {
    masterFingerprint: B.value.slice(0, 4),
    extendedPubkey: z,
    path: "m"
  };
  for (const ne of range$2(B.value.length / 4 - 1)) {
    const ie = B.value.readUInt32LE(ne * 4 + 4), oe = !!(ie & 2147483648), se = ie & 2147483647;
    Y.path += "/" + se.toString(10) + (oe ? "'" : "");
  }
  return Y;
}
globalXpub$1.decode = decode$d;
function encode$e(B) {
  const z = Buffer$D.from([typeFields_1$g.GlobalTypes.GLOBAL_XPUB]), Y = Buffer$D.concat([z, B.extendedPubkey]), ne = B.path.split("/"), ie = Buffer$D.allocUnsafe(ne.length * 4);
  B.masterFingerprint.copy(ie, 0);
  let oe = 4;
  return ne.slice(1).forEach((se) => {
    const ae = se.slice(-1) === "'";
    let ve = 2147483647 & parseInt(ae ? se.slice(0, -1) : se, 10);
    ae && (ve += 2147483648), ie.writeUInt32LE(ve, oe), oe += 4;
  }), {
    key: Y,
    value: ie
  };
}
globalXpub$1.encode = encode$e;
globalXpub$1.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
function check$c(B) {
  const z = B.extendedPubkey, Y = B.masterFingerprint, ne = B.path;
  return Buffer$D.isBuffer(z) && z.length === 78 && [2, 3].indexOf(z[45]) > -1 && Buffer$D.isBuffer(Y) && Y.length === 4 && typeof ne == "string" && !!ne.match(/^m(\/\d+'?)*$/);
}
globalXpub$1.check = check$c;
function canAddToArray$3(B, z, Y) {
  const ne = z.extendedPubkey.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter((ie) => ie.extendedPubkey.equals(z.extendedPubkey)).length === 0);
}
globalXpub$1.canAddToArray = canAddToArray$3;
var unsignedTx$1 = {};
Object.defineProperty(unsignedTx$1, "__esModule", { value: !0 });
const typeFields_1$f = typeFields;
function encode$d(B) {
  return {
    key: Buffer$D.from([typeFields_1$f.GlobalTypes.UNSIGNED_TX]),
    value: B.toBuffer()
  };
}
unsignedTx$1.encode = encode$d;
var finalScriptSig$1 = {};
Object.defineProperty(finalScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$e = typeFields;
function decode$c(B) {
  if (B.key[0] !== typeFields_1$e.InputTypes.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
finalScriptSig$1.decode = decode$c;
function encode$c(B) {
  return {
    key: Buffer$D.from([typeFields_1$e.InputTypes.FINAL_SCRIPTSIG]),
    value: B
  };
}
finalScriptSig$1.encode = encode$c;
finalScriptSig$1.expected = "Buffer";
function check$b(B) {
  return Buffer$D.isBuffer(B);
}
finalScriptSig$1.check = check$b;
function canAdd$8(B, z) {
  return !!B && !!z && B.finalScriptSig === void 0;
}
finalScriptSig$1.canAdd = canAdd$8;
var finalScriptWitness$1 = {};
Object.defineProperty(finalScriptWitness$1, "__esModule", { value: !0 });
const typeFields_1$d = typeFields;
function decode$b(B) {
  if (B.key[0] !== typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
finalScriptWitness$1.decode = decode$b;
function encode$b(B) {
  return {
    key: Buffer$D.from([typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS]),
    value: B
  };
}
finalScriptWitness$1.encode = encode$b;
finalScriptWitness$1.expected = "Buffer";
function check$a(B) {
  return Buffer$D.isBuffer(B);
}
finalScriptWitness$1.check = check$a;
function canAdd$7(B, z) {
  return !!B && !!z && B.finalScriptWitness === void 0;
}
finalScriptWitness$1.canAdd = canAdd$7;
var nonWitnessUtxo$1 = {};
Object.defineProperty(nonWitnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$c = typeFields;
function decode$a(B) {
  if (B.key[0] !== typeFields_1$c.InputTypes.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
nonWitnessUtxo$1.decode = decode$a;
function encode$a(B) {
  return {
    key: Buffer$D.from([typeFields_1$c.InputTypes.NON_WITNESS_UTXO]),
    value: B
  };
}
nonWitnessUtxo$1.encode = encode$a;
nonWitnessUtxo$1.expected = "Buffer";
function check$9(B) {
  return Buffer$D.isBuffer(B);
}
nonWitnessUtxo$1.check = check$9;
function canAdd$6(B, z) {
  return !!B && !!z && B.nonWitnessUtxo === void 0;
}
nonWitnessUtxo$1.canAdd = canAdd$6;
var partialSig$1 = {};
Object.defineProperty(partialSig$1, "__esModule", { value: !0 });
const typeFields_1$b = typeFields;
function decode$9(B) {
  if (B.key[0] !== typeFields_1$b.InputTypes.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + B.key.toString("hex")
    );
  if (!(B.key.length === 34 || B.key.length === 66) || ![2, 3, 4].includes(B.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + B.key.toString("hex")
    );
  return {
    pubkey: B.key.slice(1),
    signature: B.value
  };
}
partialSig$1.decode = decode$9;
function encode$9(B) {
  const z = Buffer$D.from([typeFields_1$b.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer$D.concat([z, B.pubkey]),
    value: B.signature
  };
}
partialSig$1.encode = encode$9;
partialSig$1.expected = "{ pubkey: Buffer; signature: Buffer; }";
function check$8(B) {
  return Buffer$D.isBuffer(B.pubkey) && Buffer$D.isBuffer(B.signature) && [33, 65].includes(B.pubkey.length) && [2, 3, 4].includes(B.pubkey[0]) && isDerSigWithSighash(B.signature);
}
partialSig$1.check = check$8;
function isDerSigWithSighash(B) {
  if (!Buffer$D.isBuffer(B) || B.length < 9 || B[0] !== 48 || B.length !== B[1] + 3 || B[2] !== 2) return !1;
  const z = B[3];
  if (z > 33 || z < 1 || B[3 + z + 1] !== 2) return !1;
  const Y = B[3 + z + 2];
  return !(Y > 33 || Y < 1 || B.length !== 3 + z + 2 + Y + 2);
}
function canAddToArray$2(B, z, Y) {
  const ne = z.pubkey.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter((ie) => ie.pubkey.equals(z.pubkey)).length === 0);
}
partialSig$1.canAddToArray = canAddToArray$2;
var porCommitment$1 = {};
Object.defineProperty(porCommitment$1, "__esModule", { value: !0 });
const typeFields_1$a = typeFields;
function decode$8(B) {
  if (B.key[0] !== typeFields_1$a.InputTypes.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + B.key.toString("hex")
    );
  return B.value.toString("utf8");
}
porCommitment$1.decode = decode$8;
function encode$8(B) {
  return {
    key: Buffer$D.from([typeFields_1$a.InputTypes.POR_COMMITMENT]),
    value: Buffer$D.from(B, "utf8")
  };
}
porCommitment$1.encode = encode$8;
porCommitment$1.expected = "string";
function check$7(B) {
  return typeof B == "string";
}
porCommitment$1.check = check$7;
function canAdd$5(B, z) {
  return !!B && !!z && B.porCommitment === void 0;
}
porCommitment$1.canAdd = canAdd$5;
var sighashType$1 = {};
Object.defineProperty(sighashType$1, "__esModule", { value: !0 });
const typeFields_1$9 = typeFields;
function decode$7(B) {
  if (B.key[0] !== typeFields_1$9.InputTypes.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + B.key.toString("hex")
    );
  return B.value.readUInt32LE(0);
}
sighashType$1.decode = decode$7;
function encode$7(B) {
  const z = Buffer$D.from([typeFields_1$9.InputTypes.SIGHASH_TYPE]), Y = Buffer$D.allocUnsafe(4);
  return Y.writeUInt32LE(B, 0), {
    key: z,
    value: Y
  };
}
sighashType$1.encode = encode$7;
sighashType$1.expected = "number";
function check$6(B) {
  return typeof B == "number";
}
sighashType$1.check = check$6;
function canAdd$4(B, z) {
  return !!B && !!z && B.sighashType === void 0;
}
sighashType$1.canAdd = canAdd$4;
var tapKeySig$1 = {};
Object.defineProperty(tapKeySig$1, "__esModule", { value: !0 });
const typeFields_1$8 = typeFields;
function decode$6(B) {
  if (B.key[0] !== typeFields_1$8.InputTypes.TAP_KEY_SIG || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + B.key.toString("hex")
    );
  if (!check$5(B.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return B.value;
}
tapKeySig$1.decode = decode$6;
function encode$6(B) {
  return { key: Buffer$D.from([typeFields_1$8.InputTypes.TAP_KEY_SIG]), value: B };
}
tapKeySig$1.encode = encode$6;
tapKeySig$1.expected = "Buffer";
function check$5(B) {
  return Buffer$D.isBuffer(B) && (B.length === 64 || B.length === 65);
}
tapKeySig$1.check = check$5;
function canAdd$3(B, z) {
  return !!B && !!z && B.tapKeySig === void 0;
}
tapKeySig$1.canAdd = canAdd$3;
var tapLeafScript$1 = {};
Object.defineProperty(tapLeafScript$1, "__esModule", { value: !0 });
const typeFields_1$7 = typeFields;
function decode$5(B) {
  if (B.key[0] !== typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + B.key.toString("hex")
    );
  if ((B.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + B.key.toString("hex")
    );
  const z = B.value[B.value.length - 1];
  if ((B.key[1] & 254) !== z)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + B.key.toString("hex")
    );
  const Y = B.value.slice(0, -1);
  return { controlBlock: B.key.slice(1), script: Y, leafVersion: z };
}
tapLeafScript$1.decode = decode$5;
function encode$5(B) {
  const z = Buffer$D.from([typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT]), Y = Buffer$D.from([B.leafVersion]);
  return {
    key: Buffer$D.concat([z, B.controlBlock]),
    value: Buffer$D.concat([B.script, Y])
  };
}
tapLeafScript$1.encode = encode$5;
tapLeafScript$1.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
function check$4(B) {
  return Buffer$D.isBuffer(B.controlBlock) && (B.controlBlock.length - 1) % 32 === 0 && (B.controlBlock[0] & 254) === B.leafVersion && Buffer$D.isBuffer(B.script);
}
tapLeafScript$1.check = check$4;
function canAddToArray$1(B, z, Y) {
  const ne = z.controlBlock.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter((ie) => ie.controlBlock.equals(z.controlBlock)).length === 0);
}
tapLeafScript$1.canAddToArray = canAddToArray$1;
var tapMerkleRoot$1 = {};
Object.defineProperty(tapMerkleRoot$1, "__esModule", { value: !0 });
const typeFields_1$6 = typeFields;
function decode$4(B) {
  if (B.key[0] !== typeFields_1$6.InputTypes.TAP_MERKLE_ROOT || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + B.key.toString("hex")
    );
  if (!check$3(B.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return B.value;
}
tapMerkleRoot$1.decode = decode$4;
function encode$4(B) {
  return { key: Buffer$D.from([typeFields_1$6.InputTypes.TAP_MERKLE_ROOT]), value: B };
}
tapMerkleRoot$1.encode = encode$4;
tapMerkleRoot$1.expected = "Buffer";
function check$3(B) {
  return Buffer$D.isBuffer(B) && B.length === 32;
}
tapMerkleRoot$1.check = check$3;
function canAdd$2(B, z) {
  return !!B && !!z && B.tapMerkleRoot === void 0;
}
tapMerkleRoot$1.canAdd = canAdd$2;
var tapScriptSig$1 = {};
Object.defineProperty(tapScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$5 = typeFields;
function decode$3(B) {
  if (B.key[0] !== typeFields_1$5.InputTypes.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + B.key.toString("hex")
    );
  if (B.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + B.key.toString("hex")
    );
  if (B.value.length !== 64 && B.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + B.key.toString("hex")
    );
  const z = B.key.slice(1, 33), Y = B.key.slice(33);
  return {
    pubkey: z,
    leafHash: Y,
    signature: B.value
  };
}
tapScriptSig$1.decode = decode$3;
function encode$3(B) {
  const z = Buffer$D.from([typeFields_1$5.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer$D.concat([z, B.pubkey, B.leafHash]),
    value: B.signature
  };
}
tapScriptSig$1.encode = encode$3;
tapScriptSig$1.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
function check$2(B) {
  return Buffer$D.isBuffer(B.pubkey) && Buffer$D.isBuffer(B.leafHash) && Buffer$D.isBuffer(B.signature) && B.pubkey.length === 32 && B.leafHash.length === 32 && (B.signature.length === 64 || B.signature.length === 65);
}
tapScriptSig$1.check = check$2;
function canAddToArray(B, z, Y) {
  const ne = z.pubkey.toString("hex") + z.leafHash.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter(
    (ie) => ie.pubkey.equals(z.pubkey) && ie.leafHash.equals(z.leafHash)
  ).length === 0);
}
tapScriptSig$1.canAddToArray = canAddToArray;
var witnessUtxo$1 = {}, tools = {}, varint = {};
Object.defineProperty(varint, "__esModule", { value: !0 });
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER || B % 1 !== 0)
    throw new RangeError("value out of range");
}
function encode$2(B, z, Y) {
  if (checkUInt53(B), z || (z = Buffer$D.allocUnsafe(encodingLength(B))), !Buffer$D.isBuffer(z))
    throw new TypeError("buffer must be a Buffer instance");
  return Y || (Y = 0), B < 253 ? (z.writeUInt8(B, Y), Object.assign(encode$2, { bytes: 1 })) : B <= 65535 ? (z.writeUInt8(253, Y), z.writeUInt16LE(B, Y + 1), Object.assign(encode$2, { bytes: 3 })) : B <= 4294967295 ? (z.writeUInt8(254, Y), z.writeUInt32LE(B, Y + 1), Object.assign(encode$2, { bytes: 5 })) : (z.writeUInt8(255, Y), z.writeUInt32LE(B >>> 0, Y + 1), z.writeUInt32LE(B / 4294967296 | 0, Y + 5), Object.assign(encode$2, { bytes: 9 })), z;
}
varint.encode = encode$2;
function decode$2(B, z) {
  if (!Buffer$D.isBuffer(B))
    throw new TypeError("buffer must be a Buffer instance");
  z || (z = 0);
  const Y = B.readUInt8(z);
  if (Y < 253)
    return Object.assign(decode$2, { bytes: 1 }), Y;
  if (Y === 253)
    return Object.assign(decode$2, { bytes: 3 }), B.readUInt16LE(z + 1);
  if (Y === 254)
    return Object.assign(decode$2, { bytes: 5 }), B.readUInt32LE(z + 1);
  {
    Object.assign(decode$2, { bytes: 9 });
    const ne = B.readUInt32LE(z + 1), oe = B.readUInt32LE(z + 5) * 4294967296 + ne;
    return checkUInt53(oe), oe;
  }
}
varint.decode = decode$2;
function encodingLength(B) {
  return checkUInt53(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
varint.encodingLength = encodingLength;
Object.defineProperty(tools, "__esModule", { value: !0 });
const varuint$6 = varint;
tools.range = (B) => [...Array(B).keys()];
function reverseBuffer(B) {
  if (B.length < 1) return B;
  let z = B.length - 1, Y = 0;
  for (let ne = 0; ne < B.length / 2; ne++)
    Y = B[ne], B[ne] = B[z], B[z] = Y, z--;
  return B;
}
tools.reverseBuffer = reverseBuffer;
function keyValsToBuffer(B) {
  const z = B.map(keyValToBuffer);
  return z.push(Buffer$D.from([0])), Buffer$D.concat(z);
}
tools.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(B) {
  const z = B.key.length, Y = B.value.length, ne = varuint$6.encodingLength(z), ie = varuint$6.encodingLength(Y), oe = Buffer$D.allocUnsafe(
    ne + z + ie + Y
  );
  return varuint$6.encode(z, oe, 0), B.key.copy(oe, ne), varuint$6.encode(Y, oe, ne + z), B.value.copy(oe, ne + z + ie), oe;
}
tools.keyValToBuffer = keyValToBuffer;
function verifuint(B, z) {
  if (typeof B != "number")
    throw new Error("cannot write a non-number as a number");
  if (B < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (B > z) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B)
    throw new Error("value has a fractional component");
}
function readUInt64LE(B, z) {
  const Y = B.readUInt32LE(z);
  let ne = B.readUInt32LE(z + 4);
  return ne *= 4294967296, verifuint(ne + Y, 9007199254740991), ne + Y;
}
tools.readUInt64LE = readUInt64LE;
function writeUInt64LE(B, z, Y) {
  return verifuint(z, 9007199254740991), B.writeInt32LE(z & -1, Y), B.writeUInt32LE(Math.floor(z / 4294967296), Y + 4), Y + 8;
}
tools.writeUInt64LE = writeUInt64LE;
Object.defineProperty(witnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$4 = typeFields, tools_1$2 = tools, varuint$5 = varint;
function decode$1(B) {
  if (B.key[0] !== typeFields_1$4.InputTypes.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + B.key.toString("hex")
    );
  const z = tools_1$2.readUInt64LE(B.value, 0);
  let Y = 8;
  const ne = varuint$5.decode(B.value, Y);
  Y += varuint$5.encodingLength(ne);
  const ie = B.value.slice(Y);
  if (ie.length !== ne)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: ie,
    value: z
  };
}
witnessUtxo$1.decode = decode$1;
function encode$1(B) {
  const { script: z, value: Y } = B, ne = varuint$5.encodingLength(z.length), ie = Buffer$D.allocUnsafe(8 + ne + z.length);
  return tools_1$2.writeUInt64LE(ie, Y, 0), varuint$5.encode(z.length, ie, 8), z.copy(ie, 8 + ne), {
    key: Buffer$D.from([typeFields_1$4.InputTypes.WITNESS_UTXO]),
    value: ie
  };
}
witnessUtxo$1.encode = encode$1;
witnessUtxo$1.expected = "{ script: Buffer; value: number; }";
function check$1(B) {
  return Buffer$D.isBuffer(B.script) && typeof B.value == "number";
}
witnessUtxo$1.check = check$1;
function canAdd$1(B, z) {
  return !!B && !!z && B.witnessUtxo === void 0;
}
witnessUtxo$1.canAdd = canAdd$1;
var tapTree$1 = {};
Object.defineProperty(tapTree$1, "__esModule", { value: !0 });
const typeFields_1$3 = typeFields, varuint$4 = varint;
function decode(B) {
  if (B.key[0] !== typeFields_1$3.OutputTypes.TAP_TREE || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + B.key.toString("hex")
    );
  let z = 0;
  const Y = [];
  for (; z < B.value.length; ) {
    const ne = B.value[z++], ie = B.value[z++], oe = varuint$4.decode(B.value, z);
    z += varuint$4.encodingLength(oe), Y.push({
      depth: ne,
      leafVersion: ie,
      script: B.value.slice(z, z + oe)
    }), z += oe;
  }
  return { leaves: Y };
}
tapTree$1.decode = decode;
function encode(B) {
  const z = Buffer$D.from([typeFields_1$3.OutputTypes.TAP_TREE]), Y = [].concat(
    ...B.leaves.map((ne) => [
      Buffer$D.of(ne.depth, ne.leafVersion),
      varuint$4.encode(ne.script.length),
      ne.script
    ])
  );
  return {
    key: z,
    value: Buffer$D.concat(Y)
  };
}
tapTree$1.encode = encode;
tapTree$1.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
function check(B) {
  return Array.isArray(B.leaves) && B.leaves.every(
    (z) => z.depth >= 0 && z.depth <= 128 && (z.leafVersion & 254) === z.leafVersion && Buffer$D.isBuffer(z.script)
  );
}
tapTree$1.check = check;
function canAdd(B, z) {
  return !!B && !!z && B.tapTree === void 0;
}
tapTree$1.canAdd = canAdd;
var bip32Derivation$2 = {};
Object.defineProperty(bip32Derivation$2, "__esModule", { value: !0 });
const range$1 = (B) => [...Array(B).keys()], isValidDERKey = (B) => B.length === 33 && [2, 3].includes(B[0]) || B.length === 65 && B[0] === 4;
function makeConverter$4(B, z = isValidDERKey) {
  function Y(ae) {
    if (ae.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + ae.key.toString("hex")
      );
    const ve = ae.key.slice(1);
    if (!z(ve))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + ae.key.toString("hex")
      );
    if (ae.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const Pe = {
      masterFingerprint: ae.value.slice(0, 4),
      pubkey: ve,
      path: "m"
    };
    for (const le of range$1(ae.value.length / 4 - 1)) {
      const Ee = ae.value.readUInt32LE(le * 4 + 4), Je = !!(Ee & 2147483648), Ce = Ee & 2147483647;
      Pe.path += "/" + Ce.toString(10) + (Je ? "'" : "");
    }
    return Pe;
  }
  function ne(ae) {
    const ve = Buffer$D.from([B]), Pe = Buffer$D.concat([ve, ae.pubkey]), le = ae.path.split("/"), Ee = Buffer$D.allocUnsafe(le.length * 4);
    ae.masterFingerprint.copy(Ee, 0);
    let Je = 4;
    return le.slice(1).forEach((Ce) => {
      const _t = Ce.slice(-1) === "'";
      let kt = 2147483647 & parseInt(_t ? Ce.slice(0, -1) : Ce, 10);
      _t && (kt += 2147483648), Ee.writeUInt32LE(kt, Je), Je += 4;
    }), {
      key: Pe,
      value: Ee
    };
  }
  const ie = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
  function oe(ae) {
    return Buffer$D.isBuffer(ae.pubkey) && Buffer$D.isBuffer(ae.masterFingerprint) && typeof ae.path == "string" && z(ae.pubkey) && ae.masterFingerprint.length === 4;
  }
  function se(ae, ve, Pe) {
    const le = ve.pubkey.toString("hex");
    return Pe.has(le) ? !1 : (Pe.add(le), ae.filter((Ee) => Ee.pubkey.equals(ve.pubkey)).length === 0);
  }
  return {
    decode: Y,
    encode: ne,
    check: oe,
    expected: ie,
    canAddToArray: se
  };
}
bip32Derivation$2.makeConverter = makeConverter$4;
var checkPubkey$1 = {};
Object.defineProperty(checkPubkey$1, "__esModule", { value: !0 });
function makeChecker(B) {
  return z;
  function z(Y) {
    let ne;
    if (B.includes(Y.key[0]) && (ne = Y.key.slice(1), !(ne.length === 33 || ne.length === 65) || ![2, 3, 4].includes(ne[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + Y.key.toString("hex")
      );
    return ne;
  }
}
checkPubkey$1.makeChecker = makeChecker;
var redeemScript$1 = {};
Object.defineProperty(redeemScript$1, "__esModule", { value: !0 });
function makeConverter$3(B) {
  function z(se) {
    if (se.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + se.key.toString("hex")
      );
    return se.value;
  }
  function Y(se) {
    return {
      key: Buffer$D.from([B]),
      value: se
    };
  }
  const ne = "Buffer";
  function ie(se) {
    return Buffer$D.isBuffer(se);
  }
  function oe(se, ae) {
    return !!se && !!ae && se.redeemScript === void 0;
  }
  return {
    decode: z,
    encode: Y,
    check: ie,
    expected: ne,
    canAdd: oe
  };
}
redeemScript$1.makeConverter = makeConverter$3;
var tapBip32Derivation$1 = {};
Object.defineProperty(tapBip32Derivation$1, "__esModule", { value: !0 });
const varuint$3 = varint, bip32Derivation$1 = bip32Derivation$2, isValidBIP340Key = (B) => B.length === 32;
function makeConverter$2(B) {
  const z = bip32Derivation$1.makeConverter(B, isValidBIP340Key);
  function Y(se) {
    const ae = varuint$3.decode(se.value), ve = varuint$3.encodingLength(ae), Pe = z.decode({
      key: se.key,
      value: se.value.slice(ve + ae * 32)
    }), le = new Array(ae);
    for (let Ee = 0, Je = ve; Ee < ae; Ee++, Je += 32)
      le[Ee] = se.value.slice(Je, Je + 32);
    return Object.assign({}, Pe, { leafHashes: le });
  }
  function ne(se) {
    const ae = z.encode(se), ve = varuint$3.encodingLength(se.leafHashes.length), Pe = Buffer$D.allocUnsafe(ve);
    varuint$3.encode(se.leafHashes.length, Pe);
    const le = Buffer$D.concat([Pe, ...se.leafHashes, ae.value]);
    return Object.assign({}, ae, { value: le });
  }
  const ie = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
  function oe(se) {
    return Array.isArray(se.leafHashes) && se.leafHashes.every(
      (ae) => Buffer$D.isBuffer(ae) && ae.length === 32
    ) && z.check(se);
  }
  return {
    decode: Y,
    encode: ne,
    check: oe,
    expected: ie,
    canAddToArray: z.canAddToArray
  };
}
tapBip32Derivation$1.makeConverter = makeConverter$2;
var tapInternalKey$1 = {};
Object.defineProperty(tapInternalKey$1, "__esModule", { value: !0 });
function makeConverter$1(B) {
  function z(se) {
    if (se.key[0] !== B || se.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + se.key.toString("hex")
      );
    if (se.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return se.value;
  }
  function Y(se) {
    return { key: Buffer$D.from([B]), value: se };
  }
  const ne = "Buffer";
  function ie(se) {
    return Buffer$D.isBuffer(se) && se.length === 32;
  }
  function oe(se, ae) {
    return !!se && !!ae && se.tapInternalKey === void 0;
  }
  return {
    decode: z,
    encode: Y,
    check: ie,
    expected: ne,
    canAdd: oe
  };
}
tapInternalKey$1.makeConverter = makeConverter$1;
var witnessScript$1 = {};
Object.defineProperty(witnessScript$1, "__esModule", { value: !0 });
function makeConverter(B) {
  function z(se) {
    if (se.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + se.key.toString("hex")
      );
    return se.value;
  }
  function Y(se) {
    return {
      key: Buffer$D.from([B]),
      value: se
    };
  }
  const ne = "Buffer";
  function ie(se) {
    return Buffer$D.isBuffer(se);
  }
  function oe(se, ae) {
    return !!se && !!ae && se.witnessScript === void 0;
  }
  return {
    decode: z,
    encode: Y,
    check: ie,
    expected: ne,
    canAdd: oe
  };
}
witnessScript$1.makeConverter = makeConverter;
Object.defineProperty(converter, "__esModule", { value: !0 });
const typeFields_1$2 = typeFields, globalXpub = globalXpub$1, unsignedTx = unsignedTx$1, finalScriptSig = finalScriptSig$1, finalScriptWitness = finalScriptWitness$1, nonWitnessUtxo = nonWitnessUtxo$1, partialSig = partialSig$1, porCommitment = porCommitment$1, sighashType = sighashType$1, tapKeySig = tapKeySig$1, tapLeafScript = tapLeafScript$1, tapMerkleRoot = tapMerkleRoot$1, tapScriptSig = tapScriptSig$1, witnessUtxo = witnessUtxo$1, tapTree = tapTree$1, bip32Derivation = bip32Derivation$2, checkPubkey = checkPubkey$1, redeemScript = redeemScript$1, tapBip32Derivation = tapBip32Derivation$1, tapInternalKey = tapInternalKey$1, witnessScript = witnessScript$1, globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([])
};
converter.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.InputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.InputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.InputTypes.PARTIAL_SIG,
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.InputTypes.TAP_INTERNAL_KEY
  ),
  tapMerkleRoot
};
converter.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.OutputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.OutputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.OutputTypes.TAP_INTERNAL_KEY
  )
};
converter.outputs = outputs;
Object.defineProperty(fromBuffer, "__esModule", { value: !0 });
const convert$1 = converter, tools_1$1 = tools, varuint$2 = varint, typeFields_1$1 = typeFields;
function psbtFromBuffer(B, z) {
  let Y = 0;
  function ne() {
    const Ct = varuint$2.decode(B, Y);
    Y += varuint$2.encodingLength(Ct);
    const Lt = B.slice(Y, Y + Ct);
    return Y += Ct, Lt;
  }
  function ie() {
    const Ct = B.readUInt32BE(Y);
    return Y += 4, Ct;
  }
  function oe() {
    const Ct = B.readUInt8(Y);
    return Y += 1, Ct;
  }
  function se() {
    const Ct = ne(), Lt = ne();
    return {
      key: Ct,
      value: Lt
    };
  }
  function ae() {
    if (Y >= B.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const Ct = B.readUInt8(Y) === 0;
    return Ct && Y++, Ct;
  }
  if (ie() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (oe() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const ve = [], Pe = {};
  for (; !ae(); ) {
    const Ct = se(), Lt = Ct.key.toString("hex");
    if (Pe[Lt])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + Lt
      );
    Pe[Lt] = 1, ve.push(Ct);
  }
  const le = ve.filter(
    (Ct) => Ct.key[0] === typeFields_1$1.GlobalTypes.UNSIGNED_TX
  );
  if (le.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const Ee = z(le[0].value), { inputCount: Je, outputCount: Ce } = Ee.getInputOutputCounts(), _t = [], kt = [];
  for (const Ct of tools_1$1.range(Je)) {
    const Lt = {}, Pt = [];
    for (; !ae(); ) {
      const Ft = se(), Ut = Ft.key.toString("hex");
      if (Lt[Ut])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + Ct + " key " + Ut
        );
      Lt[Ut] = 1, Pt.push(Ft);
    }
    _t.push(Pt);
  }
  for (const Ct of tools_1$1.range(Ce)) {
    const Lt = {}, Pt = [];
    for (; !ae(); ) {
      const Ft = se(), Ut = Ft.key.toString("hex");
      if (Lt[Ut])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + Ct + " key " + Ut
        );
      Lt[Ut] = 1, Pt.push(Ft);
    }
    kt.push(Pt);
  }
  return psbtFromKeyVals(Ee, {
    globalMapKeyVals: ve,
    inputKeyVals: _t,
    outputKeyVals: kt
  });
}
fromBuffer.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(B, z, Y) {
  if (!z.equals(Buffer$D.from([Y])))
    throw new Error(
      `Format Error: Invalid ${B} key: ${z.toString("hex")}`
    );
}
fromBuffer.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(B, { globalMapKeyVals: z, inputKeyVals: Y, outputKeyVals: ne }) {
  const ie = {
    unsignedTx: B
  };
  let oe = 0;
  for (const le of z)
    switch (le.key[0]) {
      case typeFields_1$1.GlobalTypes.UNSIGNED_TX:
        if (checkKeyBuffer(
          "global",
          le.key,
          typeFields_1$1.GlobalTypes.UNSIGNED_TX
        ), oe > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        oe++;
        break;
      case typeFields_1$1.GlobalTypes.GLOBAL_XPUB:
        ie.globalXpub === void 0 && (ie.globalXpub = []), ie.globalXpub.push(convert$1.globals.globalXpub.decode(le));
        break;
      default:
        ie.unknownKeyVals || (ie.unknownKeyVals = []), ie.unknownKeyVals.push(le);
    }
  const se = Y.length, ae = ne.length, ve = [], Pe = [];
  for (const le of tools_1$1.range(se)) {
    const Ee = {};
    for (const Je of Y[le])
      switch (convert$1.inputs.checkPubkey(Je), Je.key[0]) {
        case typeFields_1$1.InputTypes.NON_WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.NON_WITNESS_UTXO
          ), Ee.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          Ee.nonWitnessUtxo = convert$1.inputs.nonWitnessUtxo.decode(Je);
          break;
        case typeFields_1$1.InputTypes.WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.WITNESS_UTXO
          ), Ee.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          Ee.witnessUtxo = convert$1.inputs.witnessUtxo.decode(Je);
          break;
        case typeFields_1$1.InputTypes.PARTIAL_SIG:
          Ee.partialSig === void 0 && (Ee.partialSig = []), Ee.partialSig.push(convert$1.inputs.partialSig.decode(Je));
          break;
        case typeFields_1$1.InputTypes.SIGHASH_TYPE:
          if (checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.SIGHASH_TYPE
          ), Ee.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          Ee.sighashType = convert$1.inputs.sighashType.decode(Je);
          break;
        case typeFields_1$1.InputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.REDEEM_SCRIPT
          ), Ee.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          Ee.redeemScript = convert$1.inputs.redeemScript.decode(Je);
          break;
        case typeFields_1$1.InputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.WITNESS_SCRIPT
          ), Ee.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          Ee.witnessScript = convert$1.inputs.witnessScript.decode(Je);
          break;
        case typeFields_1$1.InputTypes.BIP32_DERIVATION:
          Ee.bip32Derivation === void 0 && (Ee.bip32Derivation = []), Ee.bip32Derivation.push(
            convert$1.inputs.bip32Derivation.decode(Je)
          );
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTSIG
          ), Ee.finalScriptSig = convert$1.inputs.finalScriptSig.decode(Je);
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS
          ), Ee.finalScriptWitness = convert$1.inputs.finalScriptWitness.decode(
            Je
          );
          break;
        case typeFields_1$1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.POR_COMMITMENT
          ), Ee.porCommitment = convert$1.inputs.porCommitment.decode(Je);
          break;
        case typeFields_1$1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.TAP_KEY_SIG
          ), Ee.tapKeySig = convert$1.inputs.tapKeySig.decode(Je);
          break;
        case typeFields_1$1.InputTypes.TAP_SCRIPT_SIG:
          Ee.tapScriptSig === void 0 && (Ee.tapScriptSig = []), Ee.tapScriptSig.push(convert$1.inputs.tapScriptSig.decode(Je));
          break;
        case typeFields_1$1.InputTypes.TAP_LEAF_SCRIPT:
          Ee.tapLeafScript === void 0 && (Ee.tapLeafScript = []), Ee.tapLeafScript.push(convert$1.inputs.tapLeafScript.decode(Je));
          break;
        case typeFields_1$1.InputTypes.TAP_BIP32_DERIVATION:
          Ee.tapBip32Derivation === void 0 && (Ee.tapBip32Derivation = []), Ee.tapBip32Derivation.push(
            convert$1.inputs.tapBip32Derivation.decode(Je)
          );
          break;
        case typeFields_1$1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.TAP_INTERNAL_KEY
          ), Ee.tapInternalKey = convert$1.inputs.tapInternalKey.decode(Je);
          break;
        case typeFields_1$1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.TAP_MERKLE_ROOT
          ), Ee.tapMerkleRoot = convert$1.inputs.tapMerkleRoot.decode(Je);
          break;
        default:
          Ee.unknownKeyVals || (Ee.unknownKeyVals = []), Ee.unknownKeyVals.push(Je);
      }
    ve.push(Ee);
  }
  for (const le of tools_1$1.range(ae)) {
    const Ee = {};
    for (const Je of ne[le])
      switch (convert$1.outputs.checkPubkey(Je), Je.key[0]) {
        case typeFields_1$1.OutputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "output",
            Je.key,
            typeFields_1$1.OutputTypes.REDEEM_SCRIPT
          ), Ee.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          Ee.redeemScript = convert$1.outputs.redeemScript.decode(Je);
          break;
        case typeFields_1$1.OutputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "output",
            Je.key,
            typeFields_1$1.OutputTypes.WITNESS_SCRIPT
          ), Ee.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          Ee.witnessScript = convert$1.outputs.witnessScript.decode(Je);
          break;
        case typeFields_1$1.OutputTypes.BIP32_DERIVATION:
          Ee.bip32Derivation === void 0 && (Ee.bip32Derivation = []), Ee.bip32Derivation.push(
            convert$1.outputs.bip32Derivation.decode(Je)
          );
          break;
        case typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "output",
            Je.key,
            typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY
          ), Ee.tapInternalKey = convert$1.outputs.tapInternalKey.decode(Je);
          break;
        case typeFields_1$1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            "output",
            Je.key,
            typeFields_1$1.OutputTypes.TAP_TREE
          ), Ee.tapTree = convert$1.outputs.tapTree.decode(Je);
          break;
        case typeFields_1$1.OutputTypes.TAP_BIP32_DERIVATION:
          Ee.tapBip32Derivation === void 0 && (Ee.tapBip32Derivation = []), Ee.tapBip32Derivation.push(
            convert$1.outputs.tapBip32Derivation.decode(Je)
          );
          break;
        default:
          Ee.unknownKeyVals || (Ee.unknownKeyVals = []), Ee.unknownKeyVals.push(Je);
      }
    Pe.push(Ee);
  }
  return { globalMap: ie, inputs: ve, outputs: Pe };
}
fromBuffer.psbtFromKeyVals = psbtFromKeyVals;
var toBuffer = {};
Object.defineProperty(toBuffer, "__esModule", { value: !0 });
const convert = converter, tools_1 = tools;
function psbtToBuffer({ globalMap: B, inputs: z, outputs: Y }) {
  const { globalKeyVals: ne, inputKeyVals: ie, outputKeyVals: oe } = psbtToKeyVals({
    globalMap: B,
    inputs: z,
    outputs: Y
  }), se = tools_1.keyValsToBuffer(ne), ae = (Ee) => Ee.length === 0 ? [Buffer$D.from([0])] : Ee.map(tools_1.keyValsToBuffer), ve = ae(ie), Pe = ae(oe), le = Buffer$D.allocUnsafe(5);
  return le.writeUIntBE(482972169471, 0, 5), Buffer$D.concat(
    [le, se].concat(ve, Pe)
  );
}
toBuffer.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (B, z) => B.key.compare(z.key);
function keyValsFromMap(B, z) {
  const Y = /* @__PURE__ */ new Set(), ne = Object.entries(B).reduce((oe, [se, ae]) => {
    if (se === "unknownKeyVals") return oe;
    const ve = z[se];
    if (ve === void 0) return oe;
    const Pe = (Array.isArray(ae) ? ae : [ae]).map(
      ve.encode
    );
    return Pe.map((Ee) => Ee.key.toString("hex")).forEach((Ee) => {
      if (Y.has(Ee))
        throw new Error("Serialize Error: Duplicate key: " + Ee);
      Y.add(Ee);
    }), oe.concat(Pe);
  }, []), ie = B.unknownKeyVals ? B.unknownKeyVals.filter((oe) => !Y.has(oe.key.toString("hex"))) : [];
  return ne.concat(ie).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap: B, inputs: z, outputs: Y }) {
  return {
    globalKeyVals: keyValsFromMap(B, convert.globals),
    inputKeyVals: z.map((ne) => keyValsFromMap(ne, convert.inputs)),
    outputKeyVals: Y.map((ne) => keyValsFromMap(ne, convert.outputs))
  };
}
toBuffer.psbtToKeyVals = psbtToKeyVals;
(function(B) {
  function z(Y) {
    for (var ne in Y) B.hasOwnProperty(ne) || (B[ne] = Y[ne]);
  }
  Object.defineProperty(B, "__esModule", { value: !0 }), z(fromBuffer), z(toBuffer);
})(parser);
Object.defineProperty(combiner, "__esModule", { value: !0 });
const parser_1$1 = parser;
function combine(B) {
  const z = B[0], Y = parser_1$1.psbtToKeyVals(z), ne = B.slice(1);
  if (ne.length === 0) throw new Error("Combine: Nothing to combine");
  const ie = getTx(z);
  if (ie === void 0)
    throw new Error("Combine: Self missing transaction");
  const oe = getKeySet(Y.globalKeyVals), se = Y.inputKeyVals.map(getKeySet), ae = Y.outputKeyVals.map(getKeySet);
  for (const ve of ne) {
    const Pe = getTx(ve);
    if (Pe === void 0 || !Pe.toBuffer().equals(ie.toBuffer()))
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const le = parser_1$1.psbtToKeyVals(ve);
    getKeySet(le.globalKeyVals).forEach(
      keyPusher(
        oe,
        Y.globalKeyVals,
        le.globalKeyVals
      )
    ), le.inputKeyVals.map(getKeySet).forEach(
      (_t, kt) => _t.forEach(
        keyPusher(
          se[kt],
          Y.inputKeyVals[kt],
          le.inputKeyVals[kt]
        )
      )
    ), le.outputKeyVals.map(getKeySet).forEach(
      (_t, kt) => _t.forEach(
        keyPusher(
          ae[kt],
          Y.outputKeyVals[kt],
          le.outputKeyVals[kt]
        )
      )
    );
  }
  return parser_1$1.psbtFromKeyVals(ie, {
    globalMapKeyVals: Y.globalKeyVals,
    inputKeyVals: Y.inputKeyVals,
    outputKeyVals: Y.outputKeyVals
  });
}
combiner.combine = combine;
function keyPusher(B, z, Y) {
  return (ne) => {
    if (B.has(ne)) return;
    const ie = Y.filter((oe) => oe.key.toString("hex") === ne)[0];
    z.push(ie), B.add(ne);
  };
}
function getTx(B) {
  return B.globalMap.unsignedTx;
}
function getKeySet(B) {
  const z = /* @__PURE__ */ new Set();
  return B.forEach((Y) => {
    const ne = Y.key.toString("hex");
    if (z.has(ne))
      throw new Error("Combine: KeyValue Map keys should be unique");
    z.add(ne);
  }), z;
}
var utils = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 });
  const z = converter;
  function Y(Ce, _t) {
    const kt = Ce[_t];
    if (kt === void 0) throw new Error(`No input #${_t}`);
    return kt;
  }
  B.checkForInput = Y;
  function ne(Ce, _t) {
    const kt = Ce[_t];
    if (kt === void 0) throw new Error(`No output #${_t}`);
    return kt;
  }
  B.checkForOutput = ne;
  function ie(Ce, _t, kt) {
    if (Ce.key[0] < kt)
      throw new Error(
        "Use the method for your specific key instead of addUnknownKeyVal*"
      );
    if (_t && _t.filter((Ct) => Ct.key.equals(Ce.key)).length !== 0)
      throw new Error(`Duplicate Key: ${Ce.key.toString("hex")}`);
  }
  B.checkHasKey = ie;
  function oe(Ce) {
    let _t = 0;
    return Object.keys(Ce).forEach((kt) => {
      Number(isNaN(Number(kt))) && _t++;
    }), _t;
  }
  B.getEnumLength = oe;
  function se(Ce, _t) {
    let kt = !1;
    if (_t.nonWitnessUtxo || _t.witnessUtxo) {
      const Ct = !!_t.redeemScript, Lt = !!_t.witnessScript, Pt = !Ct || !!_t.finalScriptSig, Ft = !Lt || !!_t.finalScriptWitness, Ut = !!_t.finalScriptSig || !!_t.finalScriptWitness;
      kt = Pt && Ft && Ut;
    }
    if (kt === !1)
      throw new Error(
        `Input #${Ce} has too much or too little data to clean`
      );
  }
  B.inputCheckUncleanFinalized = se;
  function ae(Ce, _t, kt, Ct) {
    throw new Error(
      `Data for ${Ce} key ${_t} is incorrect: Expected ${kt} and got ${JSON.stringify(Ct)}`
    );
  }
  function ve(Ce) {
    return (_t, kt) => {
      for (const Ct of Object.keys(_t)) {
        const Lt = _t[Ct], { canAdd: Pt, canAddToArray: Ft, check: Ut, expected: Jt } = (
          // @ts-ignore
          z[Ce + "s"][Ct] || {}
        ), Vt = !!Ft;
        if (Ut)
          if (Vt) {
            if (!Array.isArray(Lt) || // @ts-ignore
            kt[Ct] && !Array.isArray(kt[Ct]))
              throw new Error(`Key type ${Ct} must be an array`);
            Lt.every(Ut) || ae(Ce, Ct, Jt, Lt);
            const ir = kt[Ct] || [], jt = /* @__PURE__ */ new Set();
            if (!Lt.every((Rt) => Ft(ir, Rt, jt)))
              throw new Error("Can not add duplicate data to array");
            kt[Ct] = ir.concat(Lt);
          } else {
            if (Ut(Lt) || ae(Ce, Ct, Jt, Lt), !Pt(kt, Lt))
              throw new Error(`Can not add duplicate data to ${Ce}`);
            kt[Ct] = Lt;
          }
      }
    };
  }
  B.updateGlobal = ve("global"), B.updateInput = ve("input"), B.updateOutput = ve("output");
  function Pe(Ce, _t) {
    const kt = Ce.length - 1, Ct = Y(Ce, kt);
    B.updateInput(_t, Ct);
  }
  B.addInputAttributes = Pe;
  function le(Ce, _t) {
    const kt = Ce.length - 1, Ct = ne(Ce, kt);
    B.updateOutput(_t, Ct);
  }
  B.addOutputAttributes = le;
  function Ee(Ce, _t) {
    if (!Buffer$D.isBuffer(_t) || _t.length < 4)
      throw new Error("Set Version: Invalid Transaction");
    return _t.writeUInt32LE(Ce, 0), _t;
  }
  B.defaultVersionSetter = Ee;
  function Je(Ce, _t) {
    if (!Buffer$D.isBuffer(_t) || _t.length < 4)
      throw new Error("Set Locktime: Invalid Transaction");
    return _t.writeUInt32LE(Ce, _t.length - 4), _t;
  }
  B.defaultLocktimeSetter = Je;
})(utils);
Object.defineProperty(psbt, "__esModule", { value: !0 });
const combiner_1 = combiner, parser_1 = parser, typeFields_1 = typeFields, utils_1$1 = utils;
let Psbt$1 = class {
  constructor(z) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: z
    };
  }
  static fromBase64(z, Y) {
    const ne = Buffer$D.from(z, "base64");
    return this.fromBuffer(ne, Y);
  }
  static fromHex(z, Y) {
    const ne = Buffer$D.from(z, "hex");
    return this.fromBuffer(ne, Y);
  }
  static fromBuffer(z, Y) {
    const ne = parser_1.psbtFromBuffer(z, Y), ie = new this(ne.globalMap.unsignedTx);
    return Object.assign(ie, ne), ie;
  }
  toBase64() {
    return this.toBuffer().toString("base64");
  }
  toHex() {
    return this.toBuffer().toString("hex");
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(z) {
    return utils_1$1.updateGlobal(z, this.globalMap), this;
  }
  updateInput(z, Y) {
    const ne = utils_1$1.checkForInput(this.inputs, z);
    return utils_1$1.updateInput(Y, ne), this;
  }
  updateOutput(z, Y) {
    const ne = utils_1$1.checkForOutput(this.outputs, z);
    return utils_1$1.updateOutput(Y, ne), this;
  }
  addUnknownKeyValToGlobal(z) {
    return utils_1$1.checkHasKey(
      z,
      this.globalMap.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.GlobalTypes)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(z), this;
  }
  addUnknownKeyValToInput(z, Y) {
    const ne = utils_1$1.checkForInput(this.inputs, z);
    return utils_1$1.checkHasKey(
      Y,
      ne.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.InputTypes)
    ), ne.unknownKeyVals || (ne.unknownKeyVals = []), ne.unknownKeyVals.push(Y), this;
  }
  addUnknownKeyValToOutput(z, Y) {
    const ne = utils_1$1.checkForOutput(this.outputs, z);
    return utils_1$1.checkHasKey(
      Y,
      ne.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.OutputTypes)
    ), ne.unknownKeyVals || (ne.unknownKeyVals = []), ne.unknownKeyVals.push(Y), this;
  }
  addInput(z) {
    this.globalMap.unsignedTx.addInput(z), this.inputs.push({
      unknownKeyVals: []
    });
    const Y = z.unknownKeyVals || [], ne = this.inputs.length - 1;
    if (!Array.isArray(Y))
      throw new Error("unknownKeyVals must be an Array");
    return Y.forEach(
      (ie) => this.addUnknownKeyValToInput(ne, ie)
    ), utils_1$1.addInputAttributes(this.inputs, z), this;
  }
  addOutput(z) {
    this.globalMap.unsignedTx.addOutput(z), this.outputs.push({
      unknownKeyVals: []
    });
    const Y = z.unknownKeyVals || [], ne = this.outputs.length - 1;
    if (!Array.isArray(Y))
      throw new Error("unknownKeyVals must be an Array");
    return Y.forEach(
      (ie) => this.addUnknownKeyValToOutput(ne, ie)
    ), utils_1$1.addOutputAttributes(this.outputs, z), this;
  }
  clearFinalizedInput(z) {
    const Y = utils_1$1.checkForInput(this.inputs, z);
    utils_1$1.inputCheckUncleanFinalized(z, Y);
    for (const ne of Object.keys(Y))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(ne) || delete Y[ne];
    return this;
  }
  combine(...z) {
    const Y = combiner_1.combine([this].concat(z));
    return Object.assign(this, Y), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
psbt.Psbt = Psbt$1;
var bip371 = {}, psbtutils = {};
Object.defineProperty(psbtutils, "__esModule", { value: !0 });
psbtutils.signatureBlocksAction = psbtutils.checkInputForSig = psbtutils.pubkeyInScript = psbtutils.pubkeyPositionInScript = psbtutils.witnessStackToScriptWitness = psbtutils.isP2TR = psbtutils.isP2SHScript = psbtutils.isP2WSHScript = psbtutils.isP2WPKH = psbtutils.isP2PKH = psbtutils.isP2PK = psbtutils.isP2MS = void 0;
const varuint$1 = varint, bscript$1 = requireScript(), transaction_1$2 = transaction, crypto_1 = crypto$1, payments$1 = requirePayments();
function isPaymentFactory(B) {
  return (z) => {
    try {
      return B({ output: z }), !0;
    } catch {
      return !1;
    }
  };
}
psbtutils.isP2MS = isPaymentFactory(payments$1.p2ms);
psbtutils.isP2PK = isPaymentFactory(payments$1.p2pk);
psbtutils.isP2PKH = isPaymentFactory(payments$1.p2pkh);
psbtutils.isP2WPKH = isPaymentFactory(payments$1.p2wpkh);
psbtutils.isP2WSHScript = isPaymentFactory(payments$1.p2wsh);
psbtutils.isP2SHScript = isPaymentFactory(payments$1.p2sh);
psbtutils.isP2TR = isPaymentFactory(payments$1.p2tr);
function witnessStackToScriptWitness(B) {
  let z = Buffer$D.allocUnsafe(0);
  function Y(se) {
    z = Buffer$D.concat([z, Buffer$D.from(se)]);
  }
  function ne(se) {
    const ae = z.length, ve = varuint$1.encodingLength(se);
    z = Buffer$D.concat([z, Buffer$D.allocUnsafe(ve)]), varuint$1.encode(se, z, ae);
  }
  function ie(se) {
    ne(se.length), Y(se);
  }
  function oe(se) {
    ne(se.length), se.forEach(ie);
  }
  return oe(B), z;
}
psbtutils.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(B, z) {
  const Y = (0, crypto_1.hash160)(B), ne = B.slice(1, 33), ie = bscript$1.decompile(z);
  if (ie === null) throw new Error("Unknown script error");
  return ie.findIndex((oe) => typeof oe == "number" ? !1 : oe.equals(B) || oe.equals(Y) || oe.equals(ne));
}
psbtutils.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(B, z) {
  return pubkeyPositionInScript(B, z) !== -1;
}
psbtutils.pubkeyInScript = pubkeyInScript;
function checkInputForSig(B, z) {
  return extractPartialSigs(B).some(
    (ne) => signatureBlocksAction(ne, bscript$1.signature.decode, z)
  );
}
psbtutils.checkInputForSig = checkInputForSig;
function signatureBlocksAction(B, z, Y) {
  const { hashType: ne } = z(B), ie = [];
  switch (ne & transaction_1$2.Transaction.SIGHASH_ANYONECANPAY && ie.push("addInput"), ne & 31) {
    case transaction_1$2.Transaction.SIGHASH_ALL:
      break;
    case transaction_1$2.Transaction.SIGHASH_SINGLE:
    case transaction_1$2.Transaction.SIGHASH_NONE:
      ie.push("addOutput"), ie.push("setInputSequence");
      break;
  }
  return ie.indexOf(Y) === -1;
}
psbtutils.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(B) {
  let z = [];
  if ((B.partialSig || []).length === 0) {
    if (!B.finalScriptSig && !B.finalScriptWitness) return [];
    z = getPsigsFromInputFinalScripts(B);
  } else
    z = B.partialSig;
  return z.map((Y) => Y.signature);
}
function getPsigsFromInputFinalScripts(B) {
  const z = B.finalScriptSig ? bscript$1.decompile(B.finalScriptSig) || [] : [], Y = B.finalScriptWitness ? bscript$1.decompile(B.finalScriptWitness) || [] : [];
  return z.concat(Y).filter((ne) => Buffer$D.isBuffer(ne) && bscript$1.isCanonicalScriptSignature(ne)).map((ne) => ({ signature: ne }));
}
Object.defineProperty(bip371, "__esModule", { value: !0 });
bip371.checkTaprootInputForSigs = bip371.tapTreeFromList = bip371.tapTreeToList = bip371.tweakInternalPubKey = bip371.checkTaprootOutputFields = bip371.checkTaprootInputFields = bip371.isTaprootOutput = bip371.isTaprootInput = bip371.serializeTaprootSignature = bip371.tapScriptFinalizer = bip371.toXOnly = void 0;
const types_1 = types$4, transaction_1$1 = transaction, psbtutils_1$1 = psbtutils, bip341_1$1 = bip341, payments_1 = requirePayments(), psbtutils_2 = psbtutils, toXOnly = (B) => B.length === 32 ? B : B.slice(1, 33);
bip371.toXOnly = toXOnly;
function tapScriptFinalizer(B, z, Y) {
  const ne = findTapLeafToFinalize(
    z,
    B,
    Y
  );
  try {
    const oe = sortSignatures(z, ne).concat(ne.script).concat(ne.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1$1.witnessStackToScriptWitness)(oe)
    };
  } catch (ie) {
    throw new Error(`Can not finalize taproot input #${B}: ${ie}`);
  }
}
bip371.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(B, z) {
  const Y = z ? Buffer$D.from([z]) : Buffer$D.from([]);
  return Buffer$D.concat([B, Y]);
}
bip371.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(B) {
  return B && !!(B.tapInternalKey || B.tapMerkleRoot || B.tapLeafScript && B.tapLeafScript.length || B.tapBip32Derivation && B.tapBip32Derivation.length || B.witnessUtxo && (0, psbtutils_1$1.isP2TR)(B.witnessUtxo.script));
}
bip371.isTaprootInput = isTaprootInput;
function isTaprootOutput(B, z) {
  return B && !!(B.tapInternalKey || B.tapTree || B.tapBip32Derivation && B.tapBip32Derivation.length || z && (0, psbtutils_1$1.isP2TR)(z));
}
bip371.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(B, z, Y) {
  checkMixedTaprootAndNonTaprootInputFields(B, z, Y), checkIfTapLeafInTree(B, z, Y);
}
bip371.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(B, z, Y) {
  checkMixedTaprootAndNonTaprootOutputFields(B, z, Y), checkTaprootScriptPubkey(B, z);
}
bip371.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(B, z) {
  if (!z.tapTree && !z.tapInternalKey) return;
  const Y = z.tapInternalKey || B.tapInternalKey, ne = z.tapTree || B.tapTree;
  if (Y) {
    const { script: ie } = B, oe = getTaprootScripPubkey(Y, ne);
    if (ie && !ie.equals(oe))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function getTaprootScripPubkey(B, z) {
  const Y = z && tapTreeFromList(z.leaves), { output: ne } = (0, payments_1.p2tr)({
    internalPubkey: B,
    scriptTree: Y
  });
  return ne;
}
function tweakInternalPubKey(B, z) {
  const Y = z.tapInternalKey, ne = Y && (0, bip341_1$1.tweakKey)(Y, z.tapMerkleRoot);
  if (!ne)
    throw new Error(
      `Cannot tweak tap internal key for input #${B}. Public key: ${Y && Y.toString("hex")}`
    );
  return ne.x;
}
bip371.tweakInternalPubKey = tweakInternalPubKey;
function tapTreeToList(B) {
  if (!(0, types_1.isTaptree)(B))
    throw new Error(
      "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
    );
  return _tapTreeToList(B);
}
bip371.tapTreeToList = tapTreeToList;
function tapTreeFromList(B = []) {
  return B.length === 1 && B[0].depth === 0 ? {
    output: B[0].script,
    version: B[0].leafVersion
  } : instertLeavesInTree(B);
}
bip371.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(B, z) {
  return extractTaprootSigs(B).some(
    (ne) => (0, psbtutils_2.signatureBlocksAction)(ne, decodeSchnorrSignature, z)
  );
}
bip371.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(B) {
  return {
    signature: B.slice(0, 64),
    hashType: B.slice(64)[0] || transaction_1$1.Transaction.SIGHASH_DEFAULT
  };
}
function extractTaprootSigs(B) {
  const z = [];
  if (B.tapKeySig && z.push(B.tapKeySig), B.tapScriptSig && z.push(...B.tapScriptSig.map((Y) => Y.signature)), !z.length) {
    const Y = getTapKeySigFromWithness(B.finalScriptWitness);
    Y && z.push(Y);
  }
  return z;
}
function getTapKeySigFromWithness(B) {
  if (!B) return;
  const z = B.slice(2);
  if (z.length === 64 || z.length === 65) return z;
}
function _tapTreeToList(B, z = [], Y = 0) {
  if (Y > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  return B ? (0, types_1.isTapleaf)(B) ? (z.push({
    depth: Y,
    leafVersion: B.version || bip341_1$1.LEAF_VERSION_TAPSCRIPT,
    script: B.output
  }), z) : (B[0] && _tapTreeToList(B[0], z, Y + 1), B[1] && _tapTreeToList(B[1], z, Y + 1), z) : [];
}
function instertLeavesInTree(B) {
  let z;
  for (const Y of B)
    if (z = instertLeafInTree(Y, z), !z) throw new Error("No room left to insert tapleaf in tree");
  return z;
}
function instertLeafInTree(B, z, Y = 0) {
  if (Y > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  if (B.depth === Y)
    return z ? void 0 : {
      output: B.script,
      version: B.leafVersion
    };
  if ((0, types_1.isTapleaf)(z)) return;
  const ne = instertLeafInTree(B, z && z[0], Y + 1);
  if (ne) return [ne, z && z[1]];
  const ie = instertLeafInTree(B, z && z[1], Y + 1);
  if (ie) return [z && z[0], ie];
}
function checkMixedTaprootAndNonTaprootInputFields(B, z, Y) {
  const ne = isTaprootInput(B) && hasNonTaprootFields(z), ie = hasNonTaprootFields(B) && isTaprootInput(z), oe = B === z && isTaprootInput(z) && hasNonTaprootFields(z);
  if (ne || ie || oe)
    throw new Error(
      `Invalid arguments for Psbt.${Y}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(B, z, Y) {
  const ne = isTaprootOutput(B) && hasNonTaprootFields(z), ie = hasNonTaprootFields(B) && isTaprootOutput(z), oe = B === z && isTaprootOutput(z) && hasNonTaprootFields(z);
  if (ne || ie || oe)
    throw new Error(
      `Invalid arguments for Psbt.${Y}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkIfTapLeafInTree(B, z, Y) {
  if (z.tapMerkleRoot) {
    const ne = (z.tapLeafScript || []).every(
      (oe) => isTapLeafInTree(oe, z.tapMerkleRoot)
    ), ie = (B.tapLeafScript || []).every(
      (oe) => isTapLeafInTree(oe, z.tapMerkleRoot)
    );
    if (!ne || !ie)
      throw new Error(
        `Invalid arguments for Psbt.${Y}. Tapleaf not part of taptree.`
      );
  } else if (B.tapMerkleRoot && !(z.tapLeafScript || []).every(
    (ie) => isTapLeafInTree(ie, B.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${Y}. Tapleaf not part of taptree.`
    );
}
function isTapLeafInTree(B, z) {
  if (!z) return !0;
  const Y = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (0, bip341_1$1.rootHashFromPath)(
    B.controlBlock,
    Y
  ).equals(z);
}
function sortSignatures(B, z) {
  const Y = (0, bip341_1$1.tapleafHash)({
    output: z.script,
    version: z.leafVersion
  });
  return (B.tapScriptSig || []).filter((ne) => ne.leafHash.equals(Y)).map((ne) => addPubkeyPositionInScript(z.script, ne)).sort((ne, ie) => ie.positionInScript - ne.positionInScript).map((ne) => ne.signature);
}
function addPubkeyPositionInScript(B, z) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1$1.pubkeyPositionInScript)(
        z.pubkey,
        B
      )
    },
    z
  );
}
function findTapLeafToFinalize(B, z, Y) {
  if (!B.tapScriptSig || !B.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${z}. No tapleaf script signature provided.`
    );
  const ne = (B.tapLeafScript || []).sort((ie, oe) => ie.controlBlock.length - oe.controlBlock.length).find(
    (ie) => canFinalizeLeaf(ie, B.tapScriptSig, Y)
  );
  if (!ne)
    throw new Error(
      `Can not finalize taproot input #${z}. Signature for tapleaf script not found.`
    );
  return ne;
}
function canFinalizeLeaf(B, z, Y) {
  const ne = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (!Y || Y.equals(ne)) && z.find((oe) => oe.leafHash.equals(ne)) !== void 0;
}
function hasNonTaprootFields(B) {
  return B && !!(B.redeemScript || B.witnessScript || B.bip32Derivation && B.bip32Derivation.length);
}
Object.defineProperty(psbt$1, "__esModule", { value: !0 });
psbt$1.Psbt = void 0;
const bip174_1 = psbt, varuint = varint, utils_1 = utils, address_1 = requireAddress(), bufferutils_1 = bufferutils, networks_1 = networks, payments = requirePayments(), bip341_1 = bip341, bscript = requireScript(), transaction_1 = transaction, bip371_1 = bip371, psbtutils_1 = psbtutils, DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Psbt {
  static fromBase64(z, Y = {}) {
    const ne = Buffer$D.from(z, "base64");
    return this.fromBuffer(ne, Y);
  }
  static fromHex(z, Y = {}) {
    const ne = Buffer$D.from(z, "hex");
    return this.fromBuffer(ne, Y);
  }
  static fromBuffer(z, Y = {}) {
    const ne = bip174_1.Psbt.fromBuffer(z, transactionFromBuffer), ie = new Psbt(Y, ne);
    return checkTxForDupeIns(ie.__CACHE.__TX, ie.__CACHE), ie;
  }
  constructor(z = {}, Y = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = Y, this.opts = Object.assign({}, DEFAULT_OPTS, z), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const ne = (ie, oe, se, ae) => Object.defineProperty(ie, oe, {
      enumerable: se,
      writable: ae
    });
    ne(this, "__CACHE", !1, !0), ne(this, "opts", !1, !0);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(z) {
    this.setVersion(z);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(z) {
    this.setLocktime(z);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((z) => ({
      hash: (0, bufferutils_1.cloneBuffer)(z.hash),
      index: z.index,
      sequence: z.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((z) => {
      let Y;
      try {
        Y = (0, address_1.fromOutputScript)(
          z.script,
          this.opts.network
        );
      } catch {
      }
      return {
        script: (0, bufferutils_1.cloneBuffer)(z.script),
        value: z.value,
        address: Y
      };
    });
  }
  combine(...z) {
    return this.data.combine(...z.map((Y) => Y.data)), this;
  }
  clone() {
    const z = Psbt.fromBuffer(this.data.toBuffer());
    return z.opts = JSON.parse(JSON.stringify(this.opts)), z;
  }
  setMaximumFeeRate(z) {
    check32Bit(z), this.opts.maximumFeeRate = z;
  }
  setVersion(z) {
    check32Bit(z), checkInputsForPartialSig(this.data.inputs, "setVersion");
    const Y = this.__CACHE;
    return Y.__TX.version = z, Y.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(z) {
    check32Bit(z), checkInputsForPartialSig(this.data.inputs, "setLocktime");
    const Y = this.__CACHE;
    return Y.__TX.locktime = z, Y.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(z, Y) {
    check32Bit(Y), checkInputsForPartialSig(this.data.inputs, "setInputSequence");
    const ne = this.__CACHE;
    if (ne.__TX.ins.length <= z)
      throw new Error("Input index too high");
    return ne.__TX.ins[z].sequence = Y, ne.__EXTRACTED_TX = void 0, this;
  }
  addInputs(z) {
    return z.forEach((Y) => this.addInput(Y)), this;
  }
  addInput(z) {
    if (arguments.length > 1 || !z || z.hash === void 0 || z.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    (0, bip371_1.checkTaprootInputFields)(z, z, "addInput"), checkInputsForPartialSig(this.data.inputs, "addInput"), z.witnessScript && checkInvalidP2WSH(z.witnessScript);
    const Y = this.__CACHE;
    this.data.addInput(z);
    const ne = Y.__TX.ins[Y.__TX.ins.length - 1];
    checkTxInputCache(Y, ne);
    const ie = this.data.inputs.length - 1, oe = this.data.inputs[ie];
    return oe.nonWitnessUtxo && addNonWitnessTxCache(this.__CACHE, oe, ie), Y.__FEE = void 0, Y.__FEE_RATE = void 0, Y.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(z) {
    return z.forEach((Y) => this.addOutput(Y)), this;
  }
  addOutput(z) {
    if (arguments.length > 1 || !z || z.value === void 0 || z.address === void 0 && z.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    checkInputsForPartialSig(this.data.inputs, "addOutput");
    const { address: Y } = z;
    if (typeof Y == "string") {
      const { network: ie } = this.opts, oe = (0, address_1.toOutputScript)(Y, ie);
      z = Object.assign({}, z, { script: oe });
    }
    (0, bip371_1.checkTaprootOutputFields)(z, z, "addOutput");
    const ne = this.__CACHE;
    return this.data.addOutput(z), ne.__FEE = void 0, ne.__FEE_RATE = void 0, ne.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(z) {
    if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
    const Y = this.__CACHE;
    if (z || checkFees(this, Y, this.opts), Y.__EXTRACTED_TX) return Y.__EXTRACTED_TX;
    const ne = Y.__TX.clone();
    return inputFinalizeGetAmts(this.data.inputs, ne, Y, !0), ne;
  }
  getFeeRate() {
    return getTxCacheValue(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).forEach((z) => this.finalizeInput(z)), this;
  }
  finalizeInput(z, Y) {
    const ne = (0, utils_1.checkForInput)(this.data.inputs, z);
    return (0, bip371_1.isTaprootInput)(ne) ? this._finalizeTaprootInput(
      z,
      ne,
      void 0,
      Y
    ) : this._finalizeInput(z, ne, Y);
  }
  finalizeTaprootInput(z, Y, ne = bip371_1.tapScriptFinalizer) {
    const ie = (0, utils_1.checkForInput)(this.data.inputs, z);
    if ((0, bip371_1.isTaprootInput)(ie))
      return this._finalizeTaprootInput(
        z,
        ie,
        Y,
        ne
      );
    throw new Error(`Cannot finalize input #${z}. Not Taproot.`);
  }
  _finalizeInput(z, Y, ne = getFinalScripts) {
    const { script: ie, isP2SH: oe, isP2WSH: se, isSegwit: ae } = getScriptFromInput(
      z,
      Y,
      this.__CACHE
    );
    if (!ie) throw new Error(`No script found for input #${z}`);
    checkPartialSigSighashes(Y);
    const { finalScriptSig: ve, finalScriptWitness: Pe } = ne(
      z,
      Y,
      ie,
      ae,
      oe,
      se
    );
    if (ve && this.data.updateInput(z, { finalScriptSig: ve }), Pe && this.data.updateInput(z, { finalScriptWitness: Pe }), !ve && !Pe)
      throw new Error(`Unknown error finalizing input #${z}`);
    return this.data.clearFinalizedInput(z), this;
  }
  _finalizeTaprootInput(z, Y, ne, ie = bip371_1.tapScriptFinalizer) {
    if (!Y.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${z}. Missing withness utxo.`
      );
    if (Y.tapKeySig) {
      const oe = payments.p2tr({
        output: Y.witnessUtxo.script,
        signature: Y.tapKeySig
      }), se = (0, psbtutils_1.witnessStackToScriptWitness)(
        oe.witness
      );
      this.data.updateInput(z, { finalScriptWitness: se });
    } else {
      const { finalScriptWitness: oe } = ie(
        z,
        Y,
        ne
      );
      this.data.updateInput(z, { finalScriptWitness: oe });
    }
    return this.data.clearFinalizedInput(z), this;
  }
  getInputType(z) {
    const Y = (0, utils_1.checkForInput)(this.data.inputs, z), ne = getScriptFromUtxo(z, Y, this.__CACHE), ie = getMeaningfulScript(
      ne,
      z,
      "input",
      Y.redeemScript || redeemFromFinalScriptSig(Y.finalScriptSig),
      Y.witnessScript || redeemFromFinalWitnessScript(Y.finalScriptWitness)
    ), oe = ie.type === "raw" ? "" : ie.type + "-", se = classifyScript(ie.meaningfulScript);
    return oe + se;
  }
  inputHasPubkey(z, Y) {
    const ne = (0, utils_1.checkForInput)(this.data.inputs, z);
    return pubkeyInInput(Y, ne, z, this.__CACHE);
  }
  inputHasHDKey(z, Y) {
    const ne = (0, utils_1.checkForInput)(this.data.inputs, z), ie = bip32DerivationIsMine(Y);
    return !!ne.bip32Derivation && ne.bip32Derivation.some(ie);
  }
  outputHasPubkey(z, Y) {
    const ne = (0, utils_1.checkForOutput)(this.data.outputs, z);
    return pubkeyInOutput(Y, ne, z, this.__CACHE);
  }
  outputHasHDKey(z, Y) {
    const ne = (0, utils_1.checkForOutput)(this.data.outputs, z), ie = bip32DerivationIsMine(Y);
    return !!ne.bip32Derivation && ne.bip32Derivation.some(ie);
  }
  validateSignaturesOfAllInputs(z) {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).map(
      (ne) => this.validateSignaturesOfInput(ne, z)
    ).reduce((ne, ie) => ie === !0 && ne, !0);
  }
  validateSignaturesOfInput(z, Y, ne) {
    const ie = this.data.inputs[z];
    return (0, bip371_1.isTaprootInput)(ie) ? this.validateSignaturesOfTaprootInput(
      z,
      Y,
      ne
    ) : this._validateSignaturesOfInput(z, Y, ne);
  }
  _validateSignaturesOfInput(z, Y, ne) {
    const ie = this.data.inputs[z], oe = (ie || {}).partialSig;
    if (!ie || !oe || oe.length < 1)
      throw new Error("No signatures to validate");
    if (typeof Y != "function")
      throw new Error("Need validator function to validate signatures");
    const se = ne ? oe.filter((Ee) => Ee.pubkey.equals(ne)) : oe;
    if (se.length < 1) throw new Error("No signatures for this pubkey");
    const ae = [];
    let ve, Pe, le;
    for (const Ee of se) {
      const Je = bscript.signature.decode(Ee.signature), { hash: Ce, script: _t } = le !== Je.hashType ? getHashForSig(
        z,
        Object.assign({}, ie, { sighashType: Je.hashType }),
        this.__CACHE,
        !0
      ) : { hash: ve, script: Pe };
      le = Je.hashType, ve = Ce, Pe = _t, checkScriptForPubkey(Ee.pubkey, _t, "verify"), ae.push(Y(Ee.pubkey, Ce, Je.signature));
    }
    return ae.every((Ee) => Ee === !0);
  }
  validateSignaturesOfTaprootInput(z, Y, ne) {
    const ie = this.data.inputs[z], oe = (ie || {}).tapKeySig, se = (ie || {}).tapScriptSig;
    if (!ie && !oe && !(se && !se.length))
      throw new Error("No signatures to validate");
    if (typeof Y != "function")
      throw new Error("Need validator function to validate signatures");
    ne = ne && (0, bip371_1.toXOnly)(ne);
    const ae = ne ? getTaprootHashesForSig(
      z,
      ie,
      this.data.inputs,
      ne,
      this.__CACHE
    ) : getAllTaprootHashesForSig(
      z,
      ie,
      this.data.inputs,
      this.__CACHE
    );
    if (!ae.length) throw new Error("No signatures for this pubkey");
    const ve = ae.find((le) => !le.leafHash);
    let Pe = 0;
    if (oe && ve) {
      if (!Y(
        ve.pubkey,
        ve.hash,
        trimTaprootSig(oe)
      )) return !1;
      Pe++;
    }
    if (se)
      for (const le of se) {
        const Ee = ae.find((Je) => le.pubkey.equals(Je.pubkey));
        if (Ee) {
          if (!Y(
            le.pubkey,
            Ee.hash,
            trimTaprootSig(le.signature)
          )) return !1;
          Pe++;
        }
      }
    return Pe > 0;
  }
  signAllInputsHD(z, Y = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!z || !z.publicKey || !z.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const ne = [];
    for (const ie of range(this.data.inputs.length))
      try {
        this.signInputHD(ie, z, Y), ne.push(!0);
      } catch {
        ne.push(!1);
      }
    if (ne.every((ie) => ie === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(z, Y = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((ne, ie) => {
      if (!z || !z.publicKey || !z.fingerprint)
        return ie(new Error("Need HDSigner to sign input"));
      const oe = [], se = [];
      for (const ae of range(this.data.inputs.length))
        se.push(
          this.signInputHDAsync(ae, z, Y).then(
            () => {
              oe.push(!0);
            },
            () => {
              oe.push(!1);
            }
          )
        );
      return Promise.all(se).then(() => {
        if (oe.every((ae) => ae === !1))
          return ie(new Error("No inputs were signed"));
        ne();
      });
    });
  }
  signInputHD(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!Y || !Y.publicKey || !Y.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return getSignersFromHD(z, this.data.inputs, Y).forEach((oe) => this.signInput(z, oe, ne)), this;
  }
  signInputHDAsync(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((ie, oe) => {
      if (!Y || !Y.publicKey || !Y.fingerprint)
        return oe(new Error("Need HDSigner to sign input"));
      const ae = getSignersFromHD(z, this.data.inputs, Y).map(
        (ve) => this.signInputAsync(z, ve, ne)
      );
      return Promise.all(ae).then(() => {
        ie();
      }).catch(oe);
    });
  }
  signAllInputs(z, Y) {
    if (!z || !z.publicKey)
      throw new Error("Need Signer to sign input");
    const ne = [];
    for (const ie of range(this.data.inputs.length))
      try {
        this.signInput(ie, z, Y), ne.push(!0);
      } catch {
        ne.push(!1);
      }
    if (ne.every((ie) => ie === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(z, Y) {
    return new Promise((ne, ie) => {
      if (!z || !z.publicKey)
        return ie(new Error("Need Signer to sign input"));
      const oe = [], se = [];
      for (const [ae] of this.data.inputs.entries())
        se.push(
          this.signInputAsync(ae, z, Y).then(
            () => {
              oe.push(!0);
            },
            () => {
              oe.push(!1);
            }
          )
        );
      return Promise.all(se).then(() => {
        if (oe.every((ae) => ae === !1))
          return ie(new Error("No inputs were signed"));
        ne();
      });
    });
  }
  signInput(z, Y, ne) {
    if (!Y || !Y.publicKey)
      throw new Error("Need Signer to sign input");
    const ie = (0, utils_1.checkForInput)(this.data.inputs, z);
    return (0, bip371_1.isTaprootInput)(ie) ? this._signTaprootInput(
      z,
      ie,
      Y,
      void 0,
      ne
    ) : this._signInput(z, Y, ne);
  }
  signTaprootInput(z, Y, ne, ie) {
    if (!Y || !Y.publicKey)
      throw new Error("Need Signer to sign input");
    const oe = (0, utils_1.checkForInput)(this.data.inputs, z);
    if ((0, bip371_1.isTaprootInput)(oe))
      return this._signTaprootInput(
        z,
        oe,
        Y,
        ne,
        ie
      );
    throw new Error(`Input #${z} is not of type Taproot.`);
  }
  _signInput(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: ie, sighashType: oe } = getHashAndSighashType(
      this.data.inputs,
      z,
      Y.publicKey,
      this.__CACHE,
      ne
    ), se = [
      {
        pubkey: Y.publicKey,
        signature: bscript.signature.encode(Y.sign(ie), oe)
      }
    ];
    return this.data.updateInput(z, { partialSig: se }), this;
  }
  _signTaprootInput(z, Y, ne, ie, oe = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const se = this.checkTaprootHashesForSig(
      z,
      Y,
      ne,
      ie,
      oe
    ), ae = se.filter((Pe) => !Pe.leafHash).map(
      (Pe) => (0, bip371_1.serializeTaprootSignature)(
        ne.signSchnorr(Pe.hash),
        Y.sighashType
      )
    )[0], ve = se.filter((Pe) => !!Pe.leafHash).map((Pe) => ({
      pubkey: (0, bip371_1.toXOnly)(ne.publicKey),
      signature: (0, bip371_1.serializeTaprootSignature)(
        ne.signSchnorr(Pe.hash),
        Y.sighashType
      ),
      leafHash: Pe.leafHash
    }));
    return ae && this.data.updateInput(z, { tapKeySig: ae }), ve.length && this.data.updateInput(z, { tapScriptSig: ve }), this;
  }
  signInputAsync(z, Y, ne) {
    return Promise.resolve().then(() => {
      if (!Y || !Y.publicKey)
        throw new Error("Need Signer to sign input");
      const ie = (0, utils_1.checkForInput)(this.data.inputs, z);
      return (0, bip371_1.isTaprootInput)(ie) ? this._signTaprootInputAsync(
        z,
        ie,
        Y,
        void 0,
        ne
      ) : this._signInputAsync(z, Y, ne);
    });
  }
  signTaprootInputAsync(z, Y, ne, ie) {
    return Promise.resolve().then(() => {
      if (!Y || !Y.publicKey)
        throw new Error("Need Signer to sign input");
      const oe = (0, utils_1.checkForInput)(this.data.inputs, z);
      if ((0, bip371_1.isTaprootInput)(oe))
        return this._signTaprootInputAsync(
          z,
          oe,
          Y,
          ne,
          ie
        );
      throw new Error(`Input #${z} is not of type Taproot.`);
    });
  }
  _signInputAsync(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: ie, sighashType: oe } = getHashAndSighashType(
      this.data.inputs,
      z,
      Y.publicKey,
      this.__CACHE,
      ne
    );
    return Promise.resolve(Y.sign(ie)).then((se) => {
      const ae = [
        {
          pubkey: Y.publicKey,
          signature: bscript.signature.encode(se, oe)
        }
      ];
      this.data.updateInput(z, { partialSig: ae });
    });
  }
  async _signTaprootInputAsync(z, Y, ne, ie, oe = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const se = this.checkTaprootHashesForSig(
      z,
      Y,
      ne,
      ie,
      oe
    ), ae = [], ve = se.filter((le) => !le.leafHash)[0];
    if (ve) {
      const le = Promise.resolve(
        ne.signSchnorr(ve.hash)
      ).then((Ee) => ({
        tapKeySig: (0, bip371_1.serializeTaprootSignature)(
          Ee,
          Y.sighashType
        )
      }));
      ae.push(le);
    }
    const Pe = se.filter((le) => !!le.leafHash);
    if (Pe.length) {
      const le = Pe.map((Ee) => Promise.resolve(ne.signSchnorr(Ee.hash)).then(
        (Je) => ({ tapScriptSig: [
          {
            pubkey: (0, bip371_1.toXOnly)(ne.publicKey),
            signature: (0, bip371_1.serializeTaprootSignature)(
              Je,
              Y.sighashType
            ),
            leafHash: Ee.leafHash
          }
        ] })
      ));
      ae.push(...le);
    }
    return Promise.all(ae).then((le) => {
      le.forEach((Ee) => this.data.updateInput(z, Ee));
    });
  }
  checkTaprootHashesForSig(z, Y, ne, ie, oe) {
    if (typeof ne.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${z}.`
      );
    const se = getTaprootHashesForSig(
      z,
      Y,
      this.data.inputs,
      ne.publicKey,
      this.__CACHE,
      ie,
      oe
    );
    if (!se || !se.length)
      throw new Error(
        `Can not sign for input #${z} with the key ${ne.publicKey.toString(
          "hex"
        )}`
      );
    return se;
  }
  toBuffer() {
    return checkCache(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return checkCache(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return checkCache(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(z) {
    return this.data.updateGlobal(z), this;
  }
  updateInput(z, Y) {
    return Y.witnessScript && checkInvalidP2WSH(Y.witnessScript), (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[z],
      Y,
      "updateInput"
    ), this.data.updateInput(z, Y), Y.nonWitnessUtxo && addNonWitnessTxCache(
      this.__CACHE,
      this.data.inputs[z],
      z
    ), this;
  }
  updateOutput(z, Y) {
    const ne = this.data.outputs[z];
    return (0, bip371_1.checkTaprootOutputFields)(
      ne,
      Y,
      "updateOutput"
    ), this.data.updateOutput(z, Y), this;
  }
  addUnknownKeyValToGlobal(z) {
    return this.data.addUnknownKeyValToGlobal(z), this;
  }
  addUnknownKeyValToInput(z, Y) {
    return this.data.addUnknownKeyValToInput(z, Y), this;
  }
  addUnknownKeyValToOutput(z, Y) {
    return this.data.addUnknownKeyValToOutput(z, Y), this;
  }
  clearFinalizedInput(z) {
    return this.data.clearFinalizedInput(z), this;
  }
}
psbt$1.Psbt = Psbt;
const transactionFromBuffer = (B) => new PsbtTransaction(B);
class PsbtTransaction {
  constructor(z = Buffer$D.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(z), checkTxEmpty(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(z) {
    if (z.hash === void 0 || z.index === void 0 || !Buffer$D.isBuffer(z.hash) && typeof z.hash != "string" || typeof z.index != "number")
      throw new Error("Error adding input.");
    const Y = typeof z.hash == "string" ? (0, bufferutils_1.reverseBuffer)(Buffer$D.from(z.hash, "hex")) : z.hash;
    this.tx.addInput(Y, z.index, z.sequence);
  }
  addOutput(z) {
    if (z.script === void 0 || z.value === void 0 || !Buffer$D.isBuffer(z.script) || typeof z.value != "number")
      throw new Error("Error adding output.");
    this.tx.addOutput(z.script, z.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(B, z, Y) {
  switch (Y) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, B.partialSig);
    case "multisig":
      const ne = payments.p2ms({ output: z });
      return hasSigs(ne.m, B.partialSig, ne.pubkeys);
    default:
      return !1;
  }
}
function checkCache(B) {
  if (B.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function hasSigs(B, z, Y) {
  if (!z) return !1;
  let ne;
  if (Y ? ne = Y.map((ie) => {
    const oe = compressPubkey(ie);
    return z.find((se) => se.pubkey.equals(oe));
  }).filter((ie) => !!ie) : ne = z, ne.length > B) throw new Error("Too many signatures");
  return ne.length === B;
}
function isFinalized(B) {
  return !!B.finalScriptSig || !!B.finalScriptWitness;
}
function bip32DerivationIsMine(B) {
  return (z) => !(!z.masterFingerprint.equals(B.fingerprint) || !B.derivePath(z.path).publicKey.equals(z.pubkey));
}
function check32Bit(B) {
  if (typeof B != "number" || B !== Math.floor(B) || B > 4294967295 || B < 0)
    throw new Error("Invalid 32 bit integer");
}
function checkFees(B, z, Y) {
  const ne = z.__FEE_RATE || B.getFeeRate(), ie = z.__EXTRACTED_TX.virtualSize(), oe = ne * ie;
  if (ne >= Y.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(oe / 1e8).toFixed(8)} in fees, which is ${ne} satoshi per byte for a transaction with a VSize of ${ie} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function checkInputsForPartialSig(B, z) {
  B.forEach((Y) => {
    if ((0, bip371_1.isTaprootInput)(Y) ? (0, bip371_1.checkTaprootInputForSigs)(Y, z) : (0, psbtutils_1.checkInputForSig)(Y, z))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(B) {
  if (!B.sighashType || !B.partialSig) return;
  const { partialSig: z, sighashType: Y } = B;
  z.forEach((ne) => {
    const { hashType: ie } = bscript.signature.decode(ne.signature);
    if (Y !== ie)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function checkScriptForPubkey(B, z, Y) {
  if (!(0, psbtutils_1.pubkeyInScript)(B, z))
    throw new Error(
      `Can not ${Y} for this input with the key ${B.toString("hex")}`
    );
}
function checkTxEmpty(B) {
  if (!B.ins.every(
    (Y) => Y.script && Y.script.length === 0 && Y.witness && Y.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function checkTxForDupeIns(B, z) {
  B.ins.forEach((Y) => {
    checkTxInputCache(z, Y);
  });
}
function checkTxInputCache(B, z) {
  const Y = (0, bufferutils_1.reverseBuffer)(Buffer$D.from(z.hash)).toString("hex") + ":" + z.index;
  if (B.__TX_IN_CACHE[Y]) throw new Error("Duplicate input detected.");
  B.__TX_IN_CACHE[Y] = 1;
}
function scriptCheckerFactory(B, z) {
  return (Y, ne, ie, oe) => {
    const se = B({
      redeem: { output: ie }
    }).output;
    if (!ne.equals(se))
      throw new Error(
        `${z} for ${oe} #${Y} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script"), checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  "Witness script"
);
function getTxCacheValue(B, z, Y, ne) {
  if (!Y.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${z}`);
  if (B === "__FEE_RATE" && ne.__FEE_RATE) return ne.__FEE_RATE;
  if (B === "__FEE" && ne.__FEE) return ne.__FEE;
  let ie, oe = !0;
  if (ne.__EXTRACTED_TX ? (ie = ne.__EXTRACTED_TX, oe = !1) : ie = ne.__TX.clone(), inputFinalizeGetAmts(Y, ie, ne, oe), B === "__FEE_RATE") return ne.__FEE_RATE;
  if (B === "__FEE") return ne.__FEE;
}
function getFinalScripts(B, z, Y, ne, ie, oe) {
  const se = classifyScript(Y);
  if (!canFinalize(z, Y, se))
    throw new Error(`Can not finalize input #${B}`);
  return prepareFinalScripts(
    Y,
    se,
    z.partialSig,
    ne,
    ie,
    oe
  );
}
function prepareFinalScripts(B, z, Y, ne, ie, oe) {
  let se, ae;
  const ve = getPayment(B, z, Y), Pe = oe ? payments.p2wsh({ redeem: ve }) : null, le = ie ? payments.p2sh({ redeem: Pe || ve }) : null;
  return ne ? (Pe ? ae = (0, psbtutils_1.witnessStackToScriptWitness)(
    Pe.witness
  ) : ae = (0, psbtutils_1.witnessStackToScriptWitness)(
    ve.witness
  ), le && (se = le.input)) : le ? se = le.input : se = ve.input, {
    finalScriptSig: se,
    finalScriptWitness: ae
  };
}
function getHashAndSighashType(B, z, Y, ne, ie) {
  const oe = (0, utils_1.checkForInput)(B, z), { hash: se, sighashType: ae, script: ve } = getHashForSig(
    z,
    oe,
    ne,
    !1,
    ie
  );
  return checkScriptForPubkey(Y, ve, "sign"), {
    hash: se,
    sighashType: ae
  };
}
function getHashForSig(B, z, Y, ne, ie) {
  const oe = Y.__TX, se = z.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(se, ie);
  let ae, ve;
  if (z.nonWitnessUtxo) {
    const Ee = nonWitnessUtxoTxFromCache(
      Y,
      z,
      B
    ), Je = oe.ins[B].hash, Ce = Ee.getHash();
    if (!Je.equals(Ce))
      throw new Error(
        `Non-witness UTXO hash for input #${B} doesn't match the hash specified in the prevout`
      );
    const _t = oe.ins[B].index;
    ve = Ee.outs[_t];
  } else if (z.witnessUtxo)
    ve = z.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: Pe, type: le } = getMeaningfulScript(
    ve.script,
    B,
    "input",
    z.redeemScript,
    z.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(le) >= 0)
    ae = oe.hashForWitnessV0(
      B,
      Pe,
      ve.value,
      se
    );
  else if ((0, psbtutils_1.isP2WPKH)(Pe)) {
    const Ee = payments.p2pkh({
      hash: Pe.slice(2)
    }).output;
    ae = oe.hashForWitnessV0(
      B,
      Ee,
      ve.value,
      se
    );
  } else {
    if (z.nonWitnessUtxo === void 0 && Y.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${B} has witnessUtxo but non-segwit script: ${Pe.toString("hex")}`
      );
    !ne && Y.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), ae = oe.hashForSignature(
      B,
      Pe,
      se
    );
  }
  return {
    script: Pe,
    sighashType: se,
    hash: ae
  };
}
function getAllTaprootHashesForSig(B, z, Y, ne) {
  const ie = [];
  if (z.tapInternalKey) {
    const se = getPrevoutTaprootKey(B, z, ne);
    se && ie.push(se);
  }
  if (z.tapScriptSig) {
    const se = z.tapScriptSig.map((ae) => ae.pubkey);
    ie.push(...se);
  }
  return ie.map(
    (se) => getTaprootHashesForSig(B, z, Y, se, ne)
  ).flat();
}
function getPrevoutTaprootKey(B, z, Y) {
  const { script: ne } = getScriptAndAmountFromUtxo(B, z, Y);
  return (0, psbtutils_1.isP2TR)(ne) ? ne.subarray(2, 34) : null;
}
function trimTaprootSig(B) {
  return B.length === 64 ? B : B.subarray(0, 64);
}
function getTaprootHashesForSig(B, z, Y, ne, ie, oe, se) {
  const ae = ie.__TX, ve = z.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(ve, se);
  const Pe = Y.map(
    (_t, kt) => getScriptAndAmountFromUtxo(kt, _t, ie)
  ), le = Pe.map((_t) => _t.script), Ee = Pe.map((_t) => _t.value), Je = [];
  if (z.tapInternalKey && !oe) {
    const _t = getPrevoutTaprootKey(B, z, ie) || Buffer$D.from([]);
    if ((0, bip371_1.toXOnly)(ne).equals(_t)) {
      const kt = ae.hashForWitnessV1(
        B,
        le,
        Ee,
        ve
      );
      Je.push({ pubkey: ne, hash: kt });
    }
  }
  const Ce = (z.tapLeafScript || []).filter((_t) => (0, psbtutils_1.pubkeyInScript)(ne, _t.script)).map((_t) => {
    const kt = (0, bip341_1.tapleafHash)({
      output: _t.script,
      version: _t.leafVersion
    });
    return Object.assign({ hash: kt }, _t);
  }).filter(
    (_t) => !oe || oe.equals(_t.hash)
  ).map((_t) => {
    const kt = ae.hashForWitnessV1(
      B,
      le,
      Ee,
      ve,
      _t.hash
    );
    return {
      pubkey: ne,
      hash: kt,
      leafHash: _t.hash
    };
  });
  return Je.concat(Ce);
}
function checkSighashTypeAllowed(B, z) {
  if (z && z.indexOf(B) < 0) {
    const Y = sighashTypeToString(B);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${Y}`
    );
  }
}
function getPayment(B, z, Y) {
  let ne;
  switch (z) {
    case "multisig":
      const ie = getSortedSigs(B, Y);
      ne = payments.p2ms({
        output: B,
        signatures: ie
      });
      break;
    case "pubkey":
      ne = payments.p2pk({
        output: B,
        signature: Y[0].signature
      });
      break;
    case "pubkeyhash":
      ne = payments.p2pkh({
        output: B,
        pubkey: Y[0].pubkey,
        signature: Y[0].signature
      });
      break;
    case "witnesspubkeyhash":
      ne = payments.p2wpkh({
        output: B,
        pubkey: Y[0].pubkey,
        signature: Y[0].signature
      });
      break;
  }
  return ne;
}
function getScriptFromInput(B, z, Y) {
  const ne = Y.__TX, ie = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (ie.isP2SH = !!z.redeemScript, ie.isP2WSH = !!z.witnessScript, z.witnessScript)
    ie.script = z.witnessScript;
  else if (z.redeemScript)
    ie.script = z.redeemScript;
  else if (z.nonWitnessUtxo) {
    const oe = nonWitnessUtxoTxFromCache(
      Y,
      z,
      B
    ), se = ne.ins[B].index;
    ie.script = oe.outs[se].script;
  } else z.witnessUtxo && (ie.script = z.witnessUtxo.script);
  return (z.witnessScript || (0, psbtutils_1.isP2WPKH)(ie.script)) && (ie.isSegwit = !0), ie;
}
function getSignersFromHD(B, z, Y) {
  const ne = (0, utils_1.checkForInput)(z, B);
  if (!ne.bip32Derivation || ne.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const ie = ne.bip32Derivation.map((se) => {
    if (se.masterFingerprint.equals(Y.fingerprint))
      return se;
  }).filter((se) => !!se);
  if (ie.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return ie.map((se) => {
    const ae = Y.derivePath(se.path);
    if (!se.pubkey.equals(ae.publicKey))
      throw new Error("pubkey did not match bip32Derivation");
    return ae;
  });
}
function getSortedSigs(B, z) {
  return payments.p2ms({ output: B }).pubkeys.map((ne) => (z.filter((ie) => ie.pubkey.equals(ne))[0] || {}).signature).filter((ne) => !!ne);
}
function scriptWitnessToWitnessStack(B) {
  let z = 0;
  function Y(se) {
    return z += se, B.slice(z - se, z);
  }
  function ne() {
    const se = varuint.decode(B, z);
    return z += varuint.decode.bytes, se;
  }
  function ie() {
    return Y(ne());
  }
  function oe() {
    const se = ne(), ae = [];
    for (let ve = 0; ve < se; ve++) ae.push(ie());
    return ae;
  }
  return oe();
}
function sighashTypeToString(B) {
  let z = B & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (B & 31) {
    case transaction_1.Transaction.SIGHASH_ALL:
      z += "SIGHASH_ALL";
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      z += "SIGHASH_SINGLE";
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      z += "SIGHASH_NONE";
      break;
  }
  return z;
}
function addNonWitnessTxCache(B, z, Y) {
  B.__NON_WITNESS_UTXO_BUF_CACHE[Y] = z.nonWitnessUtxo;
  const ne = transaction_1.Transaction.fromBuffer(z.nonWitnessUtxo);
  B.__NON_WITNESS_UTXO_TX_CACHE[Y] = ne;
  const ie = B, oe = Y;
  delete z.nonWitnessUtxo, Object.defineProperty(z, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const se = ie.__NON_WITNESS_UTXO_BUF_CACHE[oe], ae = ie.__NON_WITNESS_UTXO_TX_CACHE[oe];
      if (se !== void 0)
        return se;
      {
        const ve = ae.toBuffer();
        return ie.__NON_WITNESS_UTXO_BUF_CACHE[oe] = ve, ve;
      }
    },
    set(se) {
      ie.__NON_WITNESS_UTXO_BUF_CACHE[oe] = se;
    }
  });
}
function inputFinalizeGetAmts(B, z, Y, ne) {
  let ie = 0;
  B.forEach((ve, Pe) => {
    if (ne && ve.finalScriptSig && (z.ins[Pe].script = ve.finalScriptSig), ne && ve.finalScriptWitness && (z.ins[Pe].witness = scriptWitnessToWitnessStack(
      ve.finalScriptWitness
    )), ve.witnessUtxo)
      ie += ve.witnessUtxo.value;
    else if (ve.nonWitnessUtxo) {
      const le = nonWitnessUtxoTxFromCache(Y, ve, Pe), Ee = z.ins[Pe].index, Je = le.outs[Ee];
      ie += Je.value;
    }
  });
  const oe = z.outs.reduce((ve, Pe) => ve + Pe.value, 0), se = ie - oe;
  if (se < 0)
    throw new Error("Outputs are spending more than Inputs");
  const ae = z.virtualSize();
  Y.__FEE = se, Y.__EXTRACTED_TX = z, Y.__FEE_RATE = Math.floor(se / ae);
}
function nonWitnessUtxoTxFromCache(B, z, Y) {
  const ne = B.__NON_WITNESS_UTXO_TX_CACHE;
  return ne[Y] || addNonWitnessTxCache(B, z, Y), ne[Y];
}
function getScriptFromUtxo(B, z, Y) {
  const { script: ne } = getScriptAndAmountFromUtxo(B, z, Y);
  return ne;
}
function getScriptAndAmountFromUtxo(B, z, Y) {
  if (z.witnessUtxo !== void 0)
    return {
      script: z.witnessUtxo.script,
      value: z.witnessUtxo.value
    };
  if (z.nonWitnessUtxo !== void 0) {
    const ie = nonWitnessUtxoTxFromCache(
      Y,
      z,
      B
    ).outs[Y.__TX.ins[B].index];
    return { script: ie.script, value: ie.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function pubkeyInInput(B, z, Y, ne) {
  const ie = getScriptFromUtxo(Y, z, ne), { meaningfulScript: oe } = getMeaningfulScript(
    ie,
    Y,
    "input",
    z.redeemScript,
    z.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(B, oe);
}
function pubkeyInOutput(B, z, Y, ne) {
  const ie = ne.__TX.outs[Y].script, { meaningfulScript: oe } = getMeaningfulScript(
    ie,
    Y,
    "output",
    z.redeemScript,
    z.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(B, oe);
}
function redeemFromFinalScriptSig(B) {
  if (!B) return;
  const z = bscript.decompile(B);
  if (!z) return;
  const Y = z[z.length - 1];
  if (!(!Buffer$D.isBuffer(Y) || isPubkeyLike(Y) || isSigLike(Y) || !bscript.decompile(Y)))
    return Y;
}
function redeemFromFinalWitnessScript(B) {
  if (!B) return;
  const z = scriptWitnessToWitnessStack(B), Y = z[z.length - 1];
  if (!(isPubkeyLike(Y) || !bscript.decompile(Y)))
    return Y;
}
function compressPubkey(B) {
  if (B.length === 65) {
    const z = B[64] & 1, Y = B.slice(0, 33);
    return Y[0] = 2 | z, Y;
  }
  return B.slice();
}
function isPubkeyLike(B) {
  return B.length === 33 && bscript.isCanonicalPubKey(B);
}
function isSigLike(B) {
  return bscript.isCanonicalScriptSignature(B);
}
function getMeaningfulScript(B, z, Y, ne, ie) {
  const oe = (0, psbtutils_1.isP2SHScript)(B), se = oe && ne && (0, psbtutils_1.isP2WSHScript)(ne), ae = (0, psbtutils_1.isP2WSHScript)(B);
  if (oe && ne === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((ae || se) && ie === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let ve;
  return se ? (ve = ie, checkRedeemScript(z, B, ne, Y), checkWitnessScript(z, ne, ie, Y), checkInvalidP2WSH(ve)) : ae ? (ve = ie, checkWitnessScript(z, B, ie, Y), checkInvalidP2WSH(ve)) : oe ? (ve = ne, checkRedeemScript(z, B, ne, Y)) : ve = B, {
    meaningfulScript: ve,
    type: se ? "p2sh-p2wsh" : oe ? "p2sh" : ae ? "p2wsh" : "raw"
  };
}
function checkInvalidP2WSH(B) {
  if ((0, psbtutils_1.isP2WPKH)(B) || (0, psbtutils_1.isP2SHScript)(B))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function classifyScript(B) {
  return (0, psbtutils_1.isP2WPKH)(B) ? "witnesspubkeyhash" : (0, psbtutils_1.isP2PKH)(B) ? "pubkeyhash" : (0, psbtutils_1.isP2MS)(B) ? "multisig" : (0, psbtutils_1.isP2PK)(B) ? "pubkey" : "nonstandard";
}
function range(B) {
  return [...Array(B).keys()];
}
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.initEccLib = B.Transaction = B.opcodes = B.Psbt = B.Block = B.script = B.payments = B.networks = B.crypto = B.address = void 0;
  const z = requireAddress();
  B.address = z;
  const Y = crypto$1;
  B.crypto = Y;
  const ne = networks;
  B.networks = ne;
  const ie = requirePayments();
  B.payments = ie;
  const oe = requireScript();
  B.script = oe;
  var se = block;
  Object.defineProperty(B, "Block", {
    enumerable: !0,
    get: function() {
      return se.Block;
    }
  });
  var ae = psbt$1;
  Object.defineProperty(B, "Psbt", {
    enumerable: !0,
    get: function() {
      return ae.Psbt;
    }
  });
  var ve = ops;
  Object.defineProperty(B, "opcodes", {
    enumerable: !0,
    get: function() {
      return ve.OPS;
    }
  });
  var Pe = transaction;
  Object.defineProperty(B, "Transaction", {
    enumerable: !0,
    get: function() {
      return Pe.Transaction;
    }
  });
  var le = ecc_lib;
  Object.defineProperty(B, "initEccLib", {
    enumerable: !0,
    get: function() {
      return le.initEccLib;
    }
  });
})(src$1);
function useSign() {
  const { network: B, publicKey: z, format: Y, wallet: ne } = useOrdConnect(), [ie, oe] = useState(null), [se, ae] = useState(!1);
  return { sign: useCallback(
    async (Pe, le, Ee) => {
      ae(!0);
      try {
        if (oe(null), !Y || !z || !ne)
          throw new Error("No wallet is connected");
        const Je = src$1.Psbt.fromBase64(le), Ce = await signPsbt({
          address: Pe,
          wallet: ne,
          network: B,
          psbt: Je,
          options: Ee
        });
        return ae(!1), Ce;
      } catch (Je) {
        throw oe(Je.message), ae(!1), Je;
      }
    },
    [Y, B, z, ne]
  ), error: ie, loading: se };
}
function leatherPaymentTypeFromFormat(B) {
  if (B === "segwit")
    return LeatherAddressType.P2WPKH;
  if (B === "taproot")
    return LeatherAddressType.P2TR;
  throw new Error("Leather payment address format is not supported");
}
async function signXverseMessage(B, z, Y) {
  if (!B || !Y || !z)
    throw new OrditSDKError("Invalid options provided");
  let ne, ie = null;
  const oe = await request("signMessage", {
    address: z,
    message: B
  }, "XverseProviders.BitcoinProvider");
  if (console.log("xxxresponse", oe), !oe)
    throw new BrowserWalletSigningError(
      "Failed to sign message using selected wallet"
    );
  if (oe.status === "success")
    ne = Buffer$D.from(oe.result.signature, "base64").toString("hex"), ie = oe.result.signature;
  else throw oe.error.code === RpcErrorCode.USER_REJECTION ? new BrowserWalletRequestCancelledByUserError() : new Error("Failed to sign message");
  return { hex: ne, base64: ie };
}
async function signMessage({
  message: B,
  wallet: z,
  address: Y,
  network: ne,
  format: ie
}) {
  if (z === Wallet.MAGICEDEN) {
    const { base64: oe } = await signMessage$1(B, Y, ne);
    return oe;
  }
  if (z === Wallet.UNISAT) {
    const { base64: oe } = await signMessage$2(B, "bip322-simple");
    return oe;
  }
  if (z === Wallet.XVERSE) {
    const { base64: oe } = await signXverseMessage(B, Y, ne);
    return oe;
  }
  if (z === Wallet.LEATHER) {
    const oe = leatherPaymentTypeFromFormat(ie), { base64: se } = await signMessage$3(B, {
      paymentType: oe,
      network: ne
    });
    return se;
  }
  if (z === Wallet.OKX) {
    const { base64: oe } = await signMessage$4(B, "bip322-simple", ne);
    return oe;
  }
  throw new Error("Invalid wallet selected");
}
function useSignMessage() {
  const {
    network: B,
    wallet: z,
    publicKey: Y,
    format: ne,
    address: ie
  } = useOrdConnect(), [oe, se] = useState(null), [ae, ve] = useState(!1);
  return { signMsg: useCallback(
    async (le, Ee) => {
      ve(!0);
      try {
        if (se(null), !ne || !Y || !z)
          throw new Error("No wallet is connected");
        if (ie.ordinals !== le && ie.payments !== le)
          throw new Error("Address supplied is not connected address");
        const Je = await signMessage({
          address: le,
          wallet: z,
          message: Ee,
          network: B,
          format: ie.ordinals === le ? ne.ordinals : ne.payments
        });
        return ve(!1), Je;
      } catch (Je) {
        throw console.log("==>err", Je), se(Je.message), ve(!1), Je;
      }
    },
    [ne, B, Y, z, ie]
  ), error: oe, isLoading: ae };
}
export {
  Chain,
  Network,
  OrdConnectKit,
  OrdConnectProvider,
  SelectWalletModal,
  Wallet,
  useBalance,
  useOrdConnect,
  useSend,
  useSendV2,
  useSign,
  useSignMessage
};
